"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mixpanel-browser";
exports.ids = ["vendor-chunks/mixpanel-browser"];
exports.modules = {

/***/ "(ssr)/./node_modules/mixpanel-browser/dist/mixpanel.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/mixpanel-browser/dist/mixpanel.module.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mixpanel)\n/* harmony export */ });\nvar NodeType;\r\n(function (NodeType) {\r\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\r\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\r\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\r\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\r\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\r\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\r\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\r\n    return n.nodeType === n.ELEMENT_NODE;\r\n}\r\nfunction isShadowRoot(n) {\r\n    const host = n === null || n === void 0 ? void 0 : n.host;\r\n    return Boolean((host === null || host === void 0 ? void 0 : host.shadowRoot) === n);\r\n}\r\nfunction isNativeShadowDom(shadowRoot) {\r\n    return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\r\n}\r\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\r\n    if (cssText.includes(' background-clip: text;') &&\r\n        !cssText.includes(' -webkit-background-clip: text;')) {\r\n        cssText = cssText.replace(' background-clip: text;', ' -webkit-background-clip: text; background-clip: text;');\r\n    }\r\n    return cssText;\r\n}\r\nfunction escapeImportStatement(rule) {\r\n    const { cssText } = rule;\r\n    if (cssText.split('\"').length < 3)\r\n        return cssText;\r\n    const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\r\n    if (rule.layerName === '') {\r\n        statement.push(`layer`);\r\n    }\r\n    else if (rule.layerName) {\r\n        statement.push(`layer(${rule.layerName})`);\r\n    }\r\n    if (rule.supportsText) {\r\n        statement.push(`supports(${rule.supportsText})`);\r\n    }\r\n    if (rule.media.length) {\r\n        statement.push(rule.media.mediaText);\r\n    }\r\n    return statement.join(' ') + ';';\r\n}\r\nfunction stringifyStylesheet(s) {\r\n    try {\r\n        const rules = s.rules || s.cssRules;\r\n        return rules\r\n            ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(''))\r\n            : null;\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\r\nfunction stringifyRule(rule) {\r\n    let importStringified;\r\n    if (isCSSImportRule(rule)) {\r\n        try {\r\n            importStringified =\r\n                stringifyStylesheet(rule.styleSheet) ||\r\n                    escapeImportStatement(rule);\r\n        }\r\n        catch (error) {\r\n        }\r\n    }\r\n    else if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\r\n        return fixSafariColons(rule.cssText);\r\n    }\r\n    return importStringified || rule.cssText;\r\n}\r\nfunction fixSafariColons(cssStringified) {\r\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\r\n    return cssStringified.replace(regex, '$1\\\\$2');\r\n}\r\nfunction isCSSImportRule(rule) {\r\n    return 'styleSheet' in rule;\r\n}\r\nfunction isCSSStyleRule(rule) {\r\n    return 'selectorText' in rule;\r\n}\r\nclass Mirror {\r\n    constructor() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n    getId(n) {\r\n        var _a;\r\n        if (!n)\r\n            return -1;\r\n        const id = (_a = this.getMeta(n)) === null || _a === void 0 ? void 0 : _a.id;\r\n        return id !== null && id !== void 0 ? id : -1;\r\n    }\r\n    getNode(id) {\r\n        return this.idNodeMap.get(id) || null;\r\n    }\r\n    getIds() {\r\n        return Array.from(this.idNodeMap.keys());\r\n    }\r\n    getMeta(n) {\r\n        return this.nodeMetaMap.get(n) || null;\r\n    }\r\n    removeNodeFromMap(n) {\r\n        const id = this.getId(n);\r\n        this.idNodeMap.delete(id);\r\n        if (n.childNodes) {\r\n            n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\r\n        }\r\n    }\r\n    has(id) {\r\n        return this.idNodeMap.has(id);\r\n    }\r\n    hasNode(node) {\r\n        return this.nodeMetaMap.has(node);\r\n    }\r\n    add(n, meta) {\r\n        const id = meta.id;\r\n        this.idNodeMap.set(id, n);\r\n        this.nodeMetaMap.set(n, meta);\r\n    }\r\n    replace(id, n) {\r\n        const oldNode = this.getNode(id);\r\n        if (oldNode) {\r\n            const meta = this.nodeMetaMap.get(oldNode);\r\n            if (meta)\r\n                this.nodeMetaMap.set(n, meta);\r\n        }\r\n        this.idNodeMap.set(id, n);\r\n    }\r\n    reset() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n}\r\nfunction createMirror() {\r\n    return new Mirror();\r\n}\r\nfunction maskInputValue({ element, maskInputOptions, tagName, type, value, maskInputFn, }) {\r\n    let text = value || '';\r\n    const actualType = type && toLowerCase(type);\r\n    if (maskInputOptions[tagName.toLowerCase()] ||\r\n        (actualType && maskInputOptions[actualType])) {\r\n        if (maskInputFn) {\r\n            text = maskInputFn(text, element);\r\n        }\r\n        else {\r\n            text = '*'.repeat(text.length);\r\n        }\r\n    }\r\n    return text;\r\n}\r\nfunction toLowerCase(str) {\r\n    return str.toLowerCase();\r\n}\r\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\r\nfunction is2DCanvasBlank(canvas) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx)\r\n        return true;\r\n    const chunkSize = 50;\r\n    for (let x = 0; x < canvas.width; x += chunkSize) {\r\n        for (let y = 0; y < canvas.height; y += chunkSize) {\r\n            const getImageData = ctx.getImageData;\r\n            const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData\r\n                ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\r\n                : getImageData;\r\n            const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\r\n            if (pixelBuffer.some((pixel) => pixel !== 0))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getInputType(element) {\r\n    const type = element.type;\r\n    return element.hasAttribute('data-rr-is-password')\r\n        ? 'password'\r\n        : type\r\n            ?\r\n                toLowerCase(type)\r\n            : null;\r\n}\r\nfunction extractFileExtension(path, baseURL) {\r\n    var _a;\r\n    let url;\r\n    try {\r\n        url = new URL(path, baseURL !== null && baseURL !== void 0 ? baseURL : window.location.href);\r\n    }\r\n    catch (err) {\r\n        return null;\r\n    }\r\n    const regex = /\\.([0-9a-z]+)(?:$)/i;\r\n    const match = url.pathname.match(regex);\r\n    return (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : null;\r\n}\n\nlet _id = 1;\r\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\r\nconst IGNORED_NODE = -2;\r\nfunction genId() {\r\n    return _id++;\r\n}\r\nfunction getValidTagName(element) {\r\n    if (element instanceof HTMLFormElement) {\r\n        return 'form';\r\n    }\r\n    const processedTagName = toLowerCase(element.tagName);\r\n    if (tagNameRegex.test(processedTagName)) {\r\n        return 'div';\r\n    }\r\n    return processedTagName;\r\n}\r\nfunction extractOrigin(url) {\r\n    let origin = '';\r\n    if (url.indexOf('//') > -1) {\r\n        origin = url.split('/').slice(0, 3).join('/');\r\n    }\r\n    else {\r\n        origin = url.split('/')[0];\r\n    }\r\n    origin = origin.split('?')[0];\r\n    return origin;\r\n}\r\nlet canvasService;\r\nlet canvasCtx;\r\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\r\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\r\nconst URL_WWW_MATCH = /^www\\..*/i;\r\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\r\nfunction absoluteToStylesheet(cssText, href) {\r\n    return (cssText || '').replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\r\n        const filePath = path1 || path2 || path3;\r\n        const maybeQuote = quote1 || quote2 || '';\r\n        if (!filePath) {\r\n            return origin;\r\n        }\r\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (DATA_URI.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (filePath[0] === '/') {\r\n            return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\r\n        }\r\n        const stack = href.split('/');\r\n        const parts = filePath.split('/');\r\n        stack.pop();\r\n        for (const part of parts) {\r\n            if (part === '.') {\r\n                continue;\r\n            }\r\n            else if (part === '..') {\r\n                stack.pop();\r\n            }\r\n            else {\r\n                stack.push(part);\r\n            }\r\n        }\r\n        return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\r\n    });\r\n}\r\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\r\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\r\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\r\n    if (attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    let pos = 0;\r\n    function collectCharacters(regEx) {\r\n        let chars;\r\n        const match = regEx.exec(attributeValue.substring(pos));\r\n        if (match) {\r\n            chars = match[0];\r\n            pos += chars.length;\r\n            return chars;\r\n        }\r\n        return '';\r\n    }\r\n    const output = [];\r\n    while (true) {\r\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\r\n        if (pos >= attributeValue.length) {\r\n            break;\r\n        }\r\n        let url = collectCharacters(SRCSET_NOT_SPACES);\r\n        if (url.slice(-1) === ',') {\r\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\r\n            output.push(url);\r\n        }\r\n        else {\r\n            let descriptorsStr = '';\r\n            url = absoluteToDoc(doc, url);\r\n            let inParens = false;\r\n            while (true) {\r\n                const c = attributeValue.charAt(pos);\r\n                if (c === '') {\r\n                    output.push((url + descriptorsStr).trim());\r\n                    break;\r\n                }\r\n                else if (!inParens) {\r\n                    if (c === ',') {\r\n                        pos += 1;\r\n                        output.push((url + descriptorsStr).trim());\r\n                        break;\r\n                    }\r\n                    else if (c === '(') {\r\n                        inParens = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (c === ')') {\r\n                        inParens = false;\r\n                    }\r\n                }\r\n                descriptorsStr += c;\r\n                pos += 1;\r\n            }\r\n        }\r\n    }\r\n    return output.join(', ');\r\n}\r\nfunction absoluteToDoc(doc, attributeValue) {\r\n    if (!attributeValue || attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    const a = doc.createElement('a');\r\n    a.href = attributeValue;\r\n    return a.href;\r\n}\r\nfunction isSVGElement(el) {\r\n    return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\r\n}\r\nfunction getHref() {\r\n    const a = document.createElement('a');\r\n    a.href = '';\r\n    return a.href;\r\n}\r\nfunction transformAttribute(doc, tagName, name, value) {\r\n    if (!value) {\r\n        return value;\r\n    }\r\n    if (name === 'src' ||\r\n        (name === 'href' && !(tagName === 'use' && value[0] === '#'))) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'xlink:href' && value[0] !== '#') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'background' &&\r\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'srcset') {\r\n        return getAbsoluteSrcsetString(doc, value);\r\n    }\r\n    else if (name === 'style') {\r\n        return absoluteToStylesheet(value, getHref());\r\n    }\r\n    else if (tagName === 'object' && name === 'data') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    return value;\r\n}\r\nfunction ignoreAttribute(tagName, name, _value) {\r\n    return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\r\n}\r\nfunction _isBlockedElement(element, blockClass, blockSelector) {\r\n    try {\r\n        if (typeof blockClass === 'string') {\r\n            if (element.classList.contains(blockClass)) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (let eIndex = element.classList.length; eIndex--;) {\r\n                const className = element.classList[eIndex];\r\n                if (blockClass.test(className)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        if (blockSelector) {\r\n            return element.matches(blockSelector);\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction classMatchesRegex(node, regex, checkAncestors) {\r\n    if (!node)\r\n        return false;\r\n    if (node.nodeType !== node.ELEMENT_NODE) {\r\n        if (!checkAncestors)\r\n            return false;\r\n        return classMatchesRegex(node.parentNode, regex, checkAncestors);\r\n    }\r\n    for (let eIndex = node.classList.length; eIndex--;) {\r\n        const className = node.classList[eIndex];\r\n        if (regex.test(className)) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!checkAncestors)\r\n        return false;\r\n    return classMatchesRegex(node.parentNode, regex, checkAncestors);\r\n}\r\nfunction needMaskingText(node, maskTextClass, maskTextSelector, checkAncestors) {\r\n    try {\r\n        const el = node.nodeType === node.ELEMENT_NODE\r\n            ? node\r\n            : node.parentElement;\r\n        if (el === null)\r\n            return false;\r\n        if (typeof maskTextClass === 'string') {\r\n            if (checkAncestors) {\r\n                if (el.closest(`.${maskTextClass}`))\r\n                    return true;\r\n            }\r\n            else {\r\n                if (el.classList.contains(maskTextClass))\r\n                    return true;\r\n            }\r\n        }\r\n        else {\r\n            if (classMatchesRegex(el, maskTextClass, checkAncestors))\r\n                return true;\r\n        }\r\n        if (maskTextSelector) {\r\n            if (checkAncestors) {\r\n                if (el.closest(maskTextSelector))\r\n                    return true;\r\n            }\r\n            else {\r\n                if (el.matches(maskTextSelector))\r\n                    return true;\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\r\n    const win = iframeEl.contentWindow;\r\n    if (!win) {\r\n        return;\r\n    }\r\n    let fired = false;\r\n    let readyState;\r\n    try {\r\n        readyState = win.document.readyState;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (readyState !== 'complete') {\r\n        const timer = setTimeout(() => {\r\n            if (!fired) {\r\n                listener();\r\n                fired = true;\r\n            }\r\n        }, iframeLoadTimeout);\r\n        iframeEl.addEventListener('load', () => {\r\n            clearTimeout(timer);\r\n            fired = true;\r\n            listener();\r\n        });\r\n        return;\r\n    }\r\n    const blankUrl = 'about:blank';\r\n    if (win.location.href !== blankUrl ||\r\n        iframeEl.src === blankUrl ||\r\n        iframeEl.src === '') {\r\n        setTimeout(listener, 0);\r\n        return iframeEl.addEventListener('load', listener);\r\n    }\r\n    iframeEl.addEventListener('load', listener);\r\n}\r\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\r\n    let fired = false;\r\n    let styleSheetLoaded;\r\n    try {\r\n        styleSheetLoaded = link.sheet;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (styleSheetLoaded)\r\n        return;\r\n    const timer = setTimeout(() => {\r\n        if (!fired) {\r\n            listener();\r\n            fired = true;\r\n        }\r\n    }, styleSheetLoadTimeout);\r\n    link.addEventListener('load', () => {\r\n        clearTimeout(timer);\r\n        fired = true;\r\n        listener();\r\n    });\r\n}\r\nfunction serializeNode(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, needsMask, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, } = options;\r\n    const rootId = getRootId(doc, mirror);\r\n    switch (n.nodeType) {\r\n        case n.DOCUMENT_NODE:\r\n            if (n.compatMode !== 'CSS1Compat') {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                    compatMode: n.compatMode,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                };\r\n            }\r\n        case n.DOCUMENT_TYPE_NODE:\r\n            return {\r\n                type: NodeType.DocumentType,\r\n                name: n.name,\r\n                publicId: n.publicId,\r\n                systemId: n.systemId,\r\n                rootId,\r\n            };\r\n        case n.ELEMENT_NODE:\r\n            return serializeElementNode(n, {\r\n                doc,\r\n                blockClass,\r\n                blockSelector,\r\n                inlineStylesheet,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                dataURLOptions,\r\n                inlineImages,\r\n                recordCanvas,\r\n                keepIframeSrcFn,\r\n                newlyAddedElement,\r\n                rootId,\r\n            });\r\n        case n.TEXT_NODE:\r\n            return serializeTextNode(n, {\r\n                needsMask,\r\n                maskTextFn,\r\n                rootId,\r\n            });\r\n        case n.CDATA_SECTION_NODE:\r\n            return {\r\n                type: NodeType.CDATA,\r\n                textContent: '',\r\n                rootId,\r\n            };\r\n        case n.COMMENT_NODE:\r\n            return {\r\n                type: NodeType.Comment,\r\n                textContent: n.textContent || '',\r\n                rootId,\r\n            };\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getRootId(doc, mirror) {\r\n    if (!mirror.hasNode(doc))\r\n        return undefined;\r\n    const docId = mirror.getId(doc);\r\n    return docId === 1 ? undefined : docId;\r\n}\r\nfunction serializeTextNode(n, options) {\r\n    var _a;\r\n    const { needsMask, maskTextFn, rootId } = options;\r\n    const parentTagName = n.parentNode && n.parentNode.tagName;\r\n    let textContent = n.textContent;\r\n    const isStyle = parentTagName === 'STYLE' ? true : undefined;\r\n    const isScript = parentTagName === 'SCRIPT' ? true : undefined;\r\n    if (isStyle && textContent) {\r\n        try {\r\n            if (n.nextSibling || n.previousSibling) {\r\n            }\r\n            else if ((_a = n.parentNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) {\r\n                textContent = stringifyStylesheet(n.parentNode.sheet);\r\n            }\r\n        }\r\n        catch (err) {\r\n            console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\r\n        }\r\n        textContent = absoluteToStylesheet(textContent, getHref());\r\n    }\r\n    if (isScript) {\r\n        textContent = 'SCRIPT_PLACEHOLDER';\r\n    }\r\n    if (!isStyle && !isScript && textContent && needsMask) {\r\n        textContent = maskTextFn\r\n            ? maskTextFn(textContent, n.parentElement)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    return {\r\n        type: NodeType.Text,\r\n        textContent: textContent || '',\r\n        isStyle,\r\n        rootId,\r\n    };\r\n}\r\nfunction serializeElementNode(n, options) {\r\n    const { doc, blockClass, blockSelector, inlineStylesheet, maskInputOptions = {}, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId, } = options;\r\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector);\r\n    const tagName = getValidTagName(n);\r\n    let attributes = {};\r\n    const len = n.attributes.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const attr = n.attributes[i];\r\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\r\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\r\n        }\r\n    }\r\n    if (tagName === 'link' && inlineStylesheet) {\r\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\r\n            return s.href === n.href;\r\n        });\r\n        let cssText = null;\r\n        if (stylesheet) {\r\n            cssText = stringifyStylesheet(stylesheet);\r\n        }\r\n        if (cssText) {\r\n            delete attributes.rel;\r\n            delete attributes.href;\r\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\r\n        }\r\n    }\r\n    if (tagName === 'style' &&\r\n        n.sheet &&\r\n        !(n.innerText || n.textContent || '').trim().length) {\r\n        const cssText = stringifyStylesheet(n.sheet);\r\n        if (cssText) {\r\n            attributes._cssText = absoluteToStylesheet(cssText, getHref());\r\n        }\r\n    }\r\n    if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {\r\n        const value = n.value;\r\n        const checked = n.checked;\r\n        if (attributes.type !== 'radio' &&\r\n            attributes.type !== 'checkbox' &&\r\n            attributes.type !== 'submit' &&\r\n            attributes.type !== 'button' &&\r\n            value) {\r\n            attributes.value = maskInputValue({\r\n                element: n,\r\n                type: getInputType(n),\r\n                tagName,\r\n                value,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        else if (checked) {\r\n            attributes.checked = checked;\r\n        }\r\n    }\r\n    if (tagName === 'option') {\r\n        if (n.selected && !maskInputOptions['select']) {\r\n            attributes.selected = true;\r\n        }\r\n        else {\r\n            delete attributes.selected;\r\n        }\r\n    }\r\n    if (tagName === 'canvas' && recordCanvas) {\r\n        if (n.__context === '2d') {\r\n            if (!is2DCanvasBlank(n)) {\r\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n        }\r\n        else if (!('__context' in n)) {\r\n            const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            const blankCanvas = document.createElement('canvas');\r\n            blankCanvas.width = n.width;\r\n            blankCanvas.height = n.height;\r\n            const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            if (canvasDataURL !== blankCanvasDataURL) {\r\n                attributes.rr_dataURL = canvasDataURL;\r\n            }\r\n        }\r\n    }\r\n    if (tagName === 'img' && inlineImages) {\r\n        if (!canvasService) {\r\n            canvasService = doc.createElement('canvas');\r\n            canvasCtx = canvasService.getContext('2d');\r\n        }\r\n        const image = n;\r\n        const oldValue = image.crossOrigin;\r\n        image.crossOrigin = 'anonymous';\r\n        const recordInlineImage = () => {\r\n            image.removeEventListener('load', recordInlineImage);\r\n            try {\r\n                canvasService.width = image.naturalWidth;\r\n                canvasService.height = image.naturalHeight;\r\n                canvasCtx.drawImage(image, 0, 0);\r\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n            catch (err) {\r\n                console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);\r\n            }\r\n            oldValue\r\n                ? (attributes.crossOrigin = oldValue)\r\n                : image.removeAttribute('crossorigin');\r\n        };\r\n        if (image.complete && image.naturalWidth !== 0)\r\n            recordInlineImage();\r\n        else\r\n            image.addEventListener('load', recordInlineImage);\r\n    }\r\n    if (tagName === 'audio' || tagName === 'video') {\r\n        const mediaAttributes = attributes;\r\n        mediaAttributes.rr_mediaState = n.paused\r\n            ? 'paused'\r\n            : 'played';\r\n        mediaAttributes.rr_mediaCurrentTime = n.currentTime;\r\n        mediaAttributes.rr_mediaPlaybackRate = n.playbackRate;\r\n        mediaAttributes.rr_mediaMuted = n.muted;\r\n        mediaAttributes.rr_mediaLoop = n.loop;\r\n        mediaAttributes.rr_mediaVolume = n.volume;\r\n    }\r\n    if (!newlyAddedElement) {\r\n        if (n.scrollLeft) {\r\n            attributes.rr_scrollLeft = n.scrollLeft;\r\n        }\r\n        if (n.scrollTop) {\r\n            attributes.rr_scrollTop = n.scrollTop;\r\n        }\r\n    }\r\n    if (needBlock) {\r\n        const { width, height } = n.getBoundingClientRect();\r\n        attributes = {\r\n            class: attributes.class,\r\n            rr_width: `${width}px`,\r\n            rr_height: `${height}px`,\r\n        };\r\n    }\r\n    if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src)) {\r\n        if (!n.contentDocument) {\r\n            attributes.rr_src = attributes.src;\r\n        }\r\n        delete attributes.src;\r\n    }\r\n    let isCustomElement;\r\n    try {\r\n        if (customElements.get(tagName))\r\n            isCustomElement = true;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return {\r\n        type: NodeType.Element,\r\n        tagName,\r\n        attributes,\r\n        childNodes: [],\r\n        isSVG: isSVGElement(n) || undefined,\r\n        needBlock,\r\n        rootId,\r\n        isCustom: isCustomElement,\r\n    };\r\n}\r\nfunction lowerIfExists(maybeAttr) {\r\n    if (maybeAttr === undefined || maybeAttr === null) {\r\n        return '';\r\n    }\r\n    else {\r\n        return maybeAttr.toLowerCase();\r\n    }\r\n}\r\nfunction slimDOMExcluded(sn, slimDOMOptions) {\r\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\r\n        return true;\r\n    }\r\n    else if (sn.type === NodeType.Element) {\r\n        if (slimDOMOptions.script &&\r\n            (sn.tagName === 'script' ||\r\n                (sn.tagName === 'link' &&\r\n                    (sn.attributes.rel === 'preload' ||\r\n                        sn.attributes.rel === 'modulepreload') &&\r\n                    sn.attributes.as === 'script') ||\r\n                (sn.tagName === 'link' &&\r\n                    sn.attributes.rel === 'prefetch' &&\r\n                    typeof sn.attributes.href === 'string' &&\r\n                    extractFileExtension(sn.attributes.href) === 'js'))) {\r\n            return true;\r\n        }\r\n        else if (slimDOMOptions.headFavicon &&\r\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\r\n                (sn.tagName === 'meta' &&\r\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\r\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\r\n            return true;\r\n        }\r\n        else if (sn.tagName === 'meta') {\r\n            if (slimDOMOptions.headMetaDescKeywords &&\r\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaSocial &&\r\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\r\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\r\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaRobots &&\r\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\r\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\r\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaHttpEquiv &&\r\n                sn.attributes['http-equiv'] !== undefined) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaAuthorship &&\r\n                (lowerIfExists(sn.attributes.name) === 'author' ||\r\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\r\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\r\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\r\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\r\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\r\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaVerification &&\r\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\r\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction serializeNodeWithId(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, maskTextClass, maskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5000, onStylesheetLoad, stylesheetLoadTimeout = 5000, keepIframeSrcFn = () => false, newlyAddedElement = false, } = options;\r\n    let { needsMask } = options;\r\n    let { preserveWhiteSpace = true } = options;\r\n    if (!needsMask &&\r\n        n.childNodes) {\r\n        const checkAncestors = needsMask === undefined;\r\n        needsMask = needMaskingText(n, maskTextClass, maskTextSelector, checkAncestors);\r\n    }\r\n    const _serializedNode = serializeNode(n, {\r\n        doc,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        needsMask,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement,\r\n    });\r\n    if (!_serializedNode) {\r\n        console.warn(n, 'not serialized');\r\n        return null;\r\n    }\r\n    let id;\r\n    if (mirror.hasNode(n)) {\r\n        id = mirror.getId(n);\r\n    }\r\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\r\n        (!preserveWhiteSpace &&\r\n            _serializedNode.type === NodeType.Text &&\r\n            !_serializedNode.isStyle &&\r\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\r\n        id = IGNORED_NODE;\r\n    }\r\n    else {\r\n        id = genId();\r\n    }\r\n    const serializedNode = Object.assign(_serializedNode, { id });\r\n    mirror.add(n, serializedNode);\r\n    if (id === IGNORED_NODE) {\r\n        return null;\r\n    }\r\n    if (onSerialize) {\r\n        onSerialize(n);\r\n    }\r\n    let recordChild = !skipChild;\r\n    if (serializedNode.type === NodeType.Element) {\r\n        recordChild = recordChild && !serializedNode.needBlock;\r\n        delete serializedNode.needBlock;\r\n        const shadowRoot = n.shadowRoot;\r\n        if (shadowRoot && isNativeShadowDom(shadowRoot))\r\n            serializedNode.isShadowHost = true;\r\n    }\r\n    if ((serializedNode.type === NodeType.Document ||\r\n        serializedNode.type === NodeType.Element) &&\r\n        recordChild) {\r\n        if (slimDOMOptions.headWhitespace &&\r\n            serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'head') {\r\n            preserveWhiteSpace = false;\r\n        }\r\n        const bypassOptions = {\r\n            doc,\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            needsMask,\r\n            maskTextClass,\r\n            maskTextSelector,\r\n            skipChild,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            slimDOMOptions,\r\n            dataURLOptions,\r\n            inlineImages,\r\n            recordCanvas,\r\n            preserveWhiteSpace,\r\n            onSerialize,\r\n            onIframeLoad,\r\n            iframeLoadTimeout,\r\n            onStylesheetLoad,\r\n            stylesheetLoadTimeout,\r\n            keepIframeSrcFn,\r\n        };\r\n        if (serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'textarea' &&\r\n            serializedNode.attributes.value !== undefined) ;\r\n        else {\r\n            for (const childN of Array.from(n.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n        if (isElement(n) && n.shadowRoot) {\r\n            for (const childN of Array.from(n.shadowRoot.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    isNativeShadowDom(n.shadowRoot) &&\r\n                        (serializedChildNode.isShadow = true);\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (n.parentNode &&\r\n        isShadowRoot(n.parentNode) &&\r\n        isNativeShadowDom(n.parentNode)) {\r\n        serializedNode.isShadow = true;\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'iframe') {\r\n        onceIframeLoaded(n, () => {\r\n            const iframeDoc = n.contentDocument;\r\n            if (iframeDoc && onIframeLoad) {\r\n                const serializedIframeNode = serializeNodeWithId(iframeDoc, {\r\n                    doc: iframeDoc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    needsMask,\r\n                    maskTextClass,\r\n                    maskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedIframeNode) {\r\n                    onIframeLoad(n, serializedIframeNode);\r\n                }\r\n            }\r\n        }, iframeLoadTimeout);\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'link' &&\r\n        typeof serializedNode.attributes.rel === 'string' &&\r\n        (serializedNode.attributes.rel === 'stylesheet' ||\r\n            (serializedNode.attributes.rel === 'preload' &&\r\n                typeof serializedNode.attributes.href === 'string' &&\r\n                extractFileExtension(serializedNode.attributes.href) === 'css'))) {\r\n        onceStylesheetLoaded(n, () => {\r\n            if (onStylesheetLoad) {\r\n                const serializedLinkNode = serializeNodeWithId(n, {\r\n                    doc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    needsMask,\r\n                    maskTextClass,\r\n                    maskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedLinkNode) {\r\n                    onStylesheetLoad(n, serializedLinkNode);\r\n                }\r\n            }\r\n        }, stylesheetLoadTimeout);\r\n    }\r\n    return serializedNode;\r\n}\r\nfunction snapshot(n, options) {\r\n    const { mirror = new Mirror(), blockClass = 'rr-block', blockSelector = null, maskTextClass = 'rr-mask', maskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false, } = options || {};\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n            password: true,\r\n        }\r\n        : maskAllInputs === false\r\n            ? {\r\n                password: true,\r\n            }\r\n            : maskAllInputs;\r\n    const slimDOMOptions = slimDOM === true || slimDOM === 'all'\r\n        ?\r\n            {\r\n                script: true,\r\n                comment: true,\r\n                headFavicon: true,\r\n                headWhitespace: true,\r\n                headMetaDescKeywords: slimDOM === 'all',\r\n                headMetaSocial: true,\r\n                headMetaRobots: true,\r\n                headMetaHttpEquiv: true,\r\n                headMetaAuthorship: true,\r\n                headMetaVerification: true,\r\n            }\r\n        : slimDOM === false\r\n            ? {}\r\n            : slimDOM;\r\n    return serializeNodeWithId(n, {\r\n        doc: n,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        maskTextClass,\r\n        maskTextSelector,\r\n        skipChild: false,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        slimDOMOptions,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        preserveWhiteSpace,\r\n        onSerialize,\r\n        onIframeLoad,\r\n        iframeLoadTimeout,\r\n        onStylesheetLoad,\r\n        stylesheetLoadTimeout,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement: false,\r\n    });\r\n}\n\nfunction on(type, fn, target = document) {\r\n    const options = { capture: true, passive: true };\r\n    target.addEventListener(type, fn, options);\r\n    return () => target.removeEventListener(type, fn, options);\r\n}\r\nconst DEPARTED_MIRROR_ACCESS_WARNING = 'Please stop import mirror directly. Instead of that,' +\r\n    '\\r\\n' +\r\n    'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\r\n    '\\r\\n' +\r\n    'or you can use record.mirror to access the mirror instance during recording.';\r\nlet _mirror = {\r\n    map: {},\r\n    getId() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return -1;\r\n    },\r\n    getNode() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return null;\r\n    },\r\n    removeNodeFromMap() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n    has() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return false;\r\n    },\r\n    reset() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n};\r\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\r\n    _mirror = new Proxy(_mirror, {\r\n        get(target, prop, receiver) {\r\n            if (prop === 'map') {\r\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n            }\r\n            return Reflect.get(target, prop, receiver);\r\n        },\r\n    });\r\n}\r\nfunction throttle(func, wait, options = {}) {\r\n    let timeout = null;\r\n    let previous = 0;\r\n    return function (...args) {\r\n        const now = Date.now();\r\n        if (!previous && options.leading === false) {\r\n            previous = now;\r\n        }\r\n        const remaining = wait - (now - previous);\r\n        const context = this;\r\n        if (remaining <= 0 || remaining > wait) {\r\n            if (timeout) {\r\n                clearTimeout(timeout);\r\n                timeout = null;\r\n            }\r\n            previous = now;\r\n            func.apply(context, args);\r\n        }\r\n        else if (!timeout && options.trailing !== false) {\r\n            timeout = setTimeout(() => {\r\n                previous = options.leading === false ? 0 : Date.now();\r\n                timeout = null;\r\n                func.apply(context, args);\r\n            }, remaining);\r\n        }\r\n    };\r\n}\r\nfunction hookSetter(target, key, d, isRevoked, win = window) {\r\n    const original = win.Object.getOwnPropertyDescriptor(target, key);\r\n    win.Object.defineProperty(target, key, isRevoked\r\n        ? d\r\n        : {\r\n            set(value) {\r\n                setTimeout(() => {\r\n                    d.set.call(this, value);\r\n                }, 0);\r\n                if (original && original.set) {\r\n                    original.set.call(this, value);\r\n                }\r\n            },\r\n        });\r\n    return () => hookSetter(target, key, original || {}, true);\r\n}\r\nfunction patch(source, name, replacement) {\r\n    try {\r\n        if (!(name in source)) {\r\n            return () => {\r\n            };\r\n        }\r\n        const original = source[name];\r\n        const wrapped = replacement(original);\r\n        if (typeof wrapped === 'function') {\r\n            wrapped.prototype = wrapped.prototype || {};\r\n            Object.defineProperties(wrapped, {\r\n                __rrweb_original__: {\r\n                    enumerable: false,\r\n                    value: original,\r\n                },\r\n            });\r\n        }\r\n        source[name] = wrapped;\r\n        return () => {\r\n            source[name] = original;\r\n        };\r\n    }\r\n    catch (_a) {\r\n        return () => {\r\n        };\r\n    }\r\n}\r\nlet nowTimestamp = Date.now;\r\nif (!(/[1-9][0-9]{12}/.test(Date.now().toString()))) {\r\n    nowTimestamp = () => new Date().getTime();\r\n}\r\nfunction getWindowScroll(win) {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    const doc = win.document;\r\n    return {\r\n        left: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollLeft\r\n            : win.pageXOffset !== undefined\r\n                ? win.pageXOffset\r\n                : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollLeft) ||\r\n                    ((_b = (_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.scrollLeft) ||\r\n                    ((_c = doc === null || doc === void 0 ? void 0 : doc.body) === null || _c === void 0 ? void 0 : _c.scrollLeft) ||\r\n                    0,\r\n        top: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollTop\r\n            : win.pageYOffset !== undefined\r\n                ? win.pageYOffset\r\n                : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollTop) ||\r\n                    ((_e = (_d = doc === null || doc === void 0 ? void 0 : doc.body) === null || _d === void 0 ? void 0 : _d.parentElement) === null || _e === void 0 ? void 0 : _e.scrollTop) ||\r\n                    ((_f = doc === null || doc === void 0 ? void 0 : doc.body) === null || _f === void 0 ? void 0 : _f.scrollTop) ||\r\n                    0,\r\n    };\r\n}\r\nfunction getWindowHeight() {\r\n    return (window.innerHeight ||\r\n        (document.documentElement && document.documentElement.clientHeight) ||\r\n        (document.body && document.body.clientHeight));\r\n}\r\nfunction getWindowWidth() {\r\n    return (window.innerWidth ||\r\n        (document.documentElement && document.documentElement.clientWidth) ||\r\n        (document.body && document.body.clientWidth));\r\n}\r\nfunction closestElementOfNode(node) {\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    const el = node.nodeType === node.ELEMENT_NODE\r\n        ? node\r\n        : node.parentElement;\r\n    return el;\r\n}\r\nfunction isBlocked(node, blockClass, blockSelector, checkAncestors) {\r\n    if (!node) {\r\n        return false;\r\n    }\r\n    const el = closestElementOfNode(node);\r\n    if (!el) {\r\n        return false;\r\n    }\r\n    try {\r\n        if (typeof blockClass === 'string') {\r\n            if (el.classList.contains(blockClass))\r\n                return true;\r\n            if (checkAncestors && el.closest('.' + blockClass) !== null)\r\n                return true;\r\n        }\r\n        else {\r\n            if (classMatchesRegex(el, blockClass, checkAncestors))\r\n                return true;\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    if (blockSelector) {\r\n        if (el.matches(blockSelector))\r\n            return true;\r\n        if (checkAncestors && el.closest(blockSelector) !== null)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction isSerialized(n, mirror) {\r\n    return mirror.getId(n) !== -1;\r\n}\r\nfunction isIgnored(n, mirror) {\r\n    return mirror.getId(n) === IGNORED_NODE;\r\n}\r\nfunction isAncestorRemoved(target, mirror) {\r\n    if (isShadowRoot(target)) {\r\n        return false;\r\n    }\r\n    const id = mirror.getId(target);\r\n    if (!mirror.has(id)) {\r\n        return true;\r\n    }\r\n    if (target.parentNode &&\r\n        target.parentNode.nodeType === target.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    if (!target.parentNode) {\r\n        return true;\r\n    }\r\n    return isAncestorRemoved(target.parentNode, mirror);\r\n}\r\nfunction legacy_isTouchEvent(event) {\r\n    return Boolean(event.changedTouches);\r\n}\r\nfunction polyfill(win = window) {\r\n    if ('NodeList' in win && !win.NodeList.prototype.forEach) {\r\n        win.NodeList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\r\n        win.DOMTokenList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if (!Node.prototype.contains) {\r\n        Node.prototype.contains = (...args) => {\r\n            let node = args[0];\r\n            if (!(0 in args)) {\r\n                throw new TypeError('1 argument is required');\r\n            }\r\n            do {\r\n                if (this === node) {\r\n                    return true;\r\n                }\r\n            } while ((node = node && node.parentNode));\r\n            return false;\r\n        };\r\n    }\r\n}\r\nfunction isSerializedIframe(n, mirror) {\r\n    return Boolean(n.nodeName === 'IFRAME' && mirror.getMeta(n));\r\n}\r\nfunction isSerializedStylesheet(n, mirror) {\r\n    return Boolean(n.nodeName === 'LINK' &&\r\n        n.nodeType === n.ELEMENT_NODE &&\r\n        n.getAttribute &&\r\n        n.getAttribute('rel') === 'stylesheet' &&\r\n        mirror.getMeta(n));\r\n}\r\nfunction hasShadowRoot(n) {\r\n    return Boolean(n === null || n === void 0 ? void 0 : n.shadowRoot);\r\n}\r\nclass StyleSheetMirror {\r\n    constructor() {\r\n        this.id = 1;\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n    }\r\n    getId(stylesheet) {\r\n        var _a;\r\n        return (_a = this.styleIDMap.get(stylesheet)) !== null && _a !== void 0 ? _a : -1;\r\n    }\r\n    has(stylesheet) {\r\n        return this.styleIDMap.has(stylesheet);\r\n    }\r\n    add(stylesheet, id) {\r\n        if (this.has(stylesheet))\r\n            return this.getId(stylesheet);\r\n        let newId;\r\n        if (id === undefined) {\r\n            newId = this.id++;\r\n        }\r\n        else\r\n            newId = id;\r\n        this.styleIDMap.set(stylesheet, newId);\r\n        this.idStyleMap.set(newId, stylesheet);\r\n        return newId;\r\n    }\r\n    getStyle(id) {\r\n        return this.idStyleMap.get(id) || null;\r\n    }\r\n    reset() {\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n        this.id = 1;\r\n    }\r\n    generateId() {\r\n        return this.id++;\r\n    }\r\n}\r\nfunction getShadowHost(n) {\r\n    var _a, _b;\r\n    let shadowHost = null;\r\n    if (((_b = (_a = n.getRootNode) === null || _a === void 0 ? void 0 : _a.call(n)) === null || _b === void 0 ? void 0 : _b.nodeType) === Node.DOCUMENT_FRAGMENT_NODE &&\r\n        n.getRootNode().host)\r\n        shadowHost = n.getRootNode().host;\r\n    return shadowHost;\r\n}\r\nfunction getRootShadowHost(n) {\r\n    let rootShadowHost = n;\r\n    let shadowHost;\r\n    while ((shadowHost = getShadowHost(rootShadowHost)))\r\n        rootShadowHost = shadowHost;\r\n    return rootShadowHost;\r\n}\r\nfunction shadowHostInDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    const shadowHost = getRootShadowHost(n);\r\n    return doc.contains(shadowHost);\r\n}\r\nfunction inDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    return doc.contains(n) || shadowHostInDom(n);\r\n}\n\nvar EventType$1 = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType$1 || {});\nvar IncrementalSource$1 = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource$1 || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\n\nfunction isNodeInLinkedList(n) {\r\n    return '__ln' in n;\r\n}\r\nclass DoubleLinkedList {\r\n    constructor() {\r\n        this.length = 0;\r\n        this.head = null;\r\n        this.tail = null;\r\n    }\r\n    get(position) {\r\n        if (position >= this.length) {\r\n            throw new Error('Position outside of list range');\r\n        }\r\n        let current = this.head;\r\n        for (let index = 0; index < position; index++) {\r\n            current = (current === null || current === void 0 ? void 0 : current.next) || null;\r\n        }\r\n        return current;\r\n    }\r\n    addNode(n) {\r\n        const node = {\r\n            value: n,\r\n            previous: null,\r\n            next: null,\r\n        };\r\n        n.__ln = node;\r\n        if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\r\n            const current = n.previousSibling.__ln.next;\r\n            node.next = current;\r\n            node.previous = n.previousSibling.__ln;\r\n            n.previousSibling.__ln.next = node;\r\n            if (current) {\r\n                current.previous = node;\r\n            }\r\n        }\r\n        else if (n.nextSibling &&\r\n            isNodeInLinkedList(n.nextSibling) &&\r\n            n.nextSibling.__ln.previous) {\r\n            const current = n.nextSibling.__ln.previous;\r\n            node.previous = current;\r\n            node.next = n.nextSibling.__ln;\r\n            n.nextSibling.__ln.previous = node;\r\n            if (current) {\r\n                current.next = node;\r\n            }\r\n        }\r\n        else {\r\n            if (this.head) {\r\n                this.head.previous = node;\r\n            }\r\n            node.next = this.head;\r\n            this.head = node;\r\n        }\r\n        if (node.next === null) {\r\n            this.tail = node;\r\n        }\r\n        this.length++;\r\n    }\r\n    removeNode(n) {\r\n        const current = n.__ln;\r\n        if (!this.head) {\r\n            return;\r\n        }\r\n        if (!current.previous) {\r\n            this.head = current.next;\r\n            if (this.head) {\r\n                this.head.previous = null;\r\n            }\r\n            else {\r\n                this.tail = null;\r\n            }\r\n        }\r\n        else {\r\n            current.previous.next = current.next;\r\n            if (current.next) {\r\n                current.next.previous = current.previous;\r\n            }\r\n            else {\r\n                this.tail = current.previous;\r\n            }\r\n        }\r\n        if (n.__ln) {\r\n            delete n.__ln;\r\n        }\r\n        this.length--;\r\n    }\r\n}\r\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\r\nclass MutationBuffer {\r\n    constructor() {\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.texts = [];\r\n        this.attributes = [];\r\n        this.attributeMap = new WeakMap();\r\n        this.removes = [];\r\n        this.mapRemoves = [];\r\n        this.movedMap = {};\r\n        this.addedSet = new Set();\r\n        this.movedSet = new Set();\r\n        this.droppedSet = new Set();\r\n        this.processMutations = (mutations) => {\r\n            mutations.forEach(this.processMutation);\r\n            this.emit();\r\n        };\r\n        this.emit = () => {\r\n            if (this.frozen || this.locked) {\r\n                return;\r\n            }\r\n            const adds = [];\r\n            const addedIds = new Set();\r\n            const addList = new DoubleLinkedList();\r\n            const getNextId = (n) => {\r\n                let ns = n;\r\n                let nextId = IGNORED_NODE;\r\n                while (nextId === IGNORED_NODE) {\r\n                    ns = ns && ns.nextSibling;\r\n                    nextId = ns && this.mirror.getId(ns);\r\n                }\r\n                return nextId;\r\n            };\r\n            const pushAdd = (n) => {\r\n                if (!n.parentNode ||\r\n                    !inDom(n) ||\r\n                    n.parentNode.tagName === 'TEXTAREA') {\r\n                    return;\r\n                }\r\n                const parentId = isShadowRoot(n.parentNode)\r\n                    ? this.mirror.getId(getShadowHost(n))\r\n                    : this.mirror.getId(n.parentNode);\r\n                const nextId = getNextId(n);\r\n                if (parentId === -1 || nextId === -1) {\r\n                    return addList.addNode(n);\r\n                }\r\n                const sn = serializeNodeWithId(n, {\r\n                    doc: this.doc,\r\n                    mirror: this.mirror,\r\n                    blockClass: this.blockClass,\r\n                    blockSelector: this.blockSelector,\r\n                    maskTextClass: this.maskTextClass,\r\n                    maskTextSelector: this.maskTextSelector,\r\n                    skipChild: true,\r\n                    newlyAddedElement: true,\r\n                    inlineStylesheet: this.inlineStylesheet,\r\n                    maskInputOptions: this.maskInputOptions,\r\n                    maskTextFn: this.maskTextFn,\r\n                    maskInputFn: this.maskInputFn,\r\n                    slimDOMOptions: this.slimDOMOptions,\r\n                    dataURLOptions: this.dataURLOptions,\r\n                    recordCanvas: this.recordCanvas,\r\n                    inlineImages: this.inlineImages,\r\n                    onSerialize: (currentN) => {\r\n                        if (isSerializedIframe(currentN, this.mirror)) {\r\n                            this.iframeManager.addIframe(currentN);\r\n                        }\r\n                        if (isSerializedStylesheet(currentN, this.mirror)) {\r\n                            this.stylesheetManager.trackLinkElement(currentN);\r\n                        }\r\n                        if (hasShadowRoot(n)) {\r\n                            this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);\r\n                        }\r\n                    },\r\n                    onIframeLoad: (iframe, childSn) => {\r\n                        this.iframeManager.attachIframe(iframe, childSn);\r\n                        this.shadowDomManager.observeAttachShadow(iframe);\r\n                    },\r\n                    onStylesheetLoad: (link, childSn) => {\r\n                        this.stylesheetManager.attachLinkElement(link, childSn);\r\n                    },\r\n                });\r\n                if (sn) {\r\n                    adds.push({\r\n                        parentId,\r\n                        nextId,\r\n                        node: sn,\r\n                    });\r\n                    addedIds.add(sn.id);\r\n                }\r\n            };\r\n            while (this.mapRemoves.length) {\r\n                this.mirror.removeNodeFromMap(this.mapRemoves.shift());\r\n            }\r\n            for (const n of this.movedSet) {\r\n                if (isParentRemoved(this.removes, n, this.mirror) &&\r\n                    !this.movedSet.has(n.parentNode)) {\r\n                    continue;\r\n                }\r\n                pushAdd(n);\r\n            }\r\n            for (const n of this.addedSet) {\r\n                if (!isAncestorInSet(this.droppedSet, n) &&\r\n                    !isParentRemoved(this.removes, n, this.mirror)) {\r\n                    pushAdd(n);\r\n                }\r\n                else if (isAncestorInSet(this.movedSet, n)) {\r\n                    pushAdd(n);\r\n                }\r\n                else {\r\n                    this.droppedSet.add(n);\r\n                }\r\n            }\r\n            let candidate = null;\r\n            while (addList.length) {\r\n                let node = null;\r\n                if (candidate) {\r\n                    const parentId = this.mirror.getId(candidate.value.parentNode);\r\n                    const nextId = getNextId(candidate.value);\r\n                    if (parentId !== -1 && nextId !== -1) {\r\n                        node = candidate;\r\n                    }\r\n                }\r\n                if (!node) {\r\n                    let tailNode = addList.tail;\r\n                    while (tailNode) {\r\n                        const _node = tailNode;\r\n                        tailNode = tailNode.previous;\r\n                        if (_node) {\r\n                            const parentId = this.mirror.getId(_node.value.parentNode);\r\n                            const nextId = getNextId(_node.value);\r\n                            if (nextId === -1)\r\n                                continue;\r\n                            else if (parentId !== -1) {\r\n                                node = _node;\r\n                                break;\r\n                            }\r\n                            else {\r\n                                const unhandledNode = _node.value;\r\n                                if (unhandledNode.parentNode &&\r\n                                    unhandledNode.parentNode.nodeType ===\r\n                                        Node.DOCUMENT_FRAGMENT_NODE) {\r\n                                    const shadowHost = unhandledNode.parentNode\r\n                                        .host;\r\n                                    const parentId = this.mirror.getId(shadowHost);\r\n                                    if (parentId !== -1) {\r\n                                        node = _node;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!node) {\r\n                    while (addList.head) {\r\n                        addList.removeNode(addList.head.value);\r\n                    }\r\n                    break;\r\n                }\r\n                candidate = node.previous;\r\n                addList.removeNode(node.value);\r\n                pushAdd(node.value);\r\n            }\r\n            const payload = {\r\n                texts: this.texts\r\n                    .map((text) => {\r\n                    const n = text.node;\r\n                    if (n.parentNode &&\r\n                        n.parentNode.tagName === 'TEXTAREA') {\r\n                        this.genTextAreaValueMutation(n.parentNode);\r\n                    }\r\n                    return {\r\n                        id: this.mirror.getId(n),\r\n                        value: text.value,\r\n                    };\r\n                })\r\n                    .filter((text) => !addedIds.has(text.id))\r\n                    .filter((text) => this.mirror.has(text.id)),\r\n                attributes: this.attributes\r\n                    .map((attribute) => {\r\n                    const { attributes } = attribute;\r\n                    if (typeof attributes.style === 'string') {\r\n                        const diffAsStr = JSON.stringify(attribute.styleDiff);\r\n                        const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\r\n                        if (diffAsStr.length < attributes.style.length) {\r\n                            if ((diffAsStr + unchangedAsStr).split('var(').length ===\r\n                                attributes.style.split('var(').length) {\r\n                                attributes.style = attribute.styleDiff;\r\n                            }\r\n                        }\r\n                    }\r\n                    return {\r\n                        id: this.mirror.getId(attribute.node),\r\n                        attributes: attributes,\r\n                    };\r\n                })\r\n                    .filter((attribute) => !addedIds.has(attribute.id))\r\n                    .filter((attribute) => this.mirror.has(attribute.id)),\r\n                removes: this.removes,\r\n                adds,\r\n            };\r\n            if (!payload.texts.length &&\r\n                !payload.attributes.length &&\r\n                !payload.removes.length &&\r\n                !payload.adds.length) {\r\n                return;\r\n            }\r\n            this.texts = [];\r\n            this.attributes = [];\r\n            this.attributeMap = new WeakMap();\r\n            this.removes = [];\r\n            this.addedSet = new Set();\r\n            this.movedSet = new Set();\r\n            this.droppedSet = new Set();\r\n            this.movedMap = {};\r\n            this.mutationCb(payload);\r\n        };\r\n        this.genTextAreaValueMutation = (textarea) => {\r\n            let item = this.attributeMap.get(textarea);\r\n            if (!item) {\r\n                item = {\r\n                    node: textarea,\r\n                    attributes: {},\r\n                    styleDiff: {},\r\n                    _unchangedStyles: {},\r\n                };\r\n                this.attributes.push(item);\r\n                this.attributeMap.set(textarea, item);\r\n            }\r\n            item.attributes.value = Array.from(textarea.childNodes, (cn) => cn.textContent || '').join('');\r\n        };\r\n        this.processMutation = (m) => {\r\n            if (isIgnored(m.target, this.mirror)) {\r\n                return;\r\n            }\r\n            switch (m.type) {\r\n                case 'characterData': {\r\n                    const value = m.target.textContent;\r\n                    if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) &&\r\n                        value !== m.oldValue) {\r\n                        this.texts.push({\r\n                            value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, true) && value\r\n                                ? this.maskTextFn\r\n                                    ? this.maskTextFn(value, closestElementOfNode(m.target))\r\n                                    : value.replace(/[\\S]/g, '*')\r\n                                : value,\r\n                            node: m.target,\r\n                        });\r\n                    }\r\n                    break;\r\n                }\r\n                case 'attributes': {\r\n                    const target = m.target;\r\n                    let attributeName = m.attributeName;\r\n                    let value = m.target.getAttribute(attributeName);\r\n                    if (attributeName === 'value') {\r\n                        const type = getInputType(target);\r\n                        value = maskInputValue({\r\n                            element: target,\r\n                            maskInputOptions: this.maskInputOptions,\r\n                            tagName: target.tagName,\r\n                            type,\r\n                            value,\r\n                            maskInputFn: this.maskInputFn,\r\n                        });\r\n                    }\r\n                    if (isBlocked(m.target, this.blockClass, this.blockSelector, false) ||\r\n                        value === m.oldValue) {\r\n                        return;\r\n                    }\r\n                    let item = this.attributeMap.get(m.target);\r\n                    if (target.tagName === 'IFRAME' &&\r\n                        attributeName === 'src' &&\r\n                        !this.keepIframeSrcFn(value)) {\r\n                        if (!target.contentDocument) {\r\n                            attributeName = 'rr_src';\r\n                        }\r\n                        else {\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (!item) {\r\n                        item = {\r\n                            node: m.target,\r\n                            attributes: {},\r\n                            styleDiff: {},\r\n                            _unchangedStyles: {},\r\n                        };\r\n                        this.attributes.push(item);\r\n                        this.attributeMap.set(m.target, item);\r\n                    }\r\n                    if (attributeName === 'type' &&\r\n                        target.tagName === 'INPUT' &&\r\n                        (m.oldValue || '').toLowerCase() === 'password') {\r\n                        target.setAttribute('data-rr-is-password', 'true');\r\n                    }\r\n                    if (!ignoreAttribute(target.tagName, attributeName)) {\r\n                        item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value);\r\n                        if (attributeName === 'style') {\r\n                            if (!this.unattachedDoc) {\r\n                                try {\r\n                                    this.unattachedDoc =\r\n                                        document.implementation.createHTMLDocument();\r\n                                }\r\n                                catch (e) {\r\n                                    this.unattachedDoc = this.doc;\r\n                                }\r\n                            }\r\n                            const old = this.unattachedDoc.createElement('span');\r\n                            if (m.oldValue) {\r\n                                old.setAttribute('style', m.oldValue);\r\n                            }\r\n                            for (const pname of Array.from(target.style)) {\r\n                                const newValue = target.style.getPropertyValue(pname);\r\n                                const newPriority = target.style.getPropertyPriority(pname);\r\n                                if (newValue !== old.style.getPropertyValue(pname) ||\r\n                                    newPriority !== old.style.getPropertyPriority(pname)) {\r\n                                    if (newPriority === '') {\r\n                                        item.styleDiff[pname] = newValue;\r\n                                    }\r\n                                    else {\r\n                                        item.styleDiff[pname] = [newValue, newPriority];\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    item._unchangedStyles[pname] = [newValue, newPriority];\r\n                                }\r\n                            }\r\n                            for (const pname of Array.from(old.style)) {\r\n                                if (target.style.getPropertyValue(pname) === '') {\r\n                                    item.styleDiff[pname] = false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case 'childList': {\r\n                    if (isBlocked(m.target, this.blockClass, this.blockSelector, true))\r\n                        return;\r\n                    if (m.target.tagName === 'TEXTAREA') {\r\n                        this.genTextAreaValueMutation(m.target);\r\n                        return;\r\n                    }\r\n                    m.addedNodes.forEach((n) => this.genAdds(n, m.target));\r\n                    m.removedNodes.forEach((n) => {\r\n                        const nodeId = this.mirror.getId(n);\r\n                        const parentId = isShadowRoot(m.target)\r\n                            ? this.mirror.getId(m.target.host)\r\n                            : this.mirror.getId(m.target);\r\n                        if (isBlocked(m.target, this.blockClass, this.blockSelector, false) ||\r\n                            isIgnored(n, this.mirror) ||\r\n                            !isSerialized(n, this.mirror)) {\r\n                            return;\r\n                        }\r\n                        if (this.addedSet.has(n)) {\r\n                            deepDelete(this.addedSet, n);\r\n                            this.droppedSet.add(n);\r\n                        }\r\n                        else if (this.addedSet.has(m.target) && nodeId === -1) ;\r\n                        else if (isAncestorRemoved(m.target, this.mirror)) ;\r\n                        else if (this.movedSet.has(n) &&\r\n                            this.movedMap[moveKey(nodeId, parentId)]) {\r\n                            deepDelete(this.movedSet, n);\r\n                        }\r\n                        else {\r\n                            this.removes.push({\r\n                                parentId,\r\n                                id: nodeId,\r\n                                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target)\r\n                                    ? true\r\n                                    : undefined,\r\n                            });\r\n                        }\r\n                        this.mapRemoves.push(n);\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n        this.genAdds = (n, target) => {\r\n            if (this.processedNodeManager.inOtherBuffer(n, this))\r\n                return;\r\n            if (this.addedSet.has(n) || this.movedSet.has(n))\r\n                return;\r\n            if (this.mirror.hasNode(n)) {\r\n                if (isIgnored(n, this.mirror)) {\r\n                    return;\r\n                }\r\n                this.movedSet.add(n);\r\n                let targetId = null;\r\n                if (target && this.mirror.hasNode(target)) {\r\n                    targetId = this.mirror.getId(target);\r\n                }\r\n                if (targetId && targetId !== -1) {\r\n                    this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;\r\n                }\r\n            }\r\n            else {\r\n                this.addedSet.add(n);\r\n                this.droppedSet.delete(n);\r\n            }\r\n            if (!isBlocked(n, this.blockClass, this.blockSelector, false)) {\r\n                n.childNodes.forEach((childN) => this.genAdds(childN));\r\n                if (hasShadowRoot(n)) {\r\n                    n.shadowRoot.childNodes.forEach((childN) => {\r\n                        this.processedNodeManager.add(childN, this);\r\n                        this.genAdds(childN, n);\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n    init(options) {\r\n        [\r\n            'mutationCb',\r\n            'blockClass',\r\n            'blockSelector',\r\n            'maskTextClass',\r\n            'maskTextSelector',\r\n            'inlineStylesheet',\r\n            'maskInputOptions',\r\n            'maskTextFn',\r\n            'maskInputFn',\r\n            'keepIframeSrcFn',\r\n            'recordCanvas',\r\n            'inlineImages',\r\n            'slimDOMOptions',\r\n            'dataURLOptions',\r\n            'doc',\r\n            'mirror',\r\n            'iframeManager',\r\n            'stylesheetManager',\r\n            'shadowDomManager',\r\n            'canvasManager',\r\n            'processedNodeManager',\r\n        ].forEach((key) => {\r\n            this[key] = options[key];\r\n        });\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n        this.canvasManager.freeze();\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n        this.canvasManager.unfreeze();\r\n        this.emit();\r\n    }\r\n    isFrozen() {\r\n        return this.frozen;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n        this.canvasManager.lock();\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n        this.canvasManager.unlock();\r\n        this.emit();\r\n    }\r\n    reset() {\r\n        this.shadowDomManager.reset();\r\n        this.canvasManager.reset();\r\n    }\r\n}\r\nfunction deepDelete(addsSet, n) {\r\n    addsSet.delete(n);\r\n    n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\r\n}\r\nfunction isParentRemoved(removes, n, mirror) {\r\n    if (removes.length === 0)\r\n        return false;\r\n    return _isParentRemoved(removes, n, mirror);\r\n}\r\nfunction _isParentRemoved(removes, n, mirror) {\r\n    const { parentNode } = n;\r\n    if (!parentNode) {\r\n        return false;\r\n    }\r\n    const parentId = mirror.getId(parentNode);\r\n    if (removes.some((r) => r.id === parentId)) {\r\n        return true;\r\n    }\r\n    return _isParentRemoved(removes, parentNode, mirror);\r\n}\r\nfunction isAncestorInSet(set, n) {\r\n    if (set.size === 0)\r\n        return false;\r\n    return _isAncestorInSet(set, n);\r\n}\r\nfunction _isAncestorInSet(set, n) {\r\n    const { parentNode } = n;\r\n    if (!parentNode) {\r\n        return false;\r\n    }\r\n    if (set.has(parentNode)) {\r\n        return true;\r\n    }\r\n    return _isAncestorInSet(set, parentNode);\r\n}\n\nlet errorHandler;\r\nfunction registerErrorHandler(handler) {\r\n    errorHandler = handler;\r\n}\r\nfunction unregisterErrorHandler() {\r\n    errorHandler = undefined;\r\n}\r\nconst callbackWrapper = (cb) => {\r\n    if (!errorHandler) {\r\n        return cb;\r\n    }\r\n    const rrwebWrapped = ((...rest) => {\r\n        try {\r\n            return cb(...rest);\r\n        }\r\n        catch (error) {\r\n            if (errorHandler && errorHandler(error) === true) {\r\n                return;\r\n            }\r\n            throw error;\r\n        }\r\n    });\r\n    return rrwebWrapped;\r\n};\n\nconst mutationBuffers = [];\r\nfunction getEventTarget(event) {\r\n    try {\r\n        if ('composedPath' in event) {\r\n            const path = event.composedPath();\r\n            if (path.length) {\r\n                return path[0];\r\n            }\r\n        }\r\n        else if ('path' in event && event.path.length) {\r\n            return event.path[0];\r\n        }\r\n    }\r\n    catch (_a) {\r\n    }\r\n    return event && event.target;\r\n}\r\nfunction initMutationObserver(options, rootEl) {\r\n    var _a, _b;\r\n    const mutationBuffer = new MutationBuffer();\r\n    mutationBuffers.push(mutationBuffer);\r\n    mutationBuffer.init(options);\r\n    let mutationObserverCtor = window.MutationObserver ||\r\n        window.__rrMutationObserver;\r\n    const angularZoneSymbol = (_b = (_a = window === null || window === void 0 ? void 0 : window.Zone) === null || _a === void 0 ? void 0 : _a.__symbol__) === null || _b === void 0 ? void 0 : _b.call(_a, 'MutationObserver');\r\n    if (angularZoneSymbol &&\r\n        window[angularZoneSymbol]) {\r\n        mutationObserverCtor = window[angularZoneSymbol];\r\n    }\r\n    const observer = new mutationObserverCtor(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));\r\n    observer.observe(rootEl, {\r\n        attributes: true,\r\n        attributeOldValue: true,\r\n        characterData: true,\r\n        characterDataOldValue: true,\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\r\nfunction initMoveObserver({ mousemoveCb, sampling, doc, mirror, }) {\r\n    if (sampling.mousemove === false) {\r\n        return () => {\r\n        };\r\n    }\r\n    const threshold = typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\r\n    const callbackThreshold = typeof sampling.mousemoveCallback === 'number'\r\n        ? sampling.mousemoveCallback\r\n        : 500;\r\n    let positions = [];\r\n    let timeBaseline;\r\n    const wrappedCb = throttle(callbackWrapper((source) => {\r\n        const totalOffset = Date.now() - timeBaseline;\r\n        mousemoveCb(positions.map((p) => {\r\n            p.timeOffset -= totalOffset;\r\n            return p;\r\n        }), source);\r\n        positions = [];\r\n        timeBaseline = null;\r\n    }), callbackThreshold);\r\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {\r\n        const target = getEventTarget(evt);\r\n        const { clientX, clientY } = legacy_isTouchEvent(evt)\r\n            ? evt.changedTouches[0]\r\n            : evt;\r\n        if (!timeBaseline) {\r\n            timeBaseline = nowTimestamp();\r\n        }\r\n        positions.push({\r\n            x: clientX,\r\n            y: clientY,\r\n            id: mirror.getId(target),\r\n            timeOffset: nowTimestamp() - timeBaseline,\r\n        });\r\n        wrappedCb(typeof DragEvent !== 'undefined' && evt instanceof DragEvent\r\n            ? IncrementalSource$1.Drag\r\n            : evt instanceof MouseEvent\r\n                ? IncrementalSource$1.MouseMove\r\n                : IncrementalSource$1.TouchMove);\r\n    }), threshold, {\r\n        trailing: false,\r\n    }));\r\n    const handlers = [\r\n        on('mousemove', updatePosition, doc),\r\n        on('touchmove', updatePosition, doc),\r\n        on('drag', updatePosition, doc),\r\n    ];\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initMouseInteractionObserver({ mouseInteractionCb, doc, mirror, blockClass, blockSelector, sampling, }) {\r\n    if (sampling.mouseInteraction === false) {\r\n        return () => {\r\n        };\r\n    }\r\n    const disableMap = sampling.mouseInteraction === true ||\r\n        sampling.mouseInteraction === undefined\r\n        ? {}\r\n        : sampling.mouseInteraction;\r\n    const handlers = [];\r\n    let currentPointerType = null;\r\n    const getHandler = (eventKey) => {\r\n        return (event) => {\r\n            const target = getEventTarget(event);\r\n            if (isBlocked(target, blockClass, blockSelector, true)) {\r\n                return;\r\n            }\r\n            let pointerType = null;\r\n            let thisEventKey = eventKey;\r\n            if ('pointerType' in event) {\r\n                switch (event.pointerType) {\r\n                    case 'mouse':\r\n                        pointerType = PointerTypes.Mouse;\r\n                        break;\r\n                    case 'touch':\r\n                        pointerType = PointerTypes.Touch;\r\n                        break;\r\n                    case 'pen':\r\n                        pointerType = PointerTypes.Pen;\r\n                        break;\r\n                }\r\n                if (pointerType === PointerTypes.Touch) {\r\n                    if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\r\n                        thisEventKey = 'TouchStart';\r\n                    }\r\n                    else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\r\n                        thisEventKey = 'TouchEnd';\r\n                    }\r\n                }\r\n                else if (pointerType === PointerTypes.Pen) ;\r\n            }\r\n            else if (legacy_isTouchEvent(event)) {\r\n                pointerType = PointerTypes.Touch;\r\n            }\r\n            if (pointerType !== null) {\r\n                currentPointerType = pointerType;\r\n                if ((thisEventKey.startsWith('Touch') &&\r\n                    pointerType === PointerTypes.Touch) ||\r\n                    (thisEventKey.startsWith('Mouse') &&\r\n                        pointerType === PointerTypes.Mouse)) {\r\n                    pointerType = null;\r\n                }\r\n            }\r\n            else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\r\n                pointerType = currentPointerType;\r\n                currentPointerType = null;\r\n            }\r\n            const e = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\r\n            if (!e) {\r\n                return;\r\n            }\r\n            const id = mirror.getId(target);\r\n            const { clientX, clientY } = e;\r\n            callbackWrapper(mouseInteractionCb)(Object.assign({ type: MouseInteractions[thisEventKey], id, x: clientX, y: clientY }, (pointerType !== null && { pointerType })));\r\n        };\r\n    };\r\n    Object.keys(MouseInteractions)\r\n        .filter((key) => Number.isNaN(Number(key)) &&\r\n        !key.endsWith('_Departed') &&\r\n        disableMap[key] !== false)\r\n        .forEach((eventKey) => {\r\n        let eventName = toLowerCase(eventKey);\r\n        const handler = getHandler(eventKey);\r\n        if (window.PointerEvent) {\r\n            switch (MouseInteractions[eventKey]) {\r\n                case MouseInteractions.MouseDown:\r\n                case MouseInteractions.MouseUp:\r\n                    eventName = eventName.replace('mouse', 'pointer');\r\n                    break;\r\n                case MouseInteractions.TouchStart:\r\n                case MouseInteractions.TouchEnd:\r\n                    return;\r\n            }\r\n        }\r\n        handlers.push(on(eventName, handler, doc));\r\n    });\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initScrollObserver({ scrollCb, doc, mirror, blockClass, blockSelector, sampling, }) {\r\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {\r\n        const target = getEventTarget(evt);\r\n        if (!target ||\r\n            isBlocked(target, blockClass, blockSelector, true)) {\r\n            return;\r\n        }\r\n        const id = mirror.getId(target);\r\n        if (target === doc && doc.defaultView) {\r\n            const scrollLeftTop = getWindowScroll(doc.defaultView);\r\n            scrollCb({\r\n                id,\r\n                x: scrollLeftTop.left,\r\n                y: scrollLeftTop.top,\r\n            });\r\n        }\r\n        else {\r\n            scrollCb({\r\n                id,\r\n                x: target.scrollLeft,\r\n                y: target.scrollTop,\r\n            });\r\n        }\r\n    }), sampling.scroll || 100));\r\n    return on('scroll', updatePosition, doc);\r\n}\r\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\r\n    let lastH = -1;\r\n    let lastW = -1;\r\n    const updateDimension = callbackWrapper(throttle(callbackWrapper(() => {\r\n        const height = getWindowHeight();\r\n        const width = getWindowWidth();\r\n        if (lastH !== height || lastW !== width) {\r\n            viewportResizeCb({\r\n                width: Number(width),\r\n                height: Number(height),\r\n            });\r\n            lastH = height;\r\n            lastW = width;\r\n        }\r\n    }), 200));\r\n    return on('resize', updateDimension, win);\r\n}\r\nconst INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\r\nconst lastInputValueMap = new WeakMap();\r\nfunction initInputObserver({ inputCb, doc, mirror, blockClass, blockSelector, ignoreClass, ignoreSelector, maskInputOptions, maskInputFn, sampling, userTriggeredOnInput, }) {\r\n    function eventHandler(event) {\r\n        let target = getEventTarget(event);\r\n        const userTriggered = event.isTrusted;\r\n        const tagName = target && target.tagName;\r\n        if (target && tagName === 'OPTION') {\r\n            target = target.parentElement;\r\n        }\r\n        if (!target ||\r\n            !tagName ||\r\n            INPUT_TAGS.indexOf(tagName) < 0 ||\r\n            isBlocked(target, blockClass, blockSelector, true)) {\r\n            return;\r\n        }\r\n        if (target.classList.contains(ignoreClass) ||\r\n            (ignoreSelector && target.matches(ignoreSelector))) {\r\n            return;\r\n        }\r\n        let text = target.value;\r\n        let isChecked = false;\r\n        const type = getInputType(target) || '';\r\n        if (type === 'radio' || type === 'checkbox') {\r\n            isChecked = target.checked;\r\n        }\r\n        else if (maskInputOptions[tagName.toLowerCase()] ||\r\n            maskInputOptions[type]) {\r\n            text = maskInputValue({\r\n                element: target,\r\n                maskInputOptions,\r\n                tagName,\r\n                type,\r\n                value: text,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        cbWithDedup(target, userTriggeredOnInput\r\n            ? { text, isChecked, userTriggered }\r\n            : { text, isChecked });\r\n        const name = target.name;\r\n        if (type === 'radio' && name && isChecked) {\r\n            doc\r\n                .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\r\n                .forEach((el) => {\r\n                if (el !== target) {\r\n                    const text = el.value;\r\n                    cbWithDedup(el, userTriggeredOnInput\r\n                        ? { text, isChecked: !isChecked, userTriggered: false }\r\n                        : { text, isChecked: !isChecked });\r\n                }\r\n            });\r\n        }\r\n    }\r\n    function cbWithDedup(target, v) {\r\n        const lastInputValue = lastInputValueMap.get(target);\r\n        if (!lastInputValue ||\r\n            lastInputValue.text !== v.text ||\r\n            lastInputValue.isChecked !== v.isChecked) {\r\n            lastInputValueMap.set(target, v);\r\n            const id = mirror.getId(target);\r\n            callbackWrapper(inputCb)(Object.assign(Object.assign({}, v), { id }));\r\n        }\r\n    }\r\n    const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\r\n    const handlers = events.map((eventName) => on(eventName, callbackWrapper(eventHandler), doc));\r\n    const currentWindow = doc.defaultView;\r\n    if (!currentWindow) {\r\n        return () => {\r\n            handlers.forEach((h) => h());\r\n        };\r\n    }\r\n    const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, 'value');\r\n    const hookProperties = [\r\n        [currentWindow.HTMLInputElement.prototype, 'value'],\r\n        [currentWindow.HTMLInputElement.prototype, 'checked'],\r\n        [currentWindow.HTMLSelectElement.prototype, 'value'],\r\n        [currentWindow.HTMLTextAreaElement.prototype, 'value'],\r\n        [currentWindow.HTMLSelectElement.prototype, 'selectedIndex'],\r\n        [currentWindow.HTMLOptionElement.prototype, 'selected'],\r\n    ];\r\n    if (propertyDescriptor && propertyDescriptor.set) {\r\n        handlers.push(...hookProperties.map((p) => hookSetter(p[0], p[1], {\r\n            set() {\r\n                callbackWrapper(eventHandler)({\r\n                    target: this,\r\n                    isTrusted: false,\r\n                });\r\n            },\r\n        }, false, currentWindow)));\r\n    }\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction getNestedCSSRulePositions(rule) {\r\n    const positions = [];\r\n    function recurse(childRule, pos) {\r\n        if ((hasNestedCSSRule('CSSGroupingRule') &&\r\n            childRule.parentRule instanceof CSSGroupingRule) ||\r\n            (hasNestedCSSRule('CSSMediaRule') &&\r\n                childRule.parentRule instanceof CSSMediaRule) ||\r\n            (hasNestedCSSRule('CSSSupportsRule') &&\r\n                childRule.parentRule instanceof CSSSupportsRule) ||\r\n            (hasNestedCSSRule('CSSConditionRule') &&\r\n                childRule.parentRule instanceof CSSConditionRule)) {\r\n            const rules = Array.from(childRule.parentRule.cssRules);\r\n            const index = rules.indexOf(childRule);\r\n            pos.unshift(index);\r\n        }\r\n        else if (childRule.parentStyleSheet) {\r\n            const rules = Array.from(childRule.parentStyleSheet.cssRules);\r\n            const index = rules.indexOf(childRule);\r\n            pos.unshift(index);\r\n        }\r\n        return pos;\r\n    }\r\n    return recurse(rule, positions);\r\n}\r\nfunction getIdAndStyleId(sheet, mirror, styleMirror) {\r\n    let id, styleId;\r\n    if (!sheet)\r\n        return {};\r\n    if (sheet.ownerNode)\r\n        id = mirror.getId(sheet.ownerNode);\r\n    else\r\n        styleId = styleMirror.getId(sheet);\r\n    return {\r\n        styleId,\r\n        id,\r\n    };\r\n}\r\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror, stylesheetManager }, { win }) {\r\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\r\n        return () => {\r\n        };\r\n    }\r\n    const insertRule = win.CSSStyleSheet.prototype.insertRule;\r\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            const [rule, index] = argumentsList;\r\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleSheetRuleCb({\r\n                    id,\r\n                    styleId,\r\n                    adds: [{ rule, index }],\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\r\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            const [index] = argumentsList;\r\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleSheetRuleCb({\r\n                    id,\r\n                    styleId,\r\n                    removes: [{ index }],\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    let replace;\r\n    if (win.CSSStyleSheet.prototype.replace) {\r\n        replace = win.CSSStyleSheet.prototype.replace;\r\n        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [text] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        replace: text,\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    }\r\n    let replaceSync;\r\n    if (win.CSSStyleSheet.prototype.replaceSync) {\r\n        replaceSync = win.CSSStyleSheet.prototype.replaceSync;\r\n        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [text] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        replaceSync: text,\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    }\r\n    const supportedNestedCSSRuleTypes = {};\r\n    if (canMonkeyPatchNestedCSSRule('CSSGroupingRule')) {\r\n        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\r\n    }\r\n    else {\r\n        if (canMonkeyPatchNestedCSSRule('CSSMediaRule')) {\r\n            supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\r\n        }\r\n        if (canMonkeyPatchNestedCSSRule('CSSConditionRule')) {\r\n            supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\r\n        }\r\n        if (canMonkeyPatchNestedCSSRule('CSSSupportsRule')) {\r\n            supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\r\n        }\r\n    }\r\n    const unmodifiedFunctions = {};\r\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\r\n        unmodifiedFunctions[typeKey] = {\r\n            insertRule: type.prototype.insertRule,\r\n            deleteRule: type.prototype.deleteRule,\r\n        };\r\n        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [rule, index] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        adds: [\r\n                            {\r\n                                rule,\r\n                                index: [\r\n                                    ...getNestedCSSRulePositions(thisArg),\r\n                                    index || 0,\r\n                                ],\r\n                            },\r\n                        ],\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [index] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        removes: [\r\n                            { index: [...getNestedCSSRulePositions(thisArg), index] },\r\n                        ],\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    });\r\n    return callbackWrapper(() => {\r\n        win.CSSStyleSheet.prototype.insertRule = insertRule;\r\n        win.CSSStyleSheet.prototype.deleteRule = deleteRule;\r\n        replace && (win.CSSStyleSheet.prototype.replace = replace);\r\n        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\r\n        Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\r\n            type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\r\n            type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\r\n        });\r\n    });\r\n}\r\nfunction initAdoptedStyleSheetObserver({ mirror, stylesheetManager, }, host) {\r\n    var _a, _b, _c;\r\n    let hostId = null;\r\n    if (host.nodeName === '#document')\r\n        hostId = mirror.getId(host);\r\n    else\r\n        hostId = mirror.getId(host.host);\r\n    const patchTarget = host.nodeName === '#document'\r\n        ? (_a = host.defaultView) === null || _a === void 0 ? void 0 : _a.Document\r\n        : (_c = (_b = host.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView) === null || _c === void 0 ? void 0 : _c.ShadowRoot;\r\n    const originalPropertyDescriptor = (patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype)\r\n        ? Object.getOwnPropertyDescriptor(patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype, 'adoptedStyleSheets')\r\n        : undefined;\r\n    if (hostId === null ||\r\n        hostId === -1 ||\r\n        !patchTarget ||\r\n        !originalPropertyDescriptor)\r\n        return () => {\r\n        };\r\n    Object.defineProperty(host, 'adoptedStyleSheets', {\r\n        configurable: originalPropertyDescriptor.configurable,\r\n        enumerable: originalPropertyDescriptor.enumerable,\r\n        get() {\r\n            var _a;\r\n            return (_a = originalPropertyDescriptor.get) === null || _a === void 0 ? void 0 : _a.call(this);\r\n        },\r\n        set(sheets) {\r\n            var _a;\r\n            const result = (_a = originalPropertyDescriptor.set) === null || _a === void 0 ? void 0 : _a.call(this, sheets);\r\n            if (hostId !== null && hostId !== -1) {\r\n                try {\r\n                    stylesheetManager.adoptStyleSheets(sheets, hostId);\r\n                }\r\n                catch (e) {\r\n                }\r\n            }\r\n            return result;\r\n        },\r\n    });\r\n    return callbackWrapper(() => {\r\n        Object.defineProperty(host, 'adoptedStyleSheets', {\r\n            configurable: originalPropertyDescriptor.configurable,\r\n            enumerable: originalPropertyDescriptor.enumerable,\r\n            get: originalPropertyDescriptor.get,\r\n            set: originalPropertyDescriptor.set,\r\n        });\r\n    });\r\n}\r\nfunction initStyleDeclarationObserver({ styleDeclarationCb, mirror, ignoreCSSAttributes, stylesheetManager, }, { win }) {\r\n    const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\r\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            var _a;\r\n            const [property, value, priority] = argumentsList;\r\n            if (ignoreCSSAttributes.has(property)) {\r\n                return setProperty.apply(thisArg, [property, value, priority]);\r\n            }\r\n            const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleDeclarationCb({\r\n                    id,\r\n                    styleId,\r\n                    set: {\r\n                        property,\r\n                        value,\r\n                        priority,\r\n                    },\r\n                    index: getNestedCSSRulePositions(thisArg.parentRule),\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\r\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            var _a;\r\n            const [property] = argumentsList;\r\n            if (ignoreCSSAttributes.has(property)) {\r\n                return removeProperty.apply(thisArg, [property]);\r\n            }\r\n            const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleDeclarationCb({\r\n                    id,\r\n                    styleId,\r\n                    remove: {\r\n                        property,\r\n                    },\r\n                    index: getNestedCSSRulePositions(thisArg.parentRule),\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    return callbackWrapper(() => {\r\n        win.CSSStyleDeclaration.prototype.setProperty = setProperty;\r\n        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\r\n    });\r\n}\r\nfunction initMediaInteractionObserver({ mediaInteractionCb, blockClass, blockSelector, mirror, sampling, doc, }) {\r\n    const handler = callbackWrapper((type) => throttle(callbackWrapper((event) => {\r\n        const target = getEventTarget(event);\r\n        if (!target ||\r\n            isBlocked(target, blockClass, blockSelector, true)) {\r\n            return;\r\n        }\r\n        const { currentTime, volume, muted, playbackRate, loop } = target;\r\n        mediaInteractionCb({\r\n            type,\r\n            id: mirror.getId(target),\r\n            currentTime,\r\n            volume,\r\n            muted,\r\n            playbackRate,\r\n            loop,\r\n        });\r\n    }), sampling.media || 500));\r\n    const handlers = [\r\n        on('play', handler(0), doc),\r\n        on('pause', handler(1), doc),\r\n        on('seeked', handler(2), doc),\r\n        on('volumechange', handler(3), doc),\r\n        on('ratechange', handler(4), doc),\r\n    ];\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initFontObserver({ fontCb, doc }) {\r\n    const win = doc.defaultView;\r\n    if (!win) {\r\n        return () => {\r\n        };\r\n    }\r\n    const handlers = [];\r\n    const fontMap = new WeakMap();\r\n    const originalFontFace = win.FontFace;\r\n    win.FontFace = function FontFace(family, source, descriptors) {\r\n        const fontFace = new originalFontFace(family, source, descriptors);\r\n        fontMap.set(fontFace, {\r\n            family,\r\n            buffer: typeof source !== 'string',\r\n            descriptors,\r\n            fontSource: typeof source === 'string'\r\n                ? source\r\n                : JSON.stringify(Array.from(new Uint8Array(source))),\r\n        });\r\n        return fontFace;\r\n    };\r\n    const restoreHandler = patch(doc.fonts, 'add', function (original) {\r\n        return function (fontFace) {\r\n            setTimeout(callbackWrapper(() => {\r\n                const p = fontMap.get(fontFace);\r\n                if (p) {\r\n                    fontCb(p);\r\n                    fontMap.delete(fontFace);\r\n                }\r\n            }), 0);\r\n            return original.apply(this, [fontFace]);\r\n        };\r\n    });\r\n    handlers.push(() => {\r\n        win.FontFace = originalFontFace;\r\n    });\r\n    handlers.push(restoreHandler);\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initSelectionObserver(param) {\r\n    const { doc, mirror, blockClass, blockSelector, selectionCb } = param;\r\n    let collapsed = true;\r\n    const updateSelection = callbackWrapper(() => {\r\n        const selection = doc.getSelection();\r\n        if (!selection || (collapsed && (selection === null || selection === void 0 ? void 0 : selection.isCollapsed)))\r\n            return;\r\n        collapsed = selection.isCollapsed || false;\r\n        const ranges = [];\r\n        const count = selection.rangeCount || 0;\r\n        for (let i = 0; i < count; i++) {\r\n            const range = selection.getRangeAt(i);\r\n            const { startContainer, startOffset, endContainer, endOffset } = range;\r\n            const blocked = isBlocked(startContainer, blockClass, blockSelector, true) ||\r\n                isBlocked(endContainer, blockClass, blockSelector, true);\r\n            if (blocked)\r\n                continue;\r\n            ranges.push({\r\n                start: mirror.getId(startContainer),\r\n                startOffset,\r\n                end: mirror.getId(endContainer),\r\n                endOffset,\r\n            });\r\n        }\r\n        selectionCb({ ranges });\r\n    });\r\n    updateSelection();\r\n    return on('selectionchange', updateSelection);\r\n}\r\nfunction initCustomElementObserver({ doc, customElementCb, }) {\r\n    const win = doc.defaultView;\r\n    if (!win || !win.customElements)\r\n        return () => { };\r\n    const restoreHandler = patch(win.customElements, 'define', function (original) {\r\n        return function (name, constructor, options) {\r\n            try {\r\n                customElementCb({\r\n                    define: {\r\n                        name,\r\n                    },\r\n                });\r\n            }\r\n            catch (e) {\r\n                console.warn(`Custom element callback failed for ${name}`);\r\n            }\r\n            return original.apply(this, [name, constructor, options]);\r\n        };\r\n    });\r\n    return restoreHandler;\r\n}\r\nfunction mergeHooks(o, hooks) {\r\n    const { mutationCb, mousemoveCb, mouseInteractionCb, scrollCb, viewportResizeCb, inputCb, mediaInteractionCb, styleSheetRuleCb, styleDeclarationCb, canvasMutationCb, fontCb, selectionCb, customElementCb, } = o;\r\n    o.mutationCb = (...p) => {\r\n        if (hooks.mutation) {\r\n            hooks.mutation(...p);\r\n        }\r\n        mutationCb(...p);\r\n    };\r\n    o.mousemoveCb = (...p) => {\r\n        if (hooks.mousemove) {\r\n            hooks.mousemove(...p);\r\n        }\r\n        mousemoveCb(...p);\r\n    };\r\n    o.mouseInteractionCb = (...p) => {\r\n        if (hooks.mouseInteraction) {\r\n            hooks.mouseInteraction(...p);\r\n        }\r\n        mouseInteractionCb(...p);\r\n    };\r\n    o.scrollCb = (...p) => {\r\n        if (hooks.scroll) {\r\n            hooks.scroll(...p);\r\n        }\r\n        scrollCb(...p);\r\n    };\r\n    o.viewportResizeCb = (...p) => {\r\n        if (hooks.viewportResize) {\r\n            hooks.viewportResize(...p);\r\n        }\r\n        viewportResizeCb(...p);\r\n    };\r\n    o.inputCb = (...p) => {\r\n        if (hooks.input) {\r\n            hooks.input(...p);\r\n        }\r\n        inputCb(...p);\r\n    };\r\n    o.mediaInteractionCb = (...p) => {\r\n        if (hooks.mediaInteaction) {\r\n            hooks.mediaInteaction(...p);\r\n        }\r\n        mediaInteractionCb(...p);\r\n    };\r\n    o.styleSheetRuleCb = (...p) => {\r\n        if (hooks.styleSheetRule) {\r\n            hooks.styleSheetRule(...p);\r\n        }\r\n        styleSheetRuleCb(...p);\r\n    };\r\n    o.styleDeclarationCb = (...p) => {\r\n        if (hooks.styleDeclaration) {\r\n            hooks.styleDeclaration(...p);\r\n        }\r\n        styleDeclarationCb(...p);\r\n    };\r\n    o.canvasMutationCb = (...p) => {\r\n        if (hooks.canvasMutation) {\r\n            hooks.canvasMutation(...p);\r\n        }\r\n        canvasMutationCb(...p);\r\n    };\r\n    o.fontCb = (...p) => {\r\n        if (hooks.font) {\r\n            hooks.font(...p);\r\n        }\r\n        fontCb(...p);\r\n    };\r\n    o.selectionCb = (...p) => {\r\n        if (hooks.selection) {\r\n            hooks.selection(...p);\r\n        }\r\n        selectionCb(...p);\r\n    };\r\n    o.customElementCb = (...c) => {\r\n        if (hooks.customElement) {\r\n            hooks.customElement(...c);\r\n        }\r\n        customElementCb(...c);\r\n    };\r\n}\r\nfunction initObservers(o, hooks = {}) {\r\n    const currentWindow = o.doc.defaultView;\r\n    if (!currentWindow) {\r\n        return () => {\r\n        };\r\n    }\r\n    mergeHooks(o, hooks);\r\n    let mutationObserver;\r\n    if (o.recordDOM) {\r\n        mutationObserver = initMutationObserver(o, o.doc);\r\n    }\r\n    const mousemoveHandler = initMoveObserver(o);\r\n    const mouseInteractionHandler = initMouseInteractionObserver(o);\r\n    const scrollHandler = initScrollObserver(o);\r\n    const viewportResizeHandler = initViewportResizeObserver(o, {\r\n        win: currentWindow,\r\n    });\r\n    const inputHandler = initInputObserver(o);\r\n    const mediaInteractionHandler = initMediaInteractionObserver(o);\r\n    let styleSheetObserver = () => { };\r\n    let adoptedStyleSheetObserver = () => { };\r\n    let styleDeclarationObserver = () => { };\r\n    let fontObserver = () => { };\r\n    if (o.recordDOM) {\r\n        styleSheetObserver = initStyleSheetObserver(o, { win: currentWindow });\r\n        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);\r\n        styleDeclarationObserver = initStyleDeclarationObserver(o, {\r\n            win: currentWindow,\r\n        });\r\n        if (o.collectFonts) {\r\n            fontObserver = initFontObserver(o);\r\n        }\r\n    }\r\n    const selectionObserver = initSelectionObserver(o);\r\n    const customElementObserver = initCustomElementObserver(o);\r\n    const pluginHandlers = [];\r\n    for (const plugin of o.plugins) {\r\n        pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\r\n    }\r\n    return callbackWrapper(() => {\r\n        mutationBuffers.forEach((b) => b.reset());\r\n        mutationObserver === null || mutationObserver === void 0 ? void 0 : mutationObserver.disconnect();\r\n        mousemoveHandler();\r\n        mouseInteractionHandler();\r\n        scrollHandler();\r\n        viewportResizeHandler();\r\n        inputHandler();\r\n        mediaInteractionHandler();\r\n        styleSheetObserver();\r\n        adoptedStyleSheetObserver();\r\n        styleDeclarationObserver();\r\n        fontObserver();\r\n        selectionObserver();\r\n        customElementObserver();\r\n        pluginHandlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction hasNestedCSSRule(prop) {\r\n    return typeof window[prop] !== 'undefined';\r\n}\r\nfunction canMonkeyPatchNestedCSSRule(prop) {\r\n    return Boolean(typeof window[prop] !== 'undefined' &&\r\n        window[prop].prototype &&\r\n        'insertRule' in window[prop].prototype &&\r\n        'deleteRule' in window[prop].prototype);\r\n}\n\nclass CrossOriginIframeMirror {\r\n    constructor(generateIdFn) {\r\n        this.generateIdFn = generateIdFn;\r\n        this.iframeIdToRemoteIdMap = new WeakMap();\r\n        this.iframeRemoteIdToIdMap = new WeakMap();\r\n    }\r\n    getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\r\n        const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\r\n        const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\r\n        let id = idToRemoteIdMap.get(remoteId);\r\n        if (!id) {\r\n            id = this.generateIdFn();\r\n            idToRemoteIdMap.set(remoteId, id);\r\n            remoteIdToIdMap.set(id, remoteId);\r\n        }\r\n        return id;\r\n    }\r\n    getIds(iframe, remoteId) {\r\n        const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\r\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\r\n        return remoteId.map((id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap));\r\n    }\r\n    getRemoteId(iframe, id, map) {\r\n        const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\r\n        if (typeof id !== 'number')\r\n            return id;\r\n        const remoteId = remoteIdToIdMap.get(id);\r\n        if (!remoteId)\r\n            return -1;\r\n        return remoteId;\r\n    }\r\n    getRemoteIds(iframe, ids) {\r\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\r\n        return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\r\n    }\r\n    reset(iframe) {\r\n        if (!iframe) {\r\n            this.iframeIdToRemoteIdMap = new WeakMap();\r\n            this.iframeRemoteIdToIdMap = new WeakMap();\r\n            return;\r\n        }\r\n        this.iframeIdToRemoteIdMap.delete(iframe);\r\n        this.iframeRemoteIdToIdMap.delete(iframe);\r\n    }\r\n    getIdToRemoteIdMap(iframe) {\r\n        let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\r\n        if (!idToRemoteIdMap) {\r\n            idToRemoteIdMap = new Map();\r\n            this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\r\n        }\r\n        return idToRemoteIdMap;\r\n    }\r\n    getRemoteIdToIdMap(iframe) {\r\n        let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\r\n        if (!remoteIdToIdMap) {\r\n            remoteIdToIdMap = new Map();\r\n            this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\r\n        }\r\n        return remoteIdToIdMap;\r\n    }\r\n}\n\nclass IframeManager {\r\n    constructor(options) {\r\n        this.iframes = new WeakMap();\r\n        this.crossOriginIframeMap = new WeakMap();\r\n        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\r\n        this.crossOriginIframeRootIdMap = new WeakMap();\r\n        this.mutationCb = options.mutationCb;\r\n        this.wrappedEmit = options.wrappedEmit;\r\n        this.stylesheetManager = options.stylesheetManager;\r\n        this.recordCrossOriginIframes = options.recordCrossOriginIframes;\r\n        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\r\n        this.mirror = options.mirror;\r\n        if (this.recordCrossOriginIframes) {\r\n            window.addEventListener('message', this.handleMessage.bind(this));\r\n        }\r\n    }\r\n    addIframe(iframeEl) {\r\n        this.iframes.set(iframeEl, true);\r\n        if (iframeEl.contentWindow)\r\n            this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\r\n    }\r\n    addLoadListener(cb) {\r\n        this.loadListener = cb;\r\n    }\r\n    attachIframe(iframeEl, childSn) {\r\n        var _a;\r\n        this.mutationCb({\r\n            adds: [\r\n                {\r\n                    parentId: this.mirror.getId(iframeEl),\r\n                    nextId: null,\r\n                    node: childSn,\r\n                },\r\n            ],\r\n            removes: [],\r\n            texts: [],\r\n            attributes: [],\r\n            isAttachIframe: true,\r\n        });\r\n        (_a = this.loadListener) === null || _a === void 0 ? void 0 : _a.call(this, iframeEl);\r\n        if (iframeEl.contentDocument &&\r\n            iframeEl.contentDocument.adoptedStyleSheets &&\r\n            iframeEl.contentDocument.adoptedStyleSheets.length > 0)\r\n            this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\r\n    }\r\n    handleMessage(message) {\r\n        const crossOriginMessageEvent = message;\r\n        if (crossOriginMessageEvent.data.type !== 'rrweb' ||\r\n            crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\r\n            return;\r\n        const iframeSourceWindow = message.source;\r\n        if (!iframeSourceWindow)\r\n            return;\r\n        const iframeEl = this.crossOriginIframeMap.get(message.source);\r\n        if (!iframeEl)\r\n            return;\r\n        const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\r\n        if (transformedEvent)\r\n            this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\r\n    }\r\n    transformCrossOriginEvent(iframeEl, e) {\r\n        var _a;\r\n        switch (e.type) {\r\n            case EventType$1.FullSnapshot: {\r\n                this.crossOriginIframeMirror.reset(iframeEl);\r\n                this.crossOriginIframeStyleMirror.reset(iframeEl);\r\n                this.replaceIdOnNode(e.data.node, iframeEl);\r\n                const rootId = e.data.node.id;\r\n                this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\r\n                this.patchRootIdOnNode(e.data.node, rootId);\r\n                return {\r\n                    timestamp: e.timestamp,\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource$1.Mutation,\r\n                        adds: [\r\n                            {\r\n                                parentId: this.mirror.getId(iframeEl),\r\n                                nextId: null,\r\n                                node: e.data.node,\r\n                            },\r\n                        ],\r\n                        removes: [],\r\n                        texts: [],\r\n                        attributes: [],\r\n                        isAttachIframe: true,\r\n                    },\r\n                };\r\n            }\r\n            case EventType$1.Meta:\r\n            case EventType$1.Load:\r\n            case EventType$1.DomContentLoaded: {\r\n                return false;\r\n            }\r\n            case EventType$1.Plugin: {\r\n                return e;\r\n            }\r\n            case EventType$1.Custom: {\r\n                this.replaceIds(e.data.payload, iframeEl, ['id', 'parentId', 'previousId', 'nextId']);\r\n                return e;\r\n            }\r\n            case EventType$1.IncrementalSnapshot: {\r\n                switch (e.data.source) {\r\n                    case IncrementalSource$1.Mutation: {\r\n                        e.data.adds.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, [\r\n                                'parentId',\r\n                                'nextId',\r\n                                'previousId',\r\n                            ]);\r\n                            this.replaceIdOnNode(n.node, iframeEl);\r\n                            const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\r\n                            rootId && this.patchRootIdOnNode(n.node, rootId);\r\n                        });\r\n                        e.data.removes.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['parentId', 'id']);\r\n                        });\r\n                        e.data.attributes.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['id']);\r\n                        });\r\n                        e.data.texts.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['id']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.Drag:\r\n                    case IncrementalSource$1.TouchMove:\r\n                    case IncrementalSource$1.MouseMove: {\r\n                        e.data.positions.forEach((p) => {\r\n                            this.replaceIds(p, iframeEl, ['id']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.ViewportResize: {\r\n                        return false;\r\n                    }\r\n                    case IncrementalSource$1.MediaInteraction:\r\n                    case IncrementalSource$1.MouseInteraction:\r\n                    case IncrementalSource$1.Scroll:\r\n                    case IncrementalSource$1.CanvasMutation:\r\n                    case IncrementalSource$1.Input: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.StyleSheetRule:\r\n                    case IncrementalSource$1.StyleDeclaration: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        this.replaceStyleIds(e.data, iframeEl, ['styleId']);\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.Font: {\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.Selection: {\r\n                        e.data.ranges.forEach((range) => {\r\n                            this.replaceIds(range, iframeEl, ['start', 'end']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.AdoptedStyleSheet: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        this.replaceStyleIds(e.data, iframeEl, ['styleIds']);\r\n                        (_a = e.data.styles) === null || _a === void 0 ? void 0 : _a.forEach((style) => {\r\n                            this.replaceStyleIds(style, iframeEl, ['styleId']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    replace(iframeMirror, obj, iframeEl, keys) {\r\n        for (const key of keys) {\r\n            if (!Array.isArray(obj[key]) && typeof obj[key] !== 'number')\r\n                continue;\r\n            if (Array.isArray(obj[key])) {\r\n                obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\r\n            }\r\n            else {\r\n                obj[key] = iframeMirror.getId(iframeEl, obj[key]);\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n    replaceIds(obj, iframeEl, keys) {\r\n        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\r\n    }\r\n    replaceStyleIds(obj, iframeEl, keys) {\r\n        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\r\n    }\r\n    replaceIdOnNode(node, iframeEl) {\r\n        this.replaceIds(node, iframeEl, ['id', 'rootId']);\r\n        if ('childNodes' in node) {\r\n            node.childNodes.forEach((child) => {\r\n                this.replaceIdOnNode(child, iframeEl);\r\n            });\r\n        }\r\n    }\r\n    patchRootIdOnNode(node, rootId) {\r\n        if (node.type !== NodeType.Document && !node.rootId)\r\n            node.rootId = rootId;\r\n        if ('childNodes' in node) {\r\n            node.childNodes.forEach((child) => {\r\n                this.patchRootIdOnNode(child, rootId);\r\n            });\r\n        }\r\n    }\r\n}\n\nclass ShadowDomManager {\r\n    constructor(options) {\r\n        this.shadowDoms = new WeakSet();\r\n        this.restoreHandlers = [];\r\n        this.mutationCb = options.mutationCb;\r\n        this.scrollCb = options.scrollCb;\r\n        this.bypassOptions = options.bypassOptions;\r\n        this.mirror = options.mirror;\r\n        this.init();\r\n    }\r\n    init() {\r\n        this.reset();\r\n        this.patchAttachShadow(Element, document);\r\n    }\r\n    addShadowRoot(shadowRoot, doc) {\r\n        if (!isNativeShadowDom(shadowRoot))\r\n            return;\r\n        if (this.shadowDoms.has(shadowRoot))\r\n            return;\r\n        this.shadowDoms.add(shadowRoot);\r\n        const observer = initMutationObserver(Object.assign(Object.assign({}, this.bypassOptions), { doc, mutationCb: this.mutationCb, mirror: this.mirror, shadowDomManager: this }), shadowRoot);\r\n        this.restoreHandlers.push(() => observer.disconnect());\r\n        this.restoreHandlers.push(initScrollObserver(Object.assign(Object.assign({}, this.bypassOptions), { scrollCb: this.scrollCb, doc: shadowRoot, mirror: this.mirror })));\r\n        setTimeout(() => {\r\n            if (shadowRoot.adoptedStyleSheets &&\r\n                shadowRoot.adoptedStyleSheets.length > 0)\r\n                this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));\r\n            this.restoreHandlers.push(initAdoptedStyleSheetObserver({\r\n                mirror: this.mirror,\r\n                stylesheetManager: this.bypassOptions.stylesheetManager,\r\n            }, shadowRoot));\r\n        }, 0);\r\n    }\r\n    observeAttachShadow(iframeElement) {\r\n        if (!iframeElement.contentWindow || !iframeElement.contentDocument)\r\n            return;\r\n        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\r\n    }\r\n    patchAttachShadow(element, doc) {\r\n        const manager = this;\r\n        this.restoreHandlers.push(patch(element.prototype, 'attachShadow', function (original) {\r\n            return function (option) {\r\n                const shadowRoot = original.call(this, option);\r\n                if (this.shadowRoot && inDom(this))\r\n                    manager.addShadowRoot(this.shadowRoot, doc);\r\n                return shadowRoot;\r\n            };\r\n        }));\r\n    }\r\n    reset() {\r\n        this.restoreHandlers.forEach((handler) => {\r\n            try {\r\n                handler();\r\n            }\r\n            catch (e) {\r\n            }\r\n        });\r\n        this.restoreHandlers = [];\r\n        this.shadowDoms = new WeakSet();\r\n    }\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\n\nconst canvasVarMap = new Map();\r\nfunction variableListFor(ctx, ctor) {\r\n    let contextMap = canvasVarMap.get(ctx);\r\n    if (!contextMap) {\r\n        contextMap = new Map();\r\n        canvasVarMap.set(ctx, contextMap);\r\n    }\r\n    if (!contextMap.has(ctor)) {\r\n        contextMap.set(ctor, []);\r\n    }\r\n    return contextMap.get(ctor);\r\n}\r\nconst saveWebGLVar = (value, win, ctx) => {\r\n    if (!value ||\r\n        !(isInstanceOfWebGLObject(value, win) || typeof value === 'object'))\r\n        return;\r\n    const name = value.constructor.name;\r\n    const list = variableListFor(ctx, name);\r\n    let index = list.indexOf(value);\r\n    if (index === -1) {\r\n        index = list.length;\r\n        list.push(value);\r\n    }\r\n    return index;\r\n};\r\nfunction serializeArg(value, win, ctx) {\r\n    if (value instanceof Array) {\r\n        return value.map((arg) => serializeArg(arg, win, ctx));\r\n    }\r\n    else if (value === null) {\r\n        return value;\r\n    }\r\n    else if (value instanceof Float32Array ||\r\n        value instanceof Float64Array ||\r\n        value instanceof Int32Array ||\r\n        value instanceof Uint32Array ||\r\n        value instanceof Uint8Array ||\r\n        value instanceof Uint16Array ||\r\n        value instanceof Int16Array ||\r\n        value instanceof Int8Array ||\r\n        value instanceof Uint8ClampedArray) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [Object.values(value)],\r\n        };\r\n    }\r\n    else if (value instanceof ArrayBuffer) {\r\n        const name = value.constructor.name;\r\n        const base64 = encode(value);\r\n        return {\r\n            rr_type: name,\r\n            base64,\r\n        };\r\n    }\r\n    else if (value instanceof DataView) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [\r\n                serializeArg(value.buffer, win, ctx),\r\n                value.byteOffset,\r\n                value.byteLength,\r\n            ],\r\n        };\r\n    }\r\n    else if (value instanceof HTMLImageElement) {\r\n        const name = value.constructor.name;\r\n        const { src } = value;\r\n        return {\r\n            rr_type: name,\r\n            src,\r\n        };\r\n    }\r\n    else if (value instanceof HTMLCanvasElement) {\r\n        const name = 'HTMLImageElement';\r\n        const src = value.toDataURL();\r\n        return {\r\n            rr_type: name,\r\n            src,\r\n        };\r\n    }\r\n    else if (value instanceof ImageData) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [serializeArg(value.data, win, ctx), value.width, value.height],\r\n        };\r\n    }\r\n    else if (isInstanceOfWebGLObject(value, win) || typeof value === 'object') {\r\n        const name = value.constructor.name;\r\n        const index = saveWebGLVar(value, win, ctx);\r\n        return {\r\n            rr_type: name,\r\n            index: index,\r\n        };\r\n    }\r\n    return value;\r\n}\r\nconst serializeArgs = (args, win, ctx) => {\r\n    return args.map((arg) => serializeArg(arg, win, ctx));\r\n};\r\nconst isInstanceOfWebGLObject = (value, win) => {\r\n    const webGLConstructorNames = [\r\n        'WebGLActiveInfo',\r\n        'WebGLBuffer',\r\n        'WebGLFramebuffer',\r\n        'WebGLProgram',\r\n        'WebGLRenderbuffer',\r\n        'WebGLShader',\r\n        'WebGLShaderPrecisionFormat',\r\n        'WebGLTexture',\r\n        'WebGLUniformLocation',\r\n        'WebGLVertexArrayObject',\r\n        'WebGLVertexArrayObjectOES',\r\n    ];\r\n    const supportedWebGLConstructorNames = webGLConstructorNames.filter((name) => typeof win[name] === 'function');\r\n    return Boolean(supportedWebGLConstructorNames.find((name) => value instanceof win[name]));\r\n};\n\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {\r\n    const handlers = [];\r\n    const props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\r\n    for (const prop of props2D) {\r\n        try {\r\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\r\n                        setTimeout(() => {\r\n                            const recordArgs = serializeArgs(args, win, this);\r\n                            cb(this.canvas, {\r\n                                type: CanvasContext['2D'],\r\n                                property: prop,\r\n                                args: recordArgs,\r\n                            });\r\n                        }, 0);\r\n                    }\r\n                    return original.apply(this, args);\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch (_a) {\r\n            const hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type: CanvasContext['2D'],\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nfunction getNormalizedContextName(contextType) {\r\n    return contextType === 'experimental-webgl' ? 'webgl' : contextType;\r\n}\r\nfunction initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {\r\n    const handlers = [];\r\n    try {\r\n        const restoreHandler = patch(win.HTMLCanvasElement.prototype, 'getContext', function (original) {\r\n            return function (contextType, ...args) {\r\n                if (!isBlocked(this, blockClass, blockSelector, true)) {\r\n                    const ctxName = getNormalizedContextName(contextType);\r\n                    if (!('__context' in this))\r\n                        this.__context = ctxName;\r\n                    if (setPreserveDrawingBufferToTrue &&\r\n                        ['webgl', 'webgl2'].includes(ctxName)) {\r\n                        if (args[0] && typeof args[0] === 'object') {\r\n                            const contextAttributes = args[0];\r\n                            if (!contextAttributes.preserveDrawingBuffer) {\r\n                                contextAttributes.preserveDrawingBuffer = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            args.splice(0, 1, {\r\n                                preserveDrawingBuffer: true,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                return original.apply(this, [contextType, ...args]);\r\n            };\r\n        });\r\n        handlers.push(restoreHandler);\r\n    }\r\n    catch (_a) {\r\n        console.error('failed to patch HTMLCanvasElement.prototype.getContext');\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, mirror, win) {\r\n    const handlers = [];\r\n    const props = Object.getOwnPropertyNames(prototype);\r\n    for (const prop of props) {\r\n        if ([\r\n            'isContextLost',\r\n            'canvas',\r\n            'drawingBufferWidth',\r\n            'drawingBufferHeight',\r\n        ].includes(prop)) {\r\n            continue;\r\n        }\r\n        try {\r\n            if (typeof prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    const result = original.apply(this, args);\r\n                    saveWebGLVar(result, win, this);\r\n                    if ('tagName' in this.canvas &&\r\n                        !isBlocked(this.canvas, blockClass, blockSelector, true)) {\r\n                        const recordArgs = serializeArgs(args, win, this);\r\n                        const mutation = {\r\n                            type,\r\n                            property: prop,\r\n                            args: recordArgs,\r\n                        };\r\n                        cb(this.canvas, mutation);\r\n                    }\r\n                    return result;\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch (_a) {\r\n            const hookHandler = hookSetter(prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type,\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return handlers;\r\n}\r\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector, mirror) {\r\n    const handlers = [];\r\n    handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, mirror, win));\r\n    if (typeof win.WebGL2RenderingContext !== 'undefined') {\r\n        handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, mirror, win));\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nfunction funcToSource(fn, sourcemapArg) {\n    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n    var source = fn.toString();\n    var lines = source.split('\\n');\n    lines.pop();\n    lines.shift();\n    var blankPrefixLength = lines[0].search(/\\S/);\n    var regex = /(['\"])__worker_loader_strict__(['\"])/g;\n    for (var i = 0, n = lines.length; i < n; ++i) {\n        lines[i] = lines[i].substring(blankPrefixLength).replace(regex, '$1use strict$2') + '\\n';\n    }\n    if (sourcemap) {\n        lines.push('\\/\\/# sourceMappingURL=' + sourcemap + '\\n');\n    }\n    return lines;\n}\n\nfunction createURL(fn, sourcemapArg) {\n    var lines = funcToSource(fn, sourcemapArg);\n    var blob = new Blob(lines, { type: 'application/javascript' });\n    return URL.createObjectURL(blob);\n}\n\nfunction createInlineWorkerFactory(fn, sourcemapArg) {\n    var url;\n    return function WorkerFactory(options) {\n        url = url || createURL(fn, sourcemapArg);\n        return new Worker(url, options);\n    };\n}\n\nvar WorkerFactory = createInlineWorkerFactory(/* rollup-plugin-web-worker-loader */function () {\n(function () {\n    '__worker_loader_strict__';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\n\n    /*\n     * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i = 0; i < chars.length; i++) {\n        lookup[chars.charCodeAt(i)] = i;\n    }\n    var encode = function (arraybuffer) {\n        var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n        for (i = 0; i < len; i += 3) {\n            base64 += chars[bytes[i] >> 2];\n            base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n            base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n            base64 += chars[bytes[i + 2] & 63];\n        }\n        if (len % 3 === 2) {\n            base64 = base64.substring(0, base64.length - 1) + '=';\n        }\n        else if (len % 3 === 1) {\n            base64 = base64.substring(0, base64.length - 2) + '==';\n        }\n        return base64;\n    };\n\n    const lastBlobMap = new Map();\r\n    const transparentBlobMap = new Map();\r\n    function getTransparentBlobFor(width, height, dataURLOptions) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const id = `${width}-${height}`;\r\n            if ('OffscreenCanvas' in globalThis) {\r\n                if (transparentBlobMap.has(id))\r\n                    return transparentBlobMap.get(id);\r\n                const offscreen = new OffscreenCanvas(width, height);\r\n                offscreen.getContext('2d');\r\n                const blob = yield offscreen.convertToBlob(dataURLOptions);\r\n                const arrayBuffer = yield blob.arrayBuffer();\r\n                const base64 = encode(arrayBuffer);\r\n                transparentBlobMap.set(id, base64);\r\n                return base64;\r\n            }\r\n            else {\r\n                return '';\r\n            }\r\n        });\r\n    }\r\n    const worker = self;\r\n    worker.onmessage = function (e) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if ('OffscreenCanvas' in globalThis) {\r\n                const { id, bitmap, width, height, dataURLOptions } = e.data;\r\n                const transparentBase64 = getTransparentBlobFor(width, height, dataURLOptions);\r\n                const offscreen = new OffscreenCanvas(width, height);\r\n                const ctx = offscreen.getContext('2d');\r\n                ctx.drawImage(bitmap, 0, 0);\r\n                bitmap.close();\r\n                const blob = yield offscreen.convertToBlob(dataURLOptions);\r\n                const type = blob.type;\r\n                const arrayBuffer = yield blob.arrayBuffer();\r\n                const base64 = encode(arrayBuffer);\r\n                if (!lastBlobMap.has(id) && (yield transparentBase64) === base64) {\r\n                    lastBlobMap.set(id, base64);\r\n                    return worker.postMessage({ id });\r\n                }\r\n                if (lastBlobMap.get(id) === base64)\r\n                    return worker.postMessage({ id });\r\n                worker.postMessage({\r\n                    id,\r\n                    type,\r\n                    base64,\r\n                    width,\r\n                    height,\r\n                });\r\n                lastBlobMap.set(id, base64);\r\n            }\r\n            else {\r\n                return worker.postMessage({ id: e.data.id });\r\n            }\r\n        });\r\n    };\n\n})();\n}, null);\n\nclass CanvasManager {\r\n    reset() {\r\n        this.pendingCanvasMutations.clear();\r\n        this.resetObservers && this.resetObservers();\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n    }\r\n    constructor(options) {\r\n        this.pendingCanvasMutations = new Map();\r\n        this.rafStamps = { latestId: 0, invokeId: null };\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.processMutation = (target, mutation) => {\r\n            const newFrame = this.rafStamps.invokeId &&\r\n                this.rafStamps.latestId !== this.rafStamps.invokeId;\r\n            if (newFrame || !this.rafStamps.invokeId)\r\n                this.rafStamps.invokeId = this.rafStamps.latestId;\r\n            if (!this.pendingCanvasMutations.has(target)) {\r\n                this.pendingCanvasMutations.set(target, []);\r\n            }\r\n            this.pendingCanvasMutations.get(target).push(mutation);\r\n        };\r\n        const { sampling = 'all', win, blockClass, blockSelector, recordCanvas, dataURLOptions, } = options;\r\n        this.mutationCb = options.mutationCb;\r\n        this.mirror = options.mirror;\r\n        if (recordCanvas && sampling === 'all')\r\n            this.initCanvasMutationObserver(win, blockClass, blockSelector);\r\n        if (recordCanvas && typeof sampling === 'number')\r\n            this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\r\n                dataURLOptions,\r\n            });\r\n    }\r\n    initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, true);\r\n        const snapshotInProgressMap = new Map();\r\n        const worker = new WorkerFactory();\r\n        worker.onmessage = (e) => {\r\n            const { id } = e.data;\r\n            snapshotInProgressMap.set(id, false);\r\n            if (!('base64' in e.data))\r\n                return;\r\n            const { base64, type, width, height } = e.data;\r\n            this.mutationCb({\r\n                id,\r\n                type: CanvasContext['2D'],\r\n                commands: [\r\n                    {\r\n                        property: 'clearRect',\r\n                        args: [0, 0, width, height],\r\n                    },\r\n                    {\r\n                        property: 'drawImage',\r\n                        args: [\r\n                            {\r\n                                rr_type: 'ImageBitmap',\r\n                                args: [\r\n                                    {\r\n                                        rr_type: 'Blob',\r\n                                        data: [{ rr_type: 'ArrayBuffer', base64 }],\r\n                                        type,\r\n                                    },\r\n                                ],\r\n                            },\r\n                            0,\r\n                            0,\r\n                        ],\r\n                    },\r\n                ],\r\n            });\r\n        };\r\n        const timeBetweenSnapshots = 1000 / fps;\r\n        let lastSnapshotTime = 0;\r\n        let rafId;\r\n        const getCanvas = () => {\r\n            const matchedCanvas = [];\r\n            win.document.querySelectorAll('canvas').forEach((canvas) => {\r\n                if (!isBlocked(canvas, blockClass, blockSelector, true)) {\r\n                    matchedCanvas.push(canvas);\r\n                }\r\n            });\r\n            return matchedCanvas;\r\n        };\r\n        const takeCanvasSnapshots = (timestamp) => {\r\n            if (lastSnapshotTime &&\r\n                timestamp - lastSnapshotTime < timeBetweenSnapshots) {\r\n                rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n                return;\r\n            }\r\n            lastSnapshotTime = timestamp;\r\n            getCanvas()\r\n                .forEach((canvas) => __awaiter(this, void 0, void 0, function* () {\r\n                var _a;\r\n                const id = this.mirror.getId(canvas);\r\n                if (snapshotInProgressMap.get(id))\r\n                    return;\r\n                if (canvas.width === 0 || canvas.height === 0)\r\n                    return;\r\n                snapshotInProgressMap.set(id, true);\r\n                if (['webgl', 'webgl2'].includes(canvas.__context)) {\r\n                    const context = canvas.getContext(canvas.__context);\r\n                    if (((_a = context === null || context === void 0 ? void 0 : context.getContextAttributes()) === null || _a === void 0 ? void 0 : _a.preserveDrawingBuffer) === false) {\r\n                        context.clear(context.COLOR_BUFFER_BIT);\r\n                    }\r\n                }\r\n                const bitmap = yield createImageBitmap(canvas);\r\n                worker.postMessage({\r\n                    id,\r\n                    bitmap,\r\n                    width: canvas.width,\r\n                    height: canvas.height,\r\n                    dataURLOptions: options.dataURLOptions,\r\n                }, [bitmap]);\r\n            }));\r\n            rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n        };\r\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            cancelAnimationFrame(rafId);\r\n        };\r\n    }\r\n    initCanvasMutationObserver(win, blockClass, blockSelector) {\r\n        this.startRAFTimestamping();\r\n        this.startPendingCanvasMutationFlusher();\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, false);\r\n        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\r\n        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, this.mirror);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            canvas2DReset();\r\n            canvasWebGL1and2Reset();\r\n        };\r\n    }\r\n    startPendingCanvasMutationFlusher() {\r\n        requestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    startRAFTimestamping() {\r\n        const setLatestRAFTimestamp = (timestamp) => {\r\n            this.rafStamps.latestId = timestamp;\r\n            requestAnimationFrame(setLatestRAFTimestamp);\r\n        };\r\n        requestAnimationFrame(setLatestRAFTimestamp);\r\n    }\r\n    flushPendingCanvasMutations() {\r\n        this.pendingCanvasMutations.forEach((values, canvas) => {\r\n            const id = this.mirror.getId(canvas);\r\n            this.flushPendingCanvasMutationFor(canvas, id);\r\n        });\r\n        requestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    flushPendingCanvasMutationFor(canvas, id) {\r\n        if (this.frozen || this.locked) {\r\n            return;\r\n        }\r\n        const valuesWithType = this.pendingCanvasMutations.get(canvas);\r\n        if (!valuesWithType || id === -1)\r\n            return;\r\n        const values = valuesWithType.map((value) => {\r\n            const rest = __rest(value, [\"type\"]);\r\n            return rest;\r\n        });\r\n        const { type } = valuesWithType[0];\r\n        this.mutationCb({ id, type, commands: values });\r\n        this.pendingCanvasMutations.delete(canvas);\r\n    }\r\n}\n\nclass StylesheetManager {\r\n    constructor(options) {\r\n        this.trackedLinkElements = new WeakSet();\r\n        this.styleMirror = new StyleSheetMirror();\r\n        this.mutationCb = options.mutationCb;\r\n        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\r\n    }\r\n    attachLinkElement(linkEl, childSn) {\r\n        if ('_cssText' in childSn.attributes)\r\n            this.mutationCb({\r\n                adds: [],\r\n                removes: [],\r\n                texts: [],\r\n                attributes: [\r\n                    {\r\n                        id: childSn.id,\r\n                        attributes: childSn\r\n                            .attributes,\r\n                    },\r\n                ],\r\n            });\r\n        this.trackLinkElement(linkEl);\r\n    }\r\n    trackLinkElement(linkEl) {\r\n        if (this.trackedLinkElements.has(linkEl))\r\n            return;\r\n        this.trackedLinkElements.add(linkEl);\r\n        this.trackStylesheetInLinkElement(linkEl);\r\n    }\r\n    adoptStyleSheets(sheets, hostId) {\r\n        if (sheets.length === 0)\r\n            return;\r\n        const adoptedStyleSheetData = {\r\n            id: hostId,\r\n            styleIds: [],\r\n        };\r\n        const styles = [];\r\n        for (const sheet of sheets) {\r\n            let styleId;\r\n            if (!this.styleMirror.has(sheet)) {\r\n                styleId = this.styleMirror.add(sheet);\r\n                styles.push({\r\n                    styleId,\r\n                    rules: Array.from(sheet.rules || CSSRule, (r, index) => ({\r\n                        rule: stringifyRule(r),\r\n                        index,\r\n                    })),\r\n                });\r\n            }\r\n            else\r\n                styleId = this.styleMirror.getId(sheet);\r\n            adoptedStyleSheetData.styleIds.push(styleId);\r\n        }\r\n        if (styles.length > 0)\r\n            adoptedStyleSheetData.styles = styles;\r\n        this.adoptedStyleSheetCb(adoptedStyleSheetData);\r\n    }\r\n    reset() {\r\n        this.styleMirror.reset();\r\n        this.trackedLinkElements = new WeakSet();\r\n    }\r\n    trackStylesheetInLinkElement(linkEl) {\r\n    }\r\n}\n\nclass ProcessedNodeManager {\r\n    constructor() {\r\n        this.nodeMap = new WeakMap();\r\n        this.loop = true;\r\n        this.periodicallyClear();\r\n    }\r\n    periodicallyClear() {\r\n        requestAnimationFrame(() => {\r\n            this.clear();\r\n            if (this.loop)\r\n                this.periodicallyClear();\r\n        });\r\n    }\r\n    inOtherBuffer(node, thisBuffer) {\r\n        const buffers = this.nodeMap.get(node);\r\n        return (buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer));\r\n    }\r\n    add(node, buffer) {\r\n        this.nodeMap.set(node, (this.nodeMap.get(node) || new Set()).add(buffer));\r\n    }\r\n    clear() {\r\n        this.nodeMap = new WeakMap();\r\n    }\r\n    destroy() {\r\n        this.loop = false;\r\n    }\r\n}\n\nfunction wrapEvent(e) {\r\n    return Object.assign(Object.assign({}, e), { timestamp: nowTimestamp() });\r\n}\r\nlet wrappedEmit;\r\nlet takeFullSnapshot;\r\nlet canvasManager;\r\nlet recording = false;\r\nconst mirror = createMirror();\r\nfunction record(options = {}) {\r\n    const { emit, checkoutEveryNms, checkoutEveryNth, blockClass = 'rr-block', blockSelector = null, ignoreClass = 'rr-ignore', ignoreSelector = null, maskTextClass = 'rr-mask', maskTextSelector = null, inlineStylesheet = true, maskAllInputs, maskInputOptions: _maskInputOptions, slimDOMOptions: _slimDOMOptions, maskInputFn, maskTextFn, hooks, packFn, sampling = {}, dataURLOptions = {}, mousemoveWait, recordDOM = true, recordCanvas = false, recordCrossOriginIframes = false, recordAfter = options.recordAfter === 'DOMContentLoaded'\r\n        ? options.recordAfter\r\n        : 'load', userTriggeredOnInput = false, collectFonts = false, inlineImages = false, plugins, keepIframeSrcFn = () => false, ignoreCSSAttributes = new Set([]), errorHandler, } = options;\r\n    registerErrorHandler(errorHandler);\r\n    const inEmittingFrame = recordCrossOriginIframes\r\n        ? window.parent === window\r\n        : true;\r\n    let passEmitsToParent = false;\r\n    if (!inEmittingFrame) {\r\n        try {\r\n            if (window.parent.document) {\r\n                passEmitsToParent = false;\r\n            }\r\n        }\r\n        catch (e) {\r\n            passEmitsToParent = true;\r\n        }\r\n    }\r\n    if (inEmittingFrame && !emit) {\r\n        throw new Error('emit function is required');\r\n    }\r\n    if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\r\n        sampling.mousemove = mousemoveWait;\r\n    }\r\n    mirror.reset();\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n            password: true,\r\n        }\r\n        : _maskInputOptions !== undefined\r\n            ? _maskInputOptions\r\n            : { password: true };\r\n    const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === 'all'\r\n        ? {\r\n            script: true,\r\n            comment: true,\r\n            headFavicon: true,\r\n            headWhitespace: true,\r\n            headMetaSocial: true,\r\n            headMetaRobots: true,\r\n            headMetaHttpEquiv: true,\r\n            headMetaVerification: true,\r\n            headMetaAuthorship: _slimDOMOptions === 'all',\r\n            headMetaDescKeywords: _slimDOMOptions === 'all',\r\n        }\r\n        : _slimDOMOptions\r\n            ? _slimDOMOptions\r\n            : {};\r\n    polyfill();\r\n    let lastFullSnapshotEvent;\r\n    let incrementalSnapshotCount = 0;\r\n    const eventProcessor = (e) => {\r\n        for (const plugin of plugins || []) {\r\n            if (plugin.eventProcessor) {\r\n                e = plugin.eventProcessor(e);\r\n            }\r\n        }\r\n        if (packFn &&\r\n            !passEmitsToParent) {\r\n            e = packFn(e);\r\n        }\r\n        return e;\r\n    };\r\n    wrappedEmit = (e, isCheckout) => {\r\n        var _a;\r\n        if (((_a = mutationBuffers[0]) === null || _a === void 0 ? void 0 : _a.isFrozen()) &&\r\n            e.type !== EventType$1.FullSnapshot &&\r\n            !(e.type === EventType$1.IncrementalSnapshot &&\r\n                e.data.source === IncrementalSource$1.Mutation)) {\r\n            mutationBuffers.forEach((buf) => buf.unfreeze());\r\n        }\r\n        if (inEmittingFrame) {\r\n            emit === null || emit === void 0 ? void 0 : emit(eventProcessor(e), isCheckout);\r\n        }\r\n        else if (passEmitsToParent) {\r\n            const message = {\r\n                type: 'rrweb',\r\n                event: eventProcessor(e),\r\n                origin: window.location.origin,\r\n                isCheckout,\r\n            };\r\n            window.parent.postMessage(message, '*');\r\n        }\r\n        if (e.type === EventType$1.FullSnapshot) {\r\n            lastFullSnapshotEvent = e;\r\n            incrementalSnapshotCount = 0;\r\n        }\r\n        else if (e.type === EventType$1.IncrementalSnapshot) {\r\n            if (e.data.source === IncrementalSource$1.Mutation &&\r\n                e.data.isAttachIframe) {\r\n                return;\r\n            }\r\n            incrementalSnapshotCount++;\r\n            const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\r\n            const exceedTime = checkoutEveryNms &&\r\n                e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\r\n            if (exceedCount || exceedTime) {\r\n                takeFullSnapshot(true);\r\n            }\r\n        }\r\n    };\r\n    const wrappedMutationEmit = (m) => {\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType$1.IncrementalSnapshot,\r\n            data: Object.assign({ source: IncrementalSource$1.Mutation }, m),\r\n        }));\r\n    };\r\n    const wrappedScrollEmit = (p) => wrappedEmit(wrapEvent({\r\n        type: EventType$1.IncrementalSnapshot,\r\n        data: Object.assign({ source: IncrementalSource$1.Scroll }, p),\r\n    }));\r\n    const wrappedCanvasMutationEmit = (p) => wrappedEmit(wrapEvent({\r\n        type: EventType$1.IncrementalSnapshot,\r\n        data: Object.assign({ source: IncrementalSource$1.CanvasMutation }, p),\r\n    }));\r\n    const wrappedAdoptedStyleSheetEmit = (a) => wrappedEmit(wrapEvent({\r\n        type: EventType$1.IncrementalSnapshot,\r\n        data: Object.assign({ source: IncrementalSource$1.AdoptedStyleSheet }, a),\r\n    }));\r\n    const stylesheetManager = new StylesheetManager({\r\n        mutationCb: wrappedMutationEmit,\r\n        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit,\r\n    });\r\n    const iframeManager = new IframeManager({\r\n        mirror,\r\n        mutationCb: wrappedMutationEmit,\r\n        stylesheetManager: stylesheetManager,\r\n        recordCrossOriginIframes,\r\n        wrappedEmit,\r\n    });\r\n    for (const plugin of plugins || []) {\r\n        if (plugin.getMirror)\r\n            plugin.getMirror({\r\n                nodeMirror: mirror,\r\n                crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\r\n                crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror,\r\n            });\r\n    }\r\n    const processedNodeManager = new ProcessedNodeManager();\r\n    canvasManager = new CanvasManager({\r\n        recordCanvas,\r\n        mutationCb: wrappedCanvasMutationEmit,\r\n        win: window,\r\n        blockClass,\r\n        blockSelector,\r\n        mirror,\r\n        sampling: sampling.canvas,\r\n        dataURLOptions,\r\n    });\r\n    const shadowDomManager = new ShadowDomManager({\r\n        mutationCb: wrappedMutationEmit,\r\n        scrollCb: wrappedScrollEmit,\r\n        bypassOptions: {\r\n            blockClass,\r\n            blockSelector,\r\n            maskTextClass,\r\n            maskTextSelector,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            dataURLOptions,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            recordCanvas,\r\n            inlineImages,\r\n            sampling,\r\n            slimDOMOptions,\r\n            iframeManager,\r\n            stylesheetManager,\r\n            canvasManager,\r\n            keepIframeSrcFn,\r\n            processedNodeManager,\r\n        },\r\n        mirror,\r\n    });\r\n    takeFullSnapshot = (isCheckout = false) => {\r\n        if (!recordDOM) {\r\n            return;\r\n        }\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType$1.Meta,\r\n            data: {\r\n                href: window.location.href,\r\n                width: getWindowWidth(),\r\n                height: getWindowHeight(),\r\n            },\r\n        }), isCheckout);\r\n        stylesheetManager.reset();\r\n        shadowDomManager.init();\r\n        mutationBuffers.forEach((buf) => buf.lock());\r\n        const node = snapshot(document, {\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            maskTextClass,\r\n            maskTextSelector,\r\n            inlineStylesheet,\r\n            maskAllInputs: maskInputOptions,\r\n            maskTextFn,\r\n            slimDOM: slimDOMOptions,\r\n            dataURLOptions,\r\n            recordCanvas,\r\n            inlineImages,\r\n            onSerialize: (n) => {\r\n                if (isSerializedIframe(n, mirror)) {\r\n                    iframeManager.addIframe(n);\r\n                }\r\n                if (isSerializedStylesheet(n, mirror)) {\r\n                    stylesheetManager.trackLinkElement(n);\r\n                }\r\n                if (hasShadowRoot(n)) {\r\n                    shadowDomManager.addShadowRoot(n.shadowRoot, document);\r\n                }\r\n            },\r\n            onIframeLoad: (iframe, childSn) => {\r\n                iframeManager.attachIframe(iframe, childSn);\r\n                shadowDomManager.observeAttachShadow(iframe);\r\n            },\r\n            onStylesheetLoad: (linkEl, childSn) => {\r\n                stylesheetManager.attachLinkElement(linkEl, childSn);\r\n            },\r\n            keepIframeSrcFn,\r\n        });\r\n        if (!node) {\r\n            return console.warn('Failed to snapshot the document');\r\n        }\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType$1.FullSnapshot,\r\n            data: {\r\n                node,\r\n                initialOffset: getWindowScroll(window),\r\n            },\r\n        }), isCheckout);\r\n        mutationBuffers.forEach((buf) => buf.unlock());\r\n        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\r\n            stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\r\n    };\r\n    try {\r\n        const handlers = [];\r\n        const observe = (doc) => {\r\n            var _a;\r\n            return callbackWrapper(initObservers)({\r\n                mutationCb: wrappedMutationEmit,\r\n                mousemoveCb: (positions, source) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: {\r\n                        source,\r\n                        positions,\r\n                    },\r\n                })),\r\n                mouseInteractionCb: (d) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.MouseInteraction }, d),\r\n                })),\r\n                scrollCb: wrappedScrollEmit,\r\n                viewportResizeCb: (d) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.ViewportResize }, d),\r\n                })),\r\n                inputCb: (v) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.Input }, v),\r\n                })),\r\n                mediaInteractionCb: (p) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.MediaInteraction }, p),\r\n                })),\r\n                styleSheetRuleCb: (r) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.StyleSheetRule }, r),\r\n                })),\r\n                styleDeclarationCb: (r) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.StyleDeclaration }, r),\r\n                })),\r\n                canvasMutationCb: wrappedCanvasMutationEmit,\r\n                fontCb: (p) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.Font }, p),\r\n                })),\r\n                selectionCb: (p) => {\r\n                    wrappedEmit(wrapEvent({\r\n                        type: EventType$1.IncrementalSnapshot,\r\n                        data: Object.assign({ source: IncrementalSource$1.Selection }, p),\r\n                    }));\r\n                },\r\n                customElementCb: (c) => {\r\n                    wrappedEmit(wrapEvent({\r\n                        type: EventType$1.IncrementalSnapshot,\r\n                        data: Object.assign({ source: IncrementalSource$1.CustomElement }, c),\r\n                    }));\r\n                },\r\n                blockClass,\r\n                ignoreClass,\r\n                ignoreSelector,\r\n                maskTextClass,\r\n                maskTextSelector,\r\n                maskInputOptions,\r\n                inlineStylesheet,\r\n                sampling,\r\n                recordDOM,\r\n                recordCanvas,\r\n                inlineImages,\r\n                userTriggeredOnInput,\r\n                collectFonts,\r\n                doc,\r\n                maskInputFn,\r\n                maskTextFn,\r\n                keepIframeSrcFn,\r\n                blockSelector,\r\n                slimDOMOptions,\r\n                dataURLOptions,\r\n                mirror,\r\n                iframeManager,\r\n                stylesheetManager,\r\n                shadowDomManager,\r\n                processedNodeManager,\r\n                canvasManager,\r\n                ignoreCSSAttributes,\r\n                plugins: ((_a = plugins === null || plugins === void 0 ? void 0 : plugins.filter((p) => p.observer)) === null || _a === void 0 ? void 0 : _a.map((p) => ({\r\n                    observer: p.observer,\r\n                    options: p.options,\r\n                    callback: (payload) => wrappedEmit(wrapEvent({\r\n                        type: EventType$1.Plugin,\r\n                        data: {\r\n                            plugin: p.name,\r\n                            payload,\r\n                        },\r\n                    })),\r\n                }))) || [],\r\n            }, hooks);\r\n        };\r\n        iframeManager.addLoadListener((iframeEl) => {\r\n            try {\r\n                handlers.push(observe(iframeEl.contentDocument));\r\n            }\r\n            catch (error) {\r\n                console.warn(error);\r\n            }\r\n        });\r\n        const init = () => {\r\n            takeFullSnapshot();\r\n            handlers.push(observe(document));\r\n            recording = true;\r\n        };\r\n        if (document.readyState === 'interactive' ||\r\n            document.readyState === 'complete') {\r\n            init();\r\n        }\r\n        else {\r\n            handlers.push(on('DOMContentLoaded', () => {\r\n                wrappedEmit(wrapEvent({\r\n                    type: EventType$1.DomContentLoaded,\r\n                    data: {},\r\n                }));\r\n                if (recordAfter === 'DOMContentLoaded')\r\n                    init();\r\n            }));\r\n            handlers.push(on('load', () => {\r\n                wrappedEmit(wrapEvent({\r\n                    type: EventType$1.Load,\r\n                    data: {},\r\n                }));\r\n                if (recordAfter === 'load')\r\n                    init();\r\n            }, window));\r\n        }\r\n        return () => {\r\n            handlers.forEach((h) => h());\r\n            processedNodeManager.destroy();\r\n            recording = false;\r\n            unregisterErrorHandler();\r\n        };\r\n    }\r\n    catch (error) {\r\n        console.warn(error);\r\n    }\r\n}\r\nrecord.addCustomEvent = (tag, payload) => {\r\n    if (!recording) {\r\n        throw new Error('please add custom event after start recording');\r\n    }\r\n    wrappedEmit(wrapEvent({\r\n        type: EventType$1.Custom,\r\n        data: {\r\n            tag,\r\n            payload,\r\n        },\r\n    }));\r\n};\r\nrecord.freezePage = () => {\r\n    mutationBuffers.forEach((buf) => buf.freeze());\r\n};\r\nrecord.takeFullSnapshot = (isCheckout) => {\r\n    if (!recording) {\r\n        throw new Error('please take full snapshot after start recording');\r\n    }\r\n    takeFullSnapshot(isCheckout);\r\n};\r\nrecord.mirror = mirror;\n\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\n\nvar Config = {\n    DEBUG: false,\n    LIB_VERSION: '2.58.0'\n};\n\n// since es6 imports are static and we run unit tests from the console, window won't be defined when importing this file\nvar win;\nif (typeof(window) === 'undefined') {\n    var loc = {\n        hostname: ''\n    };\n    win = {\n        navigator: { userAgent: '', onLine: true },\n        document: {\n            location: loc,\n            referrer: ''\n        },\n        screen: { width: 0, height: 0 },\n        location: loc\n    };\n} else {\n    win = window;\n}\n\nvar setImmediate = win['setImmediate'];\nvar builtInProp, cycle, schedulingQueue,\n    ToString = Object.prototype.toString,\n    timer = (typeof setImmediate !== 'undefined') ?\n        function timer(fn) { return setImmediate(fn); } :\n        setTimeout;\n\n// dammit, IE8.\ntry {\n    Object.defineProperty({},'x',{});\n    builtInProp = function builtInProp(obj,name,val,config) {\n        return Object.defineProperty(obj,name,{\n            value: val,\n            writable: true,\n            configurable: config !== false\n        });\n    };\n}\ncatch (err) {\n    builtInProp = function builtInProp(obj,name,val) {\n        obj[name] = val;\n        return obj;\n    };\n}\n\n// Note: using a queue instead of array for efficiency\nschedulingQueue = (function Queue() {\n    var first, last, item;\n\n    function Item(fn,self) {\n        this.fn = fn;\n        this.self = self;\n        this.next = void 0;\n    }\n\n    return {\n        add: function add(fn,self) {\n            item = new Item(fn,self);\n            if (last) {\n                last.next = item;\n            }\n            else {\n                first = item;\n            }\n            last = item;\n            item = void 0;\n        },\n        drain: function drain() {\n            var f = first;\n            first = last = cycle = void 0;\n\n            while (f) {\n                f.fn.call(f.self);\n                f = f.next;\n            }\n        }\n    };\n})();\n\nfunction schedule(fn,self) {\n    schedulingQueue.add(fn,self);\n    if (!cycle) {\n        cycle = timer(schedulingQueue.drain);\n    }\n}\n\n// promise duck typing\nfunction isThenable(o) {\n    var _then, oType = typeof o;\n\n    if (o !== null && (oType === 'object' || oType === 'function')) {\n        _then = o.then;\n    }\n    return typeof _then === 'function' ? _then : false;\n}\n\nfunction notify() {\n    for (var i=0; i<this.chain.length; i++) {\n        notifyIsolated(\n            this,\n            (this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n            this.chain[i]\n        );\n    }\n    this.chain.length = 0;\n}\n\n// NOTE: This is a separate function to isolate\n// the `try..catch` so that other code can be\n// optimized better\nfunction notifyIsolated(self,cb,chain) {\n    var ret, _then;\n    try {\n        if (cb === false) {\n            chain.reject(self.msg);\n        }\n        else {\n            if (cb === true) {\n                ret = self.msg;\n            }\n            else {\n                ret = cb.call(void 0,self.msg);\n            }\n\n            if (ret === chain.promise) {\n                chain.reject(TypeError('Promise-chain cycle'));\n            }\n            // eslint-disable-next-line no-cond-assign\n            else if (_then = isThenable(ret)) {\n                _then.call(ret,chain.resolve,chain.reject);\n            }\n            else {\n                chain.resolve(ret);\n            }\n        }\n    }\n    catch (err) {\n        chain.reject(err);\n    }\n}\n\nfunction resolve(msg) {\n    var _then, self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    try {\n        // eslint-disable-next-line no-cond-assign\n        if (_then = isThenable(msg)) {\n            schedule(function(){\n                var defWrapper = new MakeDefWrapper(self);\n                try {\n                    _then.call(msg,\n                        function $resolve$(){ resolve.apply(defWrapper,arguments); },\n                        function $reject$(){ reject.apply(defWrapper,arguments); }\n                    );\n                }\n                catch (err) {\n                    reject.call(defWrapper,err);\n                }\n            });\n        }\n        else {\n            self.msg = msg;\n            self.state = 1;\n            if (self.chain.length > 0) {\n                schedule(notify,self);\n            }\n        }\n    }\n    catch (err) {\n        reject.call(new MakeDefWrapper(self),err);\n    }\n}\n\nfunction reject(msg) {\n    var self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    self.msg = msg;\n    self.state = 2;\n    if (self.chain.length > 0) {\n        schedule(notify,self);\n    }\n}\n\nfunction iteratePromises(Constructor,arr,resolver,rejecter) {\n    for (var idx=0; idx<arr.length; idx++) {\n        (function IIFE(idx){\n            Constructor.resolve(arr[idx])\n                .then(\n                    function $resolver$(msg){\n                        resolver(idx,msg);\n                    },\n                    rejecter\n                );\n        })(idx);\n    }\n}\n\nfunction MakeDefWrapper(self) {\n    this.def = self;\n    this.triggered = false;\n}\n\nfunction MakeDef(self) {\n    this.promise = self;\n    this.state = 0;\n    this.triggered = false;\n    this.chain = [];\n    this.msg = void 0;\n}\n\nfunction NpoPromise(executor) {\n    if (typeof executor !== 'function') {\n        throw TypeError('Not a function');\n    }\n\n    if (this['__NPO__'] !== 0) {\n        throw TypeError('Not a promise');\n    }\n\n    // instance shadowing the inherited \"brand\"\n    // to signal an already \"initialized\" promise\n    this['__NPO__'] = 1;\n\n    var def = new MakeDef(this);\n\n    this['then'] = function then(success,failure) {\n        var o = {\n            success: typeof success === 'function' ? success : true,\n            failure: typeof failure === 'function' ? failure : false\n        };\n            // Note: `then(..)` itself can be borrowed to be used against\n            // a different promise constructor for making the chained promise,\n            // by substituting a different `this` binding.\n        o.promise = new this.constructor(function extractChain(resolve,reject) {\n            if (typeof resolve !== 'function' || typeof reject !== 'function') {\n                throw TypeError('Not a function');\n            }\n\n            o.resolve = resolve;\n            o.reject = reject;\n        });\n        def.chain.push(o);\n\n        if (def.state !== 0) {\n            schedule(notify,def);\n        }\n\n        return o.promise;\n    };\n    this['catch'] = function $catch$(failure) {\n        return this.then(void 0,failure);\n    };\n\n    try {\n        executor.call(\n            void 0,\n            function publicResolve(msg){\n                resolve.call(def,msg);\n            },\n            function publicReject(msg) {\n                reject.call(def,msg);\n            }\n        );\n    }\n    catch (err) {\n        reject.call(def,err);\n    }\n}\n\nvar PromisePrototype = builtInProp({},'constructor',NpoPromise,\n    /*configurable=*/false\n);\n\n    // Note: Android 4 cannot use `Object.defineProperty(..)` here\nNpoPromise.prototype = PromisePrototype;\n\n// built-in \"brand\" to signal an \"uninitialized\" promise\nbuiltInProp(PromisePrototype,'__NPO__',0,\n    /*configurable=*/false\n);\n\nbuiltInProp(NpoPromise,'resolve',function Promise$resolve(msg) {\n    var Constructor = this;\n\n    // spec mandated checks\n    // note: best \"isPromise\" check that's practical for now\n    if (msg && typeof msg === 'object' && msg['__NPO__'] === 1) {\n        return msg;\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        resolve(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'reject',function Promise$reject(msg) {\n    return new this(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        reject(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'all',function Promise$all(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n    if (arr.length === 0) {\n        return Constructor.resolve([]);\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        var len = arr.length, msgs = Array(len), count = 0;\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg) {\n            msgs[idx] = msg;\n            if (++count === len) {\n                resolve(msgs);\n            }\n        },reject);\n    });\n});\n\nbuiltInProp(NpoPromise,'race',function Promise$race(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg){\n            resolve(msg);\n        },reject);\n    });\n});\n\nvar PromisePolyfill;\nif (typeof Promise !== 'undefined' && Promise.toString().indexOf('[native code]') !== -1) {\n    PromisePolyfill = Promise;\n} else {\n    PromisePolyfill = NpoPromise;\n}\n\n/* eslint camelcase: \"off\", eqeqeq: \"off\" */\n\n// Maximum allowed session recording length\nvar MAX_RECORDING_MS = 24 * 60 * 60 * 1000; // 24 hours\n// Maximum allowed value for minimum session recording length\nvar MAX_VALUE_FOR_MIN_RECORDING_MS = 8 * 1000; // 8 seconds\n\n/*\n * Saved references to long variable names, so that closure compiler can\n * minimize file size.\n */\n\nvar ArrayProto = Array.prototype,\n    FuncProto = Function.prototype,\n    ObjProto = Object.prototype,\n    slice = ArrayProto.slice,\n    toString = ObjProto.toString,\n    hasOwnProperty = ObjProto.hasOwnProperty,\n    windowConsole = win.console,\n    navigator = win.navigator,\n    document$1 = win.document,\n    windowOpera = win.opera,\n    screen = win.screen,\n    userAgent = navigator.userAgent;\n\nvar nativeBind = FuncProto.bind,\n    nativeForEach = ArrayProto.forEach,\n    nativeIndexOf = ArrayProto.indexOf,\n    nativeMap = ArrayProto.map,\n    nativeIsArray = Array.isArray,\n    breaker = {};\n\nvar _ = {\n    trim: function(str) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n};\n\n// Console override\nvar console$1 = {\n    /** @type {function(...*)} */\n    log: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            try {\n                windowConsole.log.apply(windowConsole, arguments);\n            } catch (err) {\n                _.each(arguments, function(arg) {\n                    windowConsole.log(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    warn: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel warning:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.warn.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.warn(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    error: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    critical: function() {\n        if (!_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    }\n};\n\nvar log_func_with_prefix = function(func, prefix) {\n    return function() {\n        arguments[0] = '[' + prefix + '] ' + arguments[0];\n        return func.apply(console$1, arguments);\n    };\n};\nvar console_with_prefix = function(prefix) {\n    return {\n        log: log_func_with_prefix(console$1.log, prefix),\n        error: log_func_with_prefix(console$1.error, prefix),\n        critical: log_func_with_prefix(console$1.critical, prefix)\n    };\n};\n\n\n// UNDERSCORE\n// Embed part of the Underscore Library\n_.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n    }\n    if (!_.isFunction(func)) {\n        throw new TypeError();\n    }\n    args = slice.call(arguments, 2);\n    bound = function() {\n        if (!(this instanceof bound)) {\n            return func.apply(context, args.concat(slice.call(arguments)));\n        }\n        var ctor = {};\n        ctor.prototype = func.prototype;\n        var self = new ctor();\n        ctor.prototype = null;\n        var result = func.apply(self, args.concat(slice.call(arguments)));\n        if (Object(result) === result) {\n            return result;\n        }\n        return self;\n    };\n    return bound;\n};\n\n/**\n * @param {*=} obj\n * @param {function(...*)=} iterator\n * @param {Object=} context\n */\n_.each = function(obj, iterator, context) {\n    if (obj === null || obj === undefined) {\n        return;\n    }\n    if (nativeForEach && obj.forEach === nativeForEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n                return;\n            }\n        }\n    } else {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                if (iterator.call(context, obj[key], key, obj) === breaker) {\n                    return;\n                }\n            }\n        }\n    }\n};\n\n_.extend = function(obj) {\n    _.each(slice.call(arguments, 1), function(source) {\n        for (var prop in source) {\n            if (source[prop] !== void 0) {\n                obj[prop] = source[prop];\n            }\n        }\n    });\n    return obj;\n};\n\n_.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n\n// from a comment on http://dbj.org/dbj/?p=286\n// fails on only one very rare and deliberate custom object:\n// var bomb = { toString : undefined, valueOf: function(o) { return \"function BOMBA!\"; }};\n_.isFunction = function(f) {\n    try {\n        return /^\\s*\\bfunction\\b/.test(f);\n    } catch (x) {\n        return false;\n    }\n};\n\n_.isArguments = function(obj) {\n    return !!(obj && hasOwnProperty.call(obj, 'callee'));\n};\n\n_.toArray = function(iterable) {\n    if (!iterable) {\n        return [];\n    }\n    if (iterable.toArray) {\n        return iterable.toArray();\n    }\n    if (_.isArray(iterable)) {\n        return slice.call(iterable);\n    }\n    if (_.isArguments(iterable)) {\n        return slice.call(iterable);\n    }\n    return _.values(iterable);\n};\n\n_.map = function(arr, callback, context) {\n    if (nativeMap && arr.map === nativeMap) {\n        return arr.map(callback, context);\n    } else {\n        var results = [];\n        _.each(arr, function(item) {\n            results.push(callback.call(context, item));\n        });\n        return results;\n    }\n};\n\n_.keys = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value, key) {\n        results[results.length] = key;\n    });\n    return results;\n};\n\n_.values = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value) {\n        results[results.length] = value;\n    });\n    return results;\n};\n\n_.include = function(obj, target) {\n    var found = false;\n    if (obj === null) {\n        return found;\n    }\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n        return obj.indexOf(target) != -1;\n    }\n    _.each(obj, function(value) {\n        if (found || (found = (value === target))) {\n            return breaker;\n        }\n    });\n    return found;\n};\n\n_.includes = function(str, needle) {\n    return str.indexOf(needle) !== -1;\n};\n\n// Underscore Addons\n_.inherit = function(subclass, superclass) {\n    subclass.prototype = new superclass();\n    subclass.prototype.constructor = subclass;\n    subclass.superclass = superclass.prototype;\n    return subclass;\n};\n\n_.isObject = function(obj) {\n    return (obj === Object(obj) && !_.isArray(obj));\n};\n\n_.isEmptyObject = function(obj) {\n    if (_.isObject(obj)) {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n_.isUndefined = function(obj) {\n    return obj === void 0;\n};\n\n_.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n};\n\n_.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n};\n\n_.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n};\n\n_.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n};\n\n_.encodeDates = function(obj) {\n    _.each(obj, function(v, k) {\n        if (_.isDate(v)) {\n            obj[k] = _.formatDate(v);\n        } else if (_.isObject(v)) {\n            obj[k] = _.encodeDates(v); // recurse\n        }\n    });\n    return obj;\n};\n\n_.timestamp = function() {\n    Date.now = Date.now || function() {\n        return +new Date;\n    };\n    return Date.now();\n};\n\n_.formatDate = function(d) {\n    // YYYY-MM-DDTHH:MM:SS in UTC\n    function pad(n) {\n        return n < 10 ? '0' + n : n;\n    }\n    return d.getUTCFullYear() + '-' +\n        pad(d.getUTCMonth() + 1) + '-' +\n        pad(d.getUTCDate()) + 'T' +\n        pad(d.getUTCHours()) + ':' +\n        pad(d.getUTCMinutes()) + ':' +\n        pad(d.getUTCSeconds());\n};\n\n_.strip_empty_properties = function(p) {\n    var ret = {};\n    _.each(p, function(v, k) {\n        if (_.isString(v) && v.length > 0) {\n            ret[k] = v;\n        }\n    });\n    return ret;\n};\n\n/*\n * this function returns a copy of object after truncating it.  If\n * passed an Array or Object it will iterate through obj and\n * truncate all the values recursively.\n */\n_.truncate = function(obj, length) {\n    var ret;\n\n    if (typeof(obj) === 'string') {\n        ret = obj.slice(0, length);\n    } else if (_.isArray(obj)) {\n        ret = [];\n        _.each(obj, function(val) {\n            ret.push(_.truncate(val, length));\n        });\n    } else if (_.isObject(obj)) {\n        ret = {};\n        _.each(obj, function(val, key) {\n            ret[key] = _.truncate(val, length);\n        });\n    } else {\n        ret = obj;\n    }\n\n    return ret;\n};\n\n_.JSONEncode = (function() {\n    return function(mixed_val) {\n        var value = mixed_val;\n        var quote = function(string) {\n            var escapable = /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // eslint-disable-line no-control-regex\n            var meta = { // table of character substitutions\n                '\\b': '\\\\b',\n                '\\t': '\\\\t',\n                '\\n': '\\\\n',\n                '\\f': '\\\\f',\n                '\\r': '\\\\r',\n                '\"': '\\\\\"',\n                '\\\\': '\\\\\\\\'\n            };\n\n            escapable.lastIndex = 0;\n            return escapable.test(string) ?\n                '\"' + string.replace(escapable, function(a) {\n                    var c = meta[a];\n                    return typeof c === 'string' ? c :\n                        '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"' :\n                '\"' + string + '\"';\n        };\n\n        var str = function(key, holder) {\n            var gap = '';\n            var indent = '    ';\n            var i = 0; // The loop counter.\n            var k = ''; // The member key.\n            var v = ''; // The member value.\n            var length = 0;\n            var mind = gap;\n            var partial = [];\n            var value = holder[key];\n\n            // If the value has a toJSON method, call it to obtain a replacement value.\n            if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n                value = value.toJSON(key);\n            }\n\n            // What happens next depends on the value's type.\n            switch (typeof value) {\n                case 'string':\n                    return quote(value);\n\n                case 'number':\n                    // JSON numbers must be finite. Encode non-finite numbers as null.\n                    return isFinite(value) ? String(value) : 'null';\n\n                case 'boolean':\n                case 'null':\n                    // If the value is a boolean or null, convert it to a string. Note:\n                    // typeof null does not produce 'null'. The case is included here in\n                    // the remote chance that this gets fixed someday.\n\n                    return String(value);\n\n                case 'object':\n                    // If the type is 'object', we might be dealing with an object or an array or\n                    // null.\n                    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n                    // so watch out for that case.\n                    if (!value) {\n                        return 'null';\n                    }\n\n                    // Make an array to hold the partial results of stringifying this object value.\n                    gap += indent;\n                    partial = [];\n\n                    // Is the value an array?\n                    if (toString.apply(value) === '[object Array]') {\n                        // The value is an array. Stringify every element. Use null as a placeholder\n                        // for non-JSON values.\n\n                        length = value.length;\n                        for (i = 0; i < length; i += 1) {\n                            partial[i] = str(i, value) || 'null';\n                        }\n\n                        // Join all of the elements together, separated with commas, and wrap them in\n                        // brackets.\n                        v = partial.length === 0 ? '[]' :\n                            gap ? '[\\n' + gap +\n                            partial.join(',\\n' + gap) + '\\n' +\n                            mind + ']' :\n                                '[' + partial.join(',') + ']';\n                        gap = mind;\n                        return v;\n                    }\n\n                    // Iterate through all of the keys in the object.\n                    for (k in value) {\n                        if (hasOwnProperty.call(value, k)) {\n                            v = str(k, value);\n                            if (v) {\n                                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                            }\n                        }\n                    }\n\n                    // Join all of the member texts together, separated with commas,\n                    // and wrap them in braces.\n                    v = partial.length === 0 ? '{}' :\n                        gap ? '{' + partial.join(',') + '' +\n                        mind + '}' : '{' + partial.join(',') + '}';\n                    gap = mind;\n                    return v;\n            }\n        };\n\n        // Make a fake root object containing our value under the key of ''.\n        // Return the result of stringifying the value.\n        return str('', {\n            '': value\n        });\n    };\n})();\n\n/**\n * From https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n * Slightly modified to throw a real Error rather than a POJO\n */\n_.JSONDecode = (function() {\n    var at, // The index of the current character\n        ch, // The current character\n        escapee = {\n            '\"': '\"',\n            '\\\\': '\\\\',\n            '/': '/',\n            'b': '\\b',\n            'f': '\\f',\n            'n': '\\n',\n            'r': '\\r',\n            't': '\\t'\n        },\n        text,\n        error = function(m) {\n            var e = new SyntaxError(m);\n            e.at = at;\n            e.text = text;\n            throw e;\n        },\n        next = function(c) {\n            // If a c parameter is provided, verify that it matches the current character.\n            if (c && c !== ch) {\n                error('Expected \\'' + c + '\\' instead of \\'' + ch + '\\'');\n            }\n            // Get the next character. When there are no more characters,\n            // return the empty string.\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n        number = function() {\n            // Parse a number value.\n            var number,\n                string = '';\n\n            if (ch === '-') {\n                string = '-';\n                next('-');\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n            if (ch === '.') {\n                string += '.';\n                while (next() && ch >= '0' && ch <= '9') {\n                    string += ch;\n                }\n            }\n            if (ch === 'e' || ch === 'E') {\n                string += ch;\n                next();\n                if (ch === '-' || ch === '+') {\n                    string += ch;\n                    next();\n                }\n                while (ch >= '0' && ch <= '9') {\n                    string += ch;\n                    next();\n                }\n            }\n            number = +string;\n            if (!isFinite(number)) {\n                error('Bad number');\n            } else {\n                return number;\n            }\n        },\n\n        string = function() {\n            // Parse a string value.\n            var hex,\n                i,\n                string = '',\n                uffff;\n            // When parsing for string values, we must look for \" and \\ characters.\n            if (ch === '\"') {\n                while (next()) {\n                    if (ch === '\"') {\n                        next();\n                        return string;\n                    }\n                    if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error('Bad string');\n        },\n        white = function() {\n            // Skip whitespace.\n            while (ch && ch <= ' ') {\n                next();\n            }\n        },\n        word = function() {\n            // true, false, or null.\n            switch (ch) {\n                case 't':\n                    next('t');\n                    next('r');\n                    next('u');\n                    next('e');\n                    return true;\n                case 'f':\n                    next('f');\n                    next('a');\n                    next('l');\n                    next('s');\n                    next('e');\n                    return false;\n                case 'n':\n                    next('n');\n                    next('u');\n                    next('l');\n                    next('l');\n                    return null;\n            }\n            error('Unexpected \"' + ch + '\"');\n        },\n        value, // Placeholder for the value function.\n        array = function() {\n            // Parse an array value.\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array; // empty array\n                }\n                while (ch) {\n                    array.push(value());\n                    white();\n                    if (ch === ']') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad array');\n        },\n        object = function() {\n            // Parse an object value.\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object; // empty object\n                }\n                while (ch) {\n                    key = string();\n                    white();\n                    next(':');\n                    if (Object.hasOwnProperty.call(object, key)) {\n                        error('Duplicate key \"' + key + '\"');\n                    }\n                    object[key] = value();\n                    white();\n                    if (ch === '}') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad object');\n        };\n\n    value = function() {\n        // Parse a JSON value. It could be an object, an array, a string,\n        // a number, or a word.\n        white();\n        switch (ch) {\n            case '{':\n                return object();\n            case '[':\n                return array();\n            case '\"':\n                return string();\n            case '-':\n                return number();\n            default:\n                return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n    // Return the json_parse function. It will have access to all of the\n    // above functions and variables.\n    return function(source) {\n        var result;\n\n        text = source;\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error('Syntax error');\n        }\n\n        return result;\n    };\n})();\n\n_.base64Encode = function(data) {\n    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = '',\n        tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    data = _.utf8Encode(data);\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n            break;\n    }\n\n    return enc;\n};\n\n_.utf8Encode = function(string) {\n    string = (string + '').replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n    var utftext = '',\n        start,\n        end;\n    var stringl = 0,\n        n;\n\n    start = end = 0;\n    stringl = string.length;\n\n    for (n = 0; n < stringl; n++) {\n        var c1 = string.charCodeAt(n);\n        var enc = null;\n\n        if (c1 < 128) {\n            end++;\n        } else if ((c1 > 127) && (c1 < 2048)) {\n            enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128);\n        } else {\n            enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);\n        }\n        if (enc !== null) {\n            if (end > start) {\n                utftext += string.substring(start, end);\n            }\n            utftext += enc;\n            start = end = n + 1;\n        }\n    }\n\n    if (end > start) {\n        utftext += string.substring(start, string.length);\n    }\n\n    return utftext;\n};\n\n_.UUID = (function() {\n\n    // Time-based entropy\n    var T = function() {\n        var time = 1 * new Date(); // cross-browser version of Date.now()\n        var ticks;\n        if (win.performance && win.performance.now) {\n            ticks = win.performance.now();\n        } else {\n            // fall back to busy loop\n            ticks = 0;\n\n            // this while loop figures how many browser ticks go by\n            // before 1*new Date() returns a new number, ie the amount\n            // of ticks that go by per millisecond\n            while (time == 1 * new Date()) {\n                ticks++;\n            }\n        }\n        return time.toString(16) + Math.floor(ticks).toString(16);\n    };\n\n    // Math.Random entropy\n    var R = function() {\n        return Math.random().toString(16).replace('.', '');\n    };\n\n    // User agent entropy\n    // This function takes the user agent string, and then xors\n    // together each sequence of 8 bytes.  This produces a final\n    // sequence of 8 bytes which it returns as hex.\n    var UA = function() {\n        var ua = userAgent,\n            i, ch, buffer = [],\n            ret = 0;\n\n        function xor(result, byte_array) {\n            var j, tmp = 0;\n            for (j = 0; j < byte_array.length; j++) {\n                tmp |= (buffer[j] << j * 8);\n            }\n            return result ^ tmp;\n        }\n\n        for (i = 0; i < ua.length; i++) {\n            ch = ua.charCodeAt(i);\n            buffer.unshift(ch & 0xFF);\n            if (buffer.length >= 4) {\n                ret = xor(ret, buffer);\n                buffer = [];\n            }\n        }\n\n        if (buffer.length > 0) {\n            ret = xor(ret, buffer);\n        }\n\n        return ret.toString(16);\n    };\n\n    return function() {\n        var se = (screen.height * screen.width).toString(16);\n        return (T() + '-' + R() + '-' + UA() + '-' + se + '-' + T());\n    };\n})();\n\n// _.isBlockedUA()\n// This is to block various web spiders from executing our JS and\n// sending false tracking data\nvar BLOCKED_UA_STRS = [\n    'ahrefsbot',\n    'ahrefssiteaudit',\n    'baiduspider',\n    'bingbot',\n    'bingpreview',\n    'chrome-lighthouse',\n    'facebookexternal',\n    'petalbot',\n    'pinterest',\n    'screaming frog',\n    'yahoo! slurp',\n    'yandexbot',\n\n    // a whole bunch of goog-specific crawlers\n    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers\n    'adsbot-google',\n    'apis-google',\n    'duplexweb-google',\n    'feedfetcher-google',\n    'google favicon',\n    'google web preview',\n    'google-read-aloud',\n    'googlebot',\n    'googleweblight',\n    'mediapartners-google',\n    'storebot-google'\n];\n_.isBlockedUA = function(ua) {\n    var i;\n    ua = ua.toLowerCase();\n    for (i = 0; i < BLOCKED_UA_STRS.length; i++) {\n        if (ua.indexOf(BLOCKED_UA_STRS[i]) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * @param {Object=} formdata\n * @param {string=} arg_separator\n */\n_.HTTPBuildQuery = function(formdata, arg_separator) {\n    var use_val, use_key, tmp_arr = [];\n\n    if (_.isUndefined(arg_separator)) {\n        arg_separator = '&';\n    }\n\n    _.each(formdata, function(val, key) {\n        use_val = encodeURIComponent(val.toString());\n        use_key = encodeURIComponent(key);\n        tmp_arr[tmp_arr.length] = use_key + '=' + use_val;\n    });\n\n    return tmp_arr.join(arg_separator);\n};\n\n_.getQueryParam = function(url, param) {\n    // Expects a raw URL\n\n    param = param.replace(/[[]/g, '\\\\[').replace(/[\\]]/g, '\\\\]');\n    var regexS = '[\\\\?&]' + param + '=([^&#]*)',\n        regex = new RegExp(regexS),\n        results = regex.exec(url);\n    if (results === null || (results && typeof(results[1]) !== 'string' && results[1].length)) {\n        return '';\n    } else {\n        var result = results[1];\n        try {\n            result = decodeURIComponent(result);\n        } catch(err) {\n            console$1.error('Skipping decoding for malformed query param: ' + result);\n        }\n        return result.replace(/\\+/g, ' ');\n    }\n};\n\n\n// _.cookie\n// Methods partially borrowed from quirksmode.org/js/cookies.html\n_.cookie = {\n    get: function(name) {\n        var nameEQ = name + '=';\n        var ca = document$1.cookie.split(';');\n        for (var i = 0; i < ca.length; i++) {\n            var c = ca[i];\n            while (c.charAt(0) == ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return decodeURIComponent(c.substring(nameEQ.length, c.length));\n            }\n        }\n        return null;\n    },\n\n    parse: function(name) {\n        var cookie;\n        try {\n            cookie = _.JSONDecode(_.cookie.get(name)) || {};\n        } catch (err) {\n            // noop\n        }\n        return cookie;\n    },\n\n    set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '',\n            expires = '',\n            secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (seconds) {\n            var date = new Date();\n            date.setTime(date.getTime() + (seconds * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        document$1.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n    },\n\n    set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '', expires = '', secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (days) {\n            var date = new Date();\n            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        var new_cookie_val = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n        document$1.cookie = new_cookie_val;\n        return new_cookie_val;\n    },\n\n    remove: function(name, is_cross_subdomain, domain_override) {\n        _.cookie.set(name, '', -1, is_cross_subdomain, false, false, domain_override);\n    }\n};\n\nvar _localStorageSupported = null;\nvar localStorageSupported = function(storage, forceCheck) {\n    if (_localStorageSupported !== null && !forceCheck) {\n        return _localStorageSupported;\n    }\n\n    var supported = true;\n    try {\n        storage = storage || win.localStorage;\n        var key = '__mplss_' + cheap_guid(8),\n            val = 'xyz';\n        storage.setItem(key, val);\n        if (storage.getItem(key) !== val) {\n            supported = false;\n        }\n        storage.removeItem(key);\n    } catch (err) {\n        supported = false;\n    }\n\n    _localStorageSupported = supported;\n    return supported;\n};\n\n// _.localStorage\n_.localStorage = {\n    is_supported: function(force_check) {\n        var supported = localStorageSupported(null, force_check);\n        if (!supported) {\n            console$1.error('localStorage unsupported; falling back to cookie store');\n        }\n        return supported;\n    },\n\n    error: function(msg) {\n        console$1.error('localStorage error: ' + msg);\n    },\n\n    get: function(name) {\n        try {\n            return win.localStorage.getItem(name);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n        return null;\n    },\n\n    parse: function(name) {\n        try {\n            return _.JSONDecode(_.localStorage.get(name)) || {};\n        } catch (err) {\n            // noop\n        }\n        return null;\n    },\n\n    set: function(name, value) {\n        try {\n            win.localStorage.setItem(name, value);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n    },\n\n    remove: function(name) {\n        try {\n            win.localStorage.removeItem(name);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n    }\n};\n\n_.register_event = (function() {\n    // written by Dean Edwards, 2005\n    // with input from Tino Zijdel - crisp@xs4all.nl\n    // with input from Carl Sverre - mail@carlsverre.com\n    // with input from Mixpanel\n    // http://dean.edwards.name/weblog/2005/10/add-event/\n    // https://gist.github.com/1930440\n\n    /**\n     * @param {Object} element\n     * @param {string} type\n     * @param {function(...*)} handler\n     * @param {boolean=} oldSchool\n     * @param {boolean=} useCapture\n     */\n    var register_event = function(element, type, handler, oldSchool, useCapture) {\n        if (!element) {\n            console$1.error('No valid element provided to register_event');\n            return;\n        }\n\n        if (element.addEventListener && !oldSchool) {\n            element.addEventListener(type, handler, !!useCapture);\n        } else {\n            var ontype = 'on' + type;\n            var old_handler = element[ontype]; // can be undefined\n            element[ontype] = makeHandler(element, handler, old_handler);\n        }\n    };\n\n    function makeHandler(element, new_handler, old_handlers) {\n        var handler = function(event) {\n            event = event || fixEvent(win.event);\n\n            // this basically happens in firefox whenever another script\n            // overwrites the onload callback and doesn't pass the event\n            // object to previously defined callbacks.  All the browsers\n            // that don't define window.event implement addEventListener\n            // so the dom_loaded handler will still be fired as usual.\n            if (!event) {\n                return undefined;\n            }\n\n            var ret = true;\n            var old_result, new_result;\n\n            if (_.isFunction(old_handlers)) {\n                old_result = old_handlers(event);\n            }\n            new_result = new_handler.call(element, event);\n\n            if ((false === old_result) || (false === new_result)) {\n                ret = false;\n            }\n\n            return ret;\n        };\n\n        return handler;\n    }\n\n    function fixEvent(event) {\n        if (event) {\n            event.preventDefault = fixEvent.preventDefault;\n            event.stopPropagation = fixEvent.stopPropagation;\n        }\n        return event;\n    }\n    fixEvent.preventDefault = function() {\n        this.returnValue = false;\n    };\n    fixEvent.stopPropagation = function() {\n        this.cancelBubble = true;\n    };\n\n    return register_event;\n})();\n\n\nvar TOKEN_MATCH_REGEX = new RegExp('^(\\\\w*)\\\\[(\\\\w+)([=~\\\\|\\\\^\\\\$\\\\*]?)=?\"?([^\\\\]\"]*)\"?\\\\]$');\n\n_.dom_query = (function() {\n    /* document.getElementsBySelector(selector)\n    - returns an array of element objects from the current document\n    matching the CSS selector. Selectors can contain element names,\n    class names and ids and can be nested. For example:\n\n    elements = document.getElementsBySelector('div#main p a.external')\n\n    Will return an array of all 'a' elements with 'external' in their\n    class attribute that are contained inside 'p' elements that are\n    contained inside the 'div' element which has id=\"main\"\n\n    New in version 0.4: Support for CSS2 and CSS3 attribute selectors:\n    See http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\n    Version 0.4 - Simon Willison, March 25th 2003\n    -- Works in Phoenix 0.5, Mozilla 1.3, Opera 7, Internet Explorer 6, Internet Explorer 5 on Windows\n    -- Opera 7 fails\n\n    Version 0.5 - Carl Sverre, Jan 7th 2013\n    -- Now uses jQuery-esque `hasClass` for testing class name\n    equality.  This fixes a bug related to '-' characters being\n    considered not part of a 'word' in regex.\n    */\n\n    function getAllChildren(e) {\n        // Returns all children of element. Workaround required for IE5/Windows. Ugh.\n        return e.all ? e.all : e.getElementsByTagName('*');\n    }\n\n    var bad_whitespace = /[\\t\\r\\n]/g;\n\n    function hasClass(elem, selector) {\n        var className = ' ' + selector + ' ';\n        return ((' ' + elem.className + ' ').replace(bad_whitespace, ' ').indexOf(className) >= 0);\n    }\n\n    function getElementsBySelector(selector) {\n        // Attempt to fail gracefully in lesser browsers\n        if (!document$1.getElementsByTagName) {\n            return [];\n        }\n        // Split selector in to tokens\n        var tokens = selector.split(' ');\n        var token, bits, tagName, found, foundCount, i, j, k, elements, currentContextIndex;\n        var currentContext = [document$1];\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i].replace(/^\\s+/, '').replace(/\\s+$/, '');\n            if (token.indexOf('#') > -1) {\n                // Token is an ID selector\n                bits = token.split('#');\n                tagName = bits[0];\n                var id = bits[1];\n                var element = document$1.getElementById(id);\n                if (!element || (tagName && element.nodeName.toLowerCase() != tagName)) {\n                    // element not found or tag with that ID not found, return false\n                    return [];\n                }\n                // Set currentContext to contain just this element\n                currentContext = [element];\n                continue; // Skip to next token\n            }\n            if (token.indexOf('.') > -1) {\n                // Token contains a class selector\n                bits = token.split('.');\n                tagName = bits[0];\n                var className = bits[1];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Get elements matching tag, filter them for class selector\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (found[j].className &&\n                        _.isString(found[j].className) && // some SVG elements have classNames which are not strings\n                        hasClass(found[j], className)\n                    ) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // Code to deal with attribute selectors\n            var token_match = token.match(TOKEN_MATCH_REGEX);\n            if (token_match) {\n                tagName = token_match[1];\n                var attrName = token_match[2];\n                var attrOperator = token_match[3];\n                var attrValue = token_match[4];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Grab all of the tagName elements within current context\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                var checkFunction; // This function will be used to filter the elements\n                switch (attrOperator) {\n                    case '=': // Equality\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName) == attrValue);\n                        };\n                        break;\n                    case '~': // Match one of space seperated words\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('\\\\b' + attrValue + '\\\\b')));\n                        };\n                        break;\n                    case '|': // Match start with value followed by optional hyphen\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('^' + attrValue + '-?')));\n                        };\n                        break;\n                    case '^': // Match starts with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) === 0);\n                        };\n                        break;\n                    case '$': // Match ends with value - fails with \"Warning\" in Opera 7\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).lastIndexOf(attrValue) == e.getAttribute(attrName).length - attrValue.length);\n                        };\n                        break;\n                    case '*': // Match ends with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) > -1);\n                        };\n                        break;\n                    default:\n                        // Just test for existence of attribute\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName);\n                        };\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (checkFunction(found[j])) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                // alert('Attribute Selector: '+tagName+' '+attrName+' '+attrOperator+' '+attrValue);\n                continue; // Skip to next token\n            }\n            // If we get here, token is JUST an element (not a class or ID selector)\n            tagName = token;\n            found = [];\n            foundCount = 0;\n            for (j = 0; j < currentContext.length; j++) {\n                elements = currentContext[j].getElementsByTagName(tagName);\n                for (k = 0; k < elements.length; k++) {\n                    found[foundCount++] = elements[k];\n                }\n            }\n            currentContext = found;\n        }\n        return currentContext;\n    }\n\n    return function(query) {\n        if (_.isElement(query)) {\n            return [query];\n        } else if (_.isObject(query) && !_.isUndefined(query.length)) {\n            return query;\n        } else {\n            return getElementsBySelector.call(this, query);\n        }\n    };\n})();\n\nvar CAMPAIGN_KEYWORDS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term', 'utm_id', 'utm_source_platform','utm_campaign_id', 'utm_creative_format', 'utm_marketing_tactic'];\nvar CLICK_IDS = ['dclid', 'fbclid', 'gclid', 'ko_click_id', 'li_fat_id', 'msclkid', 'sccid', 'ttclid', 'twclid', 'wbraid'];\n\n_.info = {\n    campaignParams: function(default_value) {\n        var kw = '',\n            params = {};\n        _.each(CAMPAIGN_KEYWORDS, function(kwkey) {\n            kw = _.getQueryParam(document$1.URL, kwkey);\n            if (kw.length) {\n                params[kwkey] = kw;\n            } else if (default_value !== undefined) {\n                params[kwkey] = default_value;\n            }\n        });\n\n        return params;\n    },\n\n    clickParams: function() {\n        var id = '',\n            params = {};\n        _.each(CLICK_IDS, function(idkey) {\n            id = _.getQueryParam(document$1.URL, idkey);\n            if (id.length) {\n                params[idkey] = id;\n            }\n        });\n\n        return params;\n    },\n\n    marketingParams: function() {\n        return _.extend(_.info.campaignParams(), _.info.clickParams());\n    },\n\n    searchEngine: function(referrer) {\n        if (referrer.search('https?://(.*)google.([^/?]*)') === 0) {\n            return 'google';\n        } else if (referrer.search('https?://(.*)bing.com') === 0) {\n            return 'bing';\n        } else if (referrer.search('https?://(.*)yahoo.com') === 0) {\n            return 'yahoo';\n        } else if (referrer.search('https?://(.*)duckduckgo.com') === 0) {\n            return 'duckduckgo';\n        } else {\n            return null;\n        }\n    },\n\n    searchInfo: function(referrer) {\n        var search = _.info.searchEngine(referrer),\n            param = (search != 'yahoo') ? 'q' : 'p',\n            ret = {};\n\n        if (search !== null) {\n            ret['$search_engine'] = search;\n\n            var keyword = _.getQueryParam(referrer, param);\n            if (keyword.length) {\n                ret['mp_keyword'] = keyword;\n            }\n        }\n\n        return ret;\n    },\n\n    /**\n     * This function detects which browser is running this script.\n     * The order of the checks are important since many user agents\n     * include key words used in later checks.\n     */\n    browser: function(user_agent, vendor, opera) {\n        vendor = vendor || ''; // vendor is undefined for at least IE9\n        if (opera || _.includes(user_agent, ' OPR/')) {\n            if (_.includes(user_agent, 'Mini')) {\n                return 'Opera Mini';\n            }\n            return 'Opera';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (_.includes(user_agent, 'IEMobile') || _.includes(user_agent, 'WPDesktop')) {\n            return 'Internet Explorer Mobile';\n        } else if (_.includes(user_agent, 'SamsungBrowser/')) {\n            // https://developer.samsung.com/internet/user-agent-string-format\n            return 'Samsung Internet';\n        } else if (_.includes(user_agent, 'Edge') || _.includes(user_agent, 'Edg/')) {\n            return 'Microsoft Edge';\n        } else if (_.includes(user_agent, 'FBIOS')) {\n            return 'Facebook Mobile';\n        } else if (_.includes(user_agent, 'Chrome')) {\n            return 'Chrome';\n        } else if (_.includes(user_agent, 'CriOS')) {\n            return 'Chrome iOS';\n        } else if (_.includes(user_agent, 'UCWEB') || _.includes(user_agent, 'UCBrowser')) {\n            return 'UC Browser';\n        } else if (_.includes(user_agent, 'FxiOS')) {\n            return 'Firefox iOS';\n        } else if (_.includes(vendor, 'Apple')) {\n            if (_.includes(user_agent, 'Mobile')) {\n                return 'Mobile Safari';\n            }\n            return 'Safari';\n        } else if (_.includes(user_agent, 'Android')) {\n            return 'Android Mobile';\n        } else if (_.includes(user_agent, 'Konqueror')) {\n            return 'Konqueror';\n        } else if (_.includes(user_agent, 'Firefox')) {\n            return 'Firefox';\n        } else if (_.includes(user_agent, 'MSIE') || _.includes(user_agent, 'Trident/')) {\n            return 'Internet Explorer';\n        } else if (_.includes(user_agent, 'Gecko')) {\n            return 'Mozilla';\n        } else {\n            return '';\n        }\n    },\n\n    /**\n     * This function detects which browser version is running this script,\n     * parsing major and minor version (e.g., 42.1). User agent strings from:\n     * http://www.useragentstring.com/pages/useragentstring.php\n     */\n    browserVersion: function(userAgent, vendor, opera) {\n        var browser = _.info.browser(userAgent, vendor, opera);\n        var versionRegexs = {\n            'Internet Explorer Mobile': /rv:(\\d+(\\.\\d+)?)/,\n            'Microsoft Edge': /Edge?\\/(\\d+(\\.\\d+)?)/,\n            'Chrome': /Chrome\\/(\\d+(\\.\\d+)?)/,\n            'Chrome iOS': /CriOS\\/(\\d+(\\.\\d+)?)/,\n            'UC Browser' : /(UCBrowser|UCWEB)\\/(\\d+(\\.\\d+)?)/,\n            'Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Mobile Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Opera': /(Opera|OPR)\\/(\\d+(\\.\\d+)?)/,\n            'Firefox': /Firefox\\/(\\d+(\\.\\d+)?)/,\n            'Firefox iOS': /FxiOS\\/(\\d+(\\.\\d+)?)/,\n            'Konqueror': /Konqueror:(\\d+(\\.\\d+)?)/,\n            'BlackBerry': /BlackBerry (\\d+(\\.\\d+)?)/,\n            'Android Mobile': /android\\s(\\d+(\\.\\d+)?)/,\n            'Samsung Internet': /SamsungBrowser\\/(\\d+(\\.\\d+)?)/,\n            'Internet Explorer': /(rv:|MSIE )(\\d+(\\.\\d+)?)/,\n            'Mozilla': /rv:(\\d+(\\.\\d+)?)/\n        };\n        var regex = versionRegexs[browser];\n        if (regex === undefined) {\n            return null;\n        }\n        var matches = userAgent.match(regex);\n        if (!matches) {\n            return null;\n        }\n        return parseFloat(matches[matches.length - 2]);\n    },\n\n    os: function() {\n        var a = userAgent;\n        if (/Windows/i.test(a)) {\n            if (/Phone/.test(a) || /WPDesktop/.test(a)) {\n                return 'Windows Phone';\n            }\n            return 'Windows';\n        } else if (/(iPhone|iPad|iPod)/.test(a)) {\n            return 'iOS';\n        } else if (/Android/.test(a)) {\n            return 'Android';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {\n            return 'BlackBerry';\n        } else if (/Mac/i.test(a)) {\n            return 'Mac OS X';\n        } else if (/Linux/.test(a)) {\n            return 'Linux';\n        } else if (/CrOS/.test(a)) {\n            return 'Chrome OS';\n        } else {\n            return '';\n        }\n    },\n\n    device: function(user_agent) {\n        if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {\n            return 'Windows Phone';\n        } else if (/iPad/.test(user_agent)) {\n            return 'iPad';\n        } else if (/iPod/.test(user_agent)) {\n            return 'iPod Touch';\n        } else if (/iPhone/.test(user_agent)) {\n            return 'iPhone';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (/Android/.test(user_agent)) {\n            return 'Android';\n        } else {\n            return '';\n        }\n    },\n\n    referringDomain: function(referrer) {\n        var split = referrer.split('/');\n        if (split.length >= 3) {\n            return split[2];\n        }\n        return '';\n    },\n\n    currentUrl: function() {\n        return win.location.href;\n    },\n\n    properties: function(extra_props) {\n        if (typeof extra_props !== 'object') {\n            extra_props = {};\n        }\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera),\n            '$referrer': document$1.referrer,\n            '$referring_domain': _.info.referringDomain(document$1.referrer),\n            '$device': _.info.device(userAgent)\n        }), {\n            '$current_url': _.info.currentUrl(),\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera),\n            '$screen_height': screen.height,\n            '$screen_width': screen.width,\n            'mp_lib': 'web',\n            '$lib_version': Config.LIB_VERSION,\n            '$insert_id': cheap_guid(),\n            'time': _.timestamp() / 1000 // epoch time in seconds\n        }, _.strip_empty_properties(extra_props));\n    },\n\n    people_properties: function() {\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera)\n        }), {\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera)\n        });\n    },\n\n    mpPageViewProperties: function() {\n        return _.strip_empty_properties({\n            'current_page_title': document$1.title,\n            'current_domain': win.location.hostname,\n            'current_url_path': win.location.pathname,\n            'current_url_protocol': win.location.protocol,\n            'current_url_search': win.location.search\n        });\n    }\n};\n\nvar cheap_guid = function(maxlen) {\n    var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n    return maxlen ? guid.substring(0, maxlen) : guid;\n};\n\n// naive way to extract domain name (example.com) from full hostname (my.sub.example.com)\nvar SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\\.[a-z]+$/i;\n// this next one attempts to account for some ccSLDs, e.g. extracting oxford.ac.uk from www.oxford.ac.uk\nvar DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\\.[a-z.]{2,6}$/i;\n/**\n * Attempts to extract main domain name from full hostname, using a few blunt heuristics. For\n * common TLDs like .com/.org that always have a simple SLD.TLD structure (example.com), we\n * simply extract the last two .-separated parts of the hostname (SIMPLE_DOMAIN_MATCH_REGEX).\n * For others, we attempt to account for short ccSLD+TLD combos (.ac.uk) with the legacy\n * DOMAIN_MATCH_REGEX (kept to maintain backwards compatibility with existing Mixpanel\n * integrations). The only _reliable_ way to extract domain from hostname is with an up-to-date\n * list like at https://publicsuffix.org/ so for cases that this helper fails at, the SDK\n * offers the 'cookie_domain' config option to set it explicitly.\n * @example\n * extract_domain('my.sub.example.com')\n * // 'example.com'\n */\nvar extract_domain = function(hostname) {\n    var domain_regex = DOMAIN_MATCH_REGEX;\n    var parts = hostname.split('.');\n    var tld = parts[parts.length - 1];\n    if (tld.length > 4 || tld === 'com' || tld === 'org') {\n        domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;\n    }\n    var matches = hostname.match(domain_regex);\n    return matches ? matches[0] : '';\n};\n\n/**\n * Check whether we have network connection. default to true for browsers that don't support navigator.onLine (IE)\n * @returns {boolean}\n */\nvar isOnline = function() {\n    var onLine = win.navigator['onLine'];\n    return _.isUndefined(onLine) || onLine;\n};\n\nvar JSONStringify = null, JSONParse = null;\nif (typeof JSON !== 'undefined') {\n    JSONStringify = JSON.stringify;\n    JSONParse = JSON.parse;\n}\nJSONStringify = JSONStringify || _.JSONEncode;\nJSONParse = JSONParse || _.JSONDecode;\n\n// EXPORTS (for closure compiler)\n_['toArray']                = _.toArray;\n_['isObject']               = _.isObject;\n_['JSONEncode']             = _.JSONEncode;\n_['JSONDecode']             = _.JSONDecode;\n_['isBlockedUA']            = _.isBlockedUA;\n_['isEmptyObject']          = _.isEmptyObject;\n_['info']                   = _.info;\n_['info']['device']         = _.info.device;\n_['info']['browser']        = _.info.browser;\n_['info']['browserVersion'] = _.info.browserVersion;\n_['info']['properties']     = _.info.properties;\n_['NPO']                    = NpoPromise;\n\n/**\n * GDPR utils\n *\n * The General Data Protection Regulation (GDPR) is a regulation in EU law on data protection\n * and privacy for all individuals within the European Union. It addresses the export of personal\n * data outside the EU. The GDPR aims primarily to give control back to citizens and residents\n * over their personal data and to simplify the regulatory environment for international business\n * by unifying the regulation within the EU.\n *\n * This set of utilities is intended to enable opt in/out functionality in the Mixpanel JS SDK.\n * These functions are used internally by the SDK and are not intended to be publicly exposed.\n */\n\n/**\n * A function used to track a Mixpanel event (e.g. MixpanelLib.track)\n * @callback trackFunction\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n */\n\n/** Public **/\n\nvar GDPR_DEFAULT_PERSISTENCE_PREFIX = '__mp_opt_in_out_';\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction optIn(token, options) {\n    _optInOut(true, token, options);\n}\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-out cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-out cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-out cookie is set as secure or not\n */\nfunction optOut(token, options) {\n    _optInOut(false, token, options);\n}\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} whether the user has opted in to the given opt type\n */\nfunction hasOptedIn(token, options) {\n    return _getStorageValue(token, options) === '1';\n}\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the user has opted out of the given opt type\n */\nfunction hasOptedOut(token, options) {\n    if (_hasDoNotTrackFlagOn(options)) {\n        console$1.warn('This browser has \"Do Not Track\" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the \"Do Not Track\" browser setting, initialize the Mixpanel instance with the config \"ignore_dnt: true\"');\n        return true;\n    }\n    var optedOut = _getStorageValue(token, options) === '0';\n    if (optedOut) {\n        console$1.warn('You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.');\n    }\n    return optedOut;\n}\n\n/**\n * Wrap a MixpanelLib method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelLib(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this.get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelPeople method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelPeople(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelGroup method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelGroup(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction clearOptInOut(token, options) {\n    options = options || {};\n    _getStorage(options).remove(\n        _getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain\n    );\n}\n\n/** Private **/\n\n/**\n * Get storage util\n * @param {Object} [options]\n * @param {string} [options.persistenceType]\n * @returns {object} either _.cookie or _.localstorage\n */\nfunction _getStorage(options) {\n    options = options || {};\n    return options.persistenceType === 'localStorage' ? _.localStorage : _.cookie;\n}\n\n/**\n * Get the name of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the name of the cookie for the given opt type\n */\nfunction _getStorageKey(token, options) {\n    options = options || {};\n    return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;\n}\n\n/**\n * Get the value of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the value of the cookie for the given opt type\n */\nfunction _getStorageValue(token, options) {\n    return _getStorage(options).get(_getStorageKey(token, options));\n}\n\n/**\n * Check whether the user has set the DNT/doNotTrack setting to true in their browser\n * @param {Object} [options]\n * @param {string} [options.window] - alternate window object to check; used to force various DNT settings in browser tests\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the DNT setting is true\n */\nfunction _hasDoNotTrackFlagOn(options) {\n    if (options && options.ignoreDnt) {\n        return false;\n    }\n    var win$1 = (options && options.window) || win;\n    var nav = win$1['navigator'] || {};\n    var hasDntOn = false;\n\n    _.each([\n        nav['doNotTrack'], // standard\n        nav['msDoNotTrack'],\n        win$1['doNotTrack']\n    ], function(dntValue) {\n        if (_.includes([true, 1, '1', 'yes'], dntValue)) {\n            hasDntOn = true;\n        }\n    });\n\n    return hasDntOn;\n}\n\n/**\n * Set cookie/localstorage for the user indicating that they are opted in or out for the given opt type\n * @param {boolean} optValue - whether to opt the user in or out for the given opt type\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction _optInOut(optValue, token, options) {\n    if (!_.isString(token) || !token.length) {\n        console$1.error('gdpr.' + (optValue ? 'optIn' : 'optOut') + ' called with an invalid token');\n        return;\n    }\n\n    options = options || {};\n\n    _getStorage(options).set(\n        _getStorageKey(token, options),\n        optValue ? 1 : 0,\n        _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null,\n        !!options.crossSubdomainCookie,\n        !!options.secureCookie,\n        !!options.crossSiteCookie,\n        options.cookieDomain\n    );\n\n    if (options.track && optValue) { // only track event if opting in (optValue=true)\n        options.track(options.trackEventName || '$opt_in', options.trackProperties, {\n            'send_immediately': true\n        });\n    }\n}\n\n/**\n * Wrap a method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @param {function} getConfigValue - getter function for the Mixpanel API token and other options to be used with opt-out check\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction _addOptOutCheck(method, getConfigValue) {\n    return function() {\n        var optedOut = false;\n\n        try {\n            var token = getConfigValue.call(this, 'token');\n            var ignoreDnt = getConfigValue.call(this, 'ignore_dnt');\n            var persistenceType = getConfigValue.call(this, 'opt_out_tracking_persistence_type');\n            var persistencePrefix = getConfigValue.call(this, 'opt_out_tracking_cookie_prefix');\n            var win = getConfigValue.call(this, 'window'); // used to override window during browser tests\n\n            if (token) { // if there was an issue getting the token, continue method execution as normal\n                optedOut = hasOptedOut(token, {\n                    ignoreDnt: ignoreDnt,\n                    persistenceType: persistenceType,\n                    persistencePrefix: persistencePrefix,\n                    window: win\n                });\n            }\n        } catch(err) {\n            console$1.error('Unexpected error when checking tracking opt-out status: ' + err);\n        }\n\n        if (!optedOut) {\n            return method.apply(this, arguments);\n        }\n\n        var callback = arguments[arguments.length - 1];\n        if (typeof(callback) === 'function') {\n            callback(0);\n        }\n\n        return;\n    };\n}\n\nvar logger$4 = console_with_prefix('lock');\n\n/**\n * SharedLock: a mutex built on HTML5 localStorage, to ensure that only one browser\n * window/tab at a time will be able to access shared resources.\n *\n * Based on the Alur and Taubenfeld fast lock\n * (http://www.cs.rochester.edu/research/synchronization/pseudocode/fastlock.html)\n * with an added timeout to ensure there will be eventual progress in the event\n * that a window is closed in the middle of the callback.\n *\n * Implementation based on the original version by David Wolever (https://github.com/wolever)\n * at https://gist.github.com/wolever/5fd7573d1ef6166e8f8c4af286a69432.\n *\n * @example\n * const myLock = new SharedLock('some-key');\n * myLock.withLock(function() {\n *   console.log('I hold the mutex!');\n * });\n *\n * @constructor\n */\nvar SharedLock = function(key, options) {\n    options = options || {};\n\n    this.storageKey = key;\n    this.storage = options.storage || window.localStorage;\n    this.pollIntervalMS = options.pollIntervalMS || 100;\n    this.timeoutMS = options.timeoutMS || 2000;\n\n    // dependency-inject promise implementation for testing purposes\n    this.promiseImpl = options.promiseImpl || PromisePolyfill;\n};\n\n// pass in a specific pid to test contention scenarios; otherwise\n// it is chosen randomly for each acquisition attempt\nSharedLock.prototype.withLock = function(lockedCB, pid) {\n    var Promise = this.promiseImpl;\n    return new Promise(_.bind(function (resolve, reject) {\n        var i = pid || (new Date().getTime() + '|' + Math.random());\n        var startTime = new Date().getTime();\n\n        var key = this.storageKey;\n        var pollIntervalMS = this.pollIntervalMS;\n        var timeoutMS = this.timeoutMS;\n        var storage = this.storage;\n\n        var keyX = key + ':X';\n        var keyY = key + ':Y';\n        var keyZ = key + ':Z';\n\n        var delay = function(cb) {\n            if (new Date().getTime() - startTime > timeoutMS) {\n                logger$4.error('Timeout waiting for mutex on ' + key + '; clearing lock. [' + i + ']');\n                storage.removeItem(keyZ);\n                storage.removeItem(keyY);\n                loop();\n                return;\n            }\n            setTimeout(function() {\n                try {\n                    cb();\n                } catch(err) {\n                    reject(err);\n                }\n            }, pollIntervalMS * (Math.random() + 0.1));\n        };\n\n        var waitFor = function(predicate, cb) {\n            if (predicate()) {\n                cb();\n            } else {\n                delay(function() {\n                    waitFor(predicate, cb);\n                });\n            }\n        };\n\n        var getSetY = function() {\n            var valY = storage.getItem(keyY);\n            if (valY && valY !== i) { // if Y == i then this process already has the lock (useful for test cases)\n                return false;\n            } else {\n                storage.setItem(keyY, i);\n                if (storage.getItem(keyY) === i) {\n                    return true;\n                } else {\n                    if (!localStorageSupported(storage, true)) {\n                        reject(new Error('localStorage support dropped while acquiring lock'));\n                    }\n                    return false;\n                }\n            }\n        };\n\n        var loop = function() {\n            storage.setItem(keyX, i);\n\n            waitFor(getSetY, function() {\n                if (storage.getItem(keyX) === i) {\n                    criticalSection();\n                    return;\n                }\n\n                delay(function() {\n                    if (storage.getItem(keyY) !== i) {\n                        loop();\n                        return;\n                    }\n                    waitFor(function() {\n                        return !storage.getItem(keyZ);\n                    }, criticalSection);\n                });\n            });\n        };\n\n        var criticalSection = function() {\n            storage.setItem(keyZ, '1');\n            var removeLock = function () {\n                storage.removeItem(keyZ);\n                if (storage.getItem(keyY) === i) {\n                    storage.removeItem(keyY);\n                }\n                if (storage.getItem(keyX) === i) {\n                    storage.removeItem(keyX);\n                }\n            };\n\n            lockedCB()\n                .then(function (ret) {\n                    removeLock();\n                    resolve(ret);\n                })\n                .catch(function (err) {\n                    removeLock();\n                    reject(err);\n                });\n        };\n\n        try {\n            if (localStorageSupported(storage, true)) {\n                loop();\n            } else {\n                throw new Error('localStorage support check failed');\n            }\n        } catch(err) {\n            reject(err);\n        }\n    }, this));\n};\n\n/**\n * @typedef {import('./wrapper').StorageWrapper}\n */\n\n/**\n * @type {StorageWrapper}\n */\nvar LocalStorageWrapper = function (storageOverride) {\n    this.storage = storageOverride || localStorage;\n};\n\nLocalStorageWrapper.prototype.init = function () {\n    return PromisePolyfill.resolve();\n};\n\nLocalStorageWrapper.prototype.setItem = function (key, value) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.setItem(key, value);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nLocalStorageWrapper.prototype.getItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        var item;\n        try {\n            item = this.storage.getItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve(item);\n    }, this));\n};\n\nLocalStorageWrapper.prototype.removeItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nvar logger$3 = console_with_prefix('batch');\n\n/**\n * RequestQueue: queue for batching API requests with localStorage backup for retries.\n * Maintains an in-memory queue which represents the source of truth for the current\n * page, but also writes all items out to a copy in the browser's localStorage, which\n * can be read on subsequent pageloads and retried. For batchability, all the request\n * items in the queue should be of the same type (events, people updates, group updates)\n * so they can be sent in a single request to the same API endpoint.\n *\n * LocalStorage keying and locking: In order for reloads and subsequent pageloads of\n * the same site to access the same persisted data, they must share the same localStorage\n * key (for instance based on project token and queue type). Therefore access to the\n * localStorage entry is guarded by an asynchronous mutex (SharedLock) to prevent\n * simultaneously open windows/tabs from overwriting each other's data (which would lead\n * to data loss in some situations).\n * @constructor\n */\nvar RequestQueue = function (storageKey, options) {\n    options = options || {};\n    this.storageKey = storageKey;\n    this.usePersistence = options.usePersistence;\n    if (this.usePersistence) {\n        this.queueStorage = options.queueStorage || new LocalStorageWrapper();\n        this.lock = new SharedLock(storageKey, { storage: options.sharedLockStorage || window.localStorage });\n        this.queueStorage.init();\n    }\n    this.reportError = options.errorReporter || _.bind(logger$3.error, logger$3);\n\n    this.pid = options.pid || null; // pass pid to test out storage lock contention scenarios\n\n    this.memQueue = [];\n    this.initialized = false;\n};\n\nRequestQueue.prototype.ensureInit = function () {\n    if (this.initialized) {\n        return PromisePolyfill.resolve();\n    }\n\n    return this.queueStorage\n        .init()\n        .then(_.bind(function () {\n            this.initialized = true;\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error initializing queue persistence. Disabling persistence', err);\n            this.initialized = true;\n            this.usePersistence = false;\n        }, this));\n};\n\n/**\n * Add one item to queues (memory and localStorage). The queued entry includes\n * the given item along with an auto-generated ID and a \"flush-after\" timestamp.\n * It is expected that the item will be sent over the network and dequeued\n * before the flush-after time; if this doesn't happen it is considered orphaned\n * (e.g., the original tab where it was enqueued got closed before it could be\n * sent) and the item can be sent by any tab that finds it in localStorage.\n *\n * The final callback param is called with a param indicating success or\n * failure of the enqueue operation; it is asynchronous because the localStorage\n * lock is asynchronous.\n */\nRequestQueue.prototype.enqueue = function (item, flushInterval) {\n    var queueEntry = {\n        'id': cheap_guid(),\n        'flushAfter': new Date().getTime() + flushInterval * 2,\n        'payload': item\n    };\n\n    if (!this.usePersistence) {\n        this.memQueue.push(queueEntry);\n        return PromisePolyfill.resolve(true);\n    } else {\n\n        var enqueueItem = _.bind(function () {\n            return this.ensureInit()\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    storedQueue.push(queueEntry);\n                    return this.saveToStorage(storedQueue);\n                }, this))\n                .then(_.bind(function (succeeded) {\n                    // only add to in-memory queue when storage succeeds\n                    if (succeeded) {\n                        this.memQueue.push(queueEntry);\n                    }\n                    return succeeded;\n                }, this))\n                .catch(_.bind(function (err) {\n                    this.reportError('Error enqueueing item', err, item);\n                    return false;\n                }, this));\n        }, this);\n\n        return this.lock\n            .withLock(enqueueItem, this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                return false;\n            }, this));\n    }\n};\n\n/**\n * Read out the given number of queue entries. If this.memQueue\n * has fewer than batchSize items, then look for \"orphaned\" items\n * in the persisted queue (items where the 'flushAfter' time has\n * already passed).\n */\nRequestQueue.prototype.fillBatch = function (batchSize) {\n    var batch = this.memQueue.slice(0, batchSize);\n    if (this.usePersistence && batch.length < batchSize) {\n        // don't need lock just to read events; localStorage is thread-safe\n        // and the worst that could happen is a duplicate send of some\n        // orphaned events, which will be deduplicated on the server side\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                if (storedQueue.length) {\n                // item IDs already in batch; don't duplicate out of storage\n                    var idsInBatch = {}; // poor man's Set\n                    _.each(batch, function (item) {\n                        idsInBatch[item['id']] = true;\n                    });\n\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (new Date().getTime() > item['flushAfter'] && !idsInBatch[item['id']]) {\n                            item.orphaned = true;\n                            batch.push(item);\n                            if (batch.length >= batchSize) {\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                return batch;\n            }, this));\n    } else {\n        return PromisePolyfill.resolve(batch);\n    }\n};\n\n/**\n * Remove items with matching 'id' from array (immutably)\n * also remove any item without a valid id (e.g., malformed\n * storage entries).\n */\nvar filterOutIDsAndInvalid = function (items, idSet) {\n    var filteredItems = [];\n    _.each(items, function (item) {\n        if (item['id'] && !idSet[item['id']]) {\n            filteredItems.push(item);\n        }\n    });\n    return filteredItems;\n};\n\n/**\n * Remove items with matching IDs from both in-memory queue\n * and persisted queue\n */\nRequestQueue.prototype.removeItemsByID = function (ids) {\n    var idSet = {}; // poor man's Set\n    _.each(ids, function (id) {\n        idSet[id] = true;\n    });\n\n    this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        var removeFromStorage = _.bind(function () {\n            return this.ensureInit()\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);\n                    return this.saveToStorage(storedQueue);\n                }, this))\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    // an extra check: did storage report success but somehow\n                    // the items are still there?\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (item['id'] && !!idSet[item['id']]) {\n                            throw new Error('Item not removed from storage');\n                        }\n                    }\n                    return true;\n                }, this))\n                .catch(_.bind(function (err) {\n                    this.reportError('Error removing items', err, ids);\n                    return false;\n                }, this));\n        }, this);\n\n        return this.lock\n            .withLock(removeFromStorage, this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                if (!localStorageSupported(this.queueStorage.storage, true)) {\n                    // Looks like localStorage writes have stopped working sometime after\n                    // initialization (probably full), and so nobody can acquire locks\n                    // anymore. Consider it temporarily safe to remove items without the\n                    // lock, since nobody's writing successfully anyway.\n                    return removeFromStorage()\n                        .then(_.bind(function (success) {\n                            if (!success) {\n                                // OK, we couldn't even write out the smaller queue. Try clearing it\n                                // entirely.\n                                return this.queueStorage.removeItem(this.storageKey).then(function () {\n                                    return success;\n                                });\n                            }\n                            return success;\n                        }, this))\n                        .catch(_.bind(function (err) {\n                            this.reportError('Error clearing queue', err);\n                            return false;\n                        }, this));\n                } else {\n                    return false;\n                }\n            }, this));\n    }\n};\n\n// internal helper for RequestQueue.updatePayloads\nvar updatePayloads = function (existingItems, itemsToUpdate) {\n    var newItems = [];\n    _.each(existingItems, function (item) {\n        var id = item['id'];\n        if (id in itemsToUpdate) {\n            var newPayload = itemsToUpdate[id];\n            if (newPayload !== null) {\n                item['payload'] = newPayload;\n                newItems.push(item);\n            }\n        } else {\n            // no update\n            newItems.push(item);\n        }\n    });\n    return newItems;\n};\n\n/**\n * Update payloads of given items in both in-memory queue and\n * persisted queue. Items set to null are removed from queues.\n */\nRequestQueue.prototype.updatePayloads = function (itemsToUpdate) {\n    this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.lock\n            .withLock(_.bind(function lockAcquired() {\n                return this.ensureInit()\n                    .then(_.bind(function () {\n                        return this.readFromStorage();\n                    }, this))\n                    .then(_.bind(function (storedQueue) {\n                        storedQueue = updatePayloads(storedQueue, itemsToUpdate);\n                        return this.saveToStorage(storedQueue);\n                    }, this))\n                    .catch(_.bind(function (err) {\n                        this.reportError('Error updating items', itemsToUpdate, err);\n                        return false;\n                    }, this));\n            }, this), this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                return false;\n            }, this));\n    }\n};\n\n/**\n * Read and parse items array from localStorage entry, handling\n * malformed/missing data if necessary.\n */\nRequestQueue.prototype.readFromStorage = function () {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.getItem(this.storageKey);\n        }, this))\n        .then(_.bind(function (storageEntry) {\n            if (storageEntry) {\n                storageEntry = JSONParse(storageEntry);\n                if (!_.isArray(storageEntry)) {\n                    this.reportError('Invalid storage entry:', storageEntry);\n                    storageEntry = null;\n                }\n            }\n            return storageEntry || [];\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error retrieving queue', err);\n            return [];\n        }, this));\n};\n\n/**\n * Serialize the given items array to localStorage.\n */\nRequestQueue.prototype.saveToStorage = function (queue) {\n    try {\n        var serialized = JSONStringify(queue);\n    } catch (err) {\n        this.reportError('Error serializing queue', err);\n        return PromisePolyfill.resolve(false);\n    }\n\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.setItem(this.storageKey, serialized);\n        }, this))\n        .then(function () {\n            return true;\n        })\n        .catch(_.bind(function (err) {\n            this.reportError('Error saving queue', err);\n            return false;\n        }, this));\n};\n\n/**\n * Clear out queues (memory and localStorage).\n */\nRequestQueue.prototype.clear = function () {\n    this.memQueue = [];\n\n    if (this.usePersistence) {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.queueStorage.removeItem(this.storageKey);\n            }, this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n\n// maximum interval between request retries after exponential backoff\nvar MAX_RETRY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\n\nvar logger$2 = console_with_prefix('batch');\n\n/**\n * RequestBatcher: manages the queueing, flushing, retry etc of requests of one\n * type (events, people, groups).\n * Uses RequestQueue to manage the backing store.\n * @constructor\n */\nvar RequestBatcher = function(storageKey, options) {\n    this.errorReporter = options.errorReporter;\n    this.queue = new RequestQueue(storageKey, {\n        errorReporter: _.bind(this.reportError, this),\n        queueStorage: options.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        usePersistence: options.usePersistence\n    });\n\n    this.libConfig = options.libConfig;\n    this.sendRequest = options.sendRequestFunc;\n    this.beforeSendHook = options.beforeSendHook;\n    this.stopAllBatching = options.stopAllBatchingFunc;\n\n    // seed variable batch size + flush interval with configured values\n    this.batchSize = this.libConfig['batch_size'];\n    this.flushInterval = this.libConfig['batch_flush_interval_ms'];\n\n    this.stopped = !this.libConfig['batch_autostart'];\n    this.consecutiveRemovalFailures = 0;\n\n    // extra client-side dedupe\n    this.itemIdsSentSuccessfully = {};\n\n    // Make the flush occur at the interval specified by flushIntervalMs, default behavior will attempt consecutive flushes\n    // as long as the queue is not empty. This is useful for high-frequency events like Session Replay where we might end up\n    // in a request loop and get ratelimited by the server.\n    this.flushOnlyOnInterval = options.flushOnlyOnInterval || false;\n};\n\n/**\n * Add one item to queue.\n */\nRequestBatcher.prototype.enqueue = function(item) {\n    return this.queue.enqueue(item, this.flushInterval);\n};\n\n/**\n * Start flushing batches at the configured time interval. Must call\n * this method upon SDK init in order to send anything over the network.\n */\nRequestBatcher.prototype.start = function() {\n    this.stopped = false;\n    this.consecutiveRemovalFailures = 0;\n    return this.flush();\n};\n\n/**\n * Stop flushing batches. Can be restarted by calling start().\n */\nRequestBatcher.prototype.stop = function() {\n    this.stopped = true;\n    if (this.timeoutID) {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n    }\n};\n\n/**\n * Clear out queue.\n */\nRequestBatcher.prototype.clear = function() {\n    return this.queue.clear();\n};\n\n/**\n * Restore batch size configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetBatchSize = function() {\n    this.batchSize = this.libConfig['batch_size'];\n};\n\n/**\n * Restore flush interval time configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetFlush = function() {\n    this.scheduleFlush(this.libConfig['batch_flush_interval_ms']);\n};\n\n/**\n * Schedule the next flush in the given number of milliseconds.\n */\nRequestBatcher.prototype.scheduleFlush = function(flushMS) {\n    this.flushInterval = flushMS;\n    if (!this.stopped) { // don't schedule anymore if batching has been stopped\n        this.timeoutID = setTimeout(_.bind(function() {\n            if (!this.stopped) {\n                this.flush();\n            }\n        }, this), this.flushInterval);\n    }\n};\n\n/**\n * Send a request using the sendRequest callback, but promisified.\n * TODO: sendRequest should be promisified in the first place.\n */\nRequestBatcher.prototype.sendRequestPromise = function(data, options) {\n    return new PromisePolyfill(_.bind(function(resolve) {\n        this.sendRequest(data, options, resolve);\n    }, this));\n};\n\n\n/**\n * Flush one batch to network. Depending on success/failure modes, it will either\n * remove the batch from the queue or leave it in for retry, and schedule the next\n * flush. In cases of most network or API failures, it will back off exponentially\n * when retrying.\n * @param {Object} [options]\n * @param {boolean} [options.sendBeacon] - whether to send batch with\n * navigator.sendBeacon (only useful for sending batches before page unloads, as\n * sendBeacon offers no callbacks or status indications)\n */\nRequestBatcher.prototype.flush = function(options) {\n    if (this.requestInProgress) {\n        logger$2.log('Flush: Request already in progress');\n        return PromisePolyfill.resolve();\n    }\n\n    this.requestInProgress = true;\n\n    options = options || {};\n    var timeoutMS = this.libConfig['batch_request_timeout_ms'];\n    var startTime = new Date().getTime();\n    var currentBatchSize = this.batchSize;\n\n    return this.queue.fillBatch(currentBatchSize)\n        .then(_.bind(function(batch) {\n\n            // if there's more items in the queue than the batch size, attempt\n            // to flush again after the current batch is done.\n            var attemptSecondaryFlush = batch.length === currentBatchSize;\n            var dataForRequest = [];\n            var transformedItems = {};\n            _.each(batch, function(item) {\n                var payload = item['payload'];\n                if (this.beforeSendHook && !item.orphaned) {\n                    payload = this.beforeSendHook(payload);\n                }\n                if (payload) {\n                    // mp_sent_by_lib_version prop captures which lib version actually\n                    // sends each event (regardless of which version originally queued\n                    // it for sending)\n                    if (payload['event'] && payload['properties']) {\n                        payload['properties'] = _.extend(\n                            {},\n                            payload['properties'],\n                            {'mp_sent_by_lib_version': Config.LIB_VERSION}\n                        );\n                    }\n                    var addPayload = true;\n                    var itemId = item['id'];\n                    if (itemId) {\n                        if ((this.itemIdsSentSuccessfully[itemId] || 0) > 5) {\n                            this.reportError('[dupe] item ID sent too many times, not sending', {\n                                item: item,\n                                batchSize: batch.length,\n                                timesSent: this.itemIdsSentSuccessfully[itemId]\n                            });\n                            addPayload = false;\n                        }\n                    } else {\n                        this.reportError('[dupe] found item with no ID', {item: item});\n                    }\n\n                    if (addPayload) {\n                        dataForRequest.push(payload);\n                    }\n                }\n                transformedItems[item['id']] = payload;\n            }, this);\n\n            if (dataForRequest.length < 1) {\n                this.requestInProgress = false;\n                this.resetFlush();\n                return PromisePolyfill.resolve(); // nothing to do\n            }\n\n            var removeItemsFromQueue = _.bind(function () {\n                return this.queue\n                    .removeItemsByID(\n                        _.map(batch, function (item) {\n                            return item['id'];\n                        })\n                    )\n                    .then(_.bind(function (succeeded) {\n                        // client-side dedupe\n                        _.each(batch, _.bind(function(item) {\n                            var itemId = item['id'];\n                            if (itemId) {\n                                this.itemIdsSentSuccessfully[itemId] = this.itemIdsSentSuccessfully[itemId] || 0;\n                                this.itemIdsSentSuccessfully[itemId]++;\n                                if (this.itemIdsSentSuccessfully[itemId] > 5) {\n                                    this.reportError('[dupe] item ID sent too many times', {\n                                        item: item,\n                                        batchSize: batch.length,\n                                        timesSent: this.itemIdsSentSuccessfully[itemId]\n                                    });\n                                }\n                            } else {\n                                this.reportError('[dupe] found item with no ID while removing', {item: item});\n                            }\n                        }, this));\n\n                        if (succeeded) {\n                            this.consecutiveRemovalFailures = 0;\n                            if (this.flushOnlyOnInterval && !attemptSecondaryFlush) {\n                                this.resetFlush(); // schedule next batch with a delay\n                                return PromisePolyfill.resolve();\n                            } else {\n                                return this.flush(); // handle next batch if the queue isn't empty\n                            }\n                        } else {\n                            if (++this.consecutiveRemovalFailures > 5) {\n                                this.reportError('Too many queue failures; disabling batching system.');\n                                this.stopAllBatching();\n                            } else {\n                                this.resetFlush();\n                            }\n                            return PromisePolyfill.resolve();\n                        }\n                    }, this));\n            }, this);\n\n            var batchSendCallback = _.bind(function(res) {\n                this.requestInProgress = false;\n\n                try {\n\n                    // handle API response in a try-catch to make sure we can reset the\n                    // flush operation if something goes wrong\n\n                    if (options.unloading) {\n                        // update persisted data to include hook transformations\n                        return this.queue.updatePayloads(transformedItems);\n                    } else if (\n                        _.isObject(res) &&\n                            res.error === 'timeout' &&\n                            new Date().getTime() - startTime >= timeoutMS\n                    ) {\n                        this.reportError('Network timeout; retrying');\n                        return this.flush();\n                    } else if (\n                        _.isObject(res) &&\n                            (\n                                res.httpStatusCode >= 500\n                                || res.httpStatusCode === 429\n                                || (res.httpStatusCode <= 0 && !isOnline())\n                                || res.error === 'timeout'\n                            )\n                    ) {\n                        // network or API error, or 429 Too Many Requests, retry\n                        var retryMS = this.flushInterval * 2;\n                        if (res.retryAfter) {\n                            retryMS = (parseInt(res.retryAfter, 10) * 1000) || retryMS;\n                        }\n                        retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);\n                        this.reportError('Error; retry in ' + retryMS + ' ms');\n                        this.scheduleFlush(retryMS);\n                        return PromisePolyfill.resolve();\n                    } else if (_.isObject(res) && res.httpStatusCode === 413) {\n                        // 413 Payload Too Large\n                        if (batch.length > 1) {\n                            var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));\n                            this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);\n                            this.reportError('413 response; reducing batch size to ' + this.batchSize);\n                            this.resetFlush();\n                            return PromisePolyfill.resolve();\n                        } else {\n                            this.reportError('Single-event request too large; dropping', batch);\n                            this.resetBatchSize();\n                            return removeItemsFromQueue();\n                        }\n                    } else {\n                        // successful network request+response; remove each item in batch from queue\n                        // (even if it was e.g. a 400, in which case retrying won't help)\n                        return removeItemsFromQueue();\n                    }\n                } catch(err) {\n                    this.reportError('Error handling API response', err);\n                    this.resetFlush();\n                }\n            }, this);\n            var requestOptions = {\n                method: 'POST',\n                verbose: true,\n                ignore_json_errors: true, // eslint-disable-line camelcase\n                timeout_ms: timeoutMS // eslint-disable-line camelcase\n            };\n            if (options.unloading) {\n                requestOptions.transport = 'sendBeacon';\n            }\n            logger$2.log('MIXPANEL REQUEST:', dataForRequest);\n            return this.sendRequestPromise(dataForRequest, requestOptions).then(batchSendCallback);\n        }, this))\n        .catch(_.bind(function(err) {\n            this.reportError('Error flushing request queue', err);\n            this.resetFlush();\n        }, this));\n};\n\n/**\n * Log error to global logger and optional user-defined logger.\n */\nRequestBatcher.prototype.reportError = function(msg, err) {\n    logger$2.error.apply(logger$2.error, arguments);\n    if (this.errorReporter) {\n        try {\n            if (!(err instanceof Error)) {\n                err = new Error(msg);\n            }\n            this.errorReporter(msg, err);\n        } catch(err) {\n            logger$2.error(err);\n        }\n    }\n};\n\nvar logger$1 = console_with_prefix('recorder');\nvar CompressionStream = win['CompressionStream'];\n\nvar RECORDER_BATCHER_LIB_CONFIG = {\n    'batch_size': 1000,\n    'batch_flush_interval_ms': 10 * 1000,\n    'batch_request_timeout_ms': 90 * 1000,\n    'batch_autostart': true\n};\n\nvar ACTIVE_SOURCES = new Set([\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n    IncrementalSource.Selection,\n]);\n\nfunction isUserEvent(ev) {\n    return ev.type === EventType.IncrementalSnapshot && ACTIVE_SOURCES.has(ev.data.source);\n}\n\n/**\n * This class encapsulates a single session recording and its lifecycle.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n * @param {String} [options.replayId] - unique uuid for a single replay\n * @param {Function} [options.onIdleTimeout] - callback when a recording reaches idle timeout\n * @param {Function} [options.onMaxLengthReached] - callback when a recording reaches its maximum length\n * @param {Function} [options.rrwebRecord] - rrweb's `record` function\n */\nvar SessionRecording = function(options) {\n    this._mixpanel = options.mixpanelInstance;\n    this._onIdleTimeout = options.onIdleTimeout;\n    this._onMaxLengthReached = options.onMaxLengthReached;\n    this._rrwebRecord = options.rrwebRecord;\n\n    this.replayId = options.replayId;\n\n    // internal rrweb stopRecording function\n    this._stopRecording = null;\n\n    this.seqNo = 0;\n    this.replayStartTime = null;\n    this.replayStartUrl = null;\n    this.batchStartUrl = null;\n\n    this.idleTimeoutId = null;\n    this.maxTimeoutId = null;\n\n    this.recordMaxMs = MAX_RECORDING_MS;\n    this.recordMinMs = 0;\n\n    // each replay has its own batcher key to avoid conflicts between rrweb events of different recordings\n    // this will be important when persistence is introduced\n    var batcherKey = '__mprec_' + this.getConfig('token') + '_' + this.replayId;\n    this.batcher = new RequestBatcher(batcherKey, {\n        errorReporter: _.bind(this.reportError, this),\n        flushOnlyOnInterval: true,\n        libConfig: RECORDER_BATCHER_LIB_CONFIG,\n        sendRequestFunc: _.bind(this.flushEventsWithOptOut, this),\n        usePersistence: false\n    });\n};\n\nSessionRecording.prototype.getConfig = function(configVar) {\n    return this._mixpanel.get_config(configVar);\n};\n\n// Alias for getConfig, used by the common addOptOutCheckMixpanelLib function which\n// reaches into this class instance and expects the snake case version of the function.\n// eslint-disable-next-line camelcase\nSessionRecording.prototype.get_config = function(configVar) {\n    return this.getConfig(configVar);\n};\n\nSessionRecording.prototype.startRecording = function (shouldStopBatcher) {\n    if (this._stopRecording !== null) {\n        logger$1.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    this.recordMaxMs = this.getConfig('record_max_ms');\n    if (this.recordMaxMs > MAX_RECORDING_MS) {\n        this.recordMaxMs = MAX_RECORDING_MS;\n        logger$1.critical('record_max_ms cannot be greater than ' + MAX_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    this.recordMinMs = this.getConfig('record_min_ms');\n    if (this.recordMinMs > MAX_VALUE_FOR_MIN_RECORDING_MS) {\n        this.recordMinMs = MAX_VALUE_FOR_MIN_RECORDING_MS;\n        logger$1.critical('record_min_ms cannot be greater than ' + MAX_VALUE_FOR_MIN_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    this.replayStartTime = new Date().getTime();\n    this.batchStartUrl = _.info.currentUrl();\n    this.replayStartUrl = _.info.currentUrl();\n\n    if (shouldStopBatcher || this.recordMinMs > 0) {\n        // the primary case for shouldStopBatcher is when we're starting recording after a reset\n        // and don't want to send anything over the network until there's\n        // actual user activity\n        // this also applies if the minimum recording length has not been hit yet\n        // so that we don't send data until we know the recording will be long enough\n        this.batcher.stop();\n    } else {\n        this.batcher.start();\n    }\n\n    var resetIdleTimeout = _.bind(function () {\n        clearTimeout(this.idleTimeoutId);\n        this.idleTimeoutId = setTimeout(this._onIdleTimeout, this.getConfig('record_idle_timeout_ms'));\n    }, this);\n\n    var blockSelector = this.getConfig('record_block_selector');\n    if (blockSelector === '' || blockSelector === null) {\n        blockSelector = undefined;\n    }\n\n    this._stopRecording = this._rrwebRecord({\n        'emit': _.bind(function (ev) {\n            this.batcher.enqueue(ev);\n            if (isUserEvent(ev)) {\n                if (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs) {\n                    // start flushing again after user activity\n                    this.batcher.start();\n                }\n                resetIdleTimeout();\n            }\n        }, this),\n        'blockClass': this.getConfig('record_block_class'),\n        'blockSelector': blockSelector,\n        'collectFonts': this.getConfig('record_collect_fonts'),\n        'dataURLOptions': { // canvas image options (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL)\n            'type': 'image/webp',\n            'quality': 0.6\n        },\n        'maskAllInputs': true,\n        'maskTextClass': this.getConfig('record_mask_text_class'),\n        'maskTextSelector': this.getConfig('record_mask_text_selector'),\n        'recordCanvas': this.getConfig('record_canvas'),\n        'sampling': {\n            'canvas': 15\n        }\n    });\n\n    if (typeof this._stopRecording !== 'function') {\n        this.reportError('rrweb failed to start, skipping this recording.');\n        this._stopRecording = null;\n        this.stopRecording(); // stop batcher looping and any timeouts\n        return;\n    }\n\n    resetIdleTimeout();\n\n    this.maxTimeoutId = setTimeout(_.bind(this._onMaxLengthReached, this), this.recordMaxMs);\n};\n\nSessionRecording.prototype.stopRecording = function () {\n    if (!this.isRrwebStopped()) {\n        try {\n            this._stopRecording();\n        } catch (err) {\n            this.reportError('Error with rrweb stopRecording', err);\n        }\n        this._stopRecording = null;\n    }\n\n    if (this.batcher.stopped) {\n        // never got user activity to flush after reset, so just clear the batcher\n        this.batcher.clear();\n    } else {\n        // flush any remaining events from running batcher\n        this.batcher.flush();\n        this.batcher.stop();\n    }\n\n    clearTimeout(this.idleTimeoutId);\n    clearTimeout(this.maxTimeoutId);\n};\n\nSessionRecording.prototype.isRrwebStopped = function () {\n    return this._stopRecording === null;\n};\n\n/**\n * Flushes the current batch of events to the server, but passes an opt-out callback to make sure\n * we stop recording and dump any queued events if the user has opted out.\n */\nSessionRecording.prototype.flushEventsWithOptOut = function (data, options, cb) {\n    this._flushEvents(data, options, cb, _.bind(this._onOptOut, this));\n};\n\nSessionRecording.prototype._onOptOut = function (code) {\n    // addOptOutCheckMixpanelLib invokes this function with code=0 when the user has opted out\n    if (code === 0) {\n        this.stopRecording();\n    }\n};\n\nSessionRecording.prototype._sendRequest = function(currentReplayId, reqParams, reqBody, callback) {\n    var onSuccess = _.bind(function (response, responseBody) {\n        // Update batch specific props only if the request was successful to guarantee ordering.\n        // RequestBatcher will always flush the next batch after the previous one succeeds.\n        // extra check to see if the replay ID has changed so that we don't increment the seqNo on the wrong replay\n        if (response.status === 200 && this.replayId === currentReplayId) {\n            this.seqNo++;\n            this.batchStartUrl = _.info.currentUrl();\n        }\n        callback({\n            status: 0,\n            httpStatusCode: response.status,\n            responseBody: responseBody,\n            retryAfter: response.headers.get('Retry-After')\n        });\n    }, this);\n\n    win['fetch'](this.getConfig('api_host') + '/' + this.getConfig('api_routes')['record'] + '?' + new URLSearchParams(reqParams), {\n        'method': 'POST',\n        'headers': {\n            'Authorization': 'Basic ' + btoa(this.getConfig('token') + ':'),\n            'Content-Type': 'application/octet-stream'\n        },\n        'body': reqBody,\n    }).then(function (response) {\n        response.json().then(function (responseBody) {\n            onSuccess(response, responseBody);\n        }).catch(function (error) {\n            callback({error: error});\n        });\n    }).catch(function (error) {\n        callback({error: error, httpStatusCode: 0});\n    });\n};\n\nSessionRecording.prototype._flushEvents = addOptOutCheckMixpanelLib(function (data, options, callback) {\n    const numEvents = data.length;\n\n    if (numEvents > 0) {\n        var replayId = this.replayId;\n        // each rrweb event has a timestamp - leverage those to get time properties\n        var batchStartTime = data[0].timestamp;\n        if (this.seqNo === 0 || !this.replayStartTime) {\n            // extra safety net so that we don't send a null replay start time\n            if (this.seqNo !== 0) {\n                this.reportError('Replay start time not set but seqNo is not 0. Using current batch start time as a fallback.');\n            }\n\n            this.replayStartTime = batchStartTime;\n        }\n        var replayLengthMs = data[numEvents - 1].timestamp - this.replayStartTime;\n\n        var reqParams = {\n            '$current_url': this.batchStartUrl,\n            '$lib_version': Config.LIB_VERSION,\n            'batch_start_time': batchStartTime / 1000,\n            'distinct_id': String(this._mixpanel.get_distinct_id()),\n            'mp_lib': 'web',\n            'replay_id': replayId,\n            'replay_length_ms': replayLengthMs,\n            'replay_start_time': this.replayStartTime / 1000,\n            'replay_start_url': this.replayStartUrl,\n            'seq': this.seqNo\n        };\n        var eventsJson = _.JSONEncode(data);\n\n        // send ID management props if they exist\n        var deviceId = this._mixpanel.get_property('$device_id');\n        if (deviceId) {\n            reqParams['$device_id'] = deviceId;\n        }\n        var userId = this._mixpanel.get_property('$user_id');\n        if (userId) {\n            reqParams['$user_id'] = userId;\n        }\n\n        if (CompressionStream) {\n            var jsonStream = new Blob([eventsJson], {type: 'application/json'}).stream();\n            var gzipStream = jsonStream.pipeThrough(new CompressionStream('gzip'));\n            new Response(gzipStream)\n                .blob()\n                .then(_.bind(function(compressedBlob) {\n                    reqParams['format'] = 'gzip';\n                    this._sendRequest(replayId, reqParams, compressedBlob, callback);\n                }, this));\n        } else {\n            reqParams['format'] = 'body';\n            this._sendRequest(replayId, reqParams, eventsJson, callback);\n        }\n    }\n});\n\n\nSessionRecording.prototype.reportError = function(msg, err) {\n    logger$1.error.apply(logger$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.getConfig('error_reporter')(msg, err);\n    } catch(err) {\n        logger$1.error(err);\n    }\n};\n\nvar logger = console_with_prefix('recorder');\n\n/**\n * Recorder API: manages recordings and exposes methods public to the core Mixpanel library.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n */\nvar MixpanelRecorder = function(mixpanelInstance) {\n    this._mixpanel = mixpanelInstance;\n    this.activeRecording = null;\n};\n\nMixpanelRecorder.prototype.startRecording = function(shouldStopBatcher) {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        logger.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    var onIdleTimeout = _.bind(function () {\n        logger.log('Idle timeout reached, restarting recording.');\n        this.resetRecording();\n    }, this);\n\n    var onMaxLengthReached = _.bind(function () {\n        logger.log('Max recording length reached, stopping recording.');\n        this.resetRecording();\n    }, this);\n\n    this.activeRecording = new SessionRecording({\n        mixpanelInstance: this._mixpanel,\n        onIdleTimeout: onIdleTimeout,\n        onMaxLengthReached: onMaxLengthReached,\n        replayId: _.UUID(),\n        rrwebRecord: record\n    });\n\n    this.activeRecording.startRecording(shouldStopBatcher);\n};\n\nMixpanelRecorder.prototype.stopRecording = function() {\n    if (this.activeRecording) {\n        this.activeRecording.stopRecording();\n        this.activeRecording = null;\n    }\n};\n\nMixpanelRecorder.prototype.resetRecording = function () {\n    this.stopRecording();\n    this.startRecording(true);\n};\n\nMixpanelRecorder.prototype.getActiveReplayId = function () {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        return this.activeRecording.replayId;\n    } else {\n        return null;\n    }\n};\n\n// getter so that older mixpanel-core versions can still retrieve the replay ID\n// when pulling the latest recorder bundle from the CDN\nObject.defineProperty(MixpanelRecorder.prototype, 'replayId', {\n    get: function () {\n        return this.getActiveReplayId();\n    }\n});\n\nwin['__mp_recorder'] = MixpanelRecorder;\n\n/* eslint camelcase: \"off\" */\n\n/**\n * DomTracker Object\n * @constructor\n */\nvar DomTracker = function() {};\n\n\n// interface\nDomTracker.prototype.create_properties = function() {};\nDomTracker.prototype.event_handler = function() {};\nDomTracker.prototype.after_track_handler = function() {};\n\nDomTracker.prototype.init = function(mixpanel_instance) {\n    this.mp = mixpanel_instance;\n    return this;\n};\n\n/**\n * @param {Object|string} query\n * @param {string} event_name\n * @param {Object=} properties\n * @param {function=} user_callback\n */\nDomTracker.prototype.track = function(query, event_name, properties, user_callback) {\n    var that = this;\n    var elements = _.dom_query(query);\n\n    if (elements.length === 0) {\n        console$1.error('The DOM query (' + query + ') returned 0 elements');\n        return;\n    }\n\n    _.each(elements, function(element) {\n        _.register_event(element, this.override_event, function(e) {\n            var options = {};\n            var props = that.create_properties(properties, this);\n            var timeout = that.mp.get_config('track_links_timeout');\n\n            that.event_handler(e, this, options);\n\n            // in case the mixpanel servers don't get back to us in time\n            window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);\n\n            // fire the tracking event\n            that.mp.track(event_name, props, that.track_callback(user_callback, props, options));\n        });\n    }, this);\n\n    return true;\n};\n\n/**\n * @param {function} user_callback\n * @param {Object} props\n * @param {boolean=} timeout_occured\n */\nDomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {\n    timeout_occured = timeout_occured || false;\n    var that = this;\n\n    return function() {\n        // options is referenced from both callbacks, so we can have\n        // a 'lock' of sorts to ensure only one fires\n        if (options.callback_fired) { return; }\n        options.callback_fired = true;\n\n        if (user_callback && user_callback(timeout_occured, props) === false) {\n            // user can prevent the default functionality by\n            // returning false from their callback\n            return;\n        }\n\n        that.after_track_handler(props, options, timeout_occured);\n    };\n};\n\nDomTracker.prototype.create_properties = function(properties, element) {\n    var props;\n\n    if (typeof(properties) === 'function') {\n        props = properties(element);\n    } else {\n        props = _.extend({}, properties);\n    }\n\n    return props;\n};\n\n/**\n * LinkTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar LinkTracker = function() {\n    this.override_event = 'click';\n};\n_.inherit(LinkTracker, DomTracker);\n\nLinkTracker.prototype.create_properties = function(properties, element) {\n    var props = LinkTracker.superclass.create_properties.apply(this, arguments);\n\n    if (element.href) { props['url'] = element.href; }\n\n    return props;\n};\n\nLinkTracker.prototype.event_handler = function(evt, element, options) {\n    options.new_tab = (\n        evt.which === 2 ||\n        evt.metaKey ||\n        evt.ctrlKey ||\n        element.target === '_blank'\n    );\n    options.href = element.href;\n\n    if (!options.new_tab) {\n        evt.preventDefault();\n    }\n};\n\nLinkTracker.prototype.after_track_handler = function(props, options) {\n    if (options.new_tab) { return; }\n\n    setTimeout(function() {\n        window.location = options.href;\n    }, 0);\n};\n\n/**\n * FormTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar FormTracker = function() {\n    this.override_event = 'submit';\n};\n_.inherit(FormTracker, DomTracker);\n\nFormTracker.prototype.event_handler = function(evt, element, options) {\n    options.element = element;\n    evt.preventDefault();\n};\n\nFormTracker.prototype.after_track_handler = function(props, options) {\n    setTimeout(function() {\n        options.element.submit();\n    }, 0);\n};\n\n/* eslint camelcase: \"off\" */\n\n/** @const */ var SET_ACTION      = '$set';\n/** @const */ var SET_ONCE_ACTION = '$set_once';\n/** @const */ var UNSET_ACTION    = '$unset';\n/** @const */ var ADD_ACTION      = '$add';\n/** @const */ var APPEND_ACTION   = '$append';\n/** @const */ var UNION_ACTION    = '$union';\n/** @const */ var REMOVE_ACTION   = '$remove';\n/** @const */ var DELETE_ACTION   = '$delete';\n\n// Common internal methods for mixpanel.people and mixpanel.group APIs.\n// These methods shouldn't involve network I/O.\nvar apiActions = {\n    set_action: function(prop, to) {\n        var data = {};\n        var $set = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set[k] = v;\n                }\n            }, this);\n        } else {\n            $set[prop] = to;\n        }\n\n        data[SET_ACTION] = $set;\n        return data;\n    },\n\n    unset_action: function(prop) {\n        var data = {};\n        var $unset = [];\n        if (!_.isArray(prop)) {\n            prop = [prop];\n        }\n\n        _.each(prop, function(k) {\n            if (!this._is_reserved_property(k)) {\n                $unset.push(k);\n            }\n        }, this);\n\n        data[UNSET_ACTION] = $unset;\n        return data;\n    },\n\n    set_once_action: function(prop, to) {\n        var data = {};\n        var $set_once = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set_once[k] = v;\n                }\n            }, this);\n        } else {\n            $set_once[prop] = to;\n        }\n        data[SET_ONCE_ACTION] = $set_once;\n        return data;\n    },\n\n    union_action: function(list_name, values) {\n        var data = {};\n        var $union = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $union[k] = _.isArray(v) ? v : [v];\n                }\n            }, this);\n        } else {\n            $union[list_name] = _.isArray(values) ? values : [values];\n        }\n        data[UNION_ACTION] = $union;\n        return data;\n    },\n\n    append_action: function(list_name, value) {\n        var data = {};\n        var $append = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $append[k] = v;\n                }\n            }, this);\n        } else {\n            $append[list_name] = value;\n        }\n        data[APPEND_ACTION] = $append;\n        return data;\n    },\n\n    remove_action: function(list_name, value) {\n        var data = {};\n        var $remove = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $remove[k] = v;\n                }\n            }, this);\n        } else {\n            $remove[list_name] = value;\n        }\n        data[REMOVE_ACTION] = $remove;\n        return data;\n    },\n\n    delete_action: function() {\n        var data = {};\n        data[DELETE_ACTION] = '';\n        return data;\n    }\n};\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel Group Object\n * @constructor\n */\nvar MixpanelGroup = function() {};\n\n_.extend(MixpanelGroup.prototype, apiActions);\n\nMixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {\n    this._mixpanel = mixpanel_instance;\n    this._group_key = group_key;\n    this._group_id = group_id;\n};\n\n/**\n * Set properties on a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, dates, or lists\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Set properties on a group, only if they do not yet exist.\n * This will not overwrite previous group property values, unlike\n * group.set().\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set_once('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set_once({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, lists or dates\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Unset properties on a group permanently.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').unset('Founded');\n *\n * @param {String} prop The name of the property.\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/**\n * Merge a given list with a list-valued group property, excluding duplicate values.\n *\n * ### Usage:\n *\n *     // merge a value to a list, creating it if needed\n *     mixpanel.get_group('company', 'mixpanel').union('Location', ['San Francisco', 'London']);\n *\n * @param {String} list_name Name of the property.\n * @param {Array} values Values to merge with the given property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/**\n * Permanently delete a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').delete();\n *\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype['delete'] = addOptOutCheckMixpanelGroup(function(callback) {\n    // bracket notation above prevents a minification error related to reserved words\n    var data = this.delete_action();\n    return this._send_request(data, callback);\n});\n\n/**\n * Remove a property from a group. The value will be ignored if doesn't exist.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').remove('Location', 'London');\n *\n * @param {String} list_name Name of the property.\n * @param {Object} value Value to remove from the given group property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\nMixpanelGroup.prototype._send_request = function(data, callback) {\n    data['$group_key'] = this._group_key;\n    data['$group_id'] = this._group_id;\n    data['$token'] = this._get_config('token');\n\n    var date_encoded_data = _.encodeDates(data);\n    return this._mixpanel._track_or_batch({\n        type: 'groups',\n        data: date_encoded_data,\n        endpoint: this._get_config('api_host') + '/' +  this._get_config('api_routes')['groups'],\n        batcher: this._mixpanel.request_batchers.groups\n    }, callback);\n};\n\nMixpanelGroup.prototype._is_reserved_property = function(prop) {\n    return prop === '$group_key' || prop === '$group_id';\n};\n\nMixpanelGroup.prototype._get_config = function(conf) {\n    return this._mixpanel.get_config(conf);\n};\n\nMixpanelGroup.prototype.toString = function() {\n    return this._mixpanel.toString() + '.group.' + this._group_key + '.' + this._group_id;\n};\n\n// MixpanelGroup Exports\nMixpanelGroup.prototype['remove']   = MixpanelGroup.prototype.remove;\nMixpanelGroup.prototype['set']      = MixpanelGroup.prototype.set;\nMixpanelGroup.prototype['set_once'] = MixpanelGroup.prototype.set_once;\nMixpanelGroup.prototype['union']    = MixpanelGroup.prototype.union;\nMixpanelGroup.prototype['unset']    = MixpanelGroup.prototype.unset;\nMixpanelGroup.prototype['toString'] = MixpanelGroup.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel People Object\n * @constructor\n */\nvar MixpanelPeople = function() {};\n\n_.extend(MixpanelPeople.prototype, apiActions);\n\nMixpanelPeople.prototype._init = function(mixpanel_instance) {\n    this._mixpanel = mixpanel_instance;\n};\n\n/*\n* Set properties on a user record.\n*\n* ### Usage:\n*\n*     mixpanel.people.set('gender', 'm');\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set({\n*         'Company': 'Acme',\n*         'Plan': 'Premium',\n*         'Upgrade date': new Date()\n*     });\n*     // properties can be strings, integers, dates, or lists\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    // make sure that the referrer info has been updated and saved\n    if (this._get_config('save_referrer')) {\n        this._mixpanel['persistence'].update_referrer_info(document.referrer);\n    }\n\n    // update $set object with default people properties\n    data[SET_ACTION] = _.extend(\n        {},\n        _.info.people_properties(),\n        data[SET_ACTION]\n    );\n    return this._send_request(data, callback);\n});\n\n/*\n* Set properties on a user record, only if they do not yet exist.\n* This will not overwrite previous people property values, unlike\n* people.set().\n*\n* ### Usage:\n*\n*     mixpanel.people.set_once('First Login Date', new Date());\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set_once({\n*         'First Login Date': new Date(),\n*         'Starting Plan': 'Premium'\n*     });\n*\n*     // properties can be strings, integers or dates\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/*\n* Unset properties on a user record (permanently removes the properties and their values from a profile).\n*\n* ### Usage:\n*\n*     mixpanel.people.unset('gender');\n*\n*     // or unset multiple properties at once\n*     mixpanel.people.unset(['gender', 'Company']);\n*\n* @param {Array|String} prop If a string, this is the name of the property. If an array, this is a list of property names.\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/*\n* Increment/decrement numeric people analytics properties.\n*\n* ### Usage:\n*\n*     mixpanel.people.increment('page_views', 1);\n*\n*     // or, for convenience, if you're just incrementing a counter by\n*     // 1, you can simply do\n*     mixpanel.people.increment('page_views');\n*\n*     // to decrement a counter, pass a negative number\n*     mixpanel.people.increment('credits_left', -1);\n*\n*     // like mixpanel.people.set(), you can increment multiple\n*     // properties at once:\n*     mixpanel.people.increment({\n*         counter1: 1,\n*         counter2: 6\n*     });\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.\n* @param {Number} [by] An amount to increment the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {\n    var data = {};\n    var $add = {};\n    if (_.isObject(prop)) {\n        _.each(prop, function(v, k) {\n            if (!this._is_reserved_property(k)) {\n                if (isNaN(parseFloat(v))) {\n                    console$1.error('Invalid increment value passed to mixpanel.people.increment - must be a number');\n                    return;\n                } else {\n                    $add[k] = v;\n                }\n            }\n        }, this);\n        callback = by;\n    } else {\n        // convenience: mixpanel.people.increment('property'); will\n        // increment 'property' by 1\n        if (_.isUndefined(by)) {\n            by = 1;\n        }\n        $add[prop] = by;\n    }\n    data[ADD_ACTION] = $add;\n\n    return this._send_request(data, callback);\n});\n\n/*\n* Append a value to a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     // append a value to a list, creating it if needed\n*     mixpanel.people.append('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.append({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value An item to append to the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.append_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Remove a value from a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     mixpanel.people.remove('School', 'UCB');\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value Item to remove from the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Merge a given list with a list-valued people analytics property,\n* excluding duplicate values.\n*\n* ### Usage:\n*\n*     // merge a value to a list, creating it if needed\n*     mixpanel.people.union('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.union({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n*     // like mixpanel.people.append(), you can append multiple\n*     // values to the same list:\n*     mixpanel.people.union({\n*         list1: ['bob', 'billy']\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] Value / values to merge with the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/*\n * Record that you have charged the current user a certain amount\n * of money. Charges recorded with track_charge() will appear in the\n * Mixpanel revenue report.\n *\n * ### Usage:\n *\n *     // charge a user $50\n *     mixpanel.people.track_charge(50);\n *\n *     // charge a user $30.50 on the 2nd of january\n *     mixpanel.people.track_charge(30.50, {\n *         '$time': new Date('jan 1 2012')\n *     });\n *\n * @param {Number} amount The amount of money charged to the current user\n * @param {Object} [properties] An associative array of properties associated with the charge\n * @param {Function} [callback] If provided, the callback will be called when the server responds\n * @deprecated\n */\nMixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function(amount, properties, callback) {\n    if (!_.isNumber(amount)) {\n        amount = parseFloat(amount);\n        if (isNaN(amount)) {\n            console$1.error('Invalid value passed to mixpanel.people.track_charge - must be a number');\n            return;\n        }\n    }\n\n    return this.append('$transactions', _.extend({\n        '$amount': amount\n    }, properties), callback);\n});\n\n/*\n * Permanently clear all revenue report transactions from the\n * current user's people analytics profile.\n *\n * ### Usage:\n *\n *     mixpanel.people.clear_charges();\n *\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n * @deprecated\n */\nMixpanelPeople.prototype.clear_charges = function(callback) {\n    return this.set('$transactions', [], callback);\n};\n\n/*\n* Permanently deletes the current people analytics profile from\n* Mixpanel (using the current distinct_id).\n*\n* ### Usage:\n*\n*     // remove the all data you have stored about the current user\n*     mixpanel.people.delete_user();\n*\n*/\nMixpanelPeople.prototype.delete_user = function() {\n    if (!this._identify_called()) {\n        console$1.error('mixpanel.people.delete_user() requires you to call identify() first');\n        return;\n    }\n    var data = {'$delete': this._mixpanel.get_distinct_id()};\n    return this._send_request(data);\n};\n\nMixpanelPeople.prototype.toString = function() {\n    return this._mixpanel.toString() + '.people';\n};\n\nMixpanelPeople.prototype._send_request = function(data, callback) {\n    data['$token'] = this._get_config('token');\n    data['$distinct_id'] = this._mixpanel.get_distinct_id();\n    var device_id = this._mixpanel.get_property('$device_id');\n    var user_id = this._mixpanel.get_property('$user_id');\n    var had_persisted_distinct_id = this._mixpanel.get_property('$had_persisted_distinct_id');\n    if (device_id) {\n        data['$device_id'] = device_id;\n    }\n    if (user_id) {\n        data['$user_id'] = user_id;\n    }\n    if (had_persisted_distinct_id) {\n        data['$had_persisted_distinct_id'] = had_persisted_distinct_id;\n    }\n\n    var date_encoded_data = _.encodeDates(data);\n\n    if (!this._identify_called()) {\n        this._enqueue(data);\n        if (!_.isUndefined(callback)) {\n            if (this._get_config('verbose')) {\n                callback({status: -1, error: null});\n            } else {\n                callback(-1);\n            }\n        }\n        return _.truncate(date_encoded_data, 255);\n    }\n\n    return this._mixpanel._track_or_batch({\n        type: 'people',\n        data: date_encoded_data,\n        endpoint: this._get_config('api_host') + '/' +  this._get_config('api_routes')['engage'],\n        batcher: this._mixpanel.request_batchers.people\n    }, callback);\n};\n\nMixpanelPeople.prototype._get_config = function(conf_var) {\n    return this._mixpanel.get_config(conf_var);\n};\n\nMixpanelPeople.prototype._identify_called = function() {\n    return this._mixpanel._flags.identify_called === true;\n};\n\n// Queue up engage operations if identify hasn't been called yet.\nMixpanelPeople.prototype._enqueue = function(data) {\n    if (SET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ACTION, data);\n    } else if (SET_ONCE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ONCE_ACTION, data);\n    } else if (UNSET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNSET_ACTION, data);\n    } else if (ADD_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(ADD_ACTION, data);\n    } else if (APPEND_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, data);\n    } else if (REMOVE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, data);\n    } else if (UNION_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNION_ACTION, data);\n    } else {\n        console$1.error('Invalid call to _enqueue():', data);\n    }\n};\n\nMixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {\n    var _this = this;\n    var queued_data = _.extend({}, this._mixpanel['persistence'].load_queue(action));\n    var action_params = queued_data;\n\n    if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {\n        _this._mixpanel['persistence']._pop_from_people_queue(action, queued_data);\n        _this._mixpanel['persistence'].save();\n        if (queue_to_params_fn) {\n            action_params = queue_to_params_fn(queued_data);\n        }\n        action_method.call(_this, action_params, function(response, data) {\n            // on bad response, we want to add it back to the queue\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(action, queued_data);\n            }\n            if (!_.isUndefined(callback)) {\n                callback(response, data);\n            }\n        });\n    }\n};\n\n// Flush queued engage operations - order does not matter,\n// and there are network level race conditions anyway\nMixpanelPeople.prototype._flush = function(\n    _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    var _this = this;\n\n    this._flush_one_queue(SET_ACTION, this.set, _set_callback);\n    this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);\n    this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) { return _.keys(queue); });\n    this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);\n    this._flush_one_queue(UNION_ACTION, this.union, _union_callback);\n\n    // we have to fire off each $append individually since there is\n    // no concat method server side\n    var $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n    if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {\n        var $append_item;\n        var append_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, $append_item);\n            }\n            if (!_.isUndefined(_append_callback)) {\n                _append_callback(response, data);\n            }\n        };\n        for (var i = $append_queue.length - 1; i >= 0; i--) {\n            $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n            $append_item = $append_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($append_item)) {\n                _this.append($append_item, append_callback);\n            }\n        }\n    }\n\n    // same for $remove\n    var $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n    if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {\n        var $remove_item;\n        var remove_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, $remove_item);\n            }\n            if (!_.isUndefined(_remove_callback)) {\n                _remove_callback(response, data);\n            }\n        };\n        for (var j = $remove_queue.length - 1; j >= 0; j--) {\n            $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n            $remove_item = $remove_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($remove_item)) {\n                _this.remove($remove_item, remove_callback);\n            }\n        }\n    }\n};\n\nMixpanelPeople.prototype._is_reserved_property = function(prop) {\n    return prop === '$distinct_id' || prop === '$token' || prop === '$device_id' || prop === '$user_id' || prop === '$had_persisted_distinct_id';\n};\n\n// MixpanelPeople Exports\nMixpanelPeople.prototype['set']           = MixpanelPeople.prototype.set;\nMixpanelPeople.prototype['set_once']      = MixpanelPeople.prototype.set_once;\nMixpanelPeople.prototype['unset']         = MixpanelPeople.prototype.unset;\nMixpanelPeople.prototype['increment']     = MixpanelPeople.prototype.increment;\nMixpanelPeople.prototype['append']        = MixpanelPeople.prototype.append;\nMixpanelPeople.prototype['remove']        = MixpanelPeople.prototype.remove;\nMixpanelPeople.prototype['union']         = MixpanelPeople.prototype.union;\nMixpanelPeople.prototype['track_charge']  = MixpanelPeople.prototype.track_charge;\nMixpanelPeople.prototype['clear_charges'] = MixpanelPeople.prototype.clear_charges;\nMixpanelPeople.prototype['delete_user']   = MixpanelPeople.prototype.delete_user;\nMixpanelPeople.prototype['toString']      = MixpanelPeople.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n/*\n * Constants\n */\n/** @const */ var SET_QUEUE_KEY          = '__mps';\n/** @const */ var SET_ONCE_QUEUE_KEY     = '__mpso';\n/** @const */ var UNSET_QUEUE_KEY        = '__mpus';\n/** @const */ var ADD_QUEUE_KEY          = '__mpa';\n/** @const */ var APPEND_QUEUE_KEY       = '__mpap';\n/** @const */ var REMOVE_QUEUE_KEY       = '__mpr';\n/** @const */ var UNION_QUEUE_KEY        = '__mpu';\n// This key is deprecated, but we want to check for it to see whether aliasing is allowed.\n/** @const */ var PEOPLE_DISTINCT_ID_KEY = '$people_distinct_id';\n/** @const */ var ALIAS_ID_KEY           = '__alias';\n/** @const */ var EVENT_TIMERS_KEY       = '__timers';\n/** @const */ var RESERVED_PROPERTIES = [\n    SET_QUEUE_KEY,\n    SET_ONCE_QUEUE_KEY,\n    UNSET_QUEUE_KEY,\n    ADD_QUEUE_KEY,\n    APPEND_QUEUE_KEY,\n    REMOVE_QUEUE_KEY,\n    UNION_QUEUE_KEY,\n    PEOPLE_DISTINCT_ID_KEY,\n    ALIAS_ID_KEY,\n    EVENT_TIMERS_KEY\n];\n\n/**\n * Mixpanel Persistence Object\n * @constructor\n */\nvar MixpanelPersistence = function(config) {\n    this['props'] = {};\n    this.campaign_params_saved = false;\n\n    if (config['persistence_name']) {\n        this.name = 'mp_' + config['persistence_name'];\n    } else {\n        this.name = 'mp_' + config['token'] + '_mixpanel';\n    }\n\n    var storage_type = config['persistence'];\n    if (storage_type !== 'cookie' && storage_type !== 'localStorage') {\n        console$1.critical('Unknown persistence type ' + storage_type + '; falling back to cookie');\n        storage_type = config['persistence'] = 'cookie';\n    }\n\n    if (storage_type === 'localStorage' && _.localStorage.is_supported()) {\n        this.storage = _.localStorage;\n    } else {\n        this.storage = _.cookie;\n    }\n\n    this.load();\n    this.update_config(config);\n    this.upgrade();\n    this.save();\n};\n\nMixpanelPersistence.prototype.properties = function() {\n    var p = {};\n\n    this.load();\n\n    // Filter out reserved properties\n    _.each(this['props'], function(v, k) {\n        if (!_.include(RESERVED_PROPERTIES, k)) {\n            p[k] = v;\n        }\n    });\n    return p;\n};\n\nMixpanelPersistence.prototype.load = function() {\n    if (this.disabled) { return; }\n\n    var entry = this.storage.parse(this.name);\n\n    if (entry) {\n        this['props'] = _.extend({}, entry);\n    }\n};\n\nMixpanelPersistence.prototype.upgrade = function() {\n    var old_cookie,\n        old_localstorage;\n\n    // if transferring from cookie to localStorage or vice-versa, copy existing\n    // super properties over to new storage mode\n    if (this.storage === _.localStorage) {\n        old_cookie = _.cookie.parse(this.name);\n\n        _.cookie.remove(this.name);\n        _.cookie.remove(this.name, true);\n\n        if (old_cookie) {\n            this.register_once(old_cookie);\n        }\n    } else if (this.storage === _.cookie) {\n        old_localstorage = _.localStorage.parse(this.name);\n\n        _.localStorage.remove(this.name);\n\n        if (old_localstorage) {\n            this.register_once(old_localstorage);\n        }\n    }\n};\n\nMixpanelPersistence.prototype.save = function() {\n    if (this.disabled) { return; }\n\n    this.storage.set(\n        this.name,\n        _.JSONEncode(this['props']),\n        this.expire_days,\n        this.cross_subdomain,\n        this.secure,\n        this.cross_site,\n        this.cookie_domain\n    );\n};\n\nMixpanelPersistence.prototype.load_prop = function(key) {\n    this.load();\n    return this['props'][key];\n};\n\nMixpanelPersistence.prototype.remove = function() {\n    // remove both domain and subdomain cookies\n    this.storage.remove(this.name, false, this.cookie_domain);\n    this.storage.remove(this.name, true, this.cookie_domain);\n};\n\n// removes the storage entry and deletes all loaded data\n// forced name for tests\nMixpanelPersistence.prototype.clear = function() {\n    this.remove();\n    this['props'] = {};\n};\n\n/**\n* @param {Object} props\n* @param {*=} default_value\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register_once = function(props, default_value, days) {\n    if (_.isObject(props)) {\n        if (typeof(default_value) === 'undefined') { default_value = 'None'; }\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n\n        _.each(props, function(val, prop) {\n            if (!this['props'].hasOwnProperty(prop) || this['props'][prop] === default_value) {\n                this['props'][prop] = val;\n            }\n        }, this);\n\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\n/**\n* @param {Object} props\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register = function(props, days) {\n    if (_.isObject(props)) {\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n        _.extend(this['props'], props);\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\nMixpanelPersistence.prototype.unregister = function(prop) {\n    this.load();\n    if (prop in this['props']) {\n        delete this['props'][prop];\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.update_search_keyword = function(referrer) {\n    this.register(_.info.searchInfo(referrer));\n};\n\n// EXPORTED METHOD, we test this directly.\nMixpanelPersistence.prototype.update_referrer_info = function(referrer) {\n    // If referrer doesn't exist, we want to note the fact that it was type-in traffic.\n    this.register_once({\n        '$initial_referrer': referrer || '$direct',\n        '$initial_referring_domain': _.info.referringDomain(referrer) || '$direct'\n    }, '');\n};\n\nMixpanelPersistence.prototype.get_referrer_info = function() {\n    return _.strip_empty_properties({\n        '$initial_referrer': this['props']['$initial_referrer'],\n        '$initial_referring_domain': this['props']['$initial_referring_domain']\n    });\n};\n\nMixpanelPersistence.prototype.update_config = function(config) {\n    this.default_expiry = this.expire_days = config['cookie_expiration'];\n    this.set_disabled(config['disable_persistence']);\n    this.set_cookie_domain(config['cookie_domain']);\n    this.set_cross_site(config['cross_site_cookie']);\n    this.set_cross_subdomain(config['cross_subdomain_cookie']);\n    this.set_secure(config['secure_cookie']);\n};\n\nMixpanelPersistence.prototype.set_disabled = function(disabled) {\n    this.disabled = disabled;\n    if (this.disabled) {\n        this.remove();\n    } else {\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {\n    if (cookie_domain !== this.cookie_domain) {\n        this.remove();\n        this.cookie_domain = cookie_domain;\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_site = function(cross_site) {\n    if (cross_site !== this.cross_site) {\n        this.cross_site = cross_site;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {\n    if (cross_subdomain !== this.cross_subdomain) {\n        this.cross_subdomain = cross_subdomain;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.get_cross_subdomain = function() {\n    return this.cross_subdomain;\n};\n\nMixpanelPersistence.prototype.set_secure = function(secure) {\n    if (secure !== this.secure) {\n        this.secure = secure ? true : false;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype._add_to_people_queue = function(queue, data) {\n    var q_key = this._get_queue_key(queue),\n        q_data = data[queue],\n        set_q = this._get_or_create_queue(SET_ACTION),\n        set_once_q = this._get_or_create_queue(SET_ONCE_ACTION),\n        unset_q = this._get_or_create_queue(UNSET_ACTION),\n        add_q = this._get_or_create_queue(ADD_ACTION),\n        union_q = this._get_or_create_queue(UNION_ACTION),\n        remove_q = this._get_or_create_queue(REMOVE_ACTION, []),\n        append_q = this._get_or_create_queue(APPEND_ACTION, []);\n\n    if (q_key === SET_QUEUE_KEY) {\n        // Update the set queue - we can override any existing values\n        _.extend(set_q, q_data);\n        // if there was a pending increment, override it\n        // with the set.\n        this._pop_from_people_queue(ADD_ACTION, q_data);\n        // if there was a pending union, override it\n        // with the set.\n        this._pop_from_people_queue(UNION_ACTION, q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === SET_ONCE_QUEUE_KEY) {\n        // only queue the data if there is not already a set_once call for it.\n        _.each(q_data, function(v, k) {\n            if (!(k in set_once_q)) {\n                set_once_q[k] = v;\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNSET_QUEUE_KEY) {\n        _.each(q_data, function(prop) {\n\n            // undo previously-queued actions on this key\n            _.each([set_q, set_once_q, add_q, union_q], function(enqueued_obj) {\n                if (prop in enqueued_obj) {\n                    delete enqueued_obj[prop];\n                }\n            });\n            _.each(append_q, function(append_obj) {\n                if (prop in append_obj) {\n                    delete append_obj[prop];\n                }\n            });\n\n            unset_q[prop] = true;\n\n        });\n    } else if (q_key === ADD_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            // If it exists in the set queue, increment\n            // the value\n            if (k in set_q) {\n                set_q[k] += v;\n            } else {\n                // If it doesn't exist, update the add\n                // queue\n                if (!(k in add_q)) {\n                    add_q[k] = 0;\n                }\n                add_q[k] += v;\n            }\n        }, this);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNION_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            if (_.isArray(v)) {\n                if (!(k in union_q)) {\n                    union_q[k] = [];\n                }\n                // We may send duplicates, the server will dedup them.\n                union_q[k] = union_q[k].concat(v);\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === REMOVE_QUEUE_KEY) {\n        remove_q.push(q_data);\n        this._pop_from_people_queue(APPEND_ACTION, q_data);\n    } else if (q_key === APPEND_QUEUE_KEY) {\n        append_q.push(q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    }\n\n    console$1.log('MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):');\n    console$1.log(data);\n\n    this.save();\n};\n\nMixpanelPersistence.prototype._pop_from_people_queue = function(queue, data) {\n    var q = this['props'][this._get_queue_key(queue)];\n    if (!_.isUndefined(q)) {\n        _.each(data, function(v, k) {\n            if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {\n                // list actions: only remove if both k+v match\n                // e.g. remove should not override append in a case like\n                // append({foo: 'bar'}); remove({foo: 'qux'})\n                _.each(q, function(queued_action) {\n                    if (queued_action[k] === v) {\n                        delete queued_action[k];\n                    }\n                });\n            } else {\n                delete q[k];\n            }\n        }, this);\n    }\n};\n\nMixpanelPersistence.prototype.load_queue = function(queue) {\n    return this.load_prop(this._get_queue_key(queue));\n};\n\nMixpanelPersistence.prototype._get_queue_key = function(queue) {\n    if (queue === SET_ACTION) {\n        return SET_QUEUE_KEY;\n    } else if (queue === SET_ONCE_ACTION) {\n        return SET_ONCE_QUEUE_KEY;\n    } else if (queue === UNSET_ACTION) {\n        return UNSET_QUEUE_KEY;\n    } else if (queue === ADD_ACTION) {\n        return ADD_QUEUE_KEY;\n    } else if (queue === APPEND_ACTION) {\n        return APPEND_QUEUE_KEY;\n    } else if (queue === REMOVE_ACTION) {\n        return REMOVE_QUEUE_KEY;\n    } else if (queue === UNION_ACTION) {\n        return UNION_QUEUE_KEY;\n    } else {\n        console$1.error('Invalid queue:', queue);\n    }\n};\n\nMixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {\n    var key = this._get_queue_key(queue);\n    default_val = _.isUndefined(default_val) ? {} : default_val;\n    return this['props'][key] || (this['props'][key] = default_val);\n};\n\nMixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    timers[event_name] = timestamp;\n    this['props'][EVENT_TIMERS_KEY] = timers;\n    this.save();\n};\n\nMixpanelPersistence.prototype.remove_event_timer = function(event_name) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    var timestamp = timers[event_name];\n    if (!_.isUndefined(timestamp)) {\n        delete this['props'][EVENT_TIMERS_KEY][event_name];\n        this.save();\n    }\n    return timestamp;\n};\n\n/* eslint camelcase: \"off\" */\n\n/*\n * Mixpanel JS Library\n *\n * Copyright 2012, Mixpanel, Inc. All Rights Reserved\n * http://mixpanel.com/\n *\n * Includes portions of Underscore.js\n * http://documentcloud.github.com/underscore/\n * (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT License.\n */\n\n// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @output_file_name mixpanel-2.8.min.js\n// ==/ClosureCompiler==\n\n/*\nSIMPLE STYLE GUIDE:\n\nthis.x === public function\nthis._x === internal - only use within this file\nthis.__x === private - only use within the class\n\nGlobals should be all caps\n*/\n\nvar init_type;       // MODULE or SNIPPET loader\n// allow bundlers to specify how extra code (recorder bundle) should be loaded\n// eslint-disable-next-line no-unused-vars\nvar load_extra_bundle = function(src, _onload) {\n    throw new Error(src + ' not available in this build.');\n};\n\nvar mixpanel_master; // main mixpanel instance / object\nvar INIT_MODULE  = 0;\nvar INIT_SNIPPET = 1;\n\nvar IDENTITY_FUNC = function(x) {return x;};\nvar NOOP_FUNC = function() {};\n\n/** @const */ var PRIMARY_INSTANCE_NAME = 'mixpanel';\n/** @const */ var PAYLOAD_TYPE_BASE64   = 'base64';\n/** @const */ var PAYLOAD_TYPE_JSON     = 'json';\n/** @const */ var DEVICE_ID_PREFIX      = '$device:';\n\n\n/*\n * Dynamic... constants? Is that an oxymoron?\n */\n// http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n// https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#withCredentials\nvar USE_XHR = (win.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest());\n\n// IE<10 does not support cross-origin XHR's but script tags\n// with defer won't block window.onload; ENQUEUE_REQUESTS\n// should only be true for Opera<12\nvar ENQUEUE_REQUESTS = !USE_XHR && (userAgent.indexOf('MSIE') === -1) && (userAgent.indexOf('Mozilla') === -1);\n\n// save reference to navigator.sendBeacon so it can be minified\nvar sendBeacon = null;\nif (navigator['sendBeacon']) {\n    sendBeacon = function() {\n        // late reference to navigator.sendBeacon to allow patching/spying\n        return navigator['sendBeacon'].apply(navigator, arguments);\n    };\n}\n\nvar DEFAULT_API_ROUTES = {\n    'track': 'track/',\n    'engage': 'engage/',\n    'groups': 'groups/',\n    'record': 'record/'\n};\n\n/*\n * Module-level globals\n */\nvar DEFAULT_CONFIG = {\n    'api_host':                          'https://api-js.mixpanel.com',\n    'api_routes':                        DEFAULT_API_ROUTES,\n    'api_method':                        'POST',\n    'api_transport':                     'XHR',\n    'api_payload_format':                PAYLOAD_TYPE_BASE64,\n    'app_host':                          'https://mixpanel.com',\n    'cdn':                               'https://cdn.mxpnl.com',\n    'cross_site_cookie':                 false,\n    'cross_subdomain_cookie':            true,\n    'error_reporter':                    NOOP_FUNC,\n    'persistence':                       'cookie',\n    'persistence_name':                  '',\n    'cookie_domain':                     '',\n    'cookie_name':                       '',\n    'loaded':                            NOOP_FUNC,\n    'mp_loader':                         null,\n    'track_marketing':                   true,\n    'track_pageview':                    false,\n    'skip_first_touch_marketing':        false,\n    'store_google':                      true,\n    'stop_utm_persistence':              false,\n    'save_referrer':                     true,\n    'test':                              false,\n    'verbose':                           false,\n    'img':                               false,\n    'debug':                             false,\n    'track_links_timeout':               300,\n    'cookie_expiration':                 365,\n    'upgrade':                           false,\n    'disable_persistence':               false,\n    'disable_cookie':                    false,\n    'secure_cookie':                     false,\n    'ip':                                true,\n    'opt_out_tracking_by_default':       false,\n    'opt_out_persistence_by_default':    false,\n    'opt_out_tracking_persistence_type': 'localStorage',\n    'opt_out_tracking_cookie_prefix':    null,\n    'property_blacklist':                [],\n    'xhr_headers':                       {}, // { header: value, header2: value }\n    'ignore_dnt':                        false,\n    'batch_requests':                    true,\n    'batch_size':                        50,\n    'batch_flush_interval_ms':           5000,\n    'batch_request_timeout_ms':          90000,\n    'batch_autostart':                   true,\n    'hooks':                             {},\n    'record_block_class':                new RegExp('^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$'),\n    'record_block_selector':             'img, video',\n    'record_canvas':                     false,\n    'record_collect_fonts':              false,\n    'record_idle_timeout_ms':            30 * 60 * 1000, // 30 minutes\n    'record_mask_text_class':            new RegExp('^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$'),\n    'record_mask_text_selector':         '*',\n    'record_max_ms':                     MAX_RECORDING_MS,\n    'record_min_ms':                     0,\n    'record_sessions_percent':           0,\n    'recorder_src':                      'https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js'\n};\n\nvar DOM_LOADED = false;\n\n/**\n * Mixpanel Library Object\n * @constructor\n */\nvar MixpanelLib = function() {};\n\n\n/**\n * create_mplib(token:string, config:object, name:string)\n *\n * This function is used by the init method of MixpanelLib objects\n * as well as the main initializer at the end of the JSLib (that\n * initializes document.mixpanel as well as any additional instances\n * declared before this file has loaded).\n */\nvar create_mplib = function(token, config, name) {\n    var instance,\n        target = (name === PRIMARY_INSTANCE_NAME) ? mixpanel_master : mixpanel_master[name];\n\n    if (target && init_type === INIT_MODULE) {\n        instance = target;\n    } else {\n        if (target && !_.isArray(target)) {\n            console$1.error('You have already initialized ' + name);\n            return;\n        }\n        instance = new MixpanelLib();\n    }\n\n    instance._cached_groups = {}; // cache groups in a pool\n\n    instance._init(token, config, name);\n\n    instance['people'] = new MixpanelPeople();\n    instance['people']._init(instance);\n\n    if (!instance.get_config('skip_first_touch_marketing')) {\n        // We need null UTM params in the object because\n        // UTM parameters act as a tuple. If any UTM param\n        // is present, then we set all UTM params including\n        // empty ones together\n        var utm_params = _.info.campaignParams(null);\n        var initial_utm_params = {};\n        var has_utm = false;\n        _.each(utm_params, function(utm_value, utm_key) {\n            initial_utm_params['initial_' + utm_key] = utm_value;\n            if (utm_value) {\n                has_utm = true;\n            }\n        });\n        if (has_utm) {\n            instance['people'].set_once(initial_utm_params);\n        }\n    }\n\n    // if any instance on the page has debug = true, we set the\n    // global debug to be true\n    Config.DEBUG = Config.DEBUG || instance.get_config('debug');\n\n    // if target is not defined, we called init after the lib already\n    // loaded, so there won't be an array of things to execute\n    if (!_.isUndefined(target) && _.isArray(target)) {\n        // Crunch through the people queue first - we queue this data up &\n        // flush on identify, so it's better to do all these operations first\n        instance._execute_array.call(instance['people'], target['people']);\n        instance._execute_array(target);\n    }\n\n    return instance;\n};\n\n// Initialization methods\n\n/**\n * This function initializes a new instance of the Mixpanel tracking object.\n * All new instances are added to the main mixpanel object as sub properties (such as\n * mixpanel.library_name) and also returned by this function. To define a\n * second instance on the page, you would call:\n *\n *     mixpanel.init('new token', { your: 'config' }, 'library_name');\n *\n * and use it like so:\n *\n *     mixpanel.library_name.track(...);\n *\n * @param {String} token   Your Mixpanel API token\n * @param {Object} [config]  A dictionary of config options to override. <a href=\"https://github.com/mixpanel/mixpanel-js/blob/v2.46.0/src/mixpanel-core.js#L88-L127\">See a list of default config options</a>.\n * @param {String} [name]    The name for the new mixpanel instance that you want created\n */\nMixpanelLib.prototype.init = function (token, config, name) {\n    if (_.isUndefined(name)) {\n        this.report_error('You must name your new library: init(token, config, name)');\n        return;\n    }\n    if (name === PRIMARY_INSTANCE_NAME) {\n        this.report_error('You must initialize the main mixpanel object right after you include the Mixpanel js snippet');\n        return;\n    }\n\n    var instance = create_mplib(token, config, name);\n    mixpanel_master[name] = instance;\n    instance._loaded();\n\n    return instance;\n};\n\n// mixpanel._init(token:string, config:object, name:string)\n//\n// This function sets up the current instance of the mixpanel\n// library.  The difference between this method and the init(...)\n// method is this one initializes the actual instance, whereas the\n// init(...) method sets up a new library and calls _init on it.\n//\nMixpanelLib.prototype._init = function(token, config, name) {\n    config = config || {};\n\n    this['__loaded'] = true;\n    this['config'] = {};\n\n    var variable_features = {};\n\n    // default to JSON payload for standard mixpanel.com API hosts\n    if (!('api_payload_format' in config)) {\n        var api_host = config['api_host'] || DEFAULT_CONFIG['api_host'];\n        if (api_host.match(/\\.mixpanel\\.com/)) {\n            variable_features['api_payload_format'] = PAYLOAD_TYPE_JSON;\n        }\n    }\n\n    this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {\n        'name': name,\n        'token': token,\n        'callback_fn': ((name === PRIMARY_INSTANCE_NAME) ? name : PRIMARY_INSTANCE_NAME + '.' + name) + '._jsc'\n    }));\n\n    this['_jsc'] = NOOP_FUNC;\n\n    this.__dom_loaded_queue = [];\n    this.__request_queue = [];\n    this.__disabled_events = [];\n    this._flags = {\n        'disable_all_events': false,\n        'identify_called': false\n    };\n\n    // set up request queueing/batching\n    this.request_batchers = {};\n    this._batch_requests = this.get_config('batch_requests');\n    if (this._batch_requests) {\n        if (!_.localStorage.is_supported(true) || !USE_XHR) {\n            this._batch_requests = false;\n            console$1.log('Turning off Mixpanel request-queueing; needs XHR and localStorage support');\n            _.each(this.get_batcher_configs(), function(batcher_config) {\n                console$1.log('Clearing batch queue ' + batcher_config.queue_key);\n                _.localStorage.remove(batcher_config.queue_key);\n            });\n        } else {\n            this.init_batchers();\n            if (sendBeacon && win.addEventListener) {\n                // Before page closes or hides (user tabs away etc), attempt to flush any events\n                // queued up via navigator.sendBeacon. Since sendBeacon doesn't report success/failure,\n                // events will not be removed from the persistent store; if the site is loaded again,\n                // the events will be flushed again on startup and deduplicated on the Mixpanel server\n                // side.\n                // There is no reliable way to capture only page close events, so we lean on the\n                // visibilitychange and pagehide events as recommended at\n                // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes.\n                // These events fire when the user clicks away from the current page/tab, so will occur\n                // more frequently than page unload, but are the only mechanism currently for capturing\n                // this scenario somewhat reliably.\n                var flush_on_unload = _.bind(function() {\n                    if (!this.request_batchers.events.stopped) {\n                        this.request_batchers.events.flush({unloading: true});\n                    }\n                }, this);\n                win.addEventListener('pagehide', function(ev) {\n                    if (ev['persisted']) {\n                        flush_on_unload();\n                    }\n                });\n                win.addEventListener('visibilitychange', function() {\n                    if (document$1['visibilityState'] === 'hidden') {\n                        flush_on_unload();\n                    }\n                });\n            }\n        }\n    }\n\n    this['persistence'] = this['cookie'] = new MixpanelPersistence(this['config']);\n    this.unpersisted_superprops = {};\n    this._gdpr_init();\n\n    var uuid = _.UUID();\n    if (!this.get_distinct_id()) {\n        // There is no need to set the distinct id\n        // or the device id if something was already stored\n        // in the persitence\n        this.register_once({\n            'distinct_id': DEVICE_ID_PREFIX + uuid,\n            '$device_id': uuid\n        }, '');\n    }\n\n    var track_pageview_option = this.get_config('track_pageview');\n    if (track_pageview_option) {\n        this._init_url_change_tracking(track_pageview_option);\n    }\n\n    if (this.get_config('record_sessions_percent') > 0 && Math.random() * 100 <= this.get_config('record_sessions_percent')) {\n        this.start_session_recording();\n    }\n};\n\nMixpanelLib.prototype.start_session_recording = addOptOutCheckMixpanelLib(function () {\n    if (!win['MutationObserver']) {\n        console$1.critical('Browser does not support MutationObserver; skipping session recording');\n        return;\n    }\n\n    var handleLoadedRecorder = _.bind(function() {\n        this._recorder = this._recorder || new win['__mp_recorder'](this);\n        this._recorder['startRecording']();\n    }, this);\n\n    if (_.isUndefined(win['__mp_recorder'])) {\n        load_extra_bundle(this.get_config('recorder_src'), handleLoadedRecorder);\n    } else {\n        handleLoadedRecorder();\n    }\n});\n\nMixpanelLib.prototype.stop_session_recording = function () {\n    if (this._recorder) {\n        this._recorder['stopRecording']();\n    } else {\n        console$1.critical('Session recorder module not loaded');\n    }\n};\n\nMixpanelLib.prototype.get_session_recording_properties = function () {\n    var props = {};\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        props['$mp_replay_id'] = replay_id;\n    }\n    return props;\n};\n\nMixpanelLib.prototype.get_session_replay_url = function () {\n    var replay_url = null;\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        var query_params = _.HTTPBuildQuery({\n            'replay_id': replay_id,\n            'distinct_id': this.get_distinct_id(),\n            'token': this.get_config('token')\n        });\n        replay_url = 'https://mixpanel.com/projects/replay-redirect?' + query_params;\n    }\n    return replay_url;\n};\n\nMixpanelLib.prototype._get_session_replay_id = function () {\n    var replay_id = null;\n    if (this._recorder) {\n        replay_id = this._recorder['replayId'];\n    }\n    return replay_id || null;\n};\n\n// Private methods\n\nMixpanelLib.prototype._loaded = function() {\n    this.get_config('loaded')(this);\n    this._set_default_superprops();\n    this['people'].set_once(this['persistence'].get_referrer_info());\n\n    // `store_google` is now deprecated and previously stored UTM parameters are cleared\n    // from persistence by default.\n    if (this.get_config('store_google') && this.get_config('stop_utm_persistence')) {\n        var utm_params = _.info.campaignParams(null);\n        _.each(utm_params, function(_utm_value, utm_key) {\n            // We need to unregister persisted UTM parameters so old values\n            // are not mixed with the new UTM parameters\n            this.unregister(utm_key);\n        }.bind(this));\n    }\n};\n\n// update persistence with info on referrer, UTM params, etc\nMixpanelLib.prototype._set_default_superprops = function() {\n    this['persistence'].update_search_keyword(document$1.referrer);\n    // Registering super properties for UTM persistence by 'store_google' is deprecated.\n    if (this.get_config('store_google') && !this.get_config('stop_utm_persistence')) {\n        this.register(_.info.campaignParams());\n    }\n    if (this.get_config('save_referrer')) {\n        this['persistence'].update_referrer_info(document$1.referrer);\n    }\n};\n\nMixpanelLib.prototype._dom_loaded = function() {\n    _.each(this.__dom_loaded_queue, function(item) {\n        this._track_dom.apply(this, item);\n    }, this);\n\n    if (!this.has_opted_out_tracking()) {\n        _.each(this.__request_queue, function(item) {\n            this._send_request.apply(this, item);\n        }, this);\n    }\n\n    delete this.__dom_loaded_queue;\n    delete this.__request_queue;\n};\n\nMixpanelLib.prototype._track_dom = function(DomClass, args) {\n    if (this.get_config('img')) {\n        this.report_error('You can\\'t use DOM tracking functions with img = true.');\n        return false;\n    }\n\n    if (!DOM_LOADED) {\n        this.__dom_loaded_queue.push([DomClass, args]);\n        return false;\n    }\n\n    var dt = new DomClass().init(this);\n    return dt.track.apply(dt, args);\n};\n\nMixpanelLib.prototype._init_url_change_tracking = function(track_pageview_option) {\n    var previous_tracked_url = '';\n    var tracked = this.track_pageview();\n    if (tracked) {\n        previous_tracked_url = _.info.currentUrl();\n    }\n\n    if (_.include(['full-url', 'url-with-path-and-query-string', 'url-with-path'], track_pageview_option)) {\n        win.addEventListener('popstate', function() {\n            win.dispatchEvent(new Event('mp_locationchange'));\n        });\n        win.addEventListener('hashchange', function() {\n            win.dispatchEvent(new Event('mp_locationchange'));\n        });\n        var nativePushState = win.history.pushState;\n        if (typeof nativePushState === 'function') {\n            win.history.pushState = function(state, unused, url) {\n                nativePushState.call(win.history, state, unused, url);\n                win.dispatchEvent(new Event('mp_locationchange'));\n            };\n        }\n        var nativeReplaceState = win.history.replaceState;\n        if (typeof nativeReplaceState === 'function') {\n            win.history.replaceState = function(state, unused, url) {\n                nativeReplaceState.call(win.history, state, unused, url);\n                win.dispatchEvent(new Event('mp_locationchange'));\n            };\n        }\n        win.addEventListener('mp_locationchange', function() {\n            var current_url = _.info.currentUrl();\n            var should_track = false;\n            if (track_pageview_option === 'full-url') {\n                should_track = current_url !== previous_tracked_url;\n            } else if (track_pageview_option === 'url-with-path-and-query-string') {\n                should_track = current_url.split('#')[0] !== previous_tracked_url.split('#')[0];\n            } else if (track_pageview_option === 'url-with-path') {\n                should_track = current_url.split('#')[0].split('?')[0] !== previous_tracked_url.split('#')[0].split('?')[0];\n            }\n\n            if (should_track) {\n                var tracked = this.track_pageview();\n                if (tracked) {\n                    previous_tracked_url = current_url;\n                }\n            }\n        }.bind(this));\n    }\n};\n\n/**\n * _prepare_callback() should be called by callers of _send_request for use\n * as the callback argument.\n *\n * If there is no callback, this returns null.\n * If we are going to make XHR/XDR requests, this returns a function.\n * If we are going to use script tags, this returns a string to use as the\n * callback GET param.\n */\nMixpanelLib.prototype._prepare_callback = function(callback, data) {\n    if (_.isUndefined(callback)) {\n        return null;\n    }\n\n    if (USE_XHR) {\n        var callback_function = function(response) {\n            callback(response, data);\n        };\n        return callback_function;\n    } else {\n        // if the user gives us a callback, we store as a random\n        // property on this instances jsc function and update our\n        // callback string to reflect that.\n        var jsc = this['_jsc'];\n        var randomized_cb = '' + Math.floor(Math.random() * 100000000);\n        var callback_string = this.get_config('callback_fn') + '[' + randomized_cb + ']';\n        jsc[randomized_cb] = function(response) {\n            delete jsc[randomized_cb];\n            callback(response, data);\n        };\n        return callback_string;\n    }\n};\n\nMixpanelLib.prototype._send_request = function(url, data, options, callback) {\n    var succeeded = true;\n\n    if (ENQUEUE_REQUESTS) {\n        this.__request_queue.push(arguments);\n        return succeeded;\n    }\n\n    var DEFAULT_OPTIONS = {\n        method: this.get_config('api_method'),\n        transport: this.get_config('api_transport'),\n        verbose: this.get_config('verbose')\n    };\n    var body_data = null;\n\n    if (!callback && (_.isFunction(options) || typeof options === 'string')) {\n        callback = options;\n        options = null;\n    }\n    options = _.extend(DEFAULT_OPTIONS, options || {});\n    if (!USE_XHR) {\n        options.method = 'GET';\n    }\n    var use_post = options.method === 'POST';\n    var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === 'sendbeacon';\n\n    // needed to correctly format responses\n    var verbose_mode = options.verbose;\n    if (data['verbose']) { verbose_mode = true; }\n\n    if (this.get_config('test')) { data['test'] = 1; }\n    if (verbose_mode) { data['verbose'] = 1; }\n    if (this.get_config('img')) { data['img'] = 1; }\n    if (!USE_XHR) {\n        if (callback) {\n            data['callback'] = callback;\n        } else if (verbose_mode || this.get_config('test')) {\n            // Verbose output (from verbose mode, or an error in test mode) is a json blob,\n            // which by itself is not valid javascript. Without a callback, this verbose output will\n            // cause an error when returned via jsonp, so we force a no-op callback param.\n            // See the ECMA script spec: http://www.ecma-international.org/ecma-262/5.1/#sec-12.4\n            data['callback'] = '(function(){})';\n        }\n    }\n\n    data['ip'] = this.get_config('ip')?1:0;\n    data['_'] = new Date().getTime().toString();\n\n    if (use_post) {\n        body_data = 'data=' + encodeURIComponent(data['data']);\n        delete data['data'];\n    }\n\n    url += '?' + _.HTTPBuildQuery(data);\n\n    var lib = this;\n    if ('img' in data) {\n        var img = document$1.createElement('img');\n        img.src = url;\n        document$1.body.appendChild(img);\n    } else if (use_sendBeacon) {\n        try {\n            succeeded = sendBeacon(url, body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n        try {\n            if (callback) {\n                callback(succeeded ? 1 : 0);\n            }\n        } catch (e) {\n            lib.report_error(e);\n        }\n    } else if (USE_XHR) {\n        try {\n            var req = new XMLHttpRequest();\n            req.open(options.method, url, true);\n\n            var headers = this.get_config('xhr_headers');\n            if (use_post) {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n            _.each(headers, function(headerValue, headerName) {\n                req.setRequestHeader(headerName, headerValue);\n            });\n\n            if (options.timeout_ms && typeof req.timeout !== 'undefined') {\n                req.timeout = options.timeout_ms;\n                var start_time = new Date().getTime();\n            }\n\n            // send the mp_optout cookie\n            // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n            req.withCredentials = true;\n            req.onreadystatechange = function () {\n                if (req.readyState === 4) { // XMLHttpRequest.DONE == 4, except in safari 4\n                    if (req.status === 200) {\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response;\n                                try {\n                                    response = _.JSONDecode(req.responseText);\n                                } catch (e) {\n                                    lib.report_error(e);\n                                    if (options.ignore_json_errors) {\n                                        response = req.responseText;\n                                    } else {\n                                        return;\n                                    }\n                                }\n                                callback(response);\n                            } else {\n                                callback(Number(req.responseText));\n                            }\n                        }\n                    } else {\n                        var error;\n                        if (\n                            req.timeout &&\n                            !req.status &&\n                            new Date().getTime() - start_time >= req.timeout\n                        ) {\n                            error = 'timeout';\n                        } else {\n                            error = 'Bad HTTP status: ' + req.status + ' ' + req.statusText;\n                        }\n                        lib.report_error(error);\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response_headers = req['responseHeaders'] || {};\n                                callback({status: 0, httpStatusCode: req['status'], error: error, retryAfter: response_headers['Retry-After']});\n                            } else {\n                                callback(0);\n                            }\n                        }\n                    }\n                }\n            };\n            req.send(body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n    } else {\n        var script = document$1.createElement('script');\n        script.type = 'text/javascript';\n        script.async = true;\n        script.defer = true;\n        script.src = url;\n        var s = document$1.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(script, s);\n    }\n\n    return succeeded;\n};\n\n/**\n * _execute_array() deals with processing any mixpanel function\n * calls that were called before the Mixpanel library were loaded\n * (and are thus stored in an array so they can be called later)\n *\n * Note: we fire off all the mixpanel function calls && user defined\n * functions BEFORE we fire off mixpanel tracking calls. This is so\n * identify/register/set_config calls can properly modify early\n * tracking calls.\n *\n * @param {Array} array\n */\nMixpanelLib.prototype._execute_array = function(array) {\n    var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];\n    _.each(array, function(item) {\n        if (item) {\n            fn_name = item[0];\n            if (_.isArray(fn_name)) {\n                tracking_calls.push(item); // chained call e.g. mixpanel.get_group().set()\n            } else if (typeof(item) === 'function') {\n                item.call(this);\n            } else if (_.isArray(item) && fn_name === 'alias') {\n                alias_calls.push(item);\n            } else if (_.isArray(item) && fn_name.indexOf('track') !== -1 && typeof(this[fn_name]) === 'function') {\n                tracking_calls.push(item);\n            } else {\n                other_calls.push(item);\n            }\n        }\n    }, this);\n\n    var execute = function(calls, context) {\n        _.each(calls, function(item) {\n            if (_.isArray(item[0])) {\n                // chained call\n                var caller = context;\n                _.each(item, function(call) {\n                    caller = caller[call[0]].apply(caller, call.slice(1));\n                });\n            } else {\n                this[item[0]].apply(this, item.slice(1));\n            }\n        }, context);\n    };\n\n    execute(alias_calls, this);\n    execute(other_calls, this);\n    execute(tracking_calls, this);\n};\n\n// request queueing utils\n\nMixpanelLib.prototype.are_batchers_initialized = function() {\n    return !!this.request_batchers.events;\n};\n\nMixpanelLib.prototype.get_batcher_configs = function() {\n    var queue_prefix = '__mpq_' + this.get_config('token');\n    var api_routes = this.get_config('api_routes');\n    this._batcher_configs = this._batcher_configs || {\n        events: {type: 'events', endpoint: '/' + api_routes['track'], queue_key: queue_prefix + '_ev'},\n        people: {type: 'people', endpoint: '/' + api_routes['engage'], queue_key: queue_prefix + '_pp'},\n        groups: {type: 'groups', endpoint: '/' + api_routes['groups'], queue_key: queue_prefix + '_gr'}\n    };\n    return this._batcher_configs;\n};\n\nMixpanelLib.prototype.init_batchers = function() {\n    if (!this.are_batchers_initialized()) {\n        var batcher_for = _.bind(function(attrs) {\n            return new RequestBatcher(\n                attrs.queue_key,\n                {\n                    libConfig: this['config'],\n                    errorReporter: this.get_config('error_reporter'),\n                    sendRequestFunc: _.bind(function(data, options, cb) {\n                        this._send_request(\n                            this.get_config('api_host') + attrs.endpoint,\n                            this._encode_data_for_request(data),\n                            options,\n                            this._prepare_callback(cb, data)\n                        );\n                    }, this),\n                    beforeSendHook: _.bind(function(item) {\n                        return this._run_hook('before_send_' + attrs.type, item);\n                    }, this),\n                    stopAllBatchingFunc: _.bind(this.stop_batch_senders, this),\n                    usePersistence: true\n                }\n            );\n        }, this);\n        var batcher_configs = this.get_batcher_configs();\n        this.request_batchers = {\n            events: batcher_for(batcher_configs.events),\n            people: batcher_for(batcher_configs.people),\n            groups: batcher_for(batcher_configs.groups)\n        };\n    }\n    if (this.get_config('batch_autostart')) {\n        this.start_batch_senders();\n    }\n};\n\nMixpanelLib.prototype.start_batch_senders = function() {\n    this._batchers_were_started = true;\n    if (this.are_batchers_initialized()) {\n        this._batch_requests = true;\n        _.each(this.request_batchers, function(batcher) {\n            batcher.start();\n        });\n    }\n};\n\nMixpanelLib.prototype.stop_batch_senders = function() {\n    this._batch_requests = false;\n    _.each(this.request_batchers, function(batcher) {\n        batcher.stop();\n        batcher.clear();\n    });\n};\n\n/**\n * push() keeps the standard async-array-push\n * behavior around after the lib is loaded.\n * This is only useful for external integrations that\n * do not wish to rely on our convenience methods\n * (created in the snippet).\n *\n * ### Usage:\n *     mixpanel.push(['register', { a: 'b' }]);\n *\n * @param {Array} item A [function_name, args...] array to be executed\n */\nMixpanelLib.prototype.push = function(item) {\n    this._execute_array([item]);\n};\n\n/**\n * Disable events on the Mixpanel object. If passed no arguments,\n * this function disables tracking of any event. If passed an\n * array of event names, those events will be disabled, but other\n * events will continue to be tracked.\n *\n * Note: this function does not stop other mixpanel functions from\n * firing, such as register() or people.set().\n *\n * @param {Array} [events] An array of event names to disable\n */\nMixpanelLib.prototype.disable = function(events) {\n    if (typeof(events) === 'undefined') {\n        this._flags.disable_all_events = true;\n    } else {\n        this.__disabled_events = this.__disabled_events.concat(events);\n    }\n};\n\nMixpanelLib.prototype._encode_data_for_request = function(data) {\n    var encoded_data = _.JSONEncode(data);\n    if (this.get_config('api_payload_format') === PAYLOAD_TYPE_BASE64) {\n        encoded_data = _.base64Encode(encoded_data);\n    }\n    return {'data': encoded_data};\n};\n\n// internal method for handling track vs batch-enqueue logic\nMixpanelLib.prototype._track_or_batch = function(options, callback) {\n    var truncated_data = _.truncate(options.data, 255);\n    var endpoint = options.endpoint;\n    var batcher = options.batcher;\n    var should_send_immediately = options.should_send_immediately;\n    var send_request_options = options.send_request_options || {};\n    callback = callback || NOOP_FUNC;\n\n    var request_enqueued_or_initiated = true;\n    var send_request_immediately = _.bind(function() {\n        if (!send_request_options.skip_hooks) {\n            truncated_data = this._run_hook('before_send_' + options.type, truncated_data);\n        }\n        if (truncated_data) {\n            console$1.log('MIXPANEL REQUEST:');\n            console$1.log(truncated_data);\n            return this._send_request(\n                endpoint,\n                this._encode_data_for_request(truncated_data),\n                send_request_options,\n                this._prepare_callback(callback, truncated_data)\n            );\n        } else {\n            return null;\n        }\n    }, this);\n\n    if (this._batch_requests && !should_send_immediately) {\n        batcher.enqueue(truncated_data).then(function(succeeded) {\n            if (succeeded) {\n                callback(1, truncated_data);\n            } else {\n                send_request_immediately();\n            }\n        });\n    } else {\n        request_enqueued_or_initiated = send_request_immediately();\n    }\n\n    return request_enqueued_or_initiated && truncated_data;\n};\n\n/**\n * Track an event. This is the most important and\n * frequently used Mixpanel function.\n *\n * ### Usage:\n *\n *     // track an event named 'Registered'\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n *     // track an event using navigator.sendBeacon\n *     mixpanel.track('Left page', {'duration_seconds': 35}, {transport: 'sendBeacon'});\n *\n * To track link clicks or form submissions, see track_links() or track_forms().\n *\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Object} [options] Optional configuration for this track request.\n * @param {String} [options.transport] Transport method for network request ('xhr' or 'sendBeacon').\n * @param {Boolean} [options.send_immediately] Whether to bypass batching/queueing and send track request immediately.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    var transport = options['transport']; // external API, don't minify 'transport' prop\n    if (transport) {\n        options.transport = transport; // 'transport' prop name can be minified internally\n    }\n    var should_send_immediately = options['send_immediately'];\n    if (typeof callback !== 'function') {\n        callback = NOOP_FUNC;\n    }\n\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.track');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        callback(0);\n        return;\n    }\n\n    // set defaults\n    properties = _.extend({}, properties);\n    properties['token'] = this.get_config('token');\n\n    // set $duration if time_event was previously called for this event\n    var start_timestamp = this['persistence'].remove_event_timer(event_name);\n    if (!_.isUndefined(start_timestamp)) {\n        var duration_in_ms = new Date().getTime() - start_timestamp;\n        properties['$duration'] = parseFloat((duration_in_ms / 1000).toFixed(3));\n    }\n\n    this._set_default_superprops();\n\n    var marketing_properties = this.get_config('track_marketing')\n        ? _.info.marketingParams()\n        : {};\n\n    // note: extend writes to the first object, so lets make sure we\n    // don't write to the persistence properties object and info\n    // properties object by passing in a new object\n\n    // update properties with pageview info and super-properties\n    properties = _.extend(\n        {},\n        _.info.properties({'mp_loader': this.get_config('mp_loader')}),\n        marketing_properties,\n        this['persistence'].properties(),\n        this.unpersisted_superprops,\n        this.get_session_recording_properties(),\n        properties\n    );\n\n    var property_blacklist = this.get_config('property_blacklist');\n    if (_.isArray(property_blacklist)) {\n        _.each(property_blacklist, function(blacklisted_prop) {\n            delete properties[blacklisted_prop];\n        });\n    } else {\n        this.report_error('Invalid value for property_blacklist config: ' + property_blacklist);\n    }\n\n    var data = {\n        'event': event_name,\n        'properties': properties\n    };\n    var ret = this._track_or_batch({\n        type: 'events',\n        data: data,\n        endpoint: this.get_config('api_host') + '/' + this.get_config('api_routes')['track'],\n        batcher: this.request_batchers.events,\n        should_send_immediately: should_send_immediately,\n        send_request_options: options\n    }, callback);\n\n    return ret;\n});\n\n/**\n * Register the current user into one/many groups.\n *\n * ### Usage:\n *\n *      mixpanel.set_group('company', ['mixpanel', 'google']) // an array of IDs\n *      mixpanel.set_group('company', 'mixpanel')\n *      mixpanel.set_group('company', 128746312)\n *\n * @param {String} group_key Group key\n * @param {Array|String|Number} group_ids An array of group IDs, or a singular group ID\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n *\n */\nMixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {\n    if (!_.isArray(group_ids)) {\n        group_ids = [group_ids];\n    }\n    var prop = {};\n    prop[group_key] = group_ids;\n    this.register(prop);\n    return this['people'].set(group_key, group_ids, callback);\n});\n\n/**\n * Add a new group for this user.\n *\n * ### Usage:\n *\n *      mixpanel.add_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_values = this.get_property(group_key);\n    var prop = {};\n    if (old_values === undefined) {\n        prop[group_key] = [group_id];\n        this.register(prop);\n    } else {\n        if (old_values.indexOf(group_id) === -1) {\n            old_values.push(group_id);\n            prop[group_key] = old_values;\n            this.register(prop);\n        }\n    }\n    return this['people'].union(group_key, group_id, callback);\n});\n\n/**\n * Remove a group from this user.\n *\n * ### Usage:\n *\n *      mixpanel.remove_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_value = this.get_property(group_key);\n    // if the value doesn't exist, the persistent store is unchanged\n    if (old_value !== undefined) {\n        var idx = old_value.indexOf(group_id);\n        if (idx > -1) {\n            old_value.splice(idx, 1);\n            this.register({group_key: old_value});\n        }\n        if (old_value.length === 0) {\n            this.unregister(group_key);\n        }\n    }\n    return this['people'].remove(group_key, group_id, callback);\n});\n\n/**\n * Track an event with specific groups.\n *\n * ### Usage:\n *\n *      mixpanel.track_with_groups('purchase', {'product': 'iphone'}, {'University': ['UCB', 'UCLA']})\n *\n * @param {String} event_name The name of the event (see `mixpanel.track()`)\n * @param {Object=} properties A set of properties to include with the event you're sending (see `mixpanel.track()`)\n * @param {Object=} groups An object mapping group name keys to one or more values\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {\n    var tracking_props = _.extend({}, properties || {});\n    _.each(groups, function(v, k) {\n        if (v !== null && v !== undefined) {\n            tracking_props[k] = v;\n        }\n    });\n    return this.track(event_name, tracking_props, callback);\n});\n\nMixpanelLib.prototype._create_map_key = function (group_key, group_id) {\n    return group_key + '_' + JSON.stringify(group_id);\n};\n\nMixpanelLib.prototype._remove_group_from_cache = function (group_key, group_id) {\n    delete this._cached_groups[this._create_map_key(group_key, group_id)];\n};\n\n/**\n * Look up reference to a Mixpanel group\n *\n * ### Usage:\n *\n *       mixpanel.get_group(group_key, group_id)\n *\n * @param {String} group_key Group key\n * @param {Object} group_id A valid Mixpanel property type\n * @returns {Object} A MixpanelGroup identifier\n */\nMixpanelLib.prototype.get_group = function (group_key, group_id) {\n    var map_key = this._create_map_key(group_key, group_id);\n    var group = this._cached_groups[map_key];\n    if (group === undefined || group._group_key !== group_key || group._group_id !== group_id) {\n        group = new MixpanelGroup();\n        group._init(this, group_key, group_id);\n        this._cached_groups[map_key] = group;\n    }\n    return group;\n};\n\n/**\n * Track a default Mixpanel page view event, which includes extra default event properties to\n * improve page view data.\n *\n * ### Usage:\n *\n *     // track a default $mp_web_page_view event\n *     mixpanel.track_pageview();\n *\n *     // track a page view event with additional event properties\n *     mixpanel.track_pageview({'ab_test_variant': 'card-layout-b'});\n *\n *     // example approach to track page views on different page types as event properties\n *     mixpanel.track_pageview({'page': 'pricing'});\n *     mixpanel.track_pageview({'page': 'homepage'});\n *\n *     // UNCOMMON: Tracking a page view event with a custom event_name option. NOT expected to be used for\n *     // individual pages on the same site or product. Use cases for custom event_name may be page\n *     // views on different products or internal applications that are considered completely separate\n *     mixpanel.track_pageview({'page': 'customer-search'}, {'event_name': '[internal] Admin Page View'});\n *\n * ### Notes:\n *\n * The `config.track_pageview` option for <a href=\"#mixpanelinit\">mixpanel.init()</a>\n * may be turned on for tracking page loads automatically.\n *\n *     // track only page loads\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: true});\n *\n *     // track when the URL changes in any manner\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'full-url'});\n *\n *     // track when the URL changes, ignoring any changes in the hash part\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path-and-query-string'});\n *\n *     // track when the path changes, ignoring any query parameter or hash changes\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path'});\n *\n * @param {Object} [properties] An optional set of additional properties to send with the page view event\n * @param {Object} [options] Page view tracking options\n * @param {String} [options.event_name] - Alternate name for the tracking event\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(properties, options) {\n    if (typeof properties !== 'object') {\n        properties = {};\n    }\n    options = options || {};\n    var event_name = options['event_name'] || '$mp_web_page_view';\n\n    var default_page_properties = _.extend(\n        _.info.mpPageViewProperties(),\n        _.info.campaignParams(),\n        _.info.clickParams()\n    );\n\n    var event_properties = _.extend(\n        {},\n        default_page_properties,\n        properties\n    );\n\n    return this.track(event_name, event_properties);\n});\n\n/**\n * Track clicks on a set of document elements. Selector must be a\n * valid query. Elements must exist on the page at the time track_links is called.\n *\n * ### Usage:\n *\n *     // track click for link id #nav\n *     mixpanel.track_links('#nav', 'Clicked Nav Link');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the Mixpanel\n * servers to respond. If they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] A properties object or function that returns a dictionary of properties when passed a DOMElement\n */\nMixpanelLib.prototype.track_links = function() {\n    return this._track_dom.call(this, LinkTracker, arguments);\n};\n\n/**\n * Track form submissions. Selector must be a valid query.\n *\n * ### Usage:\n *\n *     // track submission for form id 'register'\n *     mixpanel.track_forms('#register', 'Created Account');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the mixpanel\n * servers to respond, if they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement\n */\nMixpanelLib.prototype.track_forms = function() {\n    return this._track_dom.call(this, FormTracker, arguments);\n};\n\n/**\n * Time an event by including the time between this call and a\n * later 'track' call for the same event in the properties sent\n * with the event.\n *\n * ### Usage:\n *\n *     // time an event named 'Registered'\n *     mixpanel.time_event('Registered');\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n * When called for a particular event name, the next track call for that event\n * name will include the elapsed time between the 'time_event' and 'track'\n * calls. This value is stored as seconds in the '$duration' property.\n *\n * @param {String} event_name The name of the event.\n */\nMixpanelLib.prototype.time_event = function(event_name) {\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.time_event');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        return;\n    }\n\n    this['persistence'].set_event_timer(event_name,  new Date().getTime());\n};\n\nvar REGISTER_DEFAULTS = {\n    'persistent': true\n};\n/**\n * Helper to parse options param for register methods, maintaining\n * legacy support for plain \"days\" param instead of options object\n * @param {Number|Object} [days_or_options] 'days' option (Number), or Options object for register methods\n * @returns {Object} options object\n */\nvar options_for_register = function(days_or_options) {\n    var options;\n    if (_.isObject(days_or_options)) {\n        options = days_or_options;\n    } else if (!_.isUndefined(days_or_options)) {\n        options = {'days': days_or_options};\n    } else {\n        options = {};\n    }\n    return _.extend({}, REGISTER_DEFAULTS, options);\n};\n\n/**\n * Register a set of super properties, which are included with all\n * events. This will overwrite previous super property values.\n *\n * ### Usage:\n *\n *     // register 'Gender' as a super property\n *     mixpanel.register({'Gender': 'Female'});\n *\n *     // register several super properties when a user signs up\n *     mixpanel.register({\n *         'Email': 'jdoe@example.com',\n *         'Account Type': 'Free'\n *     });\n *\n *     // register only for the current pageload\n *     mixpanel.register({'Name': 'Pat'}, {persistent: false});\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register = function(props, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register(props, options['days']);\n    } else {\n        _.extend(this.unpersisted_superprops, props);\n    }\n};\n\n/**\n * Register a set of super properties only once. This will not\n * overwrite previous super property values, unlike register().\n *\n * ### Usage:\n *\n *     // register a super property for the first time only\n *     mixpanel.register_once({\n *         'First Login Date': new Date().toISOString()\n *     });\n *\n *     // register once, only for the current pageload\n *     mixpanel.register_once({\n *         'First interaction time': new Date().toISOString()\n *     }, 'None', {persistent: false});\n *\n * ### Notes:\n *\n * If default_value is specified, current super properties\n * with that value will be overwritten.\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {*} [default_value] Value to override if already set in super properties (ex: 'False') Default: 'None'\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register_once(props, default_value, options['days']);\n    } else {\n        if (typeof(default_value) === 'undefined') {\n            default_value = 'None';\n        }\n        _.each(props, function(val, prop) {\n            if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {\n                this.unpersisted_superprops[prop] = val;\n            }\n        }, this);\n    }\n};\n\n/**\n * Delete a super property stored with the current user.\n *\n * @param {String} property The name of the super property to remove\n * @param {Object} [options]\n * @param {boolean} [options.persistent=true] - whether to look in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.unregister = function(property, options) {\n    options = options_for_register(options);\n    if (options['persistent']) {\n        this['persistence'].unregister(property);\n    } else {\n        delete this.unpersisted_superprops[property];\n    }\n};\n\nMixpanelLib.prototype._register_single = function(prop, value) {\n    var props = {};\n    props[prop] = value;\n    this.register(props);\n};\n\n/**\n * Identify a user with a unique ID to track user activity across\n * devices, tie a user to their events, and create a user profile.\n * If you never call this method, unique visitors are tracked using\n * a UUID generated the first time they visit the site.\n *\n * Call identify when you know the identity of the current user,\n * typically after login or signup. We recommend against using\n * identify for anonymous visitors to your site.\n *\n * ### Notes:\n * If your project has\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the identify method will connect pre- and\n * post-authentication events when appropriate.\n *\n * If your project does not have ID Merge enabled, identify will\n * change the user's local distinct_id to the unique ID you pass.\n * Events tracked prior to authentication will not be connected\n * to the same user identity. If ID Merge is disabled, alias can\n * be used to connect pre- and post-registration events.\n *\n * @param {String} [unique_id] A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.\n */\nMixpanelLib.prototype.identify = function(\n    new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    // Optional Parameters\n    //  _set_callback:function  A callback to be run if and when the People set queue is flushed\n    //  _add_callback:function  A callback to be run if and when the People add queue is flushed\n    //  _append_callback:function  A callback to be run if and when the People append queue is flushed\n    //  _set_once_callback:function  A callback to be run if and when the People set_once queue is flushed\n    //  _union_callback:function  A callback to be run if and when the People union queue is flushed\n    //  _unset_callback:function  A callback to be run if and when the People unset queue is flushed\n\n    var previous_distinct_id = this.get_distinct_id();\n    if (new_distinct_id && previous_distinct_id !== new_distinct_id) {\n        // we allow the following condition if previous distinct_id is same as new_distinct_id\n        // so that you can force flush people updates for anonymous profiles.\n        if (typeof new_distinct_id === 'string' && new_distinct_id.indexOf(DEVICE_ID_PREFIX) === 0) {\n            this.report_error('distinct_id cannot have $device: prefix');\n            return -1;\n        }\n        this.register({'$user_id': new_distinct_id});\n    }\n\n    if (!this.get_property('$device_id')) {\n        // The persisted distinct id might not actually be a device id at all\n        // it might be a distinct id of the user from before\n        var device_id = previous_distinct_id;\n        this.register_once({\n            '$had_persisted_distinct_id': true,\n            '$device_id': device_id\n        }, '');\n    }\n\n    // identify only changes the distinct id if it doesn't match either the existing or the alias;\n    // if it's new, blow away the alias as well.\n    if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {\n        this.unregister(ALIAS_ID_KEY);\n        this.register({'distinct_id': new_distinct_id});\n    }\n    this._flags.identify_called = true;\n    // Flush any queued up people requests\n    this['people']._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);\n\n    // send an $identify event any time the distinct_id is changing - logic on the server\n    // will determine whether or not to do anything with it.\n    if (new_distinct_id !== previous_distinct_id) {\n        this.track('$identify', {\n            'distinct_id': new_distinct_id,\n            '$anon_distinct_id': previous_distinct_id\n        }, {skip_hooks: true});\n    }\n};\n\n/**\n * Clears super properties and generates a new random distinct_id for this instance.\n * Useful for clearing data when a user logs out.\n */\nMixpanelLib.prototype.reset = function() {\n    this['persistence'].clear();\n    this._flags.identify_called = false;\n    var uuid = _.UUID();\n    this.register_once({\n        'distinct_id': DEVICE_ID_PREFIX + uuid,\n        '$device_id': uuid\n    }, '');\n};\n\n/**\n * Returns the current distinct id of the user. This is either the id automatically\n * generated by the library or the id that has been passed by a call to identify().\n *\n * ### Notes:\n *\n * get_distinct_id() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // set distinct_id after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             distinct_id = mixpanel.get_distinct_id();\n *         }\n *     });\n */\nMixpanelLib.prototype.get_distinct_id = function() {\n    return this.get_property('distinct_id');\n};\n\n/**\n * The alias method creates an alias which Mixpanel will use to\n * remap one id to another. Multiple aliases can point to the\n * same identifier.\n *\n * The following is a valid use of alias:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // You can add multiple id aliases to the existing ID\n *     mixpanel.alias('newer_id', 'existing_id');\n *\n * Aliases can also be chained - the following is a valid example:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // chain newer_id - new_id - existing_id\n *     mixpanel.alias('newer_id', 'new_id');\n *\n * Aliases cannot point to multiple identifiers - the following\n * example will not work:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // this is invalid as 'new_id' already points to 'existing_id'\n *     mixpanel.alias('new_id', 'newer_id');\n *\n * ### Notes:\n *\n * If your project does not have\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the best practice is to call alias once when a unique\n * ID is first created for a user (e.g., when a user first registers\n * for an account). Do not use alias multiple times for a single\n * user without ID Merge enabled.\n *\n * @param {String} alias A unique identifier that you want to use for this user in the future.\n * @param {String} [original] The current identifier being used for this user.\n */\nMixpanelLib.prototype.alias = function(alias, original) {\n    // If the $people_distinct_id key exists in persistence, there has been a previous\n    // mixpanel.people.identify() call made for this user. It is VERY BAD to make an alias with\n    // this ID, as it will duplicate users.\n    if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {\n        this.report_error('Attempting to create alias for existing People user - aborting.');\n        return -2;\n    }\n\n    var _this = this;\n    if (_.isUndefined(original)) {\n        original = this.get_distinct_id();\n    }\n    if (alias !== original) {\n        this._register_single(ALIAS_ID_KEY, alias);\n        return this.track('$create_alias', {\n            'alias': alias,\n            'distinct_id': original\n        }, {\n            skip_hooks: true\n        }, function() {\n            // Flush the people queue\n            _this.identify(alias);\n        });\n    } else {\n        this.report_error('alias matches current distinct_id - skipping api call.');\n        this.identify(alias);\n        return -1;\n    }\n};\n\n/**\n * Provide a string to recognize the user by. The string passed to\n * this method will appear in the Mixpanel Streams product rather\n * than an automatically generated name. Name tags do not have to\n * be unique.\n *\n * This value will only be included in Streams data.\n *\n * @param {String} name_tag A human readable name for the user\n * @deprecated\n */\nMixpanelLib.prototype.name_tag = function(name_tag) {\n    this._register_single('mp_name_tag', name_tag);\n};\n\n/**\n * Update the configuration of a mixpanel library instance.\n *\n * The default config is:\n *\n *     {\n *       // host for requests (customizable for e.g. a local proxy)\n *       api_host: 'https://api-js.mixpanel.com',\n *\n *       // endpoints for different types of requests\n *       api_routes: {\n *         track: 'track/',\n *         engage: 'engage/',\n *         groups: 'groups/',\n *       }\n *\n *       // HTTP method for tracking requests\n *       api_method: 'POST'\n *\n *       // transport for sending requests ('XHR' or 'sendBeacon')\n *       // NB: sendBeacon should only be used for scenarios such as\n *       // page unload where a \"best-effort\" attempt to send is\n *       // acceptable; the sendBeacon API does not support callbacks\n *       // or any way to know the result of the request. Mixpanel\n *       // tracking via sendBeacon will not support any event-\n *       // batching or retry mechanisms.\n *       api_transport: 'XHR'\n *\n *       // request-batching/queueing/retry\n *       batch_requests: true,\n *\n *       // maximum number of events/updates to send in a single\n *       // network request\n *       batch_size: 50,\n *\n *       // milliseconds to wait between sending batch requests\n *       batch_flush_interval_ms: 5000,\n *\n *       // milliseconds to wait for network responses to batch requests\n *       // before they are considered timed-out and retried\n *       batch_request_timeout_ms: 90000,\n *\n *       // override value for cookie domain, only useful for ensuring\n *       // correct cross-subdomain cookies on unusual domains like\n *       // subdomain.mainsite.avocat.fr; NB this cannot be used to\n *       // set cookies on a different domain than the current origin\n *       cookie_domain: ''\n *\n *       // super properties cookie expiration (in days)\n *       cookie_expiration: 365\n *\n *       // if true, cookie will be set with SameSite=None; Secure\n *       // this is only useful in special situations, like embedded\n *       // 3rd-party iframes that set up a Mixpanel instance\n *       cross_site_cookie: false\n *\n *       // super properties span subdomains\n *       cross_subdomain_cookie: true\n *\n *       // debug mode\n *       debug: false\n *\n *       // if this is true, the mixpanel cookie or localStorage entry\n *       // will be deleted, and no user persistence will take place\n *       disable_persistence: false\n *\n *       // if this is true, Mixpanel will automatically determine\n *       // City, Region and Country data using the IP address of\n *       //the client\n *       ip: true\n *\n *       // opt users out of tracking by this Mixpanel instance by default\n *       opt_out_tracking_by_default: false\n *\n *       // opt users out of browser data storage by this Mixpanel instance by default\n *       opt_out_persistence_by_default: false\n *\n *       // persistence mechanism used by opt-in/opt-out methods - cookie\n *       // or localStorage - falls back to cookie if localStorage is unavailable\n *       opt_out_tracking_persistence_type: 'localStorage'\n *\n *       // customize the name of cookie/localStorage set by opt-in/opt-out methods\n *       opt_out_tracking_cookie_prefix: null\n *\n *       // type of persistent store for super properties (cookie/\n *       // localStorage) if set to 'localStorage', any existing\n *       // mixpanel cookie value with the same persistence_name\n *       // will be transferred to localStorage and deleted\n *       persistence: 'cookie'\n *\n *       // name for super properties persistent store\n *       persistence_name: ''\n *\n *       // names of properties/superproperties which should never\n *       // be sent with track() calls\n *       property_blacklist: []\n *\n *       // if this is true, mixpanel cookies will be marked as\n *       // secure, meaning they will only be transmitted over https\n *       secure_cookie: false\n *\n *       // disables enriching user profiles with first touch marketing data\n *       skip_first_touch_marketing: false\n *\n *       // the amount of time track_links will\n *       // wait for Mixpanel's servers to respond\n *       track_links_timeout: 300\n *\n *       // adds any UTM parameters and click IDs present on the page to any events fired\n *       track_marketing: true\n *\n *       // enables automatic page view tracking using default page view events through\n *       // the track_pageview() method\n *       track_pageview: false\n *\n *       // if you set upgrade to be true, the library will check for\n *       // a cookie from our old js library and import super\n *       // properties from it, then the old cookie is deleted\n *       // The upgrade config option only works in the initialization,\n *       // so make sure you set it when you create the library.\n *       upgrade: false\n *\n *       // extra HTTP request headers to set for each API request, in\n *       // the format {'Header-Name': value}\n *       xhr_headers: {}\n *\n *       // whether to ignore or respect the web browser's Do Not Track setting\n *       ignore_dnt: false\n *     }\n *\n *\n * @param {Object} config A dictionary of new configuration values to update\n */\nMixpanelLib.prototype.set_config = function(config) {\n    if (_.isObject(config)) {\n        _.extend(this['config'], config);\n\n        var new_batch_size = config['batch_size'];\n        if (new_batch_size) {\n            _.each(this.request_batchers, function(batcher) {\n                batcher.resetBatchSize();\n            });\n        }\n\n        if (!this.get_config('persistence_name')) {\n            this['config']['persistence_name'] = this['config']['cookie_name'];\n        }\n        if (!this.get_config('disable_persistence')) {\n            this['config']['disable_persistence'] = this['config']['disable_cookie'];\n        }\n\n        if (this['persistence']) {\n            this['persistence'].update_config(this['config']);\n        }\n        Config.DEBUG = Config.DEBUG || this.get_config('debug');\n    }\n};\n\n/**\n * returns the current config object for the library.\n */\nMixpanelLib.prototype.get_config = function(prop_name) {\n    return this['config'][prop_name];\n};\n\n/**\n * Fetch a hook function from config, with safe default, and run it\n * against the given arguments\n * @param {string} hook_name which hook to retrieve\n * @returns {any|null} return value of user-provided hook, or null if nothing was returned\n */\nMixpanelLib.prototype._run_hook = function(hook_name) {\n    var ret = (this['config']['hooks'][hook_name] || IDENTITY_FUNC).apply(this, slice.call(arguments, 1));\n    if (typeof ret === 'undefined') {\n        this.report_error(hook_name + ' hook did not return a value');\n        ret = null;\n    }\n    return ret;\n};\n\n/**\n * Returns the value of the super property named property_name. If no such\n * property is set, get_property() will return the undefined value.\n *\n * ### Notes:\n *\n * get_property() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // grab value for 'user_id' after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             user_id = mixpanel.get_property('user_id');\n *         }\n *     });\n *\n * @param {String} property_name The name of the super property you want to retrieve\n */\nMixpanelLib.prototype.get_property = function(property_name) {\n    return this['persistence'].load_prop([property_name]);\n};\n\nMixpanelLib.prototype.toString = function() {\n    var name = this.get_config('name');\n    if (name !== PRIMARY_INSTANCE_NAME) {\n        name = PRIMARY_INSTANCE_NAME + '.' + name;\n    }\n    return name;\n};\n\nMixpanelLib.prototype._event_is_disabled = function(event_name) {\n    return _.isBlockedUA(userAgent) ||\n        this._flags.disable_all_events ||\n        _.include(this.__disabled_events, event_name);\n};\n\n// perform some housekeeping around GDPR opt-in/out state\nMixpanelLib.prototype._gdpr_init = function() {\n    var is_localStorage_requested = this.get_config('opt_out_tracking_persistence_type') === 'localStorage';\n\n    // try to convert opt-in/out cookies to localStorage if possible\n    if (is_localStorage_requested && _.localStorage.is_supported()) {\n        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({'persistence_type': 'cookie'})) {\n            this.opt_in_tracking({'enable_persistence': false});\n        }\n        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({'persistence_type': 'cookie'})) {\n            this.opt_out_tracking({'clear_persistence': false});\n        }\n        this.clear_opt_in_out_tracking({\n            'persistence_type': 'cookie',\n            'enable_persistence': false\n        });\n    }\n\n    // check whether the user has already opted out - if so, clear & disable persistence\n    if (this.has_opted_out_tracking()) {\n        this._gdpr_update_persistence({'clear_persistence': true});\n\n    // check whether we should opt out by default\n    // note: we don't clear persistence here by default since opt-out default state is often\n    //       used as an initial state while GDPR information is being collected\n    } else if (!this.has_opted_in_tracking() && (\n        this.get_config('opt_out_tracking_by_default') || _.cookie.get('mp_optout')\n    )) {\n        _.cookie.remove('mp_optout');\n        this.opt_out_tracking({\n            'clear_persistence': this.get_config('opt_out_persistence_by_default')\n        });\n    }\n};\n\n/**\n * Enable or disable persistence based on options\n * only enable/disable if persistence is not already in this state\n * @param {boolean} [options.clear_persistence] If true, will delete all data stored by the sdk in persistence and disable it\n * @param {boolean} [options.enable_persistence] If true, will re-enable sdk persistence\n */\nMixpanelLib.prototype._gdpr_update_persistence = function(options) {\n    var disabled;\n    if (options && options['clear_persistence']) {\n        disabled = true;\n    } else if (options && options['enable_persistence']) {\n        disabled = false;\n    } else {\n        return;\n    }\n\n    if (!this.get_config('disable_persistence') && this['persistence'].disabled !== disabled) {\n        this['persistence'].set_disabled(disabled);\n    }\n\n    if (disabled) {\n        this.stop_batch_senders();\n    } else {\n        // only start batchers after opt-in if they have previously been started\n        // in order to avoid unintentionally starting up batching for the first time\n        if (this._batchers_were_started) {\n            this.start_batch_senders();\n        }\n    }\n};\n\n// call a base gdpr function after constructing the appropriate token and options args\nMixpanelLib.prototype._gdpr_call_func = function(func, options) {\n    options = _.extend({\n        'track': _.bind(this.track, this),\n        'persistence_type': this.get_config('opt_out_tracking_persistence_type'),\n        'cookie_prefix': this.get_config('opt_out_tracking_cookie_prefix'),\n        'cookie_expiration': this.get_config('cookie_expiration'),\n        'cross_site_cookie': this.get_config('cross_site_cookie'),\n        'cross_subdomain_cookie': this.get_config('cross_subdomain_cookie'),\n        'cookie_domain': this.get_config('cookie_domain'),\n        'secure_cookie': this.get_config('secure_cookie'),\n        'ignore_dnt': this.get_config('ignore_dnt')\n    }, options);\n\n    // check if localStorage can be used for recording opt out status, fall back to cookie if not\n    if (!_.localStorage.is_supported()) {\n        options['persistence_type'] = 'cookie';\n    }\n\n    return func(this.get_config('token'), {\n        track: options['track'],\n        trackEventName: options['track_event_name'],\n        trackProperties: options['track_properties'],\n        persistenceType: options['persistence_type'],\n        persistencePrefix: options['cookie_prefix'],\n        cookieDomain: options['cookie_domain'],\n        cookieExpiration: options['cookie_expiration'],\n        crossSiteCookie: options['cross_site_cookie'],\n        crossSubdomainCookie: options['cross_subdomain_cookie'],\n        secureCookie: options['secure_cookie'],\n        ignoreDnt: options['ignore_dnt']\n    });\n};\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user in\n *     mixpanel.opt_in_tracking();\n *\n *     // opt user in with specific event name, properties, cookie configuration\n *     mixpanel.opt_in_tracking({\n *         track_event_name: 'User opted in',\n *         track_event_properties: {\n *             'Email': 'jdoe@example.com'\n *         },\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {function} [options.track] Function used for tracking a Mixpanel event to record the opt-in action (default is this Mixpanel instance's track method)\n * @param {string} [options.track_event_name=$opt_in] Event name to be used for tracking the opt-in action\n * @param {Object} [options.track_properties] Set of properties to be tracked along with the opt-in action\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_in_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(optIn, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user out\n *     mixpanel.opt_out_tracking();\n *\n *     // opt user out with different cookie configuration from Mixpanel instance\n *     mixpanel.opt_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.delete_user=true] If true, will delete the currently identified user's profile and clear all charges after opting the user out\n * @param {boolean} [options.clear_persistence=true] If true, will delete all data stored by the sdk in persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_out_tracking = function(options) {\n    options = _.extend({\n        'clear_persistence': true,\n        'delete_user': true\n    }, options);\n\n    // delete user and clear charges since these methods may be disabled by opt-out\n    if (options['delete_user'] && this['people'] && this['people']._identify_called()) {\n        this['people'].delete_user();\n        this['people'].clear_charges();\n    }\n\n    this._gdpr_call_func(optOut, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_in = mixpanel.has_opted_in_tracking();\n *     // use has_opted_in value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-in status\n */\nMixpanelLib.prototype.has_opted_in_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedIn, options);\n};\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_out = mixpanel.has_opted_out_tracking();\n *     // use has_opted_out value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-out status\n */\nMixpanelLib.prototype.has_opted_out_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedOut, options);\n};\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // clear user's opt-in/out status\n *     mixpanel.clear_opt_in_out_tracking();\n *\n *     // clear user's opt-in/out status with specific cookie configuration - should match\n *     // configuration used when opt_in_tracking/opt_out_tracking methods were called.\n *     mixpanel.clear_opt_in_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(clearOptInOut, options);\n    this._gdpr_update_persistence(options);\n};\n\nMixpanelLib.prototype.report_error = function(msg, err) {\n    console$1.error.apply(console$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.get_config('error_reporter')(msg, err);\n    } catch(err) {\n        console$1.error(err);\n    }\n};\n\n// EXPORTS (for closure compiler)\n\n// MixpanelLib Exports\nMixpanelLib.prototype['init']                               = MixpanelLib.prototype.init;\nMixpanelLib.prototype['reset']                              = MixpanelLib.prototype.reset;\nMixpanelLib.prototype['disable']                            = MixpanelLib.prototype.disable;\nMixpanelLib.prototype['time_event']                         = MixpanelLib.prototype.time_event;\nMixpanelLib.prototype['track']                              = MixpanelLib.prototype.track;\nMixpanelLib.prototype['track_links']                        = MixpanelLib.prototype.track_links;\nMixpanelLib.prototype['track_forms']                        = MixpanelLib.prototype.track_forms;\nMixpanelLib.prototype['track_pageview']                     = MixpanelLib.prototype.track_pageview;\nMixpanelLib.prototype['register']                           = MixpanelLib.prototype.register;\nMixpanelLib.prototype['register_once']                      = MixpanelLib.prototype.register_once;\nMixpanelLib.prototype['unregister']                         = MixpanelLib.prototype.unregister;\nMixpanelLib.prototype['identify']                           = MixpanelLib.prototype.identify;\nMixpanelLib.prototype['alias']                              = MixpanelLib.prototype.alias;\nMixpanelLib.prototype['name_tag']                           = MixpanelLib.prototype.name_tag;\nMixpanelLib.prototype['set_config']                         = MixpanelLib.prototype.set_config;\nMixpanelLib.prototype['get_config']                         = MixpanelLib.prototype.get_config;\nMixpanelLib.prototype['get_property']                       = MixpanelLib.prototype.get_property;\nMixpanelLib.prototype['get_distinct_id']                    = MixpanelLib.prototype.get_distinct_id;\nMixpanelLib.prototype['toString']                           = MixpanelLib.prototype.toString;\nMixpanelLib.prototype['opt_out_tracking']                   = MixpanelLib.prototype.opt_out_tracking;\nMixpanelLib.prototype['opt_in_tracking']                    = MixpanelLib.prototype.opt_in_tracking;\nMixpanelLib.prototype['has_opted_out_tracking']             = MixpanelLib.prototype.has_opted_out_tracking;\nMixpanelLib.prototype['has_opted_in_tracking']              = MixpanelLib.prototype.has_opted_in_tracking;\nMixpanelLib.prototype['clear_opt_in_out_tracking']          = MixpanelLib.prototype.clear_opt_in_out_tracking;\nMixpanelLib.prototype['get_group']                          = MixpanelLib.prototype.get_group;\nMixpanelLib.prototype['set_group']                          = MixpanelLib.prototype.set_group;\nMixpanelLib.prototype['add_group']                          = MixpanelLib.prototype.add_group;\nMixpanelLib.prototype['remove_group']                       = MixpanelLib.prototype.remove_group;\nMixpanelLib.prototype['track_with_groups']                  = MixpanelLib.prototype.track_with_groups;\nMixpanelLib.prototype['start_batch_senders']                = MixpanelLib.prototype.start_batch_senders;\nMixpanelLib.prototype['stop_batch_senders']                 = MixpanelLib.prototype.stop_batch_senders;\nMixpanelLib.prototype['start_session_recording']            = MixpanelLib.prototype.start_session_recording;\nMixpanelLib.prototype['stop_session_recording']             = MixpanelLib.prototype.stop_session_recording;\nMixpanelLib.prototype['get_session_recording_properties']   = MixpanelLib.prototype.get_session_recording_properties;\nMixpanelLib.prototype['get_session_replay_url']             = MixpanelLib.prototype.get_session_replay_url;\nMixpanelLib.prototype['DEFAULT_API_ROUTES']                 = DEFAULT_API_ROUTES;\n\n// MixpanelPersistence Exports\nMixpanelPersistence.prototype['properties']            = MixpanelPersistence.prototype.properties;\nMixpanelPersistence.prototype['update_search_keyword'] = MixpanelPersistence.prototype.update_search_keyword;\nMixpanelPersistence.prototype['update_referrer_info']  = MixpanelPersistence.prototype.update_referrer_info;\nMixpanelPersistence.prototype['get_cross_subdomain']   = MixpanelPersistence.prototype.get_cross_subdomain;\nMixpanelPersistence.prototype['clear']                 = MixpanelPersistence.prototype.clear;\n\n\nvar instances = {};\nvar extend_mp = function() {\n    // add all the sub mixpanel instances\n    _.each(instances, function(instance, name) {\n        if (name !== PRIMARY_INSTANCE_NAME) { mixpanel_master[name] = instance; }\n    });\n\n    // add private functions as _\n    mixpanel_master['_'] = _;\n};\n\nvar override_mp_init_func = function() {\n    // we override the snippets init function to handle the case where a\n    // user initializes the mixpanel library after the script loads & runs\n    mixpanel_master['init'] = function(token, config, name) {\n        if (name) {\n            // initialize a sub library\n            if (!mixpanel_master[name]) {\n                mixpanel_master[name] = instances[name] = create_mplib(token, config, name);\n                mixpanel_master[name]._loaded();\n            }\n            return mixpanel_master[name];\n        } else {\n            var instance = mixpanel_master;\n\n            if (instances[PRIMARY_INSTANCE_NAME]) {\n                // main mixpanel lib already initialized\n                instance = instances[PRIMARY_INSTANCE_NAME];\n            } else if (token) {\n                // intialize the main mixpanel lib\n                instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);\n                instance._loaded();\n                instances[PRIMARY_INSTANCE_NAME] = instance;\n            }\n\n            mixpanel_master = instance;\n            if (init_type === INIT_SNIPPET) {\n                win[PRIMARY_INSTANCE_NAME] = mixpanel_master;\n            }\n            extend_mp();\n        }\n    };\n};\n\nvar add_dom_loaded_handler = function() {\n    // Cross browser DOM Loaded support\n    function dom_loaded_handler() {\n        // function flag since we only want to execute this once\n        if (dom_loaded_handler.done) { return; }\n        dom_loaded_handler.done = true;\n\n        DOM_LOADED = true;\n        ENQUEUE_REQUESTS = false;\n\n        _.each(instances, function(inst) {\n            inst._dom_loaded();\n        });\n    }\n\n    function do_scroll_check() {\n        try {\n            document$1.documentElement.doScroll('left');\n        } catch(e) {\n            setTimeout(do_scroll_check, 1);\n            return;\n        }\n\n        dom_loaded_handler();\n    }\n\n    if (document$1.addEventListener) {\n        if (document$1.readyState === 'complete') {\n            // safari 4 can fire the DOMContentLoaded event before loading all\n            // external JS (including this file). you will see some copypasta\n            // on the internet that checks for 'complete' and 'loaded', but\n            // 'loaded' is an IE thing\n            dom_loaded_handler();\n        } else {\n            document$1.addEventListener('DOMContentLoaded', dom_loaded_handler, false);\n        }\n    } else if (document$1.attachEvent) {\n        // IE\n        document$1.attachEvent('onreadystatechange', dom_loaded_handler);\n\n        // check to make sure we arn't in a frame\n        var toplevel = false;\n        try {\n            toplevel = win.frameElement === null;\n        } catch(e) {\n            // noop\n        }\n\n        if (document$1.documentElement.doScroll && toplevel) {\n            do_scroll_check();\n        }\n    }\n\n    // fallback handler, always will work\n    _.register_event(win, 'load', dom_loaded_handler, true);\n};\n\nfunction init_as_module(bundle_loader) {\n    load_extra_bundle = bundle_loader;\n    init_type = INIT_MODULE;\n    mixpanel_master = new MixpanelLib();\n\n    override_mp_init_func();\n    mixpanel_master['init']();\n    add_dom_loaded_handler();\n\n    return mixpanel_master;\n}\n\n// For loading separate bundles asynchronously via script tag\n\n// For builds that have everything in one bundle, no extra work.\nfunction loadNoop (_src, onload) {\n    onload();\n}\n\n/* eslint camelcase: \"off\" */\n\nvar mixpanel = init_as_module(loadNoop);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELDBEQUEwRDtBQUMxRCwwREFBMEQsb0NBQW9DLHNCQUFzQjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EseUNBQXlDLDBCQUEwQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUErRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXLEVBQUUsU0FBUyxFQUFFLFdBQVc7QUFDN0Q7QUFDQTtBQUNBLDBCQUEwQixXQUFXLEVBQUUsU0FBUyxFQUFFLFdBQVc7QUFDN0Q7QUFDQTtBQUNBLDBCQUEwQixXQUFXLEVBQUUsK0JBQStCLEVBQUUsV0FBVztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVyxFQUFFLGdCQUFnQixFQUFFLFdBQVc7QUFDaEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMElBQTBJLDhEQUE4RCwrTUFBK007QUFDbmEsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELElBQUk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNFpBQTRaO0FBQ3hhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUcsR0FBRyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMseUNBQXlDO0FBQ3pDLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFzTTtBQUNsTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0NBQXNDO0FBQ3BGLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUE2QztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELGdDQUFnQztBQUNoQyxpQ0FBaUMsTUFBTSwwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FB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QXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsMEVBQTBFLFdBQVc7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSw4QkFBOEI7QUFDOUIsaUdBQWlHLFdBQVc7QUFDNUc7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLDhCQUE4QjtBQUM5QixxREFBcUQ7QUFDckQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0IsYUFBYTtBQUNuQyxTQUFTO0FBQ1QsS0FBSztBQUNMLGtCQUFrQixnQ0FBZ0M7QUFDbEQsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQseUJBQXlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QixVQUFVLEdBQUc7QUFDYixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsR0FBRztBQUNiLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFVBQVUsZUFBZTtBQUN6QixVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTiwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsR0FBRztBQUNiLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxHQUFHO0FBQ2IsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxHQUFHO0FBQ2IsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVGQUF1Rix1QkFBdUI7QUFDOUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLElBQUk7QUFDZCxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUEsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVcsR0FBRyxRQUFRLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNB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Q0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUUsNkJBQTZCO0FBQ3RHLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQSwyRUFBMkUsNkJBQTZCO0FBQ3hHLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEI7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUUrQiIsInNvdXJjZXMiOlsid2VicGFjazovL+Ckn+Clh+CkleCkruCkqOCljeCkpeCkqC8uL25vZGVfbW9kdWxlcy9taXhwYW5lbC1icm93c2VyL2Rpc3QvbWl4cGFuZWwubW9kdWxlLmpzPzI1NzQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE5vZGVUeXBlO1xyXG4oZnVuY3Rpb24gKE5vZGVUeXBlKSB7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRWxlbWVudFwiXSA9IDJdID0gXCJFbGVtZW50XCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xyXG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xyXG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJDb21tZW50XCJdID0gNV0gPSBcIkNvbW1lbnRcIjtcclxufSkoTm9kZVR5cGUgfHwgKE5vZGVUeXBlID0ge30pKTtcblxuZnVuY3Rpb24gaXNFbGVtZW50KG4pIHtcclxuICAgIHJldHVybiBuLm5vZGVUeXBlID09PSBuLkVMRU1FTlRfTk9ERTtcclxufVxyXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobikge1xyXG4gICAgY29uc3QgaG9zdCA9IG4gPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbi5ob3N0O1xyXG4gICAgcmV0dXJuIEJvb2xlYW4oKGhvc3QgPT09IG51bGwgfHwgaG9zdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdC5zaGFkb3dSb290KSA9PT0gbik7XHJcbn1cclxuZnVuY3Rpb24gaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzaGFkb3dSb290KSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nO1xyXG59XHJcbmZ1bmN0aW9uIGZpeEJyb3dzZXJDb21wYXRpYmlsaXR5SXNzdWVzSW5DU1MoY3NzVGV4dCkge1xyXG4gICAgaWYgKGNzc1RleHQuaW5jbHVkZXMoJyBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7JykgJiZcclxuICAgICAgICAhY3NzVGV4dC5pbmNsdWRlcygnIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0OycpKSB7XHJcbiAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZSgnIGJhY2tncm91bmQtY2xpcDogdGV4dDsnLCAnIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0OyBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7Jyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3NzVGV4dDtcclxufVxyXG5mdW5jdGlvbiBlc2NhcGVJbXBvcnRTdGF0ZW1lbnQocnVsZSkge1xyXG4gICAgY29uc3QgeyBjc3NUZXh0IH0gPSBydWxlO1xyXG4gICAgaWYgKGNzc1RleHQuc3BsaXQoJ1wiJykubGVuZ3RoIDwgMylcclxuICAgICAgICByZXR1cm4gY3NzVGV4dDtcclxuICAgIGNvbnN0IHN0YXRlbWVudCA9IFsnQGltcG9ydCcsIGB1cmwoJHtKU09OLnN0cmluZ2lmeShydWxlLmhyZWYpfSlgXTtcclxuICAgIGlmIChydWxlLmxheWVyTmFtZSA9PT0gJycpIHtcclxuICAgICAgICBzdGF0ZW1lbnQucHVzaChgbGF5ZXJgKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJ1bGUubGF5ZXJOYW1lKSB7XHJcbiAgICAgICAgc3RhdGVtZW50LnB1c2goYGxheWVyKCR7cnVsZS5sYXllck5hbWV9KWApO1xyXG4gICAgfVxyXG4gICAgaWYgKHJ1bGUuc3VwcG9ydHNUZXh0KSB7XHJcbiAgICAgICAgc3RhdGVtZW50LnB1c2goYHN1cHBvcnRzKCR7cnVsZS5zdXBwb3J0c1RleHR9KWApO1xyXG4gICAgfVxyXG4gICAgaWYgKHJ1bGUubWVkaWEubGVuZ3RoKSB7XHJcbiAgICAgICAgc3RhdGVtZW50LnB1c2gocnVsZS5tZWRpYS5tZWRpYVRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXRlbWVudC5qb2luKCcgJykgKyAnOyc7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGVzaGVldChzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJ1bGVzID0gcy5ydWxlcyB8fCBzLmNzc1J1bGVzO1xyXG4gICAgICAgIHJldHVybiBydWxlc1xyXG4gICAgICAgICAgICA/IGZpeEJyb3dzZXJDb21wYXRpYmlsaXR5SXNzdWVzSW5DU1MoQXJyYXkuZnJvbShydWxlcywgc3RyaW5naWZ5UnVsZSkuam9pbignJykpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVJ1bGUocnVsZSkge1xyXG4gICAgbGV0IGltcG9ydFN0cmluZ2lmaWVkO1xyXG4gICAgaWYgKGlzQ1NTSW1wb3J0UnVsZShydWxlKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGltcG9ydFN0cmluZ2lmaWVkID1cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeVN0eWxlc2hlZXQocnVsZS5zdHlsZVNoZWV0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNDU1NTdHlsZVJ1bGUocnVsZSkgJiYgcnVsZS5zZWxlY3RvclRleHQuaW5jbHVkZXMoJzonKSkge1xyXG4gICAgICAgIHJldHVybiBmaXhTYWZhcmlDb2xvbnMocnVsZS5jc3NUZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbXBvcnRTdHJpbmdpZmllZCB8fCBydWxlLmNzc1RleHQ7XHJcbn1cclxuZnVuY3Rpb24gZml4U2FmYXJpQ29sb25zKGNzc1N0cmluZ2lmaWVkKSB7XHJcbiAgICBjb25zdCByZWdleCA9IC8oXFxbKD86W1xcdy1dKylbXlxcXFxdKSg6KD86W1xcdy1dKylcXF0pL2dtO1xyXG4gICAgcmV0dXJuIGNzc1N0cmluZ2lmaWVkLnJlcGxhY2UocmVnZXgsICckMVxcXFwkMicpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ1NTSW1wb3J0UnVsZShydWxlKSB7XHJcbiAgICByZXR1cm4gJ3N0eWxlU2hlZXQnIGluIHJ1bGU7XHJcbn1cclxuZnVuY3Rpb24gaXNDU1NTdHlsZVJ1bGUocnVsZSkge1xyXG4gICAgcmV0dXJuICdzZWxlY3RvclRleHQnIGluIHJ1bGU7XHJcbn1cclxuY2xhc3MgTWlycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaWROb2RlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMubm9kZU1ldGFNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0SWQobikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIW4pXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBjb25zdCBpZCA9IChfYSA9IHRoaXMuZ2V0TWV0YShuKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkO1xyXG4gICAgICAgIHJldHVybiBpZCAhPT0gbnVsbCAmJiBpZCAhPT0gdm9pZCAwID8gaWQgOiAtMTtcclxuICAgIH1cclxuICAgIGdldE5vZGUoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuZ2V0KGlkKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0SWRzKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuaWROb2RlTWFwLmtleXMoKSk7XHJcbiAgICB9XHJcbiAgICBnZXRNZXRhKG4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlTWV0YU1hcC5nZXQobikgfHwgbnVsbDtcclxuICAgIH1cclxuICAgIHJlbW92ZU5vZGVGcm9tTWFwKG4pIHtcclxuICAgICAgICBjb25zdCBpZCA9IHRoaXMuZ2V0SWQobik7XHJcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAuZGVsZXRlKGlkKTtcclxuICAgICAgICBpZiAobi5jaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgICAgIG4uY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHRoaXMucmVtb3ZlTm9kZUZyb21NYXAoY2hpbGROb2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWROb2RlTWFwLmhhcyhpZCk7XHJcbiAgICB9XHJcbiAgICBoYXNOb2RlKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlTWV0YU1hcC5oYXMobm9kZSk7XHJcbiAgICB9XHJcbiAgICBhZGQobiwgbWV0YSkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gbWV0YS5pZDtcclxuICAgICAgICB0aGlzLmlkTm9kZU1hcC5zZXQoaWQsIG4pO1xyXG4gICAgICAgIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4sIG1ldGEpO1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZShpZCwgbikge1xyXG4gICAgICAgIGNvbnN0IG9sZE5vZGUgPSB0aGlzLmdldE5vZGUoaWQpO1xyXG4gICAgICAgIGlmIChvbGROb2RlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLm5vZGVNZXRhTWFwLmdldChvbGROb2RlKTtcclxuICAgICAgICAgICAgaWYgKG1ldGEpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVNZXRhTWFwLnNldChuLCBtZXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuaWROb2RlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMubm9kZU1ldGFNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU1pcnJvcigpIHtcclxuICAgIHJldHVybiBuZXcgTWlycm9yKCk7XHJcbn1cclxuZnVuY3Rpb24gbWFza0lucHV0VmFsdWUoeyBlbGVtZW50LCBtYXNrSW5wdXRPcHRpb25zLCB0YWdOYW1lLCB0eXBlLCB2YWx1ZSwgbWFza0lucHV0Rm4sIH0pIHtcclxuICAgIGxldCB0ZXh0ID0gdmFsdWUgfHwgJyc7XHJcbiAgICBjb25zdCBhY3R1YWxUeXBlID0gdHlwZSAmJiB0b0xvd2VyQ2FzZSh0eXBlKTtcclxuICAgIGlmIChtYXNrSW5wdXRPcHRpb25zW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHxcclxuICAgICAgICAoYWN0dWFsVHlwZSAmJiBtYXNrSW5wdXRPcHRpb25zW2FjdHVhbFR5cGVdKSkge1xyXG4gICAgICAgIGlmIChtYXNrSW5wdXRGbikge1xyXG4gICAgICAgICAgICB0ZXh0ID0gbWFza0lucHV0Rm4odGV4dCwgZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXh0ID0gJyonLnJlcGVhdCh0ZXh0Lmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRleHQ7XHJcbn1cclxuZnVuY3Rpb24gdG9Mb3dlckNhc2Uoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuY29uc3QgT1JJR0lOQUxfQVRUUklCVVRFX05BTUUgPSAnX19ycndlYl9vcmlnaW5hbF9fJztcclxuZnVuY3Rpb24gaXMyRENhbnZhc0JsYW5rKGNhbnZhcykge1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBpZiAoIWN0eClcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGNvbnN0IGNodW5rU2l6ZSA9IDUwO1xyXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHggKz0gY2h1bmtTaXplKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5ICs9IGNodW5rU2l6ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBnZXRJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhO1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEdldEltYWdlRGF0YSA9IE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FIGluIGdldEltYWdlRGF0YVxyXG4gICAgICAgICAgICAgICAgPyBnZXRJbWFnZURhdGFbT1JJR0lOQUxfQVRUUklCVVRFX05BTUVdXHJcbiAgICAgICAgICAgICAgICA6IGdldEltYWdlRGF0YTtcclxuICAgICAgICAgICAgY29uc3QgcGl4ZWxCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkob3JpZ2luYWxHZXRJbWFnZURhdGEuY2FsbChjdHgsIHgsIHksIE1hdGgubWluKGNodW5rU2l6ZSwgY2FudmFzLndpZHRoIC0geCksIE1hdGgubWluKGNodW5rU2l6ZSwgY2FudmFzLmhlaWdodCAtIHkpKS5kYXRhLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGlmIChwaXhlbEJ1ZmZlci5zb21lKChwaXhlbCkgPT4gcGl4ZWwgIT09IDApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGdldElucHV0VHlwZShlbGVtZW50KSB7XHJcbiAgICBjb25zdCB0eXBlID0gZWxlbWVudC50eXBlO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXJyLWlzLXBhc3N3b3JkJylcclxuICAgICAgICA/ICdwYXNzd29yZCdcclxuICAgICAgICA6IHR5cGVcclxuICAgICAgICAgICAgP1xyXG4gICAgICAgICAgICAgICAgdG9Mb3dlckNhc2UodHlwZSlcclxuICAgICAgICAgICAgOiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHBhdGgsIGJhc2VVUkwpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGxldCB1cmw7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHVybCA9IG5ldyBVUkwocGF0aCwgYmFzZVVSTCAhPT0gbnVsbCAmJiBiYXNlVVJMICE9PSB2b2lkIDAgPyBiYXNlVVJMIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVnZXggPSAvXFwuKFswLTlhLXpdKykoPzokKS9pO1xyXG4gICAgY29uc3QgbWF0Y2ggPSB1cmwucGF0aG5hbWUubWF0Y2gocmVnZXgpO1xyXG4gICAgcmV0dXJuIChfYSA9IG1hdGNoID09PSBudWxsIHx8IG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaFsxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcclxufVxuXG5sZXQgX2lkID0gMTtcclxuY29uc3QgdGFnTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnW15hLXowLTktXzpdJyk7XHJcbmNvbnN0IElHTk9SRURfTk9ERSA9IC0yO1xyXG5mdW5jdGlvbiBnZW5JZCgpIHtcclxuICAgIHJldHVybiBfaWQrKztcclxufVxyXG5mdW5jdGlvbiBnZXRWYWxpZFRhZ05hbWUoZWxlbWVudCkge1xyXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gJ2Zvcm0nO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvY2Vzc2VkVGFnTmFtZSA9IHRvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XHJcbiAgICBpZiAodGFnTmFtZVJlZ2V4LnRlc3QocHJvY2Vzc2VkVGFnTmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gJ2Rpdic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvY2Vzc2VkVGFnTmFtZTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0T3JpZ2luKHVybCkge1xyXG4gICAgbGV0IG9yaWdpbiA9ICcnO1xyXG4gICAgaWYgKHVybC5pbmRleE9mKCcvLycpID4gLTEpIHtcclxuICAgICAgICBvcmlnaW4gPSB1cmwuc3BsaXQoJy8nKS5zbGljZSgwLCAzKS5qb2luKCcvJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBvcmlnaW4gPSB1cmwuc3BsaXQoJy8nKVswXTtcclxuICAgIH1cclxuICAgIG9yaWdpbiA9IG9yaWdpbi5zcGxpdCgnPycpWzBdO1xyXG4gICAgcmV0dXJuIG9yaWdpbjtcclxufVxyXG5sZXQgY2FudmFzU2VydmljZTtcclxubGV0IGNhbnZhc0N0eDtcclxuY29uc3QgVVJMX0lOX0NTU19SRUYgPSAvdXJsXFwoKD86KCcpKFteJ10qKSd8KFwiKSguKj8pXCJ8KFteKV0qKSlcXCkvZ207XHJcbmNvbnN0IFVSTF9QUk9UT0NPTF9NQVRDSCA9IC9eKD86W2EteitdKzopP1xcL1xcLy9pO1xyXG5jb25zdCBVUkxfV1dXX01BVENIID0gL153d3dcXC4uKi9pO1xyXG5jb25zdCBEQVRBX1VSSSA9IC9eKGRhdGE6KShbXixdKiksKC4qKS9pO1xyXG5mdW5jdGlvbiBhYnNvbHV0ZVRvU3R5bGVzaGVldChjc3NUZXh0LCBocmVmKSB7XHJcbiAgICByZXR1cm4gKGNzc1RleHQgfHwgJycpLnJlcGxhY2UoVVJMX0lOX0NTU19SRUYsIChvcmlnaW4sIHF1b3RlMSwgcGF0aDEsIHF1b3RlMiwgcGF0aDIsIHBhdGgzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoMSB8fCBwYXRoMiB8fCBwYXRoMztcclxuICAgICAgICBjb25zdCBtYXliZVF1b3RlID0gcXVvdGUxIHx8IHF1b3RlMiB8fCAnJztcclxuICAgICAgICBpZiAoIWZpbGVQYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChVUkxfUFJPVE9DT0xfTUFUQ0gudGVzdChmaWxlUGF0aCkgfHwgVVJMX1dXV19NQVRDSC50ZXN0KGZpbGVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtmaWxlUGF0aH0ke21heWJlUXVvdGV9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChEQVRBX1VSSS50ZXN0KGZpbGVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtmaWxlUGF0aH0ke21heWJlUXVvdGV9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWxlUGF0aFswXSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2V4dHJhY3RPcmlnaW4oaHJlZikgKyBmaWxlUGF0aH0ke21heWJlUXVvdGV9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YWNrID0gaHJlZi5zcGxpdCgnLycpO1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gZmlsZVBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcclxuICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBhcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke3N0YWNrLmpvaW4oJy8nKX0ke21heWJlUXVvdGV9KWA7XHJcbiAgICB9KTtcclxufVxyXG5jb25zdCBTUkNTRVRfTk9UX1NQQUNFUyA9IC9eW14gXFx0XFxuXFxyXFx1MDAwY10rLztcclxuY29uc3QgU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMgPSAvXlssIFxcdFxcblxcclxcdTAwMGNdKy87XHJcbmZ1bmN0aW9uIGdldEFic29sdXRlU3Jjc2V0U3RyaW5nKGRvYywgYXR0cmlidXRlVmFsdWUpIHtcclxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xyXG4gICAgfVxyXG4gICAgbGV0IHBvcyA9IDA7XHJcbiAgICBmdW5jdGlvbiBjb2xsZWN0Q2hhcmFjdGVycyhyZWdFeCkge1xyXG4gICAgICAgIGxldCBjaGFycztcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHJlZ0V4LmV4ZWMoYXR0cmlidXRlVmFsdWUuc3Vic3RyaW5nKHBvcykpO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICBjaGFycyA9IG1hdGNoWzBdO1xyXG4gICAgICAgICAgICBwb3MgKz0gY2hhcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hhcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBjb2xsZWN0Q2hhcmFjdGVycyhTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyk7XHJcbiAgICAgICAgaWYgKHBvcyA+PSBhdHRyaWJ1dGVWYWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB1cmwgPSBjb2xsZWN0Q2hhcmFjdGVycyhTUkNTRVRfTk9UX1NQQUNFUyk7XHJcbiAgICAgICAgaWYgKHVybC5zbGljZSgtMSkgPT09ICcsJykge1xyXG4gICAgICAgICAgICB1cmwgPSBhYnNvbHV0ZVRvRG9jKGRvYywgdXJsLnN1YnN0cmluZygwLCB1cmwubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaCh1cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGRlc2NyaXB0b3JzU3RyID0gJyc7XHJcbiAgICAgICAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwpO1xyXG4gICAgICAgICAgICBsZXQgaW5QYXJlbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBhdHRyaWJ1dGVWYWx1ZS5jaGFyQXQocG9zKTtcclxuICAgICAgICAgICAgICAgIGlmIChjID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCh1cmwgKyBkZXNjcmlwdG9yc1N0cikudHJpbSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpblBhcmVucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnLCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCh1cmwgKyBkZXNjcmlwdG9yc1N0cikudHJpbSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcoJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpblBhcmVucyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcpJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpblBhcmVucyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzU3RyICs9IGM7XHJcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQuam9pbignLCAnKTtcclxufVxyXG5mdW5jdGlvbiBhYnNvbHV0ZVRvRG9jKGRvYywgYXR0cmlidXRlVmFsdWUpIHtcclxuICAgIGlmICghYXR0cmlidXRlVmFsdWUgfHwgYXR0cmlidXRlVmFsdWUudHJpbSgpID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGEgPSBkb2MuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgYS5ocmVmID0gYXR0cmlidXRlVmFsdWU7XHJcbiAgICByZXR1cm4gYS5ocmVmO1xyXG59XHJcbmZ1bmN0aW9uIGlzU1ZHRWxlbWVudChlbCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4oZWwudGFnTmFtZSA9PT0gJ3N2ZycgfHwgZWwub3duZXJTVkdFbGVtZW50KTtcclxufVxyXG5mdW5jdGlvbiBnZXRIcmVmKCkge1xyXG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgIGEuaHJlZiA9ICcnO1xyXG4gICAgcmV0dXJuIGEuaHJlZjtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1BdHRyaWJ1dGUoZG9jLCB0YWdOYW1lLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGlmIChuYW1lID09PSAnc3JjJyB8fFxyXG4gICAgICAgIChuYW1lID09PSAnaHJlZicgJiYgISh0YWdOYW1lID09PSAndXNlJyAmJiB2YWx1ZVswXSA9PT0gJyMnKSkpIHtcclxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICd4bGluazpocmVmJyAmJiB2YWx1ZVswXSAhPT0gJyMnKSB7XHJcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChuYW1lID09PSAnYmFja2dyb3VuZCcgJiZcclxuICAgICAgICAodGFnTmFtZSA9PT0gJ3RhYmxlJyB8fCB0YWdOYW1lID09PSAndGQnIHx8IHRhZ05hbWUgPT09ICd0aCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChuYW1lID09PSAnc3Jjc2V0Jykge1xyXG4gICAgICAgIHJldHVybiBnZXRBYnNvbHV0ZVNyY3NldFN0cmluZyhkb2MsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcclxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb1N0eWxlc2hlZXQodmFsdWUsIGdldEhyZWYoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0YWdOYW1lID09PSAnb2JqZWN0JyAmJiBuYW1lID09PSAnZGF0YScpIHtcclxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBpZ25vcmVBdHRyaWJ1dGUodGFnTmFtZSwgbmFtZSwgX3ZhbHVlKSB7XHJcbiAgICByZXR1cm4gKHRhZ05hbWUgPT09ICd2aWRlbycgfHwgdGFnTmFtZSA9PT0gJ2F1ZGlvJykgJiYgbmFtZSA9PT0gJ2F1dG9wbGF5JztcclxufVxyXG5mdW5jdGlvbiBfaXNCbG9ja2VkRWxlbWVudChlbGVtZW50LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2tDbGFzcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGJsb2NrQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZUluZGV4ID0gZWxlbWVudC5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgtLTspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NMaXN0W2VJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tDbGFzcy50ZXN0KGNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmxvY2tTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gY2xhc3NNYXRjaGVzUmVnZXgobm9kZSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKSB7XHJcbiAgICBpZiAoIW5vZGUpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IG5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgaWYgKCFjaGVja0FuY2VzdG9ycylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBjbGFzc01hdGNoZXNSZWdleChub2RlLnBhcmVudE5vZGUsIHJlZ2V4LCBjaGVja0FuY2VzdG9ycyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBlSW5kZXggPSBub2RlLmNsYXNzTGlzdC5sZW5ndGg7IGVJbmRleC0tOykge1xyXG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG5vZGUuY2xhc3NMaXN0W2VJbmRleF07XHJcbiAgICAgICAgaWYgKHJlZ2V4LnRlc3QoY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWNoZWNrQW5jZXN0b3JzKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBjbGFzc01hdGNoZXNSZWdleChub2RlLnBhcmVudE5vZGUsIHJlZ2V4LCBjaGVja0FuY2VzdG9ycyk7XHJcbn1cclxuZnVuY3Rpb24gbmVlZE1hc2tpbmdUZXh0KG5vZGUsIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGVsID0gbm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREVcclxuICAgICAgICAgICAgPyBub2RlXHJcbiAgICAgICAgICAgIDogbm9kZS5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIGlmIChlbCA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWFza1RleHRDbGFzcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xvc2VzdChgLiR7bWFza1RleHRDbGFzc31gKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMobWFza1RleHRDbGFzcykpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChjbGFzc01hdGNoZXNSZWdleChlbCwgbWFza1RleHRDbGFzcywgY2hlY2tBbmNlc3RvcnMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXNrVGV4dFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGVja0FuY2VzdG9ycykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsb3Nlc3QobWFza1RleHRTZWxlY3RvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwubWF0Y2hlcyhtYXNrVGV4dFNlbGVjdG9yKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gb25jZUlmcmFtZUxvYWRlZChpZnJhbWVFbCwgbGlzdGVuZXIsIGlmcmFtZUxvYWRUaW1lb3V0KSB7XHJcbiAgICBjb25zdCB3aW4gPSBpZnJhbWVFbC5jb250ZW50V2luZG93O1xyXG4gICAgaWYgKCF3aW4pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgZmlyZWQgPSBmYWxzZTtcclxuICAgIGxldCByZWFkeVN0YXRlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZWFkeVN0YXRlID0gd2luLmRvY3VtZW50LnJlYWR5U3RhdGU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAocmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xyXG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZmlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICBmaXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBpZnJhbWVMb2FkVGltZW91dCk7XHJcbiAgICAgICAgaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGJsYW5rVXJsID0gJ2Fib3V0OmJsYW5rJztcclxuICAgIGlmICh3aW4ubG9jYXRpb24uaHJlZiAhPT0gYmxhbmtVcmwgfHxcclxuICAgICAgICBpZnJhbWVFbC5zcmMgPT09IGJsYW5rVXJsIHx8XHJcbiAgICAgICAgaWZyYW1lRWwuc3JjID09PSAnJykge1xyXG4gICAgICAgIHNldFRpbWVvdXQobGlzdGVuZXIsIDApO1xyXG4gICAgICAgIHJldHVybiBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxpc3RlbmVyKTtcclxufVxyXG5mdW5jdGlvbiBvbmNlU3R5bGVzaGVldExvYWRlZChsaW5rLCBsaXN0ZW5lciwgc3R5bGVTaGVldExvYWRUaW1lb3V0KSB7XHJcbiAgICBsZXQgZmlyZWQgPSBmYWxzZTtcclxuICAgIGxldCBzdHlsZVNoZWV0TG9hZGVkO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBzdHlsZVNoZWV0TG9hZGVkID0gbGluay5zaGVldDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChzdHlsZVNoZWV0TG9hZGVkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFmaXJlZCkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgc3R5bGVTaGVldExvYWRUaW1lb3V0KTtcclxuICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICBsaXN0ZW5lcigpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZShuLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IGRvYywgbWlycm9yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBuZWVkc01hc2ssIGlubGluZVN0eWxlc2hlZXQsIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSwgbWFza1RleHRGbiwgbWFza0lucHV0Rm4sIGRhdGFVUkxPcHRpb25zID0ge30sIGlubGluZUltYWdlcywgcmVjb3JkQ2FudmFzLCBrZWVwSWZyYW1lU3JjRm4sIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3Qgcm9vdElkID0gZ2V0Um9vdElkKGRvYywgbWlycm9yKTtcclxuICAgIHN3aXRjaCAobi5ub2RlVHlwZSkge1xyXG4gICAgICAgIGNhc2Ugbi5ET0NVTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICBpZiAobi5jb21wYXRNb2RlICE9PSAnQ1NTMUNvbXBhdCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuRG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGF0TW9kZTogbi5jb21wYXRNb2RlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuRG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBuLkRPQ1VNRU5UX1RZUEVfTk9ERTpcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlLkRvY3VtZW50VHlwZSxcclxuICAgICAgICAgICAgICAgIG5hbWU6IG4ubmFtZSxcclxuICAgICAgICAgICAgICAgIHB1YmxpY0lkOiBuLnB1YmxpY0lkLFxyXG4gICAgICAgICAgICAgICAgc3lzdGVtSWQ6IG4uc3lzdGVtSWQsXHJcbiAgICAgICAgICAgICAgICByb290SWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSBuLkVMRU1FTlRfTk9ERTpcclxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUVsZW1lbnROb2RlKG4sIHtcclxuICAgICAgICAgICAgICAgIGRvYyxcclxuICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgICAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICByb290SWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2Ugbi5URVhUX05PREU6XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUZXh0Tm9kZShuLCB7XHJcbiAgICAgICAgICAgICAgICBuZWVkc01hc2ssXHJcbiAgICAgICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAgcm9vdElkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlIG4uQ0RBVEFfU0VDVElPTl9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuQ0RBVEEsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogJycsXHJcbiAgICAgICAgICAgICAgICByb290SWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSBuLkNPTU1FTlRfTk9ERTpcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlLkNvbW1lbnQsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogbi50ZXh0Q29udGVudCB8fCAnJyxcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Um9vdElkKGRvYywgbWlycm9yKSB7XHJcbiAgICBpZiAoIW1pcnJvci5oYXNOb2RlKGRvYykpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGRvY0lkID0gbWlycm9yLmdldElkKGRvYyk7XHJcbiAgICByZXR1cm4gZG9jSWQgPT09IDEgPyB1bmRlZmluZWQgOiBkb2NJZDtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVUZXh0Tm9kZShuLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCB7IG5lZWRzTWFzaywgbWFza1RleHRGbiwgcm9vdElkIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgcGFyZW50VGFnTmFtZSA9IG4ucGFyZW50Tm9kZSAmJiBuLnBhcmVudE5vZGUudGFnTmFtZTtcclxuICAgIGxldCB0ZXh0Q29udGVudCA9IG4udGV4dENvbnRlbnQ7XHJcbiAgICBjb25zdCBpc1N0eWxlID0gcGFyZW50VGFnTmFtZSA9PT0gJ1NUWUxFJyA/IHRydWUgOiB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpc1NjcmlwdCA9IHBhcmVudFRhZ05hbWUgPT09ICdTQ1JJUFQnID8gdHJ1ZSA6IHVuZGVmaW5lZDtcclxuICAgIGlmIChpc1N0eWxlICYmIHRleHRDb250ZW50KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKG4ubmV4dFNpYmxpbmcgfHwgbi5wcmV2aW91c1NpYmxpbmcpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoX2EgPSBuLnBhcmVudE5vZGUuc2hlZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jc3NSdWxlcykge1xyXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQgPSBzdHJpbmdpZnlTdHlsZXNoZWV0KG4ucGFyZW50Tm9kZS5zaGVldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBnZXQgQ1NTIHN0eWxlcyBmcm9tIHRleHQncyBwYXJlbnROb2RlLiBFcnJvcjogJHtlcnJ9YCwgbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHRDb250ZW50ID0gYWJzb2x1dGVUb1N0eWxlc2hlZXQodGV4dENvbnRlbnQsIGdldEhyZWYoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTY3JpcHQpIHtcclxuICAgICAgICB0ZXh0Q29udGVudCA9ICdTQ1JJUFRfUExBQ0VIT0xERVInO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1N0eWxlICYmICFpc1NjcmlwdCAmJiB0ZXh0Q29udGVudCAmJiBuZWVkc01hc2spIHtcclxuICAgICAgICB0ZXh0Q29udGVudCA9IG1hc2tUZXh0Rm5cclxuICAgICAgICAgICAgPyBtYXNrVGV4dEZuKHRleHRDb250ZW50LCBuLnBhcmVudEVsZW1lbnQpXHJcbiAgICAgICAgICAgIDogdGV4dENvbnRlbnQucmVwbGFjZSgvW1xcU10vZywgJyonKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogTm9kZVR5cGUuVGV4dCxcclxuICAgICAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQgfHwgJycsXHJcbiAgICAgICAgaXNTdHlsZSxcclxuICAgICAgICByb290SWQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUVsZW1lbnROb2RlKG4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgZG9jLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBpbmxpbmVTdHlsZXNoZWV0LCBtYXNrSW5wdXRPcHRpb25zID0ge30sIG1hc2tJbnB1dEZuLCBkYXRhVVJMT3B0aW9ucyA9IHt9LCBpbmxpbmVJbWFnZXMsIHJlY29yZENhbnZhcywga2VlcElmcmFtZVNyY0ZuLCBuZXdseUFkZGVkRWxlbWVudCA9IGZhbHNlLCByb290SWQsIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgbmVlZEJsb2NrID0gX2lzQmxvY2tlZEVsZW1lbnQobiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcik7XHJcbiAgICBjb25zdCB0YWdOYW1lID0gZ2V0VmFsaWRUYWdOYW1lKG4pO1xyXG4gICAgbGV0IGF0dHJpYnV0ZXMgPSB7fTtcclxuICAgIGNvbnN0IGxlbiA9IG4uYXR0cmlidXRlcy5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYXR0ciA9IG4uYXR0cmlidXRlc1tpXTtcclxuICAgICAgICBpZiAoIWlnbm9yZUF0dHJpYnV0ZSh0YWdOYW1lLCBhdHRyLm5hbWUsIGF0dHIudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0ci5uYW1lXSA9IHRyYW5zZm9ybUF0dHJpYnV0ZShkb2MsIHRhZ05hbWUsIHRvTG93ZXJDYXNlKGF0dHIubmFtZSksIGF0dHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0YWdOYW1lID09PSAnbGluaycgJiYgaW5saW5lU3R5bGVzaGVldCkge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlc2hlZXQgPSBBcnJheS5mcm9tKGRvYy5zdHlsZVNoZWV0cykuZmluZCgocykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcy5ocmVmID09PSBuLmhyZWY7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGNzc1RleHQgPSBudWxsO1xyXG4gICAgICAgIGlmIChzdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgICAgIGNzc1RleHQgPSBzdHJpbmdpZnlTdHlsZXNoZWV0KHN0eWxlc2hlZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3NzVGV4dCkge1xyXG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5yZWw7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmhyZWY7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuX2Nzc1RleHQgPSBhYnNvbHV0ZVRvU3R5bGVzaGVldChjc3NUZXh0LCBzdHlsZXNoZWV0LmhyZWYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0YWdOYW1lID09PSAnc3R5bGUnICYmXHJcbiAgICAgICAgbi5zaGVldCAmJlxyXG4gICAgICAgICEobi5pbm5lclRleHQgfHwgbi50ZXh0Q29udGVudCB8fCAnJykudHJpbSgpLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGNzc1RleHQgPSBzdHJpbmdpZnlTdHlsZXNoZWV0KG4uc2hlZXQpO1xyXG4gICAgICAgIGlmIChjc3NUZXh0KSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuX2Nzc1RleHQgPSBhYnNvbHV0ZVRvU3R5bGVzaGVldChjc3NUZXh0LCBnZXRIcmVmKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0YWdOYW1lID09PSAnaW5wdXQnIHx8IHRhZ05hbWUgPT09ICd0ZXh0YXJlYScgfHwgdGFnTmFtZSA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IG4udmFsdWU7XHJcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IG4uY2hlY2tlZDtcclxuICAgICAgICBpZiAoYXR0cmlidXRlcy50eXBlICE9PSAncmFkaW8nICYmXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudHlwZSAhPT0gJ2NoZWNrYm94JyAmJlxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnR5cGUgIT09ICdzdWJtaXQnICYmXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudHlwZSAhPT0gJ2J1dHRvbicgJiZcclxuICAgICAgICAgICAgdmFsdWUpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy52YWx1ZSA9IG1hc2tJbnB1dFZhbHVlKHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG4sXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRJbnB1dFR5cGUobiksXHJcbiAgICAgICAgICAgICAgICB0YWdOYW1lLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGVja2VkKSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2hlY2tlZCA9IGNoZWNrZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdvcHRpb24nKSB7XHJcbiAgICAgICAgaWYgKG4uc2VsZWN0ZWQgJiYgIW1hc2tJbnB1dE9wdGlvbnNbJ3NlbGVjdCddKSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdjYW52YXMnICYmIHJlY29yZENhbnZhcykge1xyXG4gICAgICAgIGlmIChuLl9fY29udGV4dCA9PT0gJzJkJykge1xyXG4gICAgICAgICAgICBpZiAoIWlzMkRDYW52YXNCbGFuayhuKSkge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9kYXRhVVJMID0gbi50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoISgnX19jb250ZXh0JyBpbiBuKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjYW52YXNEYXRhVVJMID0gbi50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsYW5rQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIGJsYW5rQ2FudmFzLndpZHRoID0gbi53aWR0aDtcclxuICAgICAgICAgICAgYmxhbmtDYW52YXMuaGVpZ2h0ID0gbi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsYW5rQ2FudmFzRGF0YVVSTCA9IGJsYW5rQ2FudmFzLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcclxuICAgICAgICAgICAgaWYgKGNhbnZhc0RhdGFVUkwgIT09IGJsYW5rQ2FudmFzRGF0YVVSTCkge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9kYXRhVVJMID0gY2FudmFzRGF0YVVSTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0YWdOYW1lID09PSAnaW1nJyAmJiBpbmxpbmVJbWFnZXMpIHtcclxuICAgICAgICBpZiAoIWNhbnZhc1NlcnZpY2UpIHtcclxuICAgICAgICAgICAgY2FudmFzU2VydmljZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgY2FudmFzQ3R4ID0gY2FudmFzU2VydmljZS5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbWFnZSA9IG47XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBpbWFnZS5jcm9zc09yaWdpbjtcclxuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xyXG4gICAgICAgIGNvbnN0IHJlY29yZElubGluZUltYWdlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgcmVjb3JkSW5saW5lSW1hZ2UpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY2FudmFzU2VydmljZS53aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgIGNhbnZhc1NlcnZpY2UuaGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIGNhbnZhc0N0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9kYXRhVVJMID0gY2FudmFzU2VydmljZS50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgaW5saW5lIGltZyBzcmM9JHtpbWFnZS5jdXJyZW50U3JjfSEgRXJyb3I6ICR7ZXJyfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9sZFZhbHVlXHJcbiAgICAgICAgICAgICAgICA/IChhdHRyaWJ1dGVzLmNyb3NzT3JpZ2luID0gb2xkVmFsdWUpXHJcbiAgICAgICAgICAgICAgICA6IGltYWdlLnJlbW92ZUF0dHJpYnV0ZSgnY3Jvc3NvcmlnaW4nKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDApXHJcbiAgICAgICAgICAgIHJlY29yZElubGluZUltYWdlKCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgcmVjb3JkSW5saW5lSW1hZ2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdhdWRpbycgfHwgdGFnTmFtZSA9PT0gJ3ZpZGVvJykge1xyXG4gICAgICAgIGNvbnN0IG1lZGlhQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhU3RhdGUgPSBuLnBhdXNlZFxyXG4gICAgICAgICAgICA/ICdwYXVzZWQnXHJcbiAgICAgICAgICAgIDogJ3BsYXllZCc7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhQ3VycmVudFRpbWUgPSBuLmN1cnJlbnRUaW1lO1xyXG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYVBsYXliYWNrUmF0ZSA9IG4ucGxheWJhY2tSYXRlO1xyXG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYU11dGVkID0gbi5tdXRlZDtcclxuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFMb29wID0gbi5sb29wO1xyXG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYVZvbHVtZSA9IG4udm9sdW1lO1xyXG4gICAgfVxyXG4gICAgaWYgKCFuZXdseUFkZGVkRWxlbWVudCkge1xyXG4gICAgICAgIGlmIChuLnNjcm9sbExlZnQpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9zY3JvbGxMZWZ0ID0gbi5zY3JvbGxMZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobi5zY3JvbGxUb3ApIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9zY3JvbGxUb3AgPSBuLnNjcm9sbFRvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobmVlZEJsb2NrKSB7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7XHJcbiAgICAgICAgICAgIGNsYXNzOiBhdHRyaWJ1dGVzLmNsYXNzLFxyXG4gICAgICAgICAgICBycl93aWR0aDogYCR7d2lkdGh9cHhgLFxyXG4gICAgICAgICAgICBycl9oZWlnaHQ6IGAke2hlaWdodH1weGAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0YWdOYW1lID09PSAnaWZyYW1lJyAmJiAha2VlcElmcmFtZVNyY0ZuKGF0dHJpYnV0ZXMuc3JjKSkge1xyXG4gICAgICAgIGlmICghbi5jb250ZW50RG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9zcmMgPSBhdHRyaWJ1dGVzLnNyYztcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuc3JjO1xyXG4gICAgfVxyXG4gICAgbGV0IGlzQ3VzdG9tRWxlbWVudDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKGN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSlcclxuICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IE5vZGVUeXBlLkVsZW1lbnQsXHJcbiAgICAgICAgdGFnTmFtZSxcclxuICAgICAgICBhdHRyaWJ1dGVzLFxyXG4gICAgICAgIGNoaWxkTm9kZXM6IFtdLFxyXG4gICAgICAgIGlzU1ZHOiBpc1NWR0VsZW1lbnQobikgfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgIG5lZWRCbG9jayxcclxuICAgICAgICByb290SWQsXHJcbiAgICAgICAgaXNDdXN0b206IGlzQ3VzdG9tRWxlbWVudCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbG93ZXJJZkV4aXN0cyhtYXliZUF0dHIpIHtcclxuICAgIGlmIChtYXliZUF0dHIgPT09IHVuZGVmaW5lZCB8fCBtYXliZUF0dHIgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbWF5YmVBdHRyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2xpbURPTUV4Y2x1ZGVkKHNuLCBzbGltRE9NT3B0aW9ucykge1xyXG4gICAgaWYgKHNsaW1ET01PcHRpb25zLmNvbW1lbnQgJiYgc24udHlwZSA9PT0gTm9kZVR5cGUuQ29tbWVudCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc24udHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCkge1xyXG4gICAgICAgIGlmIChzbGltRE9NT3B0aW9ucy5zY3JpcHQgJiZcclxuICAgICAgICAgICAgKHNuLnRhZ05hbWUgPT09ICdzY3JpcHQnIHx8XHJcbiAgICAgICAgICAgICAgICAoc24udGFnTmFtZSA9PT0gJ2xpbmsnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHNuLmF0dHJpYnV0ZXMucmVsID09PSAncHJlbG9hZCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc24uYXR0cmlidXRlcy5yZWwgPT09ICdtb2R1bGVwcmVsb2FkJykgJiZcclxuICAgICAgICAgICAgICAgICAgICBzbi5hdHRyaWJ1dGVzLmFzID09PSAnc2NyaXB0JykgfHxcclxuICAgICAgICAgICAgICAgIChzbi50YWdOYW1lID09PSAnbGluaycgJiZcclxuICAgICAgICAgICAgICAgICAgICBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gJ3ByZWZldGNoJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzbi5hdHRyaWJ1dGVzLmhyZWYgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEZpbGVFeHRlbnNpb24oc24uYXR0cmlidXRlcy5ocmVmKSA9PT0gJ2pzJykpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkRmF2aWNvbiAmJlxyXG4gICAgICAgICAgICAoKHNuLnRhZ05hbWUgPT09ICdsaW5rJyAmJiBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gJ3Nob3J0Y3V0IGljb24nKSB8fFxyXG4gICAgICAgICAgICAgICAgKHNuLnRhZ05hbWUgPT09ICdtZXRhJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL15tc2FwcGxpY2F0aW9uLXRpbGUoaW1hZ2V8Y29sb3IpJC8pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2FwcGxpY2F0aW9uLW5hbWUnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSAnaWNvbicgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09ICdhcHBsZS10b3VjaC1pY29uJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gJ3Nob3J0Y3V0IGljb24nKSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzbi50YWdOYW1lID09PSAnbWV0YScpIHtcclxuICAgICAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhRGVzY0tleXdvcmRzICYmXHJcbiAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL15kZXNjcmlwdGlvbnxrZXl3b3JkcyQvKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFTb2NpYWwgJiZcclxuICAgICAgICAgICAgICAgIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9eKG9nfHR3aXR0ZXJ8ZmIpOi8pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9eKG9nfHR3aXR0ZXIpOi8pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAncGludGVyZXN0JykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhUm9ib3RzICYmXHJcbiAgICAgICAgICAgICAgICAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAncm9ib3RzJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2dvb2dsZWJvdCcgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdiaW5nYm90JykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhSHR0cEVxdWl2ICYmXHJcbiAgICAgICAgICAgICAgICBzbi5hdHRyaWJ1dGVzWydodHRwLWVxdWl2J10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFBdXRob3JzaGlwICYmXHJcbiAgICAgICAgICAgICAgICAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnYXV0aG9yJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2dlbmVyYXRvcicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdmcmFtZXdvcmsnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAncHVibGlzaGVyJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3Byb2dpZCcgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9eYXJ0aWNsZTovKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15wcm9kdWN0Oi8pKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFWZXJpZmljYXRpb24gJiZcclxuICAgICAgICAgICAgICAgIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdnb29nbGUtc2l0ZS12ZXJpZmljYXRpb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAneWFuZGV4LXZlcmlmaWNhdGlvbicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdjc3JmLXRva2VuJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3A6ZG9tYWluX3ZlcmlmeScgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICd2ZXJpZnktdjEnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAndmVyaWZpY2F0aW9uJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3Nob3BpZnktY2hlY2tvdXQtYXBpLXRva2VuJykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVXaXRoSWQobiwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgeyBkb2MsIG1pcnJvciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3Rvciwgc2tpcENoaWxkID0gZmFsc2UsIGlubGluZVN0eWxlc2hlZXQgPSB0cnVlLCBtYXNrSW5wdXRPcHRpb25zID0ge30sIG1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuLCBzbGltRE9NT3B0aW9ucywgZGF0YVVSTE9wdGlvbnMgPSB7fSwgaW5saW5lSW1hZ2VzID0gZmFsc2UsIHJlY29yZENhbnZhcyA9IGZhbHNlLCBvblNlcmlhbGl6ZSwgb25JZnJhbWVMb2FkLCBpZnJhbWVMb2FkVGltZW91dCA9IDUwMDAsIG9uU3R5bGVzaGVldExvYWQsIHN0eWxlc2hlZXRMb2FkVGltZW91dCA9IDUwMDAsIGtlZXBJZnJhbWVTcmNGbiA9ICgpID0+IGZhbHNlLCBuZXdseUFkZGVkRWxlbWVudCA9IGZhbHNlLCB9ID0gb3B0aW9ucztcclxuICAgIGxldCB7IG5lZWRzTWFzayB9ID0gb3B0aW9ucztcclxuICAgIGxldCB7IHByZXNlcnZlV2hpdGVTcGFjZSA9IHRydWUgfSA9IG9wdGlvbnM7XHJcbiAgICBpZiAoIW5lZWRzTWFzayAmJlxyXG4gICAgICAgIG4uY2hpbGROb2Rlcykge1xyXG4gICAgICAgIGNvbnN0IGNoZWNrQW5jZXN0b3JzID0gbmVlZHNNYXNrID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbmVlZHNNYXNrID0gbmVlZE1hc2tpbmdUZXh0KG4sIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IF9zZXJpYWxpemVkTm9kZSA9IHNlcmlhbGl6ZU5vZGUobiwge1xyXG4gICAgICAgIGRvYyxcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgIG5lZWRzTWFzayxcclxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICBuZXdseUFkZGVkRWxlbWVudCxcclxuICAgIH0pO1xyXG4gICAgaWYgKCFfc2VyaWFsaXplZE5vZGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4obiwgJ25vdCBzZXJpYWxpemVkJyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBsZXQgaWQ7XHJcbiAgICBpZiAobWlycm9yLmhhc05vZGUobikpIHtcclxuICAgICAgICBpZCA9IG1pcnJvci5nZXRJZChuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNsaW1ET01FeGNsdWRlZChfc2VyaWFsaXplZE5vZGUsIHNsaW1ET01PcHRpb25zKSB8fFxyXG4gICAgICAgICghcHJlc2VydmVXaGl0ZVNwYWNlICYmXHJcbiAgICAgICAgICAgIF9zZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5UZXh0ICYmXHJcbiAgICAgICAgICAgICFfc2VyaWFsaXplZE5vZGUuaXNTdHlsZSAmJlxyXG4gICAgICAgICAgICAhX3NlcmlhbGl6ZWROb2RlLnRleHRDb250ZW50LnJlcGxhY2UoL15cXHMrfFxccyskL2dtLCAnJykubGVuZ3RoKSkge1xyXG4gICAgICAgIGlkID0gSUdOT1JFRF9OT0RFO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWQgPSBnZW5JZCgpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBPYmplY3QuYXNzaWduKF9zZXJpYWxpemVkTm9kZSwgeyBpZCB9KTtcclxuICAgIG1pcnJvci5hZGQobiwgc2VyaWFsaXplZE5vZGUpO1xyXG4gICAgaWYgKGlkID09PSBJR05PUkVEX05PREUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChvblNlcmlhbGl6ZSkge1xyXG4gICAgICAgIG9uU2VyaWFsaXplKG4pO1xyXG4gICAgfVxyXG4gICAgbGV0IHJlY29yZENoaWxkID0gIXNraXBDaGlsZDtcclxuICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50KSB7XHJcbiAgICAgICAgcmVjb3JkQ2hpbGQgPSByZWNvcmRDaGlsZCAmJiAhc2VyaWFsaXplZE5vZGUubmVlZEJsb2NrO1xyXG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkTm9kZS5uZWVkQmxvY2s7XHJcbiAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IG4uc2hhZG93Um9vdDtcclxuICAgICAgICBpZiAoc2hhZG93Um9vdCAmJiBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290KSlcclxuICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUuaXNTaGFkb3dIb3N0ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICgoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRG9jdW1lbnQgfHxcclxuICAgICAgICBzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50KSAmJlxyXG4gICAgICAgIHJlY29yZENoaWxkKSB7XHJcbiAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRXaGl0ZXNwYWNlICYmXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gJ2hlYWQnKSB7XHJcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBieXBhc3NPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBkb2MsXHJcbiAgICAgICAgICAgIG1pcnJvcixcclxuICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICAgICAgbmVlZHNNYXNrLFxyXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICBza2lwQ2hpbGQsXHJcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXHJcbiAgICAgICAgICAgIG9uU2VyaWFsaXplLFxyXG4gICAgICAgICAgICBvbklmcmFtZUxvYWQsXHJcbiAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxyXG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkLFxyXG4gICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50ICYmXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09ICd0ZXh0YXJlYScgJiZcclxuICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy52YWx1ZSAhPT0gdW5kZWZpbmVkKSA7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGROIG9mIEFycmF5LmZyb20obi5jaGlsZE5vZGVzKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoY2hpbGROLCBieXBhc3NPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkQ2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUuY2hpbGROb2Rlcy5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0VsZW1lbnQobikgJiYgbi5zaGFkb3dSb290KSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGROIG9mIEFycmF5LmZyb20obi5zaGFkb3dSb290LmNoaWxkTm9kZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChjaGlsZE4sIGJ5cGFzc09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc05hdGl2ZVNoYWRvd0RvbShuLnNoYWRvd1Jvb3QpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXJpYWxpemVkQ2hpbGROb2RlLmlzU2hhZG93ID0gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUuY2hpbGROb2Rlcy5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG4ucGFyZW50Tm9kZSAmJlxyXG4gICAgICAgIGlzU2hhZG93Um9vdChuLnBhcmVudE5vZGUpICYmXHJcbiAgICAgICAgaXNOYXRpdmVTaGFkb3dEb20obi5wYXJlbnROb2RlKSkge1xyXG4gICAgICAgIHNlcmlhbGl6ZWROb2RlLmlzU2hhZG93ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50ICYmXHJcbiAgICAgICAgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gJ2lmcmFtZScpIHtcclxuICAgICAgICBvbmNlSWZyYW1lTG9hZGVkKG4sICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaWZyYW1lRG9jID0gbi5jb250ZW50RG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChpZnJhbWVEb2MgJiYgb25JZnJhbWVMb2FkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkSWZyYW1lTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoaWZyYW1lRG9jLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jOiBpZnJhbWVEb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBuZWVkc01hc2ssXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBDaGlsZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TZXJpYWxpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25JZnJhbWVMb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0LFxyXG4gICAgICAgICAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRJZnJhbWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25JZnJhbWVMb2FkKG4sIHNlcmlhbGl6ZWRJZnJhbWVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGlmcmFtZUxvYWRUaW1lb3V0KTtcclxuICAgIH1cclxuICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50ICYmXHJcbiAgICAgICAgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gJ2xpbmsnICYmXHJcbiAgICAgICAgdHlwZW9mIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIChzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnJlbCA9PT0gJ3N0eWxlc2hlZXQnIHx8XHJcbiAgICAgICAgICAgIChzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnJlbCA9PT0gJ3ByZWxvYWQnICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5ocmVmID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgICAgICAgICAgZXh0cmFjdEZpbGVFeHRlbnNpb24oc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5ocmVmKSA9PT0gJ2NzcycpKSkge1xyXG4gICAgICAgIG9uY2VTdHlsZXNoZWV0TG9hZGVkKG4sICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9uU3R5bGVzaGVldExvYWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRMaW5rTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQobiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvYyxcclxuICAgICAgICAgICAgICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzTWFzayxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcclxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZSxcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZExpbmtOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZChuLCBzZXJpYWxpemVkTGlua05vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgc3R5bGVzaGVldExvYWRUaW1lb3V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZXJpYWxpemVkTm9kZTtcclxufVxyXG5mdW5jdGlvbiBzbmFwc2hvdChuLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IG1pcnJvciA9IG5ldyBNaXJyb3IoKSwgYmxvY2tDbGFzcyA9ICdyci1ibG9jaycsIGJsb2NrU2VsZWN0b3IgPSBudWxsLCBtYXNrVGV4dENsYXNzID0gJ3JyLW1hc2snLCBtYXNrVGV4dFNlbGVjdG9yID0gbnVsbCwgaW5saW5lU3R5bGVzaGVldCA9IHRydWUsIGlubGluZUltYWdlcyA9IGZhbHNlLCByZWNvcmRDYW52YXMgPSBmYWxzZSwgbWFza0FsbElucHV0cyA9IGZhbHNlLCBtYXNrVGV4dEZuLCBtYXNrSW5wdXRGbiwgc2xpbURPTSA9IGZhbHNlLCBkYXRhVVJMT3B0aW9ucywgcHJlc2VydmVXaGl0ZVNwYWNlLCBvblNlcmlhbGl6ZSwgb25JZnJhbWVMb2FkLCBpZnJhbWVMb2FkVGltZW91dCwgb25TdHlsZXNoZWV0TG9hZCwgc3R5bGVzaGVldExvYWRUaW1lb3V0LCBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZSwgfSA9IG9wdGlvbnMgfHwge307XHJcbiAgICBjb25zdCBtYXNrSW5wdXRPcHRpb25zID0gbWFza0FsbElucHV0cyA9PT0gdHJ1ZVxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBjb2xvcjogdHJ1ZSxcclxuICAgICAgICAgICAgZGF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcclxuICAgICAgICAgICAgZW1haWw6IHRydWUsXHJcbiAgICAgICAgICAgIG1vbnRoOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1iZXI6IHRydWUsXHJcbiAgICAgICAgICAgIHJhbmdlOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWFyY2g6IHRydWUsXHJcbiAgICAgICAgICAgIHRlbDogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dDogdHJ1ZSxcclxuICAgICAgICAgICAgdGltZTogdHJ1ZSxcclxuICAgICAgICAgICAgdXJsOiB0cnVlLFxyXG4gICAgICAgICAgICB3ZWVrOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0YXJlYTogdHJ1ZSxcclxuICAgICAgICAgICAgc2VsZWN0OiB0cnVlLFxyXG4gICAgICAgICAgICBwYXNzd29yZDogdHJ1ZSxcclxuICAgICAgICB9XHJcbiAgICAgICAgOiBtYXNrQWxsSW5wdXRzID09PSBmYWxzZVxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0cnVlLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogbWFza0FsbElucHV0cztcclxuICAgIGNvbnN0IHNsaW1ET01PcHRpb25zID0gc2xpbURPTSA9PT0gdHJ1ZSB8fCBzbGltRE9NID09PSAnYWxsJ1xyXG4gICAgICAgID9cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29tbWVudDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRGYXZpY29uOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkTWV0YURlc2NLZXl3b3Jkczogc2xpbURPTSA9PT0gJ2FsbCcsXHJcbiAgICAgICAgICAgICAgICBoZWFkTWV0YVNvY2lhbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhUm9ib3RzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkTWV0YUF1dGhvcnNoaXA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkTWV0YVZlcmlmaWNhdGlvbjogdHJ1ZSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDogc2xpbURPTSA9PT0gZmFsc2VcclxuICAgICAgICAgICAgPyB7fVxyXG4gICAgICAgICAgICA6IHNsaW1ET007XHJcbiAgICByZXR1cm4gc2VyaWFsaXplTm9kZVdpdGhJZChuLCB7XHJcbiAgICAgICAgZG9jOiBuLFxyXG4gICAgICAgIG1pcnJvcixcclxuICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgbWFza1RleHRDbGFzcyxcclxuICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgIHNraXBDaGlsZDogZmFsc2UsXHJcbiAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXHJcbiAgICAgICAgb25TZXJpYWxpemUsXHJcbiAgICAgICAgb25JZnJhbWVMb2FkLFxyXG4gICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxyXG4gICAgICAgIG9uU3R5bGVzaGVldExvYWQsXHJcbiAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0LFxyXG4gICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICBuZXdseUFkZGVkRWxlbWVudDogZmFsc2UsXHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBvbih0eXBlLCBmbiwgdGFyZ2V0ID0gZG9jdW1lbnQpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfTtcclxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcclxuICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9ucyk7XHJcbn1cclxuY29uc3QgREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HID0gJ1BsZWFzZSBzdG9wIGltcG9ydCBtaXJyb3IgZGlyZWN0bHkuIEluc3RlYWQgb2YgdGhhdCwnICtcclxuICAgICdcXHJcXG4nICtcclxuICAgICdub3cgeW91IGNhbiB1c2UgcmVwbGF5ZXIuZ2V0TWlycm9yKCkgdG8gYWNjZXNzIHRoZSBtaXJyb3IgaW5zdGFuY2Ugb2YgYSByZXBsYXllciwnICtcclxuICAgICdcXHJcXG4nICtcclxuICAgICdvciB5b3UgY2FuIHVzZSByZWNvcmQubWlycm9yIHRvIGFjY2VzcyB0aGUgbWlycm9yIGluc3RhbmNlIGR1cmluZyByZWNvcmRpbmcuJztcclxubGV0IF9taXJyb3IgPSB7XHJcbiAgICBtYXA6IHt9LFxyXG4gICAgZ2V0SWQoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH0sXHJcbiAgICBnZXROb2RlKCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcbiAgICByZW1vdmVOb2RlRnJvbU1hcCgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICB9LFxyXG4gICAgaGFzKCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgfSxcclxufTtcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5Qcm94eSAmJiB3aW5kb3cuUmVmbGVjdCkge1xyXG4gICAgX21pcnJvciA9IG5ldyBQcm94eShfbWlycm9yLCB7XHJcbiAgICAgICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdtYXAnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zID0ge30pIHtcclxuICAgIGxldCB0aW1lb3V0ID0gbnVsbDtcclxuICAgIGxldCBwcmV2aW91cyA9IDA7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xyXG4gICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgfSwgcmVtYWluaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIGQsIGlzUmV2b2tlZCwgd2luID0gd2luZG93KSB7XHJcbiAgICBjb25zdCBvcmlnaW5hbCA9IHdpbi5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcclxuICAgIHdpbi5PYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGlzUmV2b2tlZFxyXG4gICAgICAgID8gZFxyXG4gICAgICAgIDoge1xyXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGQuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWwgJiYgb3JpZ2luYWwuc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWwuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgcmV0dXJuICgpID0+IGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIG9yaWdpbmFsIHx8IHt9LCB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaChzb3VyY2UsIG5hbWUsIHJlcGxhY2VtZW50KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghKG5hbWUgaW4gc291cmNlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHNvdXJjZVtuYW1lXTtcclxuICAgICAgICBjb25zdCB3cmFwcGVkID0gcmVwbGFjZW1lbnQob3JpZ2luYWwpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB3cmFwcGVkLnByb3RvdHlwZSA9IHdyYXBwZWQucHJvdG90eXBlIHx8IHt9O1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwcGVkLCB7XHJcbiAgICAgICAgICAgICAgICBfX3Jyd2ViX29yaWdpbmFsX186IHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3JpZ2luYWwsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc291cmNlW25hbWVdID0gd3JhcHBlZDtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBzb3VyY2VbbmFtZV0gPSBvcmlnaW5hbDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmxldCBub3dUaW1lc3RhbXAgPSBEYXRlLm5vdztcclxuaWYgKCEoL1sxLTldWzAtOV17MTJ9Ly50ZXN0KERhdGUubm93KCkudG9TdHJpbmcoKSkpKSB7XHJcbiAgICBub3dUaW1lc3RhbXAgPSAoKSA9PiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxufVxyXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwod2luKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICAgIGNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogZG9jLnNjcm9sbGluZ0VsZW1lbnRcclxuICAgICAgICAgICAgPyBkb2Muc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0XHJcbiAgICAgICAgICAgIDogd2luLnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gd2luLnBhZ2VYT2Zmc2V0XHJcbiAgICAgICAgICAgICAgICA6IChkb2MgPT09IG51bGwgfHwgZG9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKChfYiA9IChfYSA9IGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjcm9sbExlZnQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKChfYyA9IGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5ib2R5KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2Nyb2xsTGVmdCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgIHRvcDogZG9jLnNjcm9sbGluZ0VsZW1lbnRcclxuICAgICAgICAgICAgPyBkb2Muc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3BcclxuICAgICAgICAgICAgOiB3aW4ucGFnZVlPZmZzZXQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyB3aW4ucGFnZVlPZmZzZXRcclxuICAgICAgICAgICAgICAgIDogKGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICgoX2UgPSAoX2QgPSBkb2MgPT09IG51bGwgfHwgZG9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2MuYm9keSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zY3JvbGxUb3ApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKChfZiA9IGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5ib2R5KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2Nyb2xsVG9wKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFdpbmRvd0hlaWdodCgpIHtcclxuICAgIHJldHVybiAod2luZG93LmlubmVySGVpZ2h0IHx8XHJcbiAgICAgICAgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSB8fFxyXG4gICAgICAgIChkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2luZG93V2lkdGgoKSB7XHJcbiAgICByZXR1cm4gKHdpbmRvdy5pbm5lcldpZHRoIHx8XHJcbiAgICAgICAgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpIHx8XHJcbiAgICAgICAgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCkpO1xyXG59XHJcbmZ1bmN0aW9uIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUpIHtcclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWwgPSBub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERVxyXG4gICAgICAgID8gbm9kZVxyXG4gICAgICAgIDogbm9kZS5wYXJlbnRFbGVtZW50O1xyXG4gICAgcmV0dXJuIGVsO1xyXG59XHJcbmZ1bmN0aW9uIGlzQmxvY2tlZChub2RlLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBjaGVja0FuY2VzdG9ycykge1xyXG4gICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWwgPSBjbG9zZXN0RWxlbWVudE9mTm9kZShub2RlKTtcclxuICAgIGlmICghZWwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2tDbGFzcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdCgnLicgKyBibG9ja0NsYXNzKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGNsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBibG9ja0NsYXNzLCBjaGVja0FuY2VzdG9ycykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgfVxyXG4gICAgaWYgKGJsb2NrU2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoZWwubWF0Y2hlcyhibG9ja1NlbGVjdG9yKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzICYmIGVsLmNsb3Nlc3QoYmxvY2tTZWxlY3RvcikgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2VyaWFsaXplZChuLCBtaXJyb3IpIHtcclxuICAgIHJldHVybiBtaXJyb3IuZ2V0SWQobikgIT09IC0xO1xyXG59XHJcbmZ1bmN0aW9uIGlzSWdub3JlZChuLCBtaXJyb3IpIHtcclxuICAgIHJldHVybiBtaXJyb3IuZ2V0SWQobikgPT09IElHTk9SRURfTk9ERTtcclxufVxyXG5mdW5jdGlvbiBpc0FuY2VzdG9yUmVtb3ZlZCh0YXJnZXQsIG1pcnJvcikge1xyXG4gICAgaWYgKGlzU2hhZG93Um9vdCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaWQgPSBtaXJyb3IuZ2V0SWQodGFyZ2V0KTtcclxuICAgIGlmICghbWlycm9yLmhhcyhpZCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSAmJlxyXG4gICAgICAgIHRhcmdldC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSB0YXJnZXQuRE9DVU1FTlRfTk9ERSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghdGFyZ2V0LnBhcmVudE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc0FuY2VzdG9yUmVtb3ZlZCh0YXJnZXQucGFyZW50Tm9kZSwgbWlycm9yKTtcclxufVxyXG5mdW5jdGlvbiBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihldmVudC5jaGFuZ2VkVG91Y2hlcyk7XHJcbn1cclxuZnVuY3Rpb24gcG9seWZpbGwod2luID0gd2luZG93KSB7XHJcbiAgICBpZiAoJ05vZGVMaXN0JyBpbiB3aW4gJiYgIXdpbi5Ob2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xyXG4gICAgICAgIHdpbi5Ob2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZVxyXG4gICAgICAgICAgICAuZm9yRWFjaDtcclxuICAgIH1cclxuICAgIGlmICgnRE9NVG9rZW5MaXN0JyBpbiB3aW4gJiYgIXdpbi5ET01Ub2tlbkxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcclxuICAgICAgICB3aW4uRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlXHJcbiAgICAgICAgICAgIC5mb3JFYWNoO1xyXG4gICAgfVxyXG4gICAgaWYgKCFOb2RlLnByb3RvdHlwZS5jb250YWlucykge1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmNvbnRhaW5zID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICBpZiAoISgwIGluIGFyZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAoKG5vZGUgPSBub2RlICYmIG5vZGUucGFyZW50Tm9kZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWRJZnJhbWUobiwgbWlycm9yKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihuLm5vZGVOYW1lID09PSAnSUZSQU1FJyAmJiBtaXJyb3IuZ2V0TWV0YShuKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNTZXJpYWxpemVkU3R5bGVzaGVldChuLCBtaXJyb3IpIHtcclxuICAgIHJldHVybiBCb29sZWFuKG4ubm9kZU5hbWUgPT09ICdMSU5LJyAmJlxyXG4gICAgICAgIG4ubm9kZVR5cGUgPT09IG4uRUxFTUVOVF9OT0RFICYmXHJcbiAgICAgICAgbi5nZXRBdHRyaWJ1dGUgJiZcclxuICAgICAgICBuLmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdzdHlsZXNoZWV0JyAmJlxyXG4gICAgICAgIG1pcnJvci5nZXRNZXRhKG4pKTtcclxufVxyXG5mdW5jdGlvbiBoYXNTaGFkb3dSb290KG4pIHtcclxuICAgIHJldHVybiBCb29sZWFuKG4gPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbi5zaGFkb3dSb290KTtcclxufVxyXG5jbGFzcyBTdHlsZVNoZWV0TWlycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaWQgPSAxO1xyXG4gICAgICAgIHRoaXMuc3R5bGVJRE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5pZFN0eWxlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0SWQoc3R5bGVzaGVldCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5zdHlsZUlETWFwLmdldChzdHlsZXNoZWV0KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTE7XHJcbiAgICB9XHJcbiAgICBoYXMoc3R5bGVzaGVldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlSURNYXAuaGFzKHN0eWxlc2hlZXQpO1xyXG4gICAgfVxyXG4gICAgYWRkKHN0eWxlc2hlZXQsIGlkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzKHN0eWxlc2hlZXQpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJZChzdHlsZXNoZWV0KTtcclxuICAgICAgICBsZXQgbmV3SWQ7XHJcbiAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbmV3SWQgPSB0aGlzLmlkKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgbmV3SWQgPSBpZDtcclxuICAgICAgICB0aGlzLnN0eWxlSURNYXAuc2V0KHN0eWxlc2hlZXQsIG5ld0lkKTtcclxuICAgICAgICB0aGlzLmlkU3R5bGVNYXAuc2V0KG5ld0lkLCBzdHlsZXNoZWV0KTtcclxuICAgICAgICByZXR1cm4gbmV3SWQ7XHJcbiAgICB9XHJcbiAgICBnZXRTdHlsZShpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkU3R5bGVNYXAuZ2V0KGlkKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5zdHlsZUlETWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmlkU3R5bGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IDE7XHJcbiAgICB9XHJcbiAgICBnZW5lcmF0ZUlkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkKys7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2hhZG93SG9zdChuKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgbGV0IHNoYWRvd0hvc3QgPSBudWxsO1xyXG4gICAgaWYgKCgoX2IgPSAoX2EgPSBuLmdldFJvb3ROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChuKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5vZGVUeXBlKSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmXHJcbiAgICAgICAgbi5nZXRSb290Tm9kZSgpLmhvc3QpXHJcbiAgICAgICAgc2hhZG93SG9zdCA9IG4uZ2V0Um9vdE5vZGUoKS5ob3N0O1xyXG4gICAgcmV0dXJuIHNoYWRvd0hvc3Q7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Um9vdFNoYWRvd0hvc3Qobikge1xyXG4gICAgbGV0IHJvb3RTaGFkb3dIb3N0ID0gbjtcclxuICAgIGxldCBzaGFkb3dIb3N0O1xyXG4gICAgd2hpbGUgKChzaGFkb3dIb3N0ID0gZ2V0U2hhZG93SG9zdChyb290U2hhZG93SG9zdCkpKVxyXG4gICAgICAgIHJvb3RTaGFkb3dIb3N0ID0gc2hhZG93SG9zdDtcclxuICAgIHJldHVybiByb290U2hhZG93SG9zdDtcclxufVxyXG5mdW5jdGlvbiBzaGFkb3dIb3N0SW5Eb20obikge1xyXG4gICAgY29uc3QgZG9jID0gbi5vd25lckRvY3VtZW50O1xyXG4gICAgaWYgKCFkb2MpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgY29uc3Qgc2hhZG93SG9zdCA9IGdldFJvb3RTaGFkb3dIb3N0KG4pO1xyXG4gICAgcmV0dXJuIGRvYy5jb250YWlucyhzaGFkb3dIb3N0KTtcclxufVxyXG5mdW5jdGlvbiBpbkRvbShuKSB7XHJcbiAgICBjb25zdCBkb2MgPSBuLm93bmVyRG9jdW1lbnQ7XHJcbiAgICBpZiAoIWRvYylcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gZG9jLmNvbnRhaW5zKG4pIHx8IHNoYWRvd0hvc3RJbkRvbShuKTtcclxufVxuXG52YXIgRXZlbnRUeXBlJDEgPSAvKiBAX19QVVJFX18gKi8gKChFdmVudFR5cGUyKSA9PiB7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkRvbUNvbnRlbnRMb2FkZWRcIl0gPSAwXSA9IFwiRG9tQ29udGVudExvYWRlZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJMb2FkXCJdID0gMV0gPSBcIkxvYWRcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRnVsbFNuYXBzaG90XCJdID0gMl0gPSBcIkZ1bGxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJJbmNyZW1lbnRhbFNuYXBzaG90XCJdID0gM10gPSBcIkluY3JlbWVudGFsU25hcHNob3RcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTWV0YVwiXSA9IDRdID0gXCJNZXRhXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkN1c3RvbVwiXSA9IDVdID0gXCJDdXN0b21cIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiUGx1Z2luXCJdID0gNl0gPSBcIlBsdWdpblwiO1xuICByZXR1cm4gRXZlbnRUeXBlMjtcbn0pKEV2ZW50VHlwZSQxIHx8IHt9KTtcbnZhciBJbmNyZW1lbnRhbFNvdXJjZSQxID0gLyogQF9fUFVSRV9fICovICgoSW5jcmVtZW50YWxTb3VyY2UyKSA9PiB7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNdXRhdGlvblwiXSA9IDBdID0gXCJNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTW91c2VNb3ZlXCJdID0gMV0gPSBcIk1vdXNlTW92ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTW91c2VJbnRlcmFjdGlvblwiXSA9IDJdID0gXCJNb3VzZUludGVyYWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTY3JvbGxcIl0gPSAzXSA9IFwiU2Nyb2xsXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJWaWV3cG9ydFJlc2l6ZVwiXSA9IDRdID0gXCJWaWV3cG9ydFJlc2l6ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiSW5wdXRcIl0gPSA1XSA9IFwiSW5wdXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlRvdWNoTW92ZVwiXSA9IDZdID0gXCJUb3VjaE1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1lZGlhSW50ZXJhY3Rpb25cIl0gPSA3XSA9IFwiTWVkaWFJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU3R5bGVTaGVldFJ1bGVcIl0gPSA4XSA9IFwiU3R5bGVTaGVldFJ1bGVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkNhbnZhc011dGF0aW9uXCJdID0gOV0gPSBcIkNhbnZhc011dGF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJGb250XCJdID0gMTBdID0gXCJGb250XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJMb2dcIl0gPSAxMV0gPSBcIkxvZ1wiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRHJhZ1wiXSA9IDEyXSA9IFwiRHJhZ1wiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU3R5bGVEZWNsYXJhdGlvblwiXSA9IDEzXSA9IFwiU3R5bGVEZWNsYXJhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2VsZWN0aW9uXCJdID0gMTRdID0gXCJTZWxlY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkFkb3B0ZWRTdHlsZVNoZWV0XCJdID0gMTVdID0gXCJBZG9wdGVkU3R5bGVTaGVldFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ3VzdG9tRWxlbWVudFwiXSA9IDE2XSA9IFwiQ3VzdG9tRWxlbWVudFwiO1xuICByZXR1cm4gSW5jcmVtZW50YWxTb3VyY2UyO1xufSkoSW5jcmVtZW50YWxTb3VyY2UkMSB8fCB7fSk7XG52YXIgTW91c2VJbnRlcmFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKChNb3VzZUludGVyYWN0aW9uczIpID0+IHtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIk1vdXNlVXBcIl0gPSAwXSA9IFwiTW91c2VVcFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VEb3duXCJdID0gMV0gPSBcIk1vdXNlRG93blwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ2xpY2tcIl0gPSAyXSA9IFwiQ2xpY2tcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkNvbnRleHRNZW51XCJdID0gM10gPSBcIkNvbnRleHRNZW51XCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJEYmxDbGlja1wiXSA9IDRdID0gXCJEYmxDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiRm9jdXNcIl0gPSA1XSA9IFwiRm9jdXNcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkJsdXJcIl0gPSA2XSA9IFwiQmx1clwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hTdGFydFwiXSA9IDddID0gXCJUb3VjaFN0YXJ0XCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIl0gPSA4XSA9IFwiVG91Y2hNb3ZlX0RlcGFydGVkXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaEVuZFwiXSA9IDldID0gXCJUb3VjaEVuZFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hDYW5jZWxcIl0gPSAxMF0gPSBcIlRvdWNoQ2FuY2VsXCI7XG4gIHJldHVybiBNb3VzZUludGVyYWN0aW9uczI7XG59KShNb3VzZUludGVyYWN0aW9ucyB8fCB7fSk7XG52YXIgUG9pbnRlclR5cGVzID0gLyogQF9fUFVSRV9fICovICgoUG9pbnRlclR5cGVzMikgPT4ge1xuICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJNb3VzZVwiXSA9IDBdID0gXCJNb3VzZVwiO1xuICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJQZW5cIl0gPSAxXSA9IFwiUGVuXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlRvdWNoXCJdID0gMl0gPSBcIlRvdWNoXCI7XG4gIHJldHVybiBQb2ludGVyVHlwZXMyO1xufSkoUG9pbnRlclR5cGVzIHx8IHt9KTtcbnZhciBDYW52YXNDb250ZXh0ID0gLyogQF9fUFVSRV9fICovICgoQ2FudmFzQ29udGV4dDIpID0+IHtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCIyRFwiXSA9IDBdID0gXCIyRFwiO1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIldlYkdMXCJdID0gMV0gPSBcIldlYkdMXCI7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0wyXCJdID0gMl0gPSBcIldlYkdMMlwiO1xuICByZXR1cm4gQ2FudmFzQ29udGV4dDI7XG59KShDYW52YXNDb250ZXh0IHx8IHt9KTtcblxuZnVuY3Rpb24gaXNOb2RlSW5MaW5rZWRMaXN0KG4pIHtcclxuICAgIHJldHVybiAnX19sbicgaW4gbjtcclxufVxyXG5jbGFzcyBEb3VibGVMaW5rZWRMaXN0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQocG9zaXRpb24pIHtcclxuICAgICAgICBpZiAocG9zaXRpb24gPj0gdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBvdXRzaWRlIG9mIGxpc3QgcmFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBvc2l0aW9uOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50Lm5leHQpIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgfVxyXG4gICAgYWRkTm9kZShuKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHtcclxuICAgICAgICAgICAgdmFsdWU6IG4sXHJcbiAgICAgICAgICAgIHByZXZpb3VzOiBudWxsLFxyXG4gICAgICAgICAgICBuZXh0OiBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbi5fX2xuID0gbm9kZTtcclxuICAgICAgICBpZiAobi5wcmV2aW91c1NpYmxpbmcgJiYgaXNOb2RlSW5MaW5rZWRMaXN0KG4ucHJldmlvdXNTaWJsaW5nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gbi5wcmV2aW91c1NpYmxpbmcuX19sbi5uZXh0O1xyXG4gICAgICAgICAgICBub2RlLm5leHQgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICBub2RlLnByZXZpb3VzID0gbi5wcmV2aW91c1NpYmxpbmcuX19sbjtcclxuICAgICAgICAgICAgbi5wcmV2aW91c1NpYmxpbmcuX19sbi5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQucHJldmlvdXMgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG4ubmV4dFNpYmxpbmcgJiZcclxuICAgICAgICAgICAgaXNOb2RlSW5MaW5rZWRMaXN0KG4ubmV4dFNpYmxpbmcpICYmXHJcbiAgICAgICAgICAgIG4ubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cykge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gbi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzO1xyXG4gICAgICAgICAgICBub2RlLnByZXZpb3VzID0gY3VycmVudDtcclxuICAgICAgICAgICAgbm9kZS5uZXh0ID0gbi5uZXh0U2libGluZy5fX2xuO1xyXG4gICAgICAgICAgICBuLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXMgPSBub2RlO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkLnByZXZpb3VzID0gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlLm5leHQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLm5leHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcclxuICAgIH1cclxuICAgIHJlbW92ZU5vZGUobikge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBuLl9fbG47XHJcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWN1cnJlbnQucHJldmlvdXMpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudC5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQucHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWlsID0gY3VycmVudC5wcmV2aW91cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobi5fX2xuKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBuLl9fbG47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVuZ3RoLS07XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbW92ZUtleSA9IChpZCwgcGFyZW50SWQpID0+IGAke2lkfUAke3BhcmVudElkfWA7XHJcbmNsYXNzIE11dGF0aW9uQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRleHRzID0gW107XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubWFwUmVtb3ZlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubW92ZWRNYXAgPSB7fTtcclxuICAgICAgICB0aGlzLmFkZGVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMubW92ZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5kcm9wcGVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc011dGF0aW9ucyA9IChtdXRhdGlvbnMpID0+IHtcclxuICAgICAgICAgICAgbXV0YXRpb25zLmZvckVhY2godGhpcy5wcm9jZXNzTXV0YXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZW1pdCA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZnJvemVuIHx8IHRoaXMubG9ja2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYWRkcyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRlZElkcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgY29uc3QgYWRkTGlzdCA9IG5ldyBEb3VibGVMaW5rZWRMaXN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdldE5leHRJZCA9IChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbnMgPSBuO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHRJZCA9IElHTk9SRURfTk9ERTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0SWQgPT09IElHTk9SRURfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5zID0gbnMgJiYgbnMubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dElkID0gbnMgJiYgdGhpcy5taXJyb3IuZ2V0SWQobnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRJZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcHVzaEFkZCA9IChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW4ucGFyZW50Tm9kZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFpbkRvbShuKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIG4ucGFyZW50Tm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50SWQgPSBpc1NoYWRvd1Jvb3Qobi5wYXJlbnROb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5taXJyb3IuZ2V0SWQoZ2V0U2hhZG93SG9zdChuKSlcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMubWlycm9yLmdldElkKG4ucGFyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SWQgPSBnZXROZXh0SWQobik7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgPT09IC0xIHx8IG5leHRJZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkTGlzdC5hZGROb2RlKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc24gPSBzZXJpYWxpemVOb2RlV2l0aElkKG4sIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2M6IHRoaXMuZG9jLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDbGFzczogdGhpcy5ibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IHRoaXMuYmxvY2tTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzOiB0aGlzLm1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogdGhpcy5tYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBDaGlsZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBuZXdseUFkZGVkRWxlbWVudDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiB0aGlzLmlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogdGhpcy5tYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm46IHRoaXMubWFza1RleHRGbixcclxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogdGhpcy5tYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9uczogdGhpcy5zbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogdGhpcy5kYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRDYW52YXM6IHRoaXMucmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZUltYWdlczogdGhpcy5pbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TZXJpYWxpemU6IChjdXJyZW50TikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkSWZyYW1lKGN1cnJlbnROLCB0aGlzLm1pcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWZyYW1lTWFuYWdlci5hZGRJZnJhbWUoY3VycmVudE4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KGN1cnJlbnROLCB0aGlzLm1pcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIudHJhY2tMaW5rRWxlbWVudChjdXJyZW50Tik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QobikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5hZGRTaGFkb3dSb290KG4uc2hhZG93Um9vdCwgdGhpcy5kb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQ6IChpZnJhbWUsIGNoaWxkU24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd0RvbU1hbmFnZXIub2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZDogKGxpbmssIGNoaWxkU24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5hdHRhY2hMaW5rRWxlbWVudChsaW5rLCBjaGlsZFNuKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc24pIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBzbixcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRlZElkcy5hZGQoc24uaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5tYXBSZW1vdmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3IucmVtb3ZlTm9kZUZyb21NYXAodGhpcy5tYXBSZW1vdmVzLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLm1vdmVkU2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXJlbnRSZW1vdmVkKHRoaXMucmVtb3ZlcywgbiwgdGhpcy5taXJyb3IpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMubW92ZWRTZXQuaGFzKG4ucGFyZW50Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHB1c2hBZGQobik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBuIG9mIHRoaXMuYWRkZWRTZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNBbmNlc3RvckluU2V0KHRoaXMuZHJvcHBlZFNldCwgbikgJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNQYXJlbnRSZW1vdmVkKHRoaXMucmVtb3ZlcywgbiwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaEFkZChuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQW5jZXN0b3JJblNldCh0aGlzLm1vdmVkU2V0LCBuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hBZGQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BwZWRTZXQuYWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBudWxsO1xyXG4gICAgICAgICAgICB3aGlsZSAoYWRkTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKGNhbmRpZGF0ZS52YWx1ZS5wYXJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SWQgPSBnZXROZXh0SWQoY2FuZGlkYXRlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IC0xICYmIG5leHRJZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGNhbmRpZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFpbE5vZGUgPSBhZGRMaXN0LnRhaWw7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRhaWxOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9ub2RlID0gdGFpbE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhaWxOb2RlID0gdGFpbE5vZGUucHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50SWQgPSB0aGlzLm1pcnJvci5nZXRJZChfbm9kZS52YWx1ZS5wYXJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChfbm9kZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dElkID09PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudElkICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBfbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuaGFuZGxlZE5vZGUgPSBfbm9kZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5oYW5kbGVkTm9kZS5wYXJlbnROb2RlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGFuZGxlZE5vZGUucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFkb3dIb3N0ID0gdW5oYW5kbGVkTm9kZS5wYXJlbnROb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaG9zdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50SWQgPSB0aGlzLm1pcnJvci5nZXRJZChzaGFkb3dIb3N0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudElkICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IF9ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYWRkTGlzdC5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShhZGRMaXN0LmhlYWQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGUucHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgICBhZGRMaXN0LnJlbW92ZU5vZGUobm9kZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBwdXNoQWRkKG5vZGUudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0czogdGhpcy50ZXh0c1xyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHRleHQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gdGV4dC5ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnBhcmVudE5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbi5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24obi5wYXJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMubWlycm9yLmdldElkKG4pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh0ZXh0KSA9PiAhYWRkZWRJZHMuaGFzKHRleHQuaWQpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHRleHQpID0+IHRoaXMubWlycm9yLmhhcyh0ZXh0LmlkKSksXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLmF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICAubWFwKChhdHRyaWJ1dGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZXMgfSA9IGF0dHJpYnV0ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuc3R5bGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZBc1N0ciA9IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZS5zdHlsZURpZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmNoYW5nZWRBc1N0ciA9IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZS5fdW5jaGFuZ2VkU3R5bGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZBc1N0ci5sZW5ndGggPCBhdHRyaWJ1dGVzLnN0eWxlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkaWZmQXNTdHIgKyB1bmNoYW5nZWRBc1N0cikuc3BsaXQoJ3ZhcignKS5sZW5ndGggPT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZS5zcGxpdCgndmFyKCcpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBhdHRyaWJ1dGUuc3R5bGVEaWZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLm1pcnJvci5nZXRJZChhdHRyaWJ1dGUubm9kZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoYXR0cmlidXRlKSA9PiAhYWRkZWRJZHMuaGFzKGF0dHJpYnV0ZS5pZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoYXR0cmlidXRlKSA9PiB0aGlzLm1pcnJvci5oYXMoYXR0cmlidXRlLmlkKSksXHJcbiAgICAgICAgICAgICAgICByZW1vdmVzOiB0aGlzLnJlbW92ZXMsXHJcbiAgICAgICAgICAgICAgICBhZGRzLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoIXBheWxvYWQudGV4dHMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAhcGF5bG9hZC5hdHRyaWJ1dGVzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgIXBheWxvYWQucmVtb3Zlcy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICFwYXlsb2FkLmFkZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50ZXh0cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5hZGRlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5kcm9wcGVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVkTWFwID0ge307XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25DYihwYXlsb2FkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2VuVGV4dEFyZWFWYWx1ZU11dGF0aW9uID0gKHRleHRhcmVhKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5hdHRyaWJ1dGVNYXAuZ2V0KHRleHRhcmVhKTtcclxuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHRleHRhcmVhLFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlRGlmZjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgX3VuY2hhbmdlZFN0eWxlczoge30sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcC5zZXQodGV4dGFyZWEsIGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlcy52YWx1ZSA9IEFycmF5LmZyb20odGV4dGFyZWEuY2hpbGROb2RlcywgKGNuKSA9PiBjbi50ZXh0Q29udGVudCB8fCAnJykuam9pbignJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbiA9IChtKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc0lnbm9yZWQobS50YXJnZXQsIHRoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAobS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjaGFyYWN0ZXJEYXRhJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbS50YXJnZXQudGV4dENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IG0ub2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZWVkTWFza2luZ1RleHQobS50YXJnZXQsIHRoaXMubWFza1RleHRDbGFzcywgdGhpcy5tYXNrVGV4dFNlbGVjdG9yLCB0cnVlKSAmJiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5tYXNrVGV4dEZuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5tYXNrVGV4dEZuKHZhbHVlLCBjbG9zZXN0RWxlbWVudE9mTm9kZShtLnRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUucmVwbGFjZSgvW1xcU10vZywgJyonKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBtLnRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBtLnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0cmlidXRlTmFtZSA9IG0uYXR0cmlidXRlTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBtLnRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdldElucHV0VHlwZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hc2tJbnB1dFZhbHVlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IHRoaXMubWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6IHRhcmdldC50YWdOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IHRoaXMubWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSBtLm9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmF0dHJpYnV0ZU1hcC5nZXQobS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0lGUkFNRScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9PT0gJ3NyYycgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMua2VlcElmcmFtZVNyY0ZuKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5jb250ZW50RG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSAncnJfc3JjJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZURpZmY6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3VuY2hhbmdlZFN0eWxlczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcC5zZXQobS50YXJnZXQsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gJ3R5cGUnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC50YWdOYW1lID09PSAnSU5QVVQnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChtLm9sZFZhbHVlIHx8ICcnKS50b0xvd2VyQ2FzZSgpID09PSAncGFzc3dvcmQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcnItaXMtcGFzc3dvcmQnLCAndHJ1ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZUF0dHJpYnV0ZSh0YXJnZXQudGFnTmFtZSwgYXR0cmlidXRlTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKHRoaXMuZG9jLCB0b0xvd2VyQ2FzZSh0YXJnZXQudGFnTmFtZSksIHRvTG93ZXJDYXNlKGF0dHJpYnV0ZU5hbWUpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudW5hdHRhY2hlZERvYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5hdHRhY2hlZERvYyA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmF0dGFjaGVkRG9jID0gdGhpcy5kb2M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkID0gdGhpcy51bmF0dGFjaGVkRG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLm9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBtLm9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG5hbWUgb2YgQXJyYXkuZnJvbSh0YXJnZXQuc3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UHJpb3JpdHkgPSB0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJpb3JpdHkgIT09IG9sZC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UHJpb3JpdHkgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IFtuZXdWYWx1ZSwgbmV3UHJpb3JpdHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl91bmNoYW5nZWRTdHlsZXNbcG5hbWVdID0gW25ld1ZhbHVlLCBuZXdQcmlvcml0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwbmFtZSBvZiBBcnJheS5mcm9tKG9sZC5zdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjaGlsZExpc3QnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxvY2tlZChtLnRhcmdldCwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIHRydWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0udGFyZ2V0LnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24obS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG0uYWRkZWROb2Rlcy5mb3JFYWNoKChuKSA9PiB0aGlzLmdlbkFkZHMobiwgbS50YXJnZXQpKTtcclxuICAgICAgICAgICAgICAgICAgICBtLnJlbW92ZWROb2Rlcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IHRoaXMubWlycm9yLmdldElkKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChtLnRhcmdldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5taXJyb3IuZ2V0SWQobS50YXJnZXQuaG9zdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5taXJyb3IuZ2V0SWQobS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0lnbm9yZWQobiwgdGhpcy5taXJyb3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNTZXJpYWxpemVkKG4sIHRoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVlcERlbGV0ZSh0aGlzLmFkZGVkU2V0LCBuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcHBlZFNldC5hZGQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hZGRlZFNldC5oYXMobS50YXJnZXQpICYmIG5vZGVJZCA9PT0gLTEpIDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBbmNlc3RvclJlbW92ZWQobS50YXJnZXQsIHRoaXMubWlycm9yKSkgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1vdmVkU2V0LmhhcyhuKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlZE1hcFttb3ZlS2V5KG5vZGVJZCwgcGFyZW50SWQpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVlcERlbGV0ZSh0aGlzLm1vdmVkU2V0LCBuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3Zlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2hhZG93OiBpc1NoYWRvd1Jvb3QobS50YXJnZXQpICYmIGlzTmF0aXZlU2hhZG93RG9tKG0udGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcFJlbW92ZXMucHVzaChuKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZW5BZGRzID0gKG4sIHRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWROb2RlTWFuYWdlci5pbk90aGVyQnVmZmVyKG4sIHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZGRlZFNldC5oYXMobikgfHwgdGhpcy5tb3ZlZFNldC5oYXMobikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvci5oYXNOb2RlKG4pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJZ25vcmVkKG4sIHRoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZWRTZXQuYWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldElkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgdGhpcy5taXJyb3IuaGFzTm9kZSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSB0aGlzLm1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldElkICYmIHRhcmdldElkICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZWRNYXBbbW92ZUtleSh0aGlzLm1pcnJvci5nZXRJZChuKSwgdGFyZ2V0SWQpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZGVkU2V0LmFkZChuKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJvcHBlZFNldC5kZWxldGUobik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQobiwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSkge1xyXG4gICAgICAgICAgICAgICAgbi5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTikgPT4gdGhpcy5nZW5BZGRzKGNoaWxkTikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QobikpIHtcclxuICAgICAgICAgICAgICAgICAgICBuLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWROb2RlTWFuYWdlci5hZGQoY2hpbGROLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5BZGRzKGNoaWxkTiwgbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaW5pdChvcHRpb25zKSB7XHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAnbXV0YXRpb25DYicsXHJcbiAgICAgICAgICAgICdibG9ja0NsYXNzJyxcclxuICAgICAgICAgICAgJ2Jsb2NrU2VsZWN0b3InLFxyXG4gICAgICAgICAgICAnbWFza1RleHRDbGFzcycsXHJcbiAgICAgICAgICAgICdtYXNrVGV4dFNlbGVjdG9yJyxcclxuICAgICAgICAgICAgJ2lubGluZVN0eWxlc2hlZXQnLFxyXG4gICAgICAgICAgICAnbWFza0lucHV0T3B0aW9ucycsXHJcbiAgICAgICAgICAgICdtYXNrVGV4dEZuJyxcclxuICAgICAgICAgICAgJ21hc2tJbnB1dEZuJyxcclxuICAgICAgICAgICAgJ2tlZXBJZnJhbWVTcmNGbicsXHJcbiAgICAgICAgICAgICdyZWNvcmRDYW52YXMnLFxyXG4gICAgICAgICAgICAnaW5saW5lSW1hZ2VzJyxcclxuICAgICAgICAgICAgJ3NsaW1ET01PcHRpb25zJyxcclxuICAgICAgICAgICAgJ2RhdGFVUkxPcHRpb25zJyxcclxuICAgICAgICAgICAgJ2RvYycsXHJcbiAgICAgICAgICAgICdtaXJyb3InLFxyXG4gICAgICAgICAgICAnaWZyYW1lTWFuYWdlcicsXHJcbiAgICAgICAgICAgICdzdHlsZXNoZWV0TWFuYWdlcicsXHJcbiAgICAgICAgICAgICdzaGFkb3dEb21NYW5hZ2VyJyxcclxuICAgICAgICAgICAgJ2NhbnZhc01hbmFnZXInLFxyXG4gICAgICAgICAgICAncHJvY2Vzc2VkTm9kZU1hbmFnZXInLFxyXG4gICAgICAgIF0uZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgfVxyXG4gICAgdW5mcmVlemUoKSB7XHJcbiAgICAgICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIudW5mcmVlemUoKTtcclxuICAgICAgICB0aGlzLmVtaXQoKTtcclxuICAgIH1cclxuICAgIGlzRnJvemVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb3plbjtcclxuICAgIH1cclxuICAgIGxvY2soKSB7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5sb2NrKCk7XHJcbiAgICB9XHJcbiAgICB1bmxvY2soKSB7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIudW5sb2NrKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KCk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnNoYWRvd0RvbU1hbmFnZXIucmVzZXQoKTtcclxuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIucmVzZXQoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkZWVwRGVsZXRlKGFkZHNTZXQsIG4pIHtcclxuICAgIGFkZHNTZXQuZGVsZXRlKG4pO1xyXG4gICAgbi5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTikgPT4gZGVlcERlbGV0ZShhZGRzU2V0LCBjaGlsZE4pKTtcclxufVxyXG5mdW5jdGlvbiBpc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbiwgbWlycm9yKSB7XHJcbiAgICBpZiAocmVtb3Zlcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbiwgbWlycm9yKTtcclxufVxyXG5mdW5jdGlvbiBfaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4sIG1pcnJvcikge1xyXG4gICAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSBuO1xyXG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFyZW50SWQgPSBtaXJyb3IuZ2V0SWQocGFyZW50Tm9kZSk7XHJcbiAgICBpZiAocmVtb3Zlcy5zb21lKChyKSA9PiByLmlkID09PSBwYXJlbnRJZCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBfaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIHBhcmVudE5vZGUsIG1pcnJvcik7XHJcbn1cclxuZnVuY3Rpb24gaXNBbmNlc3RvckluU2V0KHNldCwgbikge1xyXG4gICAgaWYgKHNldC5zaXplID09PSAwKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgbik7XHJcbn1cclxuZnVuY3Rpb24gX2lzQW5jZXN0b3JJblNldChzZXQsIG4pIHtcclxuICAgIGNvbnN0IHsgcGFyZW50Tm9kZSB9ID0gbjtcclxuICAgIGlmICghcGFyZW50Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChzZXQuaGFzKHBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2lzQW5jZXN0b3JJblNldChzZXQsIHBhcmVudE5vZGUpO1xyXG59XG5cbmxldCBlcnJvckhhbmRsZXI7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGhhbmRsZXIpIHtcclxuICAgIGVycm9ySGFuZGxlciA9IGhhbmRsZXI7XHJcbn1cclxuZnVuY3Rpb24gdW5yZWdpc3RlckVycm9ySGFuZGxlcigpIHtcclxuICAgIGVycm9ySGFuZGxlciA9IHVuZGVmaW5lZDtcclxufVxyXG5jb25zdCBjYWxsYmFja1dyYXBwZXIgPSAoY2IpID0+IHtcclxuICAgIGlmICghZXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNiO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcnJ3ZWJXcmFwcGVkID0gKCguLi5yZXN0KSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNiKC4uLnJlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKGVycm9ySGFuZGxlciAmJiBlcnJvckhhbmRsZXIoZXJyb3IpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcnJ3ZWJXcmFwcGVkO1xyXG59O1xuXG5jb25zdCBtdXRhdGlvbkJ1ZmZlcnMgPSBbXTtcclxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcclxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgncGF0aCcgaW4gZXZlbnQgJiYgZXZlbnQucGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnBhdGhbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKF9hKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnQgJiYgZXZlbnQudGFyZ2V0O1xyXG59XHJcbmZ1bmN0aW9uIGluaXRNdXRhdGlvbk9ic2VydmVyKG9wdGlvbnMsIHJvb3RFbCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGNvbnN0IG11dGF0aW9uQnVmZmVyID0gbmV3IE11dGF0aW9uQnVmZmVyKCk7XHJcbiAgICBtdXRhdGlvbkJ1ZmZlcnMucHVzaChtdXRhdGlvbkJ1ZmZlcik7XHJcbiAgICBtdXRhdGlvbkJ1ZmZlci5pbml0KG9wdGlvbnMpO1xyXG4gICAgbGV0IG11dGF0aW9uT2JzZXJ2ZXJDdG9yID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHxcclxuICAgICAgICB3aW5kb3cuX19yck11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICBjb25zdCBhbmd1bGFyWm9uZVN5bWJvbCA9IChfYiA9IChfYSA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5ab25lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX19zeW1ib2xfXykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsICdNdXRhdGlvbk9ic2VydmVyJyk7XHJcbiAgICBpZiAoYW5ndWxhclpvbmVTeW1ib2wgJiZcclxuICAgICAgICB3aW5kb3dbYW5ndWxhclpvbmVTeW1ib2xdKSB7XHJcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlckN0b3IgPSB3aW5kb3dbYW5ndWxhclpvbmVTeW1ib2xdO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgbXV0YXRpb25PYnNlcnZlckN0b3IoY2FsbGJhY2tXcmFwcGVyKG11dGF0aW9uQnVmZmVyLnByb2Nlc3NNdXRhdGlvbnMuYmluZChtdXRhdGlvbkJ1ZmZlcikpKTtcclxuICAgIG9ic2VydmVyLm9ic2VydmUocm9vdEVsLCB7XHJcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcclxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxyXG4gICAgICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcclxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9ic2VydmVyO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRNb3ZlT2JzZXJ2ZXIoeyBtb3VzZW1vdmVDYiwgc2FtcGxpbmcsIGRvYywgbWlycm9yLCB9KSB7XHJcbiAgICBpZiAoc2FtcGxpbmcubW91c2Vtb3ZlID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRocmVzaG9sZCA9IHR5cGVvZiBzYW1wbGluZy5tb3VzZW1vdmUgPT09ICdudW1iZXInID8gc2FtcGxpbmcubW91c2Vtb3ZlIDogNTA7XHJcbiAgICBjb25zdCBjYWxsYmFja1RocmVzaG9sZCA9IHR5cGVvZiBzYW1wbGluZy5tb3VzZW1vdmVDYWxsYmFjayA9PT0gJ251bWJlcidcclxuICAgICAgICA/IHNhbXBsaW5nLm1vdXNlbW92ZUNhbGxiYWNrXHJcbiAgICAgICAgOiA1MDA7XHJcbiAgICBsZXQgcG9zaXRpb25zID0gW107XHJcbiAgICBsZXQgdGltZUJhc2VsaW5lO1xyXG4gICAgY29uc3Qgd3JhcHBlZENiID0gdGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKChzb3VyY2UpID0+IHtcclxuICAgICAgICBjb25zdCB0b3RhbE9mZnNldCA9IERhdGUubm93KCkgLSB0aW1lQmFzZWxpbmU7XHJcbiAgICAgICAgbW91c2Vtb3ZlQ2IocG9zaXRpb25zLm1hcCgocCkgPT4ge1xyXG4gICAgICAgICAgICBwLnRpbWVPZmZzZXQgLT0gdG90YWxPZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH0pLCBzb3VyY2UpO1xyXG4gICAgICAgIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRpbWVCYXNlbGluZSA9IG51bGw7XHJcbiAgICB9KSwgY2FsbGJhY2tUaHJlc2hvbGQpO1xyXG4gICAgY29uc3QgdXBkYXRlUG9zaXRpb24gPSBjYWxsYmFja1dyYXBwZXIodGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKChldnQpID0+IHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldnQpO1xyXG4gICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gbGVnYWN5X2lzVG91Y2hFdmVudChldnQpXHJcbiAgICAgICAgICAgID8gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdXHJcbiAgICAgICAgICAgIDogZXZ0O1xyXG4gICAgICAgIGlmICghdGltZUJhc2VsaW5lKSB7XHJcbiAgICAgICAgICAgIHRpbWVCYXNlbGluZSA9IG5vd1RpbWVzdGFtcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb3NpdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgIHg6IGNsaWVudFgsXHJcbiAgICAgICAgICAgIHk6IGNsaWVudFksXHJcbiAgICAgICAgICAgIGlkOiBtaXJyb3IuZ2V0SWQodGFyZ2V0KSxcclxuICAgICAgICAgICAgdGltZU9mZnNldDogbm93VGltZXN0YW1wKCkgLSB0aW1lQmFzZWxpbmUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgd3JhcHBlZENiKHR5cGVvZiBEcmFnRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIGV2dCBpbnN0YW5jZW9mIERyYWdFdmVudFxyXG4gICAgICAgICAgICA/IEluY3JlbWVudGFsU291cmNlJDEuRHJhZ1xyXG4gICAgICAgICAgICA6IGV2dCBpbnN0YW5jZW9mIE1vdXNlRXZlbnRcclxuICAgICAgICAgICAgICAgID8gSW5jcmVtZW50YWxTb3VyY2UkMS5Nb3VzZU1vdmVcclxuICAgICAgICAgICAgICAgIDogSW5jcmVtZW50YWxTb3VyY2UkMS5Ub3VjaE1vdmUpO1xyXG4gICAgfSksIHRocmVzaG9sZCwge1xyXG4gICAgICAgIHRyYWlsaW5nOiBmYWxzZSxcclxuICAgIH0pKTtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW1xyXG4gICAgICAgIG9uKCdtb3VzZW1vdmUnLCB1cGRhdGVQb3NpdGlvbiwgZG9jKSxcclxuICAgICAgICBvbigndG91Y2htb3ZlJywgdXBkYXRlUG9zaXRpb24sIGRvYyksXHJcbiAgICAgICAgb24oJ2RyYWcnLCB1cGRhdGVQb3NpdGlvbiwgZG9jKSxcclxuICAgIF07XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE1vdXNlSW50ZXJhY3Rpb25PYnNlcnZlcih7IG1vdXNlSW50ZXJhY3Rpb25DYiwgZG9jLCBtaXJyb3IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHNhbXBsaW5nLCB9KSB7XHJcbiAgICBpZiAoc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBkaXNhYmxlTWFwID0gc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gdHJ1ZSB8fFxyXG4gICAgICAgIHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8ge31cclxuICAgICAgICA6IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb247XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XHJcbiAgICBjb25zdCBnZXRIYW5kbGVyID0gKGV2ZW50S2V5KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XHJcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBwb2ludGVyVHlwZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCB0aGlzRXZlbnRLZXkgPSBldmVudEtleTtcclxuICAgICAgICAgICAgaWYgKCdwb2ludGVyVHlwZScgaW4gZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQucG9pbnRlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtb3VzZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLk1vdXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0b3VjaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlRvdWNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdwZW4nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5QZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldID09PSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZURvd24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0V2ZW50S2V5ID0gJ1RvdWNoU3RhcnQnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlVXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0V2ZW50S2V5ID0gJ1RvdWNoRW5kJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLlBlbikgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Ub3VjaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9pbnRlclR5cGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzRXZlbnRLZXkuc3RhcnRzV2l0aCgnVG91Y2gnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2gpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXNFdmVudEtleS5zdGFydHNXaXRoKCdNb3VzZScpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuTW91c2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gY3VycmVudFBvaW50ZXJUeXBlO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlID0gbGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xyXG4gICAgICAgICAgICBpZiAoIWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrV3JhcHBlcihtb3VzZUludGVyYWN0aW9uQ2IpKE9iamVjdC5hc3NpZ24oeyB0eXBlOiBNb3VzZUludGVyYWN0aW9uc1t0aGlzRXZlbnRLZXldLCBpZCwgeDogY2xpZW50WCwgeTogY2xpZW50WSB9LCAocG9pbnRlclR5cGUgIT09IG51bGwgJiYgeyBwb2ludGVyVHlwZSB9KSkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmtleXMoTW91c2VJbnRlcmFjdGlvbnMpXHJcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBOdW1iZXIuaXNOYU4oTnVtYmVyKGtleSkpICYmXHJcbiAgICAgICAgIWtleS5lbmRzV2l0aCgnX0RlcGFydGVkJykgJiZcclxuICAgICAgICBkaXNhYmxlTWFwW2tleV0gIT09IGZhbHNlKVxyXG4gICAgICAgIC5mb3JFYWNoKChldmVudEtleSkgPT4ge1xyXG4gICAgICAgIGxldCBldmVudE5hbWUgPSB0b0xvd2VyQ2FzZShldmVudEtleSk7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGdldEhhbmRsZXIoZXZlbnRLZXkpO1xyXG4gICAgICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlRG93bjpcclxuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VVcDpcclxuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Ub3VjaFN0YXJ0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Ub3VjaEVuZDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaGFuZGxlcnMucHVzaChvbihldmVudE5hbWUsIGhhbmRsZXIsIGRvYykpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFNjcm9sbE9ic2VydmVyKHsgc2Nyb2xsQ2IsIGRvYywgbWlycm9yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBzYW1wbGluZywgfSkge1xyXG4gICAgY29uc3QgdXBkYXRlUG9zaXRpb24gPSBjYWxsYmFja1dyYXBwZXIodGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKChldnQpID0+IHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldnQpO1xyXG4gICAgICAgIGlmICghdGFyZ2V0IHx8XHJcbiAgICAgICAgICAgIGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaWQgPSBtaXJyb3IuZ2V0SWQodGFyZ2V0KTtcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbExlZnRUb3AgPSBnZXRXaW5kb3dTY3JvbGwoZG9jLmRlZmF1bHRWaWV3KTtcclxuICAgICAgICAgICAgc2Nyb2xsQ2Ioe1xyXG4gICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICB4OiBzY3JvbGxMZWZ0VG9wLmxlZnQsXHJcbiAgICAgICAgICAgICAgICB5OiBzY3JvbGxMZWZ0VG9wLnRvcCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzY3JvbGxDYih7XHJcbiAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgIHg6IHRhcmdldC5zY3JvbGxMZWZ0LFxyXG4gICAgICAgICAgICAgICAgeTogdGFyZ2V0LnNjcm9sbFRvcCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHNhbXBsaW5nLnNjcm9sbCB8fCAxMDApKTtcclxuICAgIHJldHVybiBvbignc2Nyb2xsJywgdXBkYXRlUG9zaXRpb24sIGRvYyk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIoeyB2aWV3cG9ydFJlc2l6ZUNiIH0sIHsgd2luIH0pIHtcclxuICAgIGxldCBsYXN0SCA9IC0xO1xyXG4gICAgbGV0IGxhc3RXID0gLTE7XHJcbiAgICBjb25zdCB1cGRhdGVEaW1lbnNpb24gPSBjYWxsYmFja1dyYXBwZXIodGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBnZXRXaW5kb3dIZWlnaHQoKTtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IGdldFdpbmRvd1dpZHRoKCk7XHJcbiAgICAgICAgaWYgKGxhc3RIICE9PSBoZWlnaHQgfHwgbGFzdFcgIT09IHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0UmVzaXplQ2Ioe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IE51bWJlcih3aWR0aCksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IE51bWJlcihoZWlnaHQpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGFzdEggPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIGxhc3RXID0gd2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIDIwMCkpO1xyXG4gICAgcmV0dXJuIG9uKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb24sIHdpbik7XHJcbn1cclxuY29uc3QgSU5QVVRfVEFHUyA9IFsnSU5QVVQnLCAnVEVYVEFSRUEnLCAnU0VMRUNUJ107XHJcbmNvbnN0IGxhc3RJbnB1dFZhbHVlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gaW5pdElucHV0T2JzZXJ2ZXIoeyBpbnB1dENiLCBkb2MsIG1pcnJvciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgaWdub3JlQ2xhc3MsIGlnbm9yZVNlbGVjdG9yLCBtYXNrSW5wdXRPcHRpb25zLCBtYXNrSW5wdXRGbiwgc2FtcGxpbmcsIHVzZXJUcmlnZ2VyZWRPbklucHV0LCB9KSB7XHJcbiAgICBmdW5jdGlvbiBldmVudEhhbmRsZXIoZXZlbnQpIHtcclxuICAgICAgICBsZXQgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xyXG4gICAgICAgIGNvbnN0IHVzZXJUcmlnZ2VyZWQgPSBldmVudC5pc1RydXN0ZWQ7XHJcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRhcmdldCAmJiB0YXJnZXQudGFnTmFtZTtcclxuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhZ05hbWUgPT09ICdPUFRJT04nKSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRhcmdldCB8fFxyXG4gICAgICAgICAgICAhdGFnTmFtZSB8fFxyXG4gICAgICAgICAgICBJTlBVVF9UQUdTLmluZGV4T2YodGFnTmFtZSkgPCAwIHx8XHJcbiAgICAgICAgICAgIGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoaWdub3JlQ2xhc3MpIHx8XHJcbiAgICAgICAgICAgIChpZ25vcmVTZWxlY3RvciAmJiB0YXJnZXQubWF0Y2hlcyhpZ25vcmVTZWxlY3RvcikpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRleHQgPSB0YXJnZXQudmFsdWU7XHJcbiAgICAgICAgbGV0IGlzQ2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRJbnB1dFR5cGUodGFyZ2V0KSB8fCAnJztcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnY2hlY2tib3gnKSB7XHJcbiAgICAgICAgICAgIGlzQ2hlY2tlZCA9IHRhcmdldC5jaGVja2VkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXNrSW5wdXRPcHRpb25zW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHxcclxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uc1t0eXBlXSkge1xyXG4gICAgICAgICAgICB0ZXh0ID0gbWFza0lucHV0VmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRleHQsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNiV2l0aERlZHVwKHRhcmdldCwgdXNlclRyaWdnZXJlZE9uSW5wdXRcclxuICAgICAgICAgICAgPyB7IHRleHQsIGlzQ2hlY2tlZCwgdXNlclRyaWdnZXJlZCB9XHJcbiAgICAgICAgICAgIDogeyB0ZXh0LCBpc0NoZWNrZWQgfSk7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHRhcmdldC5uYW1lO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAncmFkaW8nICYmIG5hbWUgJiYgaXNDaGVja2VkKSB7XHJcbiAgICAgICAgICAgIGRvY1xyXG4gICAgICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoYGlucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJHtuYW1lfVwiXWApXHJcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlbCAhPT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGVsLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNiV2l0aERlZHVwKGVsLCB1c2VyVHJpZ2dlcmVkT25JbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgdGV4dCwgaXNDaGVja2VkOiAhaXNDaGVja2VkLCB1c2VyVHJpZ2dlcmVkOiBmYWxzZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyB0ZXh0LCBpc0NoZWNrZWQ6ICFpc0NoZWNrZWQgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNiV2l0aERlZHVwKHRhcmdldCwgdikge1xyXG4gICAgICAgIGNvbnN0IGxhc3RJbnB1dFZhbHVlID0gbGFzdElucHV0VmFsdWVNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFsYXN0SW5wdXRWYWx1ZSB8fFxyXG4gICAgICAgICAgICBsYXN0SW5wdXRWYWx1ZS50ZXh0ICE9PSB2LnRleHQgfHxcclxuICAgICAgICAgICAgbGFzdElucHV0VmFsdWUuaXNDaGVja2VkICE9PSB2LmlzQ2hlY2tlZCkge1xyXG4gICAgICAgICAgICBsYXN0SW5wdXRWYWx1ZU1hcC5zZXQodGFyZ2V0LCB2KTtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBtaXJyb3IuZ2V0SWQodGFyZ2V0KTtcclxuICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKGlucHV0Q2IpKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdiksIHsgaWQgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGV2ZW50cyA9IHNhbXBsaW5nLmlucHV0ID09PSAnbGFzdCcgPyBbJ2NoYW5nZSddIDogWydpbnB1dCcsICdjaGFuZ2UnXTtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzLm1hcCgoZXZlbnROYW1lKSA9PiBvbihldmVudE5hbWUsIGNhbGxiYWNrV3JhcHBlcihldmVudEhhbmRsZXIpLCBkb2MpKTtcclxuICAgIGNvbnN0IGN1cnJlbnRXaW5kb3cgPSBkb2MuZGVmYXVsdFZpZXc7XHJcbiAgICBpZiAoIWN1cnJlbnRXaW5kb3cpIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3IgPSBjdXJyZW50V2luZG93Lk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgJ3ZhbHVlJyk7XHJcbiAgICBjb25zdCBob29rUHJvcGVydGllcyA9IFtcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgJ3ZhbHVlJ10sXHJcbiAgICAgICAgW2N1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsICdjaGVja2VkJ10sXHJcbiAgICAgICAgW2N1cnJlbnRXaW5kb3cuSFRNTFNlbGVjdEVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MVGV4dEFyZWFFbGVtZW50LnByb3RvdHlwZSwgJ3ZhbHVlJ10sXHJcbiAgICAgICAgW2N1cnJlbnRXaW5kb3cuSFRNTFNlbGVjdEVsZW1lbnQucHJvdG90eXBlLCAnc2VsZWN0ZWRJbmRleCddLFxyXG4gICAgICAgIFtjdXJyZW50V2luZG93LkhUTUxPcHRpb25FbGVtZW50LnByb3RvdHlwZSwgJ3NlbGVjdGVkJ10sXHJcbiAgICBdO1xyXG4gICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvciAmJiBwcm9wZXJ0eURlc2NyaXB0b3Iuc2V0KSB7XHJcbiAgICAgICAgaGFuZGxlcnMucHVzaCguLi5ob29rUHJvcGVydGllcy5tYXAoKHApID0+IGhvb2tTZXR0ZXIocFswXSwgcFsxXSwge1xyXG4gICAgICAgICAgICBzZXQoKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoZXZlbnRIYW5kbGVyKSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVHJ1c3RlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LCBmYWxzZSwgY3VycmVudFdpbmRvdykpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHJ1bGUpIHtcclxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgZnVuY3Rpb24gcmVjdXJzZShjaGlsZFJ1bGUsIHBvcykge1xyXG4gICAgICAgIGlmICgoaGFzTmVzdGVkQ1NTUnVsZSgnQ1NTR3JvdXBpbmdSdWxlJykgJiZcclxuICAgICAgICAgICAgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NHcm91cGluZ1J1bGUpIHx8XHJcbiAgICAgICAgICAgIChoYXNOZXN0ZWRDU1NSdWxlKCdDU1NNZWRpYVJ1bGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NNZWRpYVJ1bGUpIHx8XHJcbiAgICAgICAgICAgIChoYXNOZXN0ZWRDU1NSdWxlKCdDU1NTdXBwb3J0c1J1bGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NTdXBwb3J0c1J1bGUpIHx8XHJcbiAgICAgICAgICAgIChoYXNOZXN0ZWRDU1NSdWxlKCdDU1NDb25kaXRpb25SdWxlJykgJiZcclxuICAgICAgICAgICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTQ29uZGl0aW9uUnVsZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZXMgPSBBcnJheS5mcm9tKGNoaWxkUnVsZS5wYXJlbnRSdWxlLmNzc1J1bGVzKTtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBydWxlcy5pbmRleE9mKGNoaWxkUnVsZSk7XHJcbiAgICAgICAgICAgIHBvcy51bnNoaWZ0KGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQpIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZXMgPSBBcnJheS5mcm9tKGNoaWxkUnVsZS5wYXJlbnRTdHlsZVNoZWV0LmNzc1J1bGVzKTtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBydWxlcy5pbmRleE9mKGNoaWxkUnVsZSk7XHJcbiAgICAgICAgICAgIHBvcy51bnNoaWZ0KGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgIH1cclxuICAgIHJldHVybiByZWN1cnNlKHJ1bGUsIHBvc2l0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SWRBbmRTdHlsZUlkKHNoZWV0LCBtaXJyb3IsIHN0eWxlTWlycm9yKSB7XHJcbiAgICBsZXQgaWQsIHN0eWxlSWQ7XHJcbiAgICBpZiAoIXNoZWV0KVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIGlmIChzaGVldC5vd25lck5vZGUpXHJcbiAgICAgICAgaWQgPSBtaXJyb3IuZ2V0SWQoc2hlZXQub3duZXJOb2RlKTtcclxuICAgIGVsc2VcclxuICAgICAgICBzdHlsZUlkID0gc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgIGlkLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbml0U3R5bGVTaGVldE9ic2VydmVyKHsgc3R5bGVTaGVldFJ1bGVDYiwgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlciB9LCB7IHdpbiB9KSB7XHJcbiAgICBpZiAoIXdpbi5DU1NTdHlsZVNoZWV0IHx8ICF3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUpIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnNlcnRSdWxlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGU7XHJcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IG5ldyBQcm94eShpbnNlcnRSdWxlLCB7XHJcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtydWxlLCBpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZywgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgIGlmICgoaWQgJiYgaWQgIT09IC0xKSB8fCAoc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkczogW3sgcnVsZSwgaW5kZXggfV0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBkZWxldGVSdWxlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGU7XHJcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eShkZWxldGVSdWxlLCB7XHJcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZywgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgIGlmICgoaWQgJiYgaWQgIT09IC0xKSB8fCAoc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW3sgaW5kZXggfV0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgfSk7XHJcbiAgICBsZXQgcmVwbGFjZTtcclxuICAgIGlmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSkge1xyXG4gICAgICAgIHJlcGxhY2UgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZTtcclxuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSA9IG5ldyBQcm94eShyZXBsYWNlLCB7XHJcbiAgICAgICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3RleHRdID0gYXJndW1lbnRzTGlzdDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgICAgIGlmICgoaWQgJiYgaWQgIT09IC0xKSB8fCAoc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2U6IHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGxldCByZXBsYWNlU3luYztcclxuICAgIGlmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMpIHtcclxuICAgICAgICByZXBsYWNlU3luYyA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYztcclxuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMgPSBuZXcgUHJveHkocmVwbGFjZVN5bmMsIHtcclxuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbdGV4dF0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZVN5bmM6IHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcyA9IHt9O1xyXG4gICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZSgnQ1NTR3JvdXBpbmdSdWxlJykpIHtcclxuICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTR3JvdXBpbmdSdWxlID0gd2luLkNTU0dyb3VwaW5nUnVsZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoJ0NTU01lZGlhUnVsZScpKSB7XHJcbiAgICAgICAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NNZWRpYVJ1bGUgPSB3aW4uQ1NTTWVkaWFSdWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKCdDU1NDb25kaXRpb25SdWxlJykpIHtcclxuICAgICAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU0NvbmRpdGlvblJ1bGUgPSB3aW4uQ1NTQ29uZGl0aW9uUnVsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZSgnQ1NTU3VwcG9ydHNSdWxlJykpIHtcclxuICAgICAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU1N1cHBvcnRzUnVsZSA9IHdpbi5DU1NTdXBwb3J0c1J1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgdW5tb2RpZmllZEZ1bmN0aW9ucyA9IHt9O1xyXG4gICAgT2JqZWN0LmVudHJpZXMoc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzKS5mb3JFYWNoKChbdHlwZUtleSwgdHlwZV0pID0+IHtcclxuICAgICAgICB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldID0ge1xyXG4gICAgICAgICAgICBpbnNlcnRSdWxlOiB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlLFxyXG4gICAgICAgICAgICBkZWxldGVSdWxlOiB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IG5ldyBQcm94eSh1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmluc2VydFJ1bGUsIHtcclxuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbcnVsZSwgaW5kZXhdID0gYXJndW1lbnRzTGlzdDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggfHwgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBuZXcgUHJveHkodW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5kZWxldGVSdWxlLCB7XHJcbiAgICAgICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW2luZGV4XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZy5wYXJlbnRTdHlsZVNoZWV0LCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgICAgIGlmICgoaWQgJiYgaWQgIT09IC0xKSB8fCAoc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW5kZXg6IFsuLi5nZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLCBpbmRleF0gfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IGluc2VydFJ1bGU7XHJcbiAgICAgICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBkZWxldGVSdWxlO1xyXG4gICAgICAgIHJlcGxhY2UgJiYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gcmVwbGFjZSk7XHJcbiAgICAgICAgcmVwbGFjZVN5bmMgJiYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IHJlcGxhY2VTeW5jKTtcclxuICAgICAgICBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMpLmZvckVhY2goKFt0eXBlS2V5LCB0eXBlXSkgPT4ge1xyXG4gICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5pbnNlcnRSdWxlO1xyXG4gICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlID0gdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5kZWxldGVSdWxlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoeyBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLCB9LCBob3N0KSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIGxldCBob3N0SWQgPSBudWxsO1xyXG4gICAgaWYgKGhvc3Qubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQnKVxyXG4gICAgICAgIGhvc3RJZCA9IG1pcnJvci5nZXRJZChob3N0KTtcclxuICAgIGVsc2VcclxuICAgICAgICBob3N0SWQgPSBtaXJyb3IuZ2V0SWQoaG9zdC5ob3N0KTtcclxuICAgIGNvbnN0IHBhdGNoVGFyZ2V0ID0gaG9zdC5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCdcclxuICAgICAgICA/IChfYSA9IGhvc3QuZGVmYXVsdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5Eb2N1bWVudFxyXG4gICAgICAgIDogKF9jID0gKF9iID0gaG9zdC5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVmYXVsdFZpZXcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5TaGFkb3dSb290O1xyXG4gICAgY29uc3Qgb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IgPSAocGF0Y2hUYXJnZXQgPT09IG51bGwgfHwgcGF0Y2hUYXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhdGNoVGFyZ2V0LnByb3RvdHlwZSlcclxuICAgICAgICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGF0Y2hUYXJnZXQgPT09IG51bGwgfHwgcGF0Y2hUYXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhdGNoVGFyZ2V0LnByb3RvdHlwZSwgJ2Fkb3B0ZWRTdHlsZVNoZWV0cycpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoaG9zdElkID09PSBudWxsIHx8XHJcbiAgICAgICAgaG9zdElkID09PSAtMSB8fFxyXG4gICAgICAgICFwYXRjaFRhcmdldCB8fFxyXG4gICAgICAgICFvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvcilcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdCwgJ2Fkb3B0ZWRTdHlsZVNoZWV0cycsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5lbnVtZXJhYmxlLFxyXG4gICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gKF9hID0gb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldChzaGVldHMpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoX2EgPSBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5zZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHNoZWV0cyk7XHJcbiAgICAgICAgICAgIGlmIChob3N0SWQgIT09IG51bGwgJiYgaG9zdElkICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKHNoZWV0cywgaG9zdElkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdCwgJ2Fkb3B0ZWRTdHlsZVNoZWV0cycsIHtcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXHJcbiAgICAgICAgICAgIGdldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0LFxyXG4gICAgICAgICAgICBzZXQ6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLnNldCxcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIoeyBzdHlsZURlY2xhcmF0aW9uQ2IsIG1pcnJvciwgaWdub3JlQ1NTQXR0cmlidXRlcywgc3R5bGVzaGVldE1hbmFnZXIsIH0sIHsgd2luIH0pIHtcclxuICAgIGNvbnN0IHNldFByb3BlcnR5ID0gd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5O1xyXG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gbmV3IFByb3h5KHNldFByb3BlcnR5LCB7XHJcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY29uc3QgW3Byb3BlcnR5LCB2YWx1ZSwgcHJpb3JpdHldID0gYXJndW1lbnRzTGlzdDtcclxuICAgICAgICAgICAgaWYgKGlnbm9yZUNTU0F0dHJpYnV0ZXMuaGFzKHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFByb3BlcnR5LmFwcGx5KHRoaXNBcmcsIFtwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKChfYSA9IHRoaXNBcmcucGFyZW50UnVsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnLnBhcmVudFJ1bGUpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICB9KSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmVtb3ZlUHJvcGVydHkgPSB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlUHJvcGVydHk7XHJcbiAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlUHJvcGVydHkgPSBuZXcgUHJveHkocmVtb3ZlUHJvcGVydHksIHtcclxuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCBbcHJvcGVydHldID0gYXJndW1lbnRzTGlzdDtcclxuICAgICAgICAgICAgaWYgKGlnbm9yZUNTU0F0dHJpYnV0ZXMuaGFzKHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVByb3BlcnR5LmFwcGx5KHRoaXNBcmcsIFtwcm9wZXJ0eV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCgoX2EgPSB0aGlzQXJnLnBhcmVudFJ1bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRTdHlsZVNoZWV0LCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiKHtcclxuICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcucGFyZW50UnVsZSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBzZXRQcm9wZXJ0eTtcclxuICAgICAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlUHJvcGVydHkgPSByZW1vdmVQcm9wZXJ0eTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRNZWRpYUludGVyYWN0aW9uT2JzZXJ2ZXIoeyBtZWRpYUludGVyYWN0aW9uQ2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG1pcnJvciwgc2FtcGxpbmcsIGRvYywgfSkge1xyXG4gICAgY29uc3QgaGFuZGxlciA9IGNhbGxiYWNrV3JhcHBlcigodHlwZSkgPT4gdGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcclxuICAgICAgICBpZiAoIXRhcmdldCB8fFxyXG4gICAgICAgICAgICBpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgY3VycmVudFRpbWUsIHZvbHVtZSwgbXV0ZWQsIHBsYXliYWNrUmF0ZSwgbG9vcCB9ID0gdGFyZ2V0O1xyXG4gICAgICAgIG1lZGlhSW50ZXJhY3Rpb25DYih7XHJcbiAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgIGlkOiBtaXJyb3IuZ2V0SWQodGFyZ2V0KSxcclxuICAgICAgICAgICAgY3VycmVudFRpbWUsXHJcbiAgICAgICAgICAgIHZvbHVtZSxcclxuICAgICAgICAgICAgbXV0ZWQsXHJcbiAgICAgICAgICAgIHBsYXliYWNrUmF0ZSxcclxuICAgICAgICAgICAgbG9vcCxcclxuICAgICAgICB9KTtcclxuICAgIH0pLCBzYW1wbGluZy5tZWRpYSB8fCA1MDApKTtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW1xyXG4gICAgICAgIG9uKCdwbGF5JywgaGFuZGxlcigwKSwgZG9jKSxcclxuICAgICAgICBvbigncGF1c2UnLCBoYW5kbGVyKDEpLCBkb2MpLFxyXG4gICAgICAgIG9uKCdzZWVrZWQnLCBoYW5kbGVyKDIpLCBkb2MpLFxyXG4gICAgICAgIG9uKCd2b2x1bWVjaGFuZ2UnLCBoYW5kbGVyKDMpLCBkb2MpLFxyXG4gICAgICAgIG9uKCdyYXRlY2hhbmdlJywgaGFuZGxlcig0KSwgZG9jKSxcclxuICAgIF07XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdEZvbnRPYnNlcnZlcih7IGZvbnRDYiwgZG9jIH0pIHtcclxuICAgIGNvbnN0IHdpbiA9IGRvYy5kZWZhdWx0VmlldztcclxuICAgIGlmICghd2luKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcclxuICAgIGNvbnN0IGZvbnRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgY29uc3Qgb3JpZ2luYWxGb250RmFjZSA9IHdpbi5Gb250RmFjZTtcclxuICAgIHdpbi5Gb250RmFjZSA9IGZ1bmN0aW9uIEZvbnRGYWNlKGZhbWlseSwgc291cmNlLCBkZXNjcmlwdG9ycykge1xyXG4gICAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IG9yaWdpbmFsRm9udEZhY2UoZmFtaWx5LCBzb3VyY2UsIGRlc2NyaXB0b3JzKTtcclxuICAgICAgICBmb250TWFwLnNldChmb250RmFjZSwge1xyXG4gICAgICAgICAgICBmYW1pbHksXHJcbiAgICAgICAgICAgIGJ1ZmZlcjogdHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzLFxyXG4gICAgICAgICAgICBmb250U291cmNlOiB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgICAgPyBzb3VyY2VcclxuICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShzb3VyY2UpKSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZvbnRGYWNlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2goZG9jLmZvbnRzLCAnYWRkJywgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmb250RmFjZSkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gZm9udE1hcC5nZXQoZm9udEZhY2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb250Q2IocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9udE1hcC5kZWxldGUoZm9udEZhY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbZm9udEZhY2VdKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBoYW5kbGVycy5wdXNoKCgpID0+IHtcclxuICAgICAgICB3aW4uRm9udEZhY2UgPSBvcmlnaW5hbEZvbnRGYWNlO1xyXG4gICAgfSk7XHJcbiAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0U2VsZWN0aW9uT2JzZXJ2ZXIocGFyYW0pIHtcclxuICAgIGNvbnN0IHsgZG9jLCBtaXJyb3IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHNlbGVjdGlvbkNiIH0gPSBwYXJhbTtcclxuICAgIGxldCBjb2xsYXBzZWQgPSB0cnVlO1xyXG4gICAgY29uc3QgdXBkYXRlU2VsZWN0aW9uID0gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2MuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgKGNvbGxhcHNlZCAmJiAoc2VsZWN0aW9uID09PSBudWxsIHx8IHNlbGVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb2xsYXBzZWQgPSBzZWxlY3Rpb24uaXNDb2xsYXBzZWQgfHwgZmFsc2U7XHJcbiAgICAgICAgY29uc3QgcmFuZ2VzID0gW107XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudCB8fCAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpO1xyXG4gICAgICAgICAgICBjb25zdCB7IHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQgfSA9IHJhbmdlO1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja2VkID0gaXNCbG9ja2VkKHN0YXJ0Q29udGFpbmVyLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSB8fFxyXG4gICAgICAgICAgICAgICAgaXNCbG9ja2VkKGVuZENvbnRhaW5lciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChibG9ja2VkKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBtaXJyb3IuZ2V0SWQoc3RhcnRDb250YWluZXIpLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBlbmQ6IG1pcnJvci5nZXRJZChlbmRDb250YWluZXIpLFxyXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VsZWN0aW9uQ2IoeyByYW5nZXMgfSk7XHJcbiAgICB9KTtcclxuICAgIHVwZGF0ZVNlbGVjdGlvbigpO1xyXG4gICAgcmV0dXJuIG9uKCdzZWxlY3Rpb25jaGFuZ2UnLCB1cGRhdGVTZWxlY3Rpb24pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRDdXN0b21FbGVtZW50T2JzZXJ2ZXIoeyBkb2MsIGN1c3RvbUVsZW1lbnRDYiwgfSkge1xyXG4gICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xyXG4gICAgaWYgKCF3aW4gfHwgIXdpbi5jdXN0b21FbGVtZW50cylcclxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xyXG4gICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCh3aW4uY3VzdG9tRWxlbWVudHMsICdkZWZpbmUnLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUsIGNvbnN0cnVjdG9yLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50Q2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBDdXN0b20gZWxlbWVudCBjYWxsYmFjayBmYWlsZWQgZm9yICR7bmFtZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW25hbWUsIGNvbnN0cnVjdG9yLCBvcHRpb25zXSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3RvcmVIYW5kbGVyO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlSG9va3MobywgaG9va3MpIHtcclxuICAgIGNvbnN0IHsgbXV0YXRpb25DYiwgbW91c2Vtb3ZlQ2IsIG1vdXNlSW50ZXJhY3Rpb25DYiwgc2Nyb2xsQ2IsIHZpZXdwb3J0UmVzaXplQ2IsIGlucHV0Q2IsIG1lZGlhSW50ZXJhY3Rpb25DYiwgc3R5bGVTaGVldFJ1bGVDYiwgc3R5bGVEZWNsYXJhdGlvbkNiLCBjYW52YXNNdXRhdGlvbkNiLCBmb250Q2IsIHNlbGVjdGlvbkNiLCBjdXN0b21FbGVtZW50Q2IsIH0gPSBvO1xyXG4gICAgby5tdXRhdGlvbkNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MubXV0YXRpb24pIHtcclxuICAgICAgICAgICAgaG9va3MubXV0YXRpb24oLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG11dGF0aW9uQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5tb3VzZW1vdmVDYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLm1vdXNlbW92ZSkge1xyXG4gICAgICAgICAgICBob29rcy5tb3VzZW1vdmUoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vdXNlbW92ZUNiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8ubW91c2VJbnRlcmFjdGlvbkNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MubW91c2VJbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5tb3VzZUludGVyYWN0aW9uKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtb3VzZUludGVyYWN0aW9uQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5zY3JvbGxDYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLnNjcm9sbCkge1xyXG4gICAgICAgICAgICBob29rcy5zY3JvbGwoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjcm9sbENiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8udmlld3BvcnRSZXNpemVDYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLnZpZXdwb3J0UmVzaXplKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnZpZXdwb3J0UmVzaXplKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8uaW5wdXRDYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLmlucHV0KSB7XHJcbiAgICAgICAgICAgIGhvb2tzLmlucHV0KC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnB1dENiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8ubWVkaWFJbnRlcmFjdGlvbkNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MubWVkaWFJbnRlYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLm1lZGlhSW50ZWFjdGlvbiguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8uc3R5bGVTaGVldFJ1bGVDYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLnN0eWxlU2hlZXRSdWxlKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnN0eWxlU2hlZXRSdWxlKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8uc3R5bGVEZWNsYXJhdGlvbkNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Muc3R5bGVEZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5zdHlsZURlY2xhcmF0aW9uKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5jYW52YXNNdXRhdGlvbkNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MuY2FudmFzTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgaG9va3MuY2FudmFzTXV0YXRpb24oLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbnZhc011dGF0aW9uQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5mb250Q2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5mb250KSB7XHJcbiAgICAgICAgICAgIGhvb2tzLmZvbnQoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvbnRDYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLnNlbGVjdGlvbkNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Muc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnNlbGVjdGlvbiguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VsZWN0aW9uQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5jdXN0b21FbGVtZW50Q2IgPSAoLi4uYykgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5jdXN0b21FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGhvb2tzLmN1c3RvbUVsZW1lbnQoLi4uYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1c3RvbUVsZW1lbnRDYiguLi5jKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdE9ic2VydmVycyhvLCBob29rcyA9IHt9KSB7XHJcbiAgICBjb25zdCBjdXJyZW50V2luZG93ID0gby5kb2MuZGVmYXVsdFZpZXc7XHJcbiAgICBpZiAoIWN1cnJlbnRXaW5kb3cpIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBtZXJnZUhvb2tzKG8sIGhvb2tzKTtcclxuICAgIGxldCBtdXRhdGlvbk9ic2VydmVyO1xyXG4gICAgaWYgKG8ucmVjb3JkRE9NKSB7XHJcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKG8sIG8uZG9jKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1vdXNlbW92ZUhhbmRsZXIgPSBpbml0TW92ZU9ic2VydmVyKG8pO1xyXG4gICAgY29uc3QgbW91c2VJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TW91c2VJbnRlcmFjdGlvbk9ic2VydmVyKG8pO1xyXG4gICAgY29uc3Qgc2Nyb2xsSGFuZGxlciA9IGluaXRTY3JvbGxPYnNlcnZlcihvKTtcclxuICAgIGNvbnN0IHZpZXdwb3J0UmVzaXplSGFuZGxlciA9IGluaXRWaWV3cG9ydFJlc2l6ZU9ic2VydmVyKG8sIHtcclxuICAgICAgICB3aW46IGN1cnJlbnRXaW5kb3csXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGlucHV0SGFuZGxlciA9IGluaXRJbnB1dE9ic2VydmVyKG8pO1xyXG4gICAgY29uc3QgbWVkaWFJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyKG8pO1xyXG4gICAgbGV0IHN0eWxlU2hlZXRPYnNlcnZlciA9ICgpID0+IHsgfTtcclxuICAgIGxldCBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyID0gKCkgPT4geyB9O1xyXG4gICAgbGV0IHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlciA9ICgpID0+IHsgfTtcclxuICAgIGxldCBmb250T2JzZXJ2ZXIgPSAoKSA9PiB7IH07XHJcbiAgICBpZiAoby5yZWNvcmRET00pIHtcclxuICAgICAgICBzdHlsZVNoZWV0T2JzZXJ2ZXIgPSBpbml0U3R5bGVTaGVldE9ic2VydmVyKG8sIHsgd2luOiBjdXJyZW50V2luZG93IH0pO1xyXG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSBpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcihvLCBvLmRvYyk7XHJcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcihvLCB7XHJcbiAgICAgICAgICAgIHdpbjogY3VycmVudFdpbmRvdyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoby5jb2xsZWN0Rm9udHMpIHtcclxuICAgICAgICAgICAgZm9udE9ic2VydmVyID0gaW5pdEZvbnRPYnNlcnZlcihvKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZWxlY3Rpb25PYnNlcnZlciA9IGluaXRTZWxlY3Rpb25PYnNlcnZlcihvKTtcclxuICAgIGNvbnN0IGN1c3RvbUVsZW1lbnRPYnNlcnZlciA9IGluaXRDdXN0b21FbGVtZW50T2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBwbHVnaW5IYW5kbGVycyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2Ygby5wbHVnaW5zKSB7XHJcbiAgICAgICAgcGx1Z2luSGFuZGxlcnMucHVzaChwbHVnaW4ub2JzZXJ2ZXIocGx1Z2luLmNhbGxiYWNrLCBjdXJyZW50V2luZG93LCBwbHVnaW4ub3B0aW9ucykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGIpID0+IGIucmVzZXQoKSk7XHJcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlciA9PT0gbnVsbCB8fCBtdXRhdGlvbk9ic2VydmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICBtb3VzZW1vdmVIYW5kbGVyKCk7XHJcbiAgICAgICAgbW91c2VJbnRlcmFjdGlvbkhhbmRsZXIoKTtcclxuICAgICAgICBzY3JvbGxIYW5kbGVyKCk7XHJcbiAgICAgICAgdmlld3BvcnRSZXNpemVIYW5kbGVyKCk7XHJcbiAgICAgICAgaW5wdXRIYW5kbGVyKCk7XHJcbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkhhbmRsZXIoKTtcclxuICAgICAgICBzdHlsZVNoZWV0T2JzZXJ2ZXIoKTtcclxuICAgICAgICBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKCk7XHJcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKCk7XHJcbiAgICAgICAgZm9udE9ic2VydmVyKCk7XHJcbiAgICAgICAgc2VsZWN0aW9uT2JzZXJ2ZXIoKTtcclxuICAgICAgICBjdXN0b21FbGVtZW50T2JzZXJ2ZXIoKTtcclxuICAgICAgICBwbHVnaW5IYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzTmVzdGVkQ1NTUnVsZShwcm9wKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvd1twcm9wXSAhPT0gJ3VuZGVmaW5lZCc7XHJcbn1cclxuZnVuY3Rpb24gY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKHByb3ApIHtcclxuICAgIHJldHVybiBCb29sZWFuKHR5cGVvZiB3aW5kb3dbcHJvcF0gIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJlxyXG4gICAgICAgICdpbnNlcnRSdWxlJyBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlICYmXHJcbiAgICAgICAgJ2RlbGV0ZVJ1bGUnIGluIHdpbmRvd1twcm9wXS5wcm90b3R5cGUpO1xyXG59XG5cbmNsYXNzIENyb3NzT3JpZ2luSWZyYW1lTWlycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGdlbmVyYXRlSWRGbikge1xyXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVJZEZuID0gZ2VuZXJhdGVJZEZuO1xyXG4gICAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRJZChpZnJhbWUsIHJlbW90ZUlkLCBpZFRvUmVtb3RlTWFwLCByZW1vdGVUb0lkTWFwKSB7XHJcbiAgICAgICAgY29uc3QgaWRUb1JlbW90ZUlkTWFwID0gaWRUb1JlbW90ZU1hcCB8fCB0aGlzLmdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IHJlbW90ZVRvSWRNYXAgfHwgdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcclxuICAgICAgICBsZXQgaWQgPSBpZFRvUmVtb3RlSWRNYXAuZ2V0KHJlbW90ZUlkKTtcclxuICAgICAgICBpZiAoIWlkKSB7XHJcbiAgICAgICAgICAgIGlkID0gdGhpcy5nZW5lcmF0ZUlkRm4oKTtcclxuICAgICAgICAgICAgaWRUb1JlbW90ZUlkTWFwLnNldChyZW1vdGVJZCwgaWQpO1xyXG4gICAgICAgICAgICByZW1vdGVJZFRvSWRNYXAuc2V0KGlkLCByZW1vdGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH1cclxuICAgIGdldElkcyhpZnJhbWUsIHJlbW90ZUlkKSB7XHJcbiAgICAgICAgY29uc3QgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5nZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKTtcclxuICAgICAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIHJldHVybiByZW1vdGVJZC5tYXAoKGlkKSA9PiB0aGlzLmdldElkKGlmcmFtZSwgaWQsIGlkVG9SZW1vdGVJZE1hcCwgcmVtb3RlSWRUb0lkTWFwKSk7XHJcbiAgICB9XHJcbiAgICBnZXRSZW1vdGVJZChpZnJhbWUsIGlkLCBtYXApIHtcclxuICAgICAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSBtYXAgfHwgdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcclxuICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUlkID0gcmVtb3RlSWRUb0lkTWFwLmdldChpZCk7XHJcbiAgICAgICAgaWYgKCFyZW1vdGVJZClcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIHJldHVybiByZW1vdGVJZDtcclxuICAgIH1cclxuICAgIGdldFJlbW90ZUlkcyhpZnJhbWUsIGlkcykge1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGlkcy5tYXAoKGlkKSA9PiB0aGlzLmdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIHJlbW90ZUlkVG9JZE1hcCkpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoaWZyYW1lKSB7XHJcbiAgICAgICAgaWYgKCFpZnJhbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuZGVsZXRlKGlmcmFtZSk7XHJcbiAgICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuZGVsZXRlKGlmcmFtZSk7XHJcbiAgICB9XHJcbiAgICBnZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKSB7XHJcbiAgICAgICAgbGV0IGlkVG9SZW1vdGVJZE1hcCA9IHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLmdldChpZnJhbWUpO1xyXG4gICAgICAgIGlmICghaWRUb1JlbW90ZUlkTWFwKSB7XHJcbiAgICAgICAgICAgIGlkVG9SZW1vdGVJZE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuc2V0KGlmcmFtZSwgaWRUb1JlbW90ZUlkTWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlkVG9SZW1vdGVJZE1hcDtcclxuICAgIH1cclxuICAgIGdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpIHtcclxuICAgICAgICBsZXQgcmVtb3RlSWRUb0lkTWFwID0gdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuZ2V0KGlmcmFtZSk7XHJcbiAgICAgICAgaWYgKCFyZW1vdGVJZFRvSWRNYXApIHtcclxuICAgICAgICAgICAgcmVtb3RlSWRUb0lkTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5zZXQoaWZyYW1lLCByZW1vdGVJZFRvSWRNYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVtb3RlSWRUb0lkTWFwO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIElmcmFtZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaWZyYW1lcyA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZU1pcnJvciA9IG5ldyBDcm9zc09yaWdpbklmcmFtZU1pcnJvcihnZW5JZCk7XHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xyXG4gICAgICAgIHRoaXMud3JhcHBlZEVtaXQgPSBvcHRpb25zLndyYXBwZWRFbWl0O1xyXG4gICAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIgPSBvcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gb3B0aW9ucy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXM7XHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yID0gbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IuZ2VuZXJhdGVJZC5iaW5kKHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpKTtcclxuICAgICAgICB0aGlzLm1pcnJvciA9IG9wdGlvbnMubWlycm9yO1xyXG4gICAgICAgIGlmICh0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcykge1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRJZnJhbWUoaWZyYW1lRWwpIHtcclxuICAgICAgICB0aGlzLmlmcmFtZXMuc2V0KGlmcmFtZUVsLCB0cnVlKTtcclxuICAgICAgICBpZiAoaWZyYW1lRWwuY29udGVudFdpbmRvdylcclxuICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZU1hcC5zZXQoaWZyYW1lRWwuY29udGVudFdpbmRvdywgaWZyYW1lRWwpO1xyXG4gICAgfVxyXG4gICAgYWRkTG9hZExpc3RlbmVyKGNiKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkTGlzdGVuZXIgPSBjYjtcclxuICAgIH1cclxuICAgIGF0dGFjaElmcmFtZShpZnJhbWVFbCwgY2hpbGRTbikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xyXG4gICAgICAgICAgICBhZGRzOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsKSxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0SWQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogY2hpbGRTbixcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHJlbW92ZXM6IFtdLFxyXG4gICAgICAgICAgICB0ZXh0czogW10sXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdLFxyXG4gICAgICAgICAgICBpc0F0dGFjaElmcmFtZTogdHJ1ZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICAoX2EgPSB0aGlzLmxvYWRMaXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgaWZyYW1lRWwpO1xyXG4gICAgICAgIGlmIChpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQgJiZcclxuICAgICAgICAgICAgaWZyYW1lRWwuY29udGVudERvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJlxyXG4gICAgICAgICAgICBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLCB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQpKTtcclxuICAgIH1cclxuICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnN0IGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50ID0gbWVzc2FnZTtcclxuICAgICAgICBpZiAoY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS50eXBlICE9PSAncnJ3ZWInIHx8XHJcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50Lm9yaWdpbiAhPT0gY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5vcmlnaW4pXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBpZnJhbWVTb3VyY2VXaW5kb3cgPSBtZXNzYWdlLnNvdXJjZTtcclxuICAgICAgICBpZiAoIWlmcmFtZVNvdXJjZVdpbmRvdylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGlmcmFtZUVsID0gdGhpcy5jcm9zc09yaWdpbklmcmFtZU1hcC5nZXQobWVzc2FnZS5zb3VyY2UpO1xyXG4gICAgICAgIGlmICghaWZyYW1lRWwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEV2ZW50ID0gdGhpcy50cmFuc2Zvcm1Dcm9zc09yaWdpbkV2ZW50KGlmcmFtZUVsLCBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLmV2ZW50KTtcclxuICAgICAgICBpZiAodHJhbnNmb3JtZWRFdmVudClcclxuICAgICAgICAgICAgdGhpcy53cmFwcGVkRW1pdCh0cmFuc2Zvcm1lZEV2ZW50LCBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLmlzQ2hlY2tvdXQpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudChpZnJhbWVFbCwgZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzd2l0Y2ggKGUudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLkZ1bGxTbmFwc2hvdDoge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZU1pcnJvci5yZXNldChpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IucmVzZXQoaWZyYW1lRWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUoZS5kYXRhLm5vZGUsIGlmcmFtZUVsKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RJZCA9IGUuZGF0YS5ub2RlLmlkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcC5zZXQoaWZyYW1lRWwsIHJvb3RJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKGUuZGF0YS5ub2RlLCByb290SWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGUudGltZXN0YW1wLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuTXV0YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBlLmRhdGEubm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0czogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0F0dGFjaElmcmFtZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLk1ldGE6XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuTG9hZDpcclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5Eb21Db250ZW50TG9hZGVkOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5QbHVnaW46IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuQ3VzdG9tOiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZS5kYXRhLnBheWxvYWQsIGlmcmFtZUVsLCBbJ2lkJywgJ3BhcmVudElkJywgJ3ByZXZpb3VzSWQnLCAnbmV4dElkJ10pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90OiB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUuZGF0YS5zb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuTXV0YXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhLmFkZHMuZm9yRWFjaCgobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKG4sIGlmcmFtZUVsLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhcmVudElkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmV4dElkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJldmlvdXNJZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkT25Ob2RlKG4ubm9kZSwgaWZyYW1lRWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm9vdElkID0gdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcC5nZXQoaWZyYW1lRWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdElkICYmIHRoaXMucGF0Y2hSb290SWRPbk5vZGUobi5ub2RlLCByb290SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhLnJlbW92ZXMuZm9yRWFjaCgobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKG4sIGlmcmFtZUVsLCBbJ3BhcmVudElkJywgJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhLmF0dHJpYnV0ZXMuZm9yRWFjaCgobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKG4sIGlmcmFtZUVsLCBbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhLnRleHRzLmZvckVhY2goKG4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuLCBpZnJhbWVFbCwgWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuRHJhZzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuVG91Y2hNb3ZlOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5Nb3VzZU1vdmU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhLnBvc2l0aW9ucy5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMocCwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLlZpZXdwb3J0UmVzaXplOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLk1lZGlhSW50ZXJhY3Rpb246XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLk1vdXNlSW50ZXJhY3Rpb246XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLlNjcm9sbDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuQ2FudmFzTXV0YXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLklucHV0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlLmRhdGEsIGlmcmFtZUVsLCBbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLlN0eWxlU2hlZXRSdWxlOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5TdHlsZURlY2xhcmF0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlLmRhdGEsIGlmcmFtZUVsLCBbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhlLmRhdGEsIGlmcmFtZUVsLCBbJ3N0eWxlSWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuRm9udDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLlNlbGVjdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEucmFuZ2VzLmZvckVhY2goKHJhbmdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMocmFuZ2UsIGlmcmFtZUVsLCBbJ3N0YXJ0JywgJ2VuZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuQWRvcHRlZFN0eWxlU2hlZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVN0eWxlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnc3R5bGVJZHMnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGUuZGF0YS5zdHlsZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChzdHlsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoc3R5bGUsIGlmcmFtZUVsLCBbJ3N0eWxlSWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZShpZnJhbWVNaXJyb3IsIG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgdHlwZW9mIG9ialtrZXldICE9PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIG9ialtrZXldID0gaWZyYW1lTWlycm9yLmdldElkcyhpZnJhbWVFbCwgb2JqW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBpZnJhbWVNaXJyb3IuZ2V0SWQoaWZyYW1lRWwsIG9ialtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZUlkcyhvYmosIGlmcmFtZUVsLCBrZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcclxuICAgIH1cclxuICAgIHJlcGxhY2VTdHlsZUlkcyhvYmosIGlmcmFtZUVsLCBrZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IsIG9iaiwgaWZyYW1lRWwsIGtleXMpO1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZUlkT25Ob2RlKG5vZGUsIGlmcmFtZUVsKSB7XHJcbiAgICAgICAgdGhpcy5yZXBsYWNlSWRzKG5vZGUsIGlmcmFtZUVsLCBbJ2lkJywgJ3Jvb3RJZCddKTtcclxuICAgICAgICBpZiAoJ2NoaWxkTm9kZXMnIGluIG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZE9uTm9kZShjaGlsZCwgaWZyYW1lRWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXRjaFJvb3RJZE9uTm9kZShub2RlLCByb290SWQpIHtcclxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSBOb2RlVHlwZS5Eb2N1bWVudCAmJiAhbm9kZS5yb290SWQpXHJcbiAgICAgICAgICAgIG5vZGUucm9vdElkID0gcm9vdElkO1xyXG4gICAgICAgIGlmICgnY2hpbGROb2RlcycgaW4gbm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hSb290SWRPbk5vZGUoY2hpbGQsIHJvb3RJZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGFkb3dEb21NYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnNoYWRvd0RvbXMgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsQ2IgPSBvcHRpb25zLnNjcm9sbENiO1xyXG4gICAgICAgIHRoaXMuYnlwYXNzT3B0aW9ucyA9IG9wdGlvbnMuYnlwYXNzT3B0aW9ucztcclxuICAgICAgICB0aGlzLm1pcnJvciA9IG9wdGlvbnMubWlycm9yO1xyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgfVxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhFbGVtZW50LCBkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICBhZGRTaGFkb3dSb290KHNoYWRvd1Jvb3QsIGRvYykge1xyXG4gICAgICAgIGlmICghaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAodGhpcy5zaGFkb3dEb21zLmhhcyhzaGFkb3dSb290KSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuc2hhZG93RG9tcy5hZGQoc2hhZG93Um9vdCk7XHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBpbml0TXV0YXRpb25PYnNlcnZlcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYnlwYXNzT3B0aW9ucyksIHsgZG9jLCBtdXRhdGlvbkNiOiB0aGlzLm11dGF0aW9uQ2IsIG1pcnJvcjogdGhpcy5taXJyb3IsIHNoYWRvd0RvbU1hbmFnZXI6IHRoaXMgfSksIHNoYWRvd1Jvb3QpO1xyXG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpKTtcclxuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKGluaXRTY3JvbGxPYnNlcnZlcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYnlwYXNzT3B0aW9ucyksIHsgc2Nyb2xsQ2I6IHRoaXMuc2Nyb2xsQ2IsIGRvYzogc2hhZG93Um9vdCwgbWlycm9yOiB0aGlzLm1pcnJvciB9KSkpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2hhZG93Um9vdC5hZG9wdGVkU3R5bGVTaGVldHMgJiZcclxuICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ5cGFzc09wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhzaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cywgdGhpcy5taXJyb3IuZ2V0SWQoc2hhZG93Um9vdC5ob3N0KSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoe1xyXG4gICAgICAgICAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcclxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyOiB0aGlzLmJ5cGFzc09wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXIsXHJcbiAgICAgICAgICAgIH0sIHNoYWRvd1Jvb3QpKTtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxuICAgIG9ic2VydmVBdHRhY2hTaGFkb3coaWZyYW1lRWxlbWVudCkge1xyXG4gICAgICAgIGlmICghaWZyYW1lRWxlbWVudC5jb250ZW50V2luZG93IHx8ICFpZnJhbWVFbGVtZW50LmNvbnRlbnREb2N1bWVudClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucGF0Y2hBdHRhY2hTaGFkb3coaWZyYW1lRWxlbWVudC5jb250ZW50V2luZG93LkVsZW1lbnQsIGlmcmFtZUVsZW1lbnQuY29udGVudERvY3VtZW50KTtcclxuICAgIH1cclxuICAgIHBhdGNoQXR0YWNoU2hhZG93KGVsZW1lbnQsIGRvYykge1xyXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2gocGF0Y2goZWxlbWVudC5wcm90b3R5cGUsICdhdHRhY2hTaGFkb3cnLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBvcmlnaW5hbC5jYWxsKHRoaXMsIG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaGFkb3dSb290ICYmIGluRG9tKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuYWRkU2hhZG93Um9vdCh0aGlzLnNoYWRvd1Jvb3QsIGRvYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93Um9vdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5zaGFkb3dEb21zID0gbmV3IFdlYWtTZXQoKTtcclxuICAgIH1cclxufVxuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XG5cbi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXIgMS4wLjEgPGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXI+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgTmlrbGFzIHZvbiBIZXJ0emVuIDxodHRwczovL2hlcnR6ZW4uY29tPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIExpY2Vuc2VcbiAqL1xudmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxudmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xufVxudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSAnJztcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cbiAgICBpZiAobGVuICUgMyA9PT0gMikge1xuICAgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArICc9JztcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArICc9PSc7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQ7XG59O1xuXG5jb25zdCBjYW52YXNWYXJNYXAgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIHZhcmlhYmxlTGlzdEZvcihjdHgsIGN0b3IpIHtcclxuICAgIGxldCBjb250ZXh0TWFwID0gY2FudmFzVmFyTWFwLmdldChjdHgpO1xyXG4gICAgaWYgKCFjb250ZXh0TWFwKSB7XHJcbiAgICAgICAgY29udGV4dE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjYW52YXNWYXJNYXAuc2V0KGN0eCwgY29udGV4dE1hcCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNvbnRleHRNYXAuaGFzKGN0b3IpKSB7XHJcbiAgICAgICAgY29udGV4dE1hcC5zZXQoY3RvciwgW10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHRNYXAuZ2V0KGN0b3IpO1xyXG59XHJcbmNvbnN0IHNhdmVXZWJHTFZhciA9ICh2YWx1ZSwgd2luLCBjdHgpID0+IHtcclxuICAgIGlmICghdmFsdWUgfHxcclxuICAgICAgICAhKGlzSW5zdGFuY2VPZldlYkdMT2JqZWN0KHZhbHVlLCB3aW4pIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgY29uc3QgbGlzdCA9IHZhcmlhYmxlTGlzdEZvcihjdHgsIG5hbWUpO1xyXG4gICAgbGV0IGluZGV4ID0gbGlzdC5pbmRleE9mKHZhbHVlKTtcclxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBpbmRleCA9IGxpc3QubGVuZ3RoO1xyXG4gICAgICAgIGxpc3QucHVzaCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbn07XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUFyZyh2YWx1ZSwgd2luLCBjdHgpIHtcclxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoYXJnKSA9PiBzZXJpYWxpemVBcmcoYXJnLCB3aW4sIGN0eCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBhcmdzOiBbT2JqZWN0LnZhbHVlcyh2YWx1ZSldLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gZW5jb2RlKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBiYXNlNjQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVBcmcodmFsdWUuYnVmZmVyLCB3aW4sIGN0eCksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5ieXRlT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgdmFsdWUuYnl0ZUxlbmd0aCxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgY29uc3QgeyBzcmMgfSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIHNyYyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSAnSFRNTEltYWdlRWxlbWVudCc7XHJcbiAgICAgICAgY29uc3Qgc3JjID0gdmFsdWUudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgc3JjLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGFyZ3M6IFtzZXJpYWxpemVBcmcodmFsdWUuZGF0YSwgd2luLCBjdHgpLCB2YWx1ZS53aWR0aCwgdmFsdWUuaGVpZ2h0XSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QodmFsdWUsIHdpbikgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2F2ZVdlYkdMVmFyKHZhbHVlLCB3aW4sIGN0eCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuY29uc3Qgc2VyaWFsaXplQXJncyA9IChhcmdzLCB3aW4sIGN0eCkgPT4ge1xyXG4gICAgcmV0dXJuIGFyZ3MubWFwKChhcmcpID0+IHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KSk7XHJcbn07XHJcbmNvbnN0IGlzSW5zdGFuY2VPZldlYkdMT2JqZWN0ID0gKHZhbHVlLCB3aW4pID0+IHtcclxuICAgIGNvbnN0IHdlYkdMQ29uc3RydWN0b3JOYW1lcyA9IFtcclxuICAgICAgICAnV2ViR0xBY3RpdmVJbmZvJyxcclxuICAgICAgICAnV2ViR0xCdWZmZXInLFxyXG4gICAgICAgICdXZWJHTEZyYW1lYnVmZmVyJyxcclxuICAgICAgICAnV2ViR0xQcm9ncmFtJyxcclxuICAgICAgICAnV2ViR0xSZW5kZXJidWZmZXInLFxyXG4gICAgICAgICdXZWJHTFNoYWRlcicsXHJcbiAgICAgICAgJ1dlYkdMU2hhZGVyUHJlY2lzaW9uRm9ybWF0JyxcclxuICAgICAgICAnV2ViR0xUZXh0dXJlJyxcclxuICAgICAgICAnV2ViR0xVbmlmb3JtTG9jYXRpb24nLFxyXG4gICAgICAgICdXZWJHTFZlcnRleEFycmF5T2JqZWN0JyxcclxuICAgICAgICAnV2ViR0xWZXJ0ZXhBcnJheU9iamVjdE9FUycsXHJcbiAgICBdO1xyXG4gICAgY29uc3Qgc3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzID0gd2ViR0xDb25zdHJ1Y3Rvck5hbWVzLmZpbHRlcigobmFtZSkgPT4gdHlwZW9mIHdpbltuYW1lXSA9PT0gJ2Z1bmN0aW9uJyk7XHJcbiAgICByZXR1cm4gQm9vbGVhbihzdXBwb3J0ZWRXZWJHTENvbnN0cnVjdG9yTmFtZXMuZmluZCgobmFtZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiB3aW5bbmFtZV0pKTtcclxufTtcblxuZnVuY3Rpb24gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcihjYiwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgY29uc3QgcHJvcHMyRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlKTtcclxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wczJEKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZVtwcm9wXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCh3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZSwgcHJvcCwgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZCh0aGlzLmNhbnZhcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRBcmdzID0gc2VyaWFsaXplQXJncyhhcmdzLCB3aW4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0WycyRCddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHJlY29yZEFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvb2tIYW5kbGVyID0gaG9va1NldHRlcih3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZSwgcHJvcCwge1xyXG4gICAgICAgICAgICAgICAgc2V0KHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0WycyRCddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3ZdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChob29rSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29udGV4dE5hbWUoY29udGV4dFR5cGUpIHtcclxuICAgIHJldHVybiBjb250ZXh0VHlwZSA9PT0gJ2V4cGVyaW1lbnRhbC13ZWJnbCcgPyAnd2ViZ2wnIDogY29udGV4dFR5cGU7XHJcbn1cclxuZnVuY3Rpb24gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHNldFByZXNlcnZlRHJhd2luZ0J1ZmZlclRvVHJ1ZSkge1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCh3aW4uSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLCAnZ2V0Q29udGV4dCcsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHRUeXBlLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZCh0aGlzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eE5hbWUgPSBnZXROb3JtYWxpemVkQ29udGV4dE5hbWUoY29udGV4dFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCdfX2NvbnRleHQnIGluIHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY29udGV4dCA9IGN0eE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldFByZXNlcnZlRHJhd2luZ0J1ZmZlclRvVHJ1ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ3dlYmdsJywgJ3dlYmdsMiddLmluY2x1ZGVzKGN0eE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdICYmIHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dEF0dHJpYnV0ZXMgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0QXR0cmlidXRlcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0QXR0cmlidXRlcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5zcGxpY2UoMCwgMSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtjb250ZXh0VHlwZSwgLi4uYXJnc10pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkIHRvIHBhdGNoIEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS5nZXRDb250ZXh0Jyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIHBhdGNoR0xQcm90b3R5cGUocHJvdG90eXBlLCB0eXBlLCBjYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgbWlycm9yLCB3aW4pIHtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvdHlwZSk7XHJcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcclxuICAgICAgICBpZiAoW1xyXG4gICAgICAgICAgICAnaXNDb250ZXh0TG9zdCcsXHJcbiAgICAgICAgICAgICdjYW52YXMnLFxyXG4gICAgICAgICAgICAnZHJhd2luZ0J1ZmZlcldpZHRoJyxcclxuICAgICAgICAgICAgJ2RyYXdpbmdCdWZmZXJIZWlnaHQnLFxyXG4gICAgICAgIF0uaW5jbHVkZXMocHJvcCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlW3Byb3BdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHByb3RvdHlwZSwgcHJvcCwgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBzYXZlV2ViR0xWYXIocmVzdWx0LCB3aW4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgndGFnTmFtZScgaW4gdGhpcy5jYW52YXMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzQmxvY2tlZCh0aGlzLmNhbnZhcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkQXJncyA9IHNlcmlhbGl6ZUFyZ3MoYXJncywgd2luLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXV0YXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiByZWNvcmRBcmdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywgbXV0YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgY29uc3QgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHByb3RvdHlwZSwgcHJvcCwge1xyXG4gICAgICAgICAgICAgICAgc2V0KHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3ZdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChob29rSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhbmRsZXJzO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRDYW52YXNXZWJHTE11dGF0aW9uT2JzZXJ2ZXIoY2IsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgbWlycm9yKSB7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgaGFuZGxlcnMucHVzaCguLi5wYXRjaEdMUHJvdG90eXBlKHdpbi5XZWJHTFJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLCBDYW52YXNDb250ZXh0LldlYkdMLCBjYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgbWlycm9yLCB3aW4pKTtcclxuICAgIGlmICh0eXBlb2Ygd2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgaGFuZGxlcnMucHVzaCguLi5wYXRjaEdMUHJvdG90eXBlKHdpbi5XZWJHTDJSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZSwgQ2FudmFzQ29udGV4dC5XZWJHTDIsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IsIHdpbikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBmdW5jVG9Tb3VyY2UoZm4sIHNvdXJjZW1hcEFyZykge1xuICAgIHZhciBzb3VyY2VtYXAgPSBzb3VyY2VtYXBBcmcgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBzb3VyY2VtYXBBcmc7XG4gICAgdmFyIHNvdXJjZSA9IGZuLnRvU3RyaW5nKCk7XG4gICAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KCdcXG4nKTtcbiAgICBsaW5lcy5wb3AoKTtcbiAgICBsaW5lcy5zaGlmdCgpO1xuICAgIHZhciBibGFua1ByZWZpeExlbmd0aCA9IGxpbmVzWzBdLnNlYXJjaCgvXFxTLyk7XG4gICAgdmFyIHJlZ2V4ID0gLyhbJ1wiXSlfX3dvcmtlcl9sb2FkZXJfc3RyaWN0X18oWydcIl0pL2c7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBsaW5lcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXS5zdWJzdHJpbmcoYmxhbmtQcmVmaXhMZW5ndGgpLnJlcGxhY2UocmVnZXgsICckMXVzZSBzdHJpY3QkMicpICsgJ1xcbic7XG4gICAgfVxuICAgIGlmIChzb3VyY2VtYXApIHtcbiAgICAgICAgbGluZXMucHVzaCgnXFwvXFwvIyBzb3VyY2VNYXBwaW5nVVJMPScgKyBzb3VyY2VtYXAgKyAnXFxuJyk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVJMKGZuLCBzb3VyY2VtYXBBcmcpIHtcbiAgICB2YXIgbGluZXMgPSBmdW5jVG9Tb3VyY2UoZm4sIHNvdXJjZW1hcEFyZyk7XG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihsaW5lcywgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSk7XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUlubGluZVdvcmtlckZhY3RvcnkoZm4sIHNvdXJjZW1hcEFyZykge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIFdvcmtlckZhY3Rvcnkob3B0aW9ucykge1xuICAgICAgICB1cmwgPSB1cmwgfHwgY3JlYXRlVVJMKGZuLCBzb3VyY2VtYXBBcmcpO1xuICAgICAgICByZXR1cm4gbmV3IFdvcmtlcih1cmwsIG9wdGlvbnMpO1xuICAgIH07XG59XG5cbnZhciBXb3JrZXJGYWN0b3J5ID0gY3JlYXRlSW5saW5lV29ya2VyRmFjdG9yeSgvKiByb2xsdXAtcGx1Z2luLXdlYi13b3JrZXItbG9hZGVyICovZnVuY3Rpb24gKCkge1xuKGZ1bmN0aW9uICgpIHtcbiAgICAnX193b3JrZXJfbG9hZGVyX3N0cmljdF9fJztcblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG4gICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbiAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG4gICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbiAgICBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbiAgICBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbiAgICBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcbiAgICBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbiAgICBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cblxuICAgIC8qXG4gICAgICogYmFzZTY0LWFycmF5YnVmZmVyIDEuMC4xIDxodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyPlxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBOaWtsYXMgdm9uIEhlcnR6ZW4gPGh0dHBzOi8vaGVydHplbi5jb20+XG4gICAgICogUmVsZWFzZWQgdW5kZXIgTUlUIExpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICAgIHZhciBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBbXSA6IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xuICAgIH1cbiAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24gKGFycmF5YnVmZmVyKSB7XG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSAnJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICAgICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiAlIDMgPT09IDIpIHtcbiAgICAgICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgJz0nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgJz09JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTY0O1xuICAgIH07XG5cbiAgICBjb25zdCBsYXN0QmxvYk1hcCA9IG5ldyBNYXAoKTtcclxuICAgIGNvbnN0IHRyYW5zcGFyZW50QmxvYk1hcCA9IG5ldyBNYXAoKTtcclxuICAgIGZ1bmN0aW9uIGdldFRyYW5zcGFyZW50QmxvYkZvcih3aWR0aCwgaGVpZ2h0LCBkYXRhVVJMT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7XHJcbiAgICAgICAgICAgIGlmICgnT2Zmc2NyZWVuQ2FudmFzJyBpbiBnbG9iYWxUaGlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zcGFyZW50QmxvYk1hcC5nZXQoaWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIG9mZnNjcmVlbi5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IHlpZWxkIG9mZnNjcmVlbi5jb252ZXJ0VG9CbG9iKGRhdGFVUkxPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0geWllbGQgYmxvYi5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0ID0gZW5jb2RlKGFycmF5QnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3b3JrZXIgPSBzZWxmO1xyXG4gICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKCdPZmZzY3JlZW5DYW52YXMnIGluIGdsb2JhbFRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIGJpdG1hcCwgd2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMgfSA9IGUuZGF0YTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zcGFyZW50QmFzZTY0ID0gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIGJpdG1hcC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IHlpZWxkIG9mZnNjcmVlbi5jb252ZXJ0VG9CbG9iKGRhdGFVUkxPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBibG9iLnR5cGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IHlpZWxkIGJsb2IuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZShhcnJheUJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RCbG9iTWFwLmhhcyhpZCkgJiYgKHlpZWxkIHRyYW5zcGFyZW50QmFzZTY0KSA9PT0gYmFzZTY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsYXN0QmxvYk1hcC5nZXQoaWQpID09PSBiYXNlNjQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlci5wb3N0TWVzc2FnZSh7IGlkIH0pO1xyXG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGxhc3RCbG9iTWFwLnNldChpZCwgYmFzZTY0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZDogZS5kYXRhLmlkIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xuXG59KSgpO1xufSwgbnVsbCk7XG5cbmNsYXNzIENhbnZhc01hbmFnZXIge1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldE9ic2VydmVycyAmJiB0aGlzLnJlc2V0T2JzZXJ2ZXJzKCk7XHJcbiAgICB9XHJcbiAgICBmcmVlemUoKSB7XHJcbiAgICAgICAgdGhpcy5mcm96ZW4gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdW5mcmVlemUoKSB7XHJcbiAgICAgICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGxvY2soKSB7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdW5sb2NrKCkge1xyXG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMucmFmU3RhbXBzID0geyBsYXRlc3RJZDogMCwgaW52b2tlSWQ6IG51bGwgfTtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb24gPSAodGFyZ2V0LCBtdXRhdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdGcmFtZSA9IHRoaXMucmFmU3RhbXBzLmludm9rZUlkICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhZlN0YW1wcy5sYXRlc3RJZCAhPT0gdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQ7XHJcbiAgICAgICAgICAgIGlmIChuZXdGcmFtZSB8fCAhdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZCA9IHRoaXMucmFmU3RhbXBzLmxhdGVzdElkO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLnNldCh0YXJnZXQsIFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZ2V0KHRhcmdldCkucHVzaChtdXRhdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB7IHNhbXBsaW5nID0gJ2FsbCcsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgcmVjb3JkQ2FudmFzLCBkYXRhVVJMT3B0aW9ucywgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xyXG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XHJcbiAgICAgICAgaWYgKHJlY29yZENhbnZhcyAmJiBzYW1wbGluZyA9PT0gJ2FsbCcpXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcclxuICAgICAgICBpZiAocmVjb3JkQ2FudmFzICYmIHR5cGVvZiBzYW1wbGluZyA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhc0ZQU09ic2VydmVyKHNhbXBsaW5nLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHtcclxuICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGluaXRDYW52YXNGUFNPYnNlcnZlcihmcHMsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc0NvbnRleHRSZXNldCA9IGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlckZhY3RvcnkoKTtcclxuICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gKGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gZS5kYXRhO1xyXG4gICAgICAgICAgICBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuc2V0KGlkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmICghKCdiYXNlNjQnIGluIGUuZGF0YSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYmFzZTY0LCB0eXBlLCB3aWR0aCwgaGVpZ2h0IH0gPSBlLmRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25DYih7XHJcbiAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbJzJEJ10sXHJcbiAgICAgICAgICAgICAgICBjb21tYW5kczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6ICdjbGVhclJlY3QnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbMCwgMCwgd2lkdGgsIGhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiAnZHJhd0ltYWdlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6ICdJbWFnZUJpdG1hcCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBycl90eXBlOiAnQmxvYicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbeyBycl90eXBlOiAnQXJyYXlCdWZmZXInLCBiYXNlNjQgfV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdGltZUJldHdlZW5TbmFwc2hvdHMgPSAxMDAwIC8gZnBzO1xyXG4gICAgICAgIGxldCBsYXN0U25hcHNob3RUaW1lID0gMDtcclxuICAgICAgICBsZXQgcmFmSWQ7XHJcbiAgICAgICAgY29uc3QgZ2V0Q2FudmFzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkQ2FudmFzID0gW107XHJcbiAgICAgICAgICAgIHdpbi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdjYW52YXMnKS5mb3JFYWNoKChjYW52YXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKGNhbnZhcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ2FudmFzLnB1c2goY2FudmFzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVkQ2FudmFzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdGFrZUNhbnZhc1NuYXBzaG90cyA9ICh0aW1lc3RhbXApID0+IHtcclxuICAgICAgICAgICAgaWYgKGxhc3RTbmFwc2hvdFRpbWUgJiZcclxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCAtIGxhc3RTbmFwc2hvdFRpbWUgPCB0aW1lQmV0d2VlblNuYXBzaG90cykge1xyXG4gICAgICAgICAgICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdFNuYXBzaG90VGltZSA9IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgZ2V0Q2FudmFzKClcclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChjYW52YXMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5taXJyb3IuZ2V0SWQoY2FudmFzKTtcclxuICAgICAgICAgICAgICAgIGlmIChzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuZ2V0KGlkKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzLndpZHRoID09PSAwIHx8IGNhbnZhcy5oZWlnaHQgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgc25hcHNob3RJblByb2dyZXNzTWFwLnNldChpZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoWyd3ZWJnbCcsICd3ZWJnbDInXS5pbmNsdWRlcyhjYW52YXMuX19jb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChjYW52YXMuX19jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKChfYSA9IGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5nZXRDb250ZXh0QXR0cmlidXRlcygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJlc2VydmVEcmF3aW5nQnVmZmVyKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jbGVhcihjb250ZXh0LkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGJpdG1hcCA9IHlpZWxkIGNyZWF0ZUltYWdlQml0bWFwKGNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGJpdG1hcCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogb3B0aW9ucy5kYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIH0sIFtiaXRtYXBdKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xyXG4gICAgICAgIHRoaXMucmVzZXRPYnNlcnZlcnMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHRSZXNldCgpO1xyXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGluaXRDYW52YXNNdXRhdGlvbk9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xyXG4gICAgICAgIHRoaXMuc3RhcnRSQUZUaW1lc3RhbXBpbmcoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc0NvbnRleHRSZXNldCA9IGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgY2FudmFzMkRSZXNldCA9IGluaXRDYW52YXMyRE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcclxuICAgICAgICBjb25zdCBjYW52YXNXZWJHTDFhbmQyUmVzZXQgPSBpbml0Q2FudmFzV2ViR0xNdXRhdGlvbk9ic2VydmVyKHRoaXMucHJvY2Vzc011dGF0aW9uLmJpbmQodGhpcyksIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdGhpcy5taXJyb3IpO1xyXG4gICAgICAgIHRoaXMucmVzZXRPYnNlcnZlcnMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHRSZXNldCgpO1xyXG4gICAgICAgICAgICBjYW52YXMyRFJlc2V0KCk7XHJcbiAgICAgICAgICAgIGNhbnZhc1dlYkdMMWFuZDJSZXNldCgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGFydFBlbmRpbmdDYW52YXNNdXRhdGlvbkZsdXNoZXIoKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkpO1xyXG4gICAgfVxyXG4gICAgc3RhcnRSQUZUaW1lc3RhbXBpbmcoKSB7XHJcbiAgICAgICAgY29uc3Qgc2V0TGF0ZXN0UkFGVGltZXN0YW1wID0gKHRpbWVzdGFtcCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJhZlN0YW1wcy5sYXRlc3RJZCA9IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNldExhdGVzdFJBRlRpbWVzdGFtcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcclxuICAgIH1cclxuICAgIGZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZm9yRWFjaCgodmFsdWVzLCBjYW52YXMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1pcnJvci5nZXRJZChjYW52YXMpO1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yKGNhbnZhcywgaWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpKTtcclxuICAgIH1cclxuICAgIGZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yKGNhbnZhcywgaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5mcm96ZW4gfHwgdGhpcy5sb2NrZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2YWx1ZXNXaXRoVHlwZSA9IHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5nZXQoY2FudmFzKTtcclxuICAgICAgICBpZiAoIXZhbHVlc1dpdGhUeXBlIHx8IGlkID09PSAtMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHZhbHVlc1dpdGhUeXBlLm1hcCgodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdCA9IF9fcmVzdCh2YWx1ZSwgW1widHlwZVwiXSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gdmFsdWVzV2l0aFR5cGVbMF07XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHsgaWQsIHR5cGUsIGNvbW1hbmRzOiB2YWx1ZXMgfSk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmRlbGV0ZShjYW52YXMpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFN0eWxlc2hlZXRNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVNaXJyb3IgPSBuZXcgU3R5bGVTaGVldE1pcnJvcigpO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcclxuICAgICAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IgPSBvcHRpb25zLmFkb3B0ZWRTdHlsZVNoZWV0Q2I7XHJcbiAgICB9XHJcbiAgICBhdHRhY2hMaW5rRWxlbWVudChsaW5rRWwsIGNoaWxkU24pIHtcclxuICAgICAgICBpZiAoJ19jc3NUZXh0JyBpbiBjaGlsZFNuLmF0dHJpYnV0ZXMpXHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25DYih7XHJcbiAgICAgICAgICAgICAgICBhZGRzOiBbXSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgdGV4dHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkU24uaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGNoaWxkU25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnRyYWNrTGlua0VsZW1lbnQobGlua0VsKTtcclxuICAgIH1cclxuICAgIHRyYWNrTGlua0VsZW1lbnQobGlua0VsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZExpbmtFbGVtZW50cy5oYXMobGlua0VsKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMudHJhY2tlZExpbmtFbGVtZW50cy5hZGQobGlua0VsKTtcclxuICAgICAgICB0aGlzLnRyYWNrU3R5bGVzaGVldEluTGlua0VsZW1lbnQobGlua0VsKTtcclxuICAgIH1cclxuICAgIGFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpIHtcclxuICAgICAgICBpZiAoc2hlZXRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGFkb3B0ZWRTdHlsZVNoZWV0RGF0YSA9IHtcclxuICAgICAgICAgICAgaWQ6IGhvc3RJZCxcclxuICAgICAgICAgICAgc3R5bGVJZHM6IFtdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBzaGVldCBvZiBzaGVldHMpIHtcclxuICAgICAgICAgICAgbGV0IHN0eWxlSWQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zdHlsZU1pcnJvci5oYXMoc2hlZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZUlkID0gdGhpcy5zdHlsZU1pcnJvci5hZGQoc2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IEFycmF5LmZyb20oc2hlZXQucnVsZXMgfHwgQ1NTUnVsZSwgKHIsIGluZGV4KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBzdHJpbmdpZnlSdWxlKHIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzdHlsZUlkID0gdGhpcy5zdHlsZU1pcnJvci5nZXRJZChzaGVldCk7XHJcbiAgICAgICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZUlkcy5wdXNoKHN0eWxlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZXMgPSBzdHlsZXM7XHJcbiAgICAgICAgdGhpcy5hZG9wdGVkU3R5bGVTaGVldENiKGFkb3B0ZWRTdHlsZVNoZWV0RGF0YSk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnN0eWxlTWlycm9yLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzID0gbmV3IFdlYWtTZXQoKTtcclxuICAgIH1cclxuICAgIHRyYWNrU3R5bGVzaGVldEluTGlua0VsZW1lbnQobGlua0VsKSB7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUHJvY2Vzc2VkTm9kZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmxvb3AgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucGVyaW9kaWNhbGx5Q2xlYXIoKTtcclxuICAgIH1cclxuICAgIHBlcmlvZGljYWxseUNsZWFyKCkge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubG9vcClcclxuICAgICAgICAgICAgICAgIHRoaXMucGVyaW9kaWNhbGx5Q2xlYXIoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGluT3RoZXJCdWZmZXIobm9kZSwgdGhpc0J1ZmZlcikge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLm5vZGVNYXAuZ2V0KG5vZGUpO1xyXG4gICAgICAgIHJldHVybiAoYnVmZmVycyAmJiBBcnJheS5mcm9tKGJ1ZmZlcnMpLnNvbWUoKGJ1ZmZlcikgPT4gYnVmZmVyICE9PSB0aGlzQnVmZmVyKSk7XHJcbiAgICB9XHJcbiAgICBhZGQobm9kZSwgYnVmZmVyKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlTWFwLnNldChub2RlLCAodGhpcy5ub2RlTWFwLmdldChub2RlKSB8fCBuZXcgU2V0KCkpLmFkZChidWZmZXIpKTtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMubm9kZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMubG9vcCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHdyYXBFdmVudChlKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlKSwgeyB0aW1lc3RhbXA6IG5vd1RpbWVzdGFtcCgpIH0pO1xyXG59XHJcbmxldCB3cmFwcGVkRW1pdDtcclxubGV0IHRha2VGdWxsU25hcHNob3Q7XHJcbmxldCBjYW52YXNNYW5hZ2VyO1xyXG5sZXQgcmVjb3JkaW5nID0gZmFsc2U7XHJcbmNvbnN0IG1pcnJvciA9IGNyZWF0ZU1pcnJvcigpO1xyXG5mdW5jdGlvbiByZWNvcmQob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCB7IGVtaXQsIGNoZWNrb3V0RXZlcnlObXMsIGNoZWNrb3V0RXZlcnlOdGgsIGJsb2NrQ2xhc3MgPSAncnItYmxvY2snLCBibG9ja1NlbGVjdG9yID0gbnVsbCwgaWdub3JlQ2xhc3MgPSAncnItaWdub3JlJywgaWdub3JlU2VsZWN0b3IgPSBudWxsLCBtYXNrVGV4dENsYXNzID0gJ3JyLW1hc2snLCBtYXNrVGV4dFNlbGVjdG9yID0gbnVsbCwgaW5saW5lU3R5bGVzaGVldCA9IHRydWUsIG1hc2tBbGxJbnB1dHMsIG1hc2tJbnB1dE9wdGlvbnM6IF9tYXNrSW5wdXRPcHRpb25zLCBzbGltRE9NT3B0aW9uczogX3NsaW1ET01PcHRpb25zLCBtYXNrSW5wdXRGbiwgbWFza1RleHRGbiwgaG9va3MsIHBhY2tGbiwgc2FtcGxpbmcgPSB7fSwgZGF0YVVSTE9wdGlvbnMgPSB7fSwgbW91c2Vtb3ZlV2FpdCwgcmVjb3JkRE9NID0gdHJ1ZSwgcmVjb3JkQ2FudmFzID0gZmFsc2UsIHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA9IGZhbHNlLCByZWNvcmRBZnRlciA9IG9wdGlvbnMucmVjb3JkQWZ0ZXIgPT09ICdET01Db250ZW50TG9hZGVkJ1xyXG4gICAgICAgID8gb3B0aW9ucy5yZWNvcmRBZnRlclxyXG4gICAgICAgIDogJ2xvYWQnLCB1c2VyVHJpZ2dlcmVkT25JbnB1dCA9IGZhbHNlLCBjb2xsZWN0Rm9udHMgPSBmYWxzZSwgaW5saW5lSW1hZ2VzID0gZmFsc2UsIHBsdWdpbnMsIGtlZXBJZnJhbWVTcmNGbiA9ICgpID0+IGZhbHNlLCBpZ25vcmVDU1NBdHRyaWJ1dGVzID0gbmV3IFNldChbXSksIGVycm9ySGFuZGxlciwgfSA9IG9wdGlvbnM7XHJcbiAgICByZWdpc3RlckVycm9ySGFuZGxlcihlcnJvckhhbmRsZXIpO1xyXG4gICAgY29uc3QgaW5FbWl0dGluZ0ZyYW1lID0gcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzXHJcbiAgICAgICAgPyB3aW5kb3cucGFyZW50ID09PSB3aW5kb3dcclxuICAgICAgICA6IHRydWU7XHJcbiAgICBsZXQgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcclxuICAgIGlmICghaW5FbWl0dGluZ0ZyYW1lKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHBhc3NFbWl0c1RvUGFyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpbkVtaXR0aW5nRnJhbWUgJiYgIWVtaXQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VtaXQgZnVuY3Rpb24gaXMgcmVxdWlyZWQnKTtcclxuICAgIH1cclxuICAgIGlmIChtb3VzZW1vdmVXYWl0ICE9PSB1bmRlZmluZWQgJiYgc2FtcGxpbmcubW91c2Vtb3ZlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBzYW1wbGluZy5tb3VzZW1vdmUgPSBtb3VzZW1vdmVXYWl0O1xyXG4gICAgfVxyXG4gICAgbWlycm9yLnJlc2V0KCk7XHJcbiAgICBjb25zdCBtYXNrSW5wdXRPcHRpb25zID0gbWFza0FsbElucHV0cyA9PT0gdHJ1ZVxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBjb2xvcjogdHJ1ZSxcclxuICAgICAgICAgICAgZGF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcclxuICAgICAgICAgICAgZW1haWw6IHRydWUsXHJcbiAgICAgICAgICAgIG1vbnRoOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1iZXI6IHRydWUsXHJcbiAgICAgICAgICAgIHJhbmdlOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWFyY2g6IHRydWUsXHJcbiAgICAgICAgICAgIHRlbDogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dDogdHJ1ZSxcclxuICAgICAgICAgICAgdGltZTogdHJ1ZSxcclxuICAgICAgICAgICAgdXJsOiB0cnVlLFxyXG4gICAgICAgICAgICB3ZWVrOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0YXJlYTogdHJ1ZSxcclxuICAgICAgICAgICAgc2VsZWN0OiB0cnVlLFxyXG4gICAgICAgICAgICBwYXNzd29yZDogdHJ1ZSxcclxuICAgICAgICB9XHJcbiAgICAgICAgOiBfbWFza0lucHV0T3B0aW9ucyAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gX21hc2tJbnB1dE9wdGlvbnNcclxuICAgICAgICAgICAgOiB7IHBhc3N3b3JkOiB0cnVlIH07XHJcbiAgICBjb25zdCBzbGltRE9NT3B0aW9ucyA9IF9zbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSB8fCBfc2xpbURPTU9wdGlvbnMgPT09ICdhbGwnXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIHNjcmlwdDogdHJ1ZSxcclxuICAgICAgICAgICAgY29tbWVudDogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZEZhdmljb246IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRXaGl0ZXNwYWNlOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YVNvY2lhbDogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YVZlcmlmaWNhdGlvbjogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZE1ldGFBdXRob3JzaGlwOiBfc2xpbURPTU9wdGlvbnMgPT09ICdhbGwnLFxyXG4gICAgICAgICAgICBoZWFkTWV0YURlc2NLZXl3b3JkczogX3NsaW1ET01PcHRpb25zID09PSAnYWxsJyxcclxuICAgICAgICB9XHJcbiAgICAgICAgOiBfc2xpbURPTU9wdGlvbnNcclxuICAgICAgICAgICAgPyBfc2xpbURPTU9wdGlvbnNcclxuICAgICAgICAgICAgOiB7fTtcclxuICAgIHBvbHlmaWxsKCk7XHJcbiAgICBsZXQgbGFzdEZ1bGxTbmFwc2hvdEV2ZW50O1xyXG4gICAgbGV0IGluY3JlbWVudGFsU25hcHNob3RDb3VudCA9IDA7XHJcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IChlKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucyB8fCBbXSkge1xyXG4gICAgICAgICAgICBpZiAocGx1Z2luLmV2ZW50UHJvY2Vzc29yKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gcGx1Z2luLmV2ZW50UHJvY2Vzc29yKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYWNrRm4gJiZcclxuICAgICAgICAgICAgIXBhc3NFbWl0c1RvUGFyZW50KSB7XHJcbiAgICAgICAgICAgIGUgPSBwYWNrRm4oZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlO1xyXG4gICAgfTtcclxuICAgIHdyYXBwZWRFbWl0ID0gKGUsIGlzQ2hlY2tvdXQpID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKCgoX2EgPSBtdXRhdGlvbkJ1ZmZlcnNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Zyb3plbigpKSAmJlxyXG4gICAgICAgICAgICBlLnR5cGUgIT09IEV2ZW50VHlwZSQxLkZ1bGxTbmFwc2hvdCAmJlxyXG4gICAgICAgICAgICAhKGUudHlwZSA9PT0gRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCAmJlxyXG4gICAgICAgICAgICAgICAgZS5kYXRhLnNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UkMS5NdXRhdGlvbikpIHtcclxuICAgICAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLnVuZnJlZXplKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5FbWl0dGluZ0ZyYW1lKSB7XHJcbiAgICAgICAgICAgIGVtaXQgPT09IG51bGwgfHwgZW1pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW1pdChldmVudFByb2Nlc3NvcihlKSwgaXNDaGVja291dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhc3NFbWl0c1RvUGFyZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAncnJ3ZWInLFxyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50UHJvY2Vzc29yKGUpLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxyXG4gICAgICAgICAgICAgICAgaXNDaGVja291dCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZS50eXBlID09PSBFdmVudFR5cGUkMS5GdWxsU25hcHNob3QpIHtcclxuICAgICAgICAgICAgbGFzdEZ1bGxTbmFwc2hvdEV2ZW50ID0gZTtcclxuICAgICAgICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZS50eXBlID09PSBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgIGlmIChlLmRhdGEuc291cmNlID09PSBJbmNyZW1lbnRhbFNvdXJjZSQxLk11dGF0aW9uICYmXHJcbiAgICAgICAgICAgICAgICBlLmRhdGEuaXNBdHRhY2hJZnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQrKztcclxuICAgICAgICAgICAgY29uc3QgZXhjZWVkQ291bnQgPSBjaGVja291dEV2ZXJ5TnRoICYmIGluY3JlbWVudGFsU25hcHNob3RDb3VudCA+PSBjaGVja291dEV2ZXJ5TnRoO1xyXG4gICAgICAgICAgICBjb25zdCBleGNlZWRUaW1lID0gY2hlY2tvdXRFdmVyeU5tcyAmJlxyXG4gICAgICAgICAgICAgICAgZS50aW1lc3RhbXAgLSBsYXN0RnVsbFNuYXBzaG90RXZlbnQudGltZXN0YW1wID4gY2hlY2tvdXRFdmVyeU5tcztcclxuICAgICAgICAgICAgaWYgKGV4Y2VlZENvdW50IHx8IGV4Y2VlZFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHRha2VGdWxsU25hcHNob3QodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgd3JhcHBlZE11dGF0aW9uRW1pdCA9IChtKSA9PiB7XHJcbiAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5NdXRhdGlvbiB9LCBtKSxcclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgd3JhcHBlZFNjcm9sbEVtaXQgPSAocCkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuU2Nyb2xsIH0sIHApLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3Qgd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCA9IChwKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5DYW52YXNNdXRhdGlvbiB9LCBwKSxcclxuICAgIH0pKTtcclxuICAgIGNvbnN0IHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQgPSAoYSkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuQWRvcHRlZFN0eWxlU2hlZXQgfSwgYSksXHJcbiAgICB9KSk7XHJcbiAgICBjb25zdCBzdHlsZXNoZWV0TWFuYWdlciA9IG5ldyBTdHlsZXNoZWV0TWFuYWdlcih7XHJcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcclxuICAgICAgICBhZG9wdGVkU3R5bGVTaGVldENiOiB3cmFwcGVkQWRvcHRlZFN0eWxlU2hlZXRFbWl0LFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBpZnJhbWVNYW5hZ2VyID0gbmV3IElmcmFtZU1hbmFnZXIoe1xyXG4gICAgICAgIG1pcnJvcixcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyOiBzdHlsZXNoZWV0TWFuYWdlcixcclxuICAgICAgICByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMsXHJcbiAgICAgICAgd3JhcHBlZEVtaXQsXHJcbiAgICB9KTtcclxuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMgfHwgW10pIHtcclxuICAgICAgICBpZiAocGx1Z2luLmdldE1pcnJvcilcclxuICAgICAgICAgICAgcGx1Z2luLmdldE1pcnJvcih7XHJcbiAgICAgICAgICAgICAgICBub2RlTWlycm9yOiBtaXJyb3IsXHJcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbklmcmFtZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZU1pcnJvcixcclxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3I6IGlmcmFtZU1hbmFnZXIuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9jZXNzZWROb2RlTWFuYWdlciA9IG5ldyBQcm9jZXNzZWROb2RlTWFuYWdlcigpO1xyXG4gICAgY2FudmFzTWFuYWdlciA9IG5ldyBDYW52YXNNYW5hZ2VyKHtcclxuICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcclxuICAgICAgICB3aW46IHdpbmRvdyxcclxuICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIHNhbXBsaW5nOiBzYW1wbGluZy5jYW52YXMsXHJcbiAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHNoYWRvd0RvbU1hbmFnZXIgPSBuZXcgU2hhZG93RG9tTWFuYWdlcih7XHJcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcclxuICAgICAgICBzY3JvbGxDYjogd3JhcHBlZFNjcm9sbEVtaXQsXHJcbiAgICAgICAgYnlwYXNzT3B0aW9uczoge1xyXG4gICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICBzYW1wbGluZyxcclxuICAgICAgICAgICAgc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgIGlmcmFtZU1hbmFnZXIsXHJcbiAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLFxyXG4gICAgICAgICAgICBjYW52YXNNYW5hZ2VyLFxyXG4gICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgfSk7XHJcbiAgICB0YWtlRnVsbFNuYXBzaG90ID0gKGlzQ2hlY2tvdXQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGlmICghcmVjb3JkRE9NKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuTWV0YSxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgaHJlZjogd2luZG93LmxvY2F0aW9uLmhyZWYsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogZ2V0V2luZG93V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogZ2V0V2luZG93SGVpZ2h0KCksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSksIGlzQ2hlY2tvdXQpO1xyXG4gICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnJlc2V0KCk7XHJcbiAgICAgICAgc2hhZG93RG9tTWFuYWdlci5pbml0KCk7XHJcbiAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLmxvY2soKSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHNuYXBzaG90KGRvY3VtZW50LCB7XHJcbiAgICAgICAgICAgIG1pcnJvcixcclxuICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgbWFza0FsbElucHV0czogbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgc2xpbURPTTogc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgb25TZXJpYWxpemU6IChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkSWZyYW1lKG4sIG1pcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyLmFkZElmcmFtZShuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KG4sIG1pcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci50cmFja0xpbmtFbGVtZW50KG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QobikpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLmFkZFNoYWRvd1Jvb3Qobi5zaGFkb3dSb290LCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogKGlmcmFtZSwgY2hpbGRTbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWZyYW1lTWFuYWdlci5hdHRhY2hJZnJhbWUoaWZyYW1lLCBjaGlsZFNuKTtcclxuICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIub2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiAobGlua0VsLCBjaGlsZFNuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hdHRhY2hMaW5rRWxlbWVudChsaW5rRWwsIGNoaWxkU24pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzbmFwc2hvdCB0aGUgZG9jdW1lbnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuRnVsbFNuYXBzaG90LFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICAgICAgaW5pdGlhbE9mZnNldDogZ2V0V2luZG93U2Nyb2xsKHdpbmRvdyksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSksIGlzQ2hlY2tvdXQpO1xyXG4gICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi51bmxvY2soKSk7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiBkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMsIG1pcnJvci5nZXRJZChkb2N1bWVudCkpO1xyXG4gICAgfTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcclxuICAgICAgICBjb25zdCBvYnNlcnZlID0gKGRvYykgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoaW5pdE9ic2VydmVycykoe1xyXG4gICAgICAgICAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcclxuICAgICAgICAgICAgICAgIG1vdXNlbW92ZUNiOiAocG9zaXRpb25zLCBzb3VyY2UpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBtb3VzZUludGVyYWN0aW9uQ2I6IChkKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5Nb3VzZUludGVyYWN0aW9uIH0sIGQpLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2I6IHdyYXBwZWRTY3JvbGxFbWl0LFxyXG4gICAgICAgICAgICAgICAgdmlld3BvcnRSZXNpemVDYjogKGQpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLlZpZXdwb3J0UmVzaXplIH0sIGQpLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgaW5wdXRDYjogKHYpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLklucHV0IH0sIHYpLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiOiAocCkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuTWVkaWFJbnRlcmFjdGlvbiB9LCBwKSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2I6IChyKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5TdHlsZVNoZWV0UnVsZSB9LCByKSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYjogKHIpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLlN0eWxlRGVjbGFyYXRpb24gfSwgciksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBjYW52YXNNdXRhdGlvbkNiOiB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0LFxyXG4gICAgICAgICAgICAgICAgZm9udENiOiAocCkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuRm9udCB9LCBwKSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkNiOiAocCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuU2VsZWN0aW9uIH0sIHApLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50Q2I6IChjKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5DdXN0b21FbGVtZW50IH0sIGMpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgaWdub3JlQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICBpZ25vcmVTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgICAgICBzYW1wbGluZyxcclxuICAgICAgICAgICAgICAgIHJlY29yZERPTSxcclxuICAgICAgICAgICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0LFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdEZvbnRzLFxyXG4gICAgICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLFxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBjYW52YXNNYW5hZ2VyLFxyXG4gICAgICAgICAgICAgICAgaWdub3JlQ1NTQXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgIHBsdWdpbnM6ICgoX2EgPSBwbHVnaW5zID09PSBudWxsIHx8IHBsdWdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBsdWdpbnMuZmlsdGVyKChwKSA9PiBwLm9ic2VydmVyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgocCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcjogcC5vYnNlcnZlcixcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBwLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IChwYXlsb2FkKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5QbHVnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbjogcC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICB9KSkpIHx8IFtdLFxyXG4gICAgICAgICAgICB9LCBob29rcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZnJhbWVNYW5hZ2VyLmFkZExvYWRMaXN0ZW5lcigoaWZyYW1lRWwpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob2JzZXJ2ZShpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0YWtlRnVsbFNuYXBzaG90KCk7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob2JzZXJ2ZShkb2N1bWVudCkpO1xyXG4gICAgICAgICAgICByZWNvcmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHxcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xyXG4gICAgICAgICAgICBpbml0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKG9uKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5Eb21Db250ZW50TG9hZGVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZEFmdGVyID09PSAnRE9NQ29udGVudExvYWRlZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdCgpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob24oJ2xvYWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkxvYWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge30sXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkQWZ0ZXIgPT09ICdsb2FkJylcclxuICAgICAgICAgICAgICAgICAgICBpbml0KCk7XHJcbiAgICAgICAgICAgIH0sIHdpbmRvdykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHJlY29yZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXJyb3JIYW5kbGVyKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XHJcbiAgICB9XHJcbn1cclxucmVjb3JkLmFkZEN1c3RvbUV2ZW50ID0gKHRhZywgcGF5bG9hZCkgPT4ge1xyXG4gICAgaWYgKCFyZWNvcmRpbmcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsZWFzZSBhZGQgY3VzdG9tIGV2ZW50IGFmdGVyIHN0YXJ0IHJlY29yZGluZycpO1xyXG4gICAgfVxyXG4gICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5DdXN0b20sXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICB0YWcsXHJcbiAgICAgICAgICAgIHBheWxvYWQsXHJcbiAgICAgICAgfSxcclxuICAgIH0pKTtcclxufTtcclxucmVjb3JkLmZyZWV6ZVBhZ2UgPSAoKSA9PiB7XHJcbiAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYuZnJlZXplKCkpO1xyXG59O1xyXG5yZWNvcmQudGFrZUZ1bGxTbmFwc2hvdCA9IChpc0NoZWNrb3V0KSA9PiB7XHJcbiAgICBpZiAoIXJlY29yZGluZykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGxlYXNlIHRha2UgZnVsbCBzbmFwc2hvdCBhZnRlciBzdGFydCByZWNvcmRpbmcnKTtcclxuICAgIH1cclxuICAgIHRha2VGdWxsU25hcHNob3QoaXNDaGVja291dCk7XHJcbn07XHJcbnJlY29yZC5taXJyb3IgPSBtaXJyb3I7XG5cbnZhciBFdmVudFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFdmVudFR5cGUyKSA9PiB7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkRvbUNvbnRlbnRMb2FkZWRcIl0gPSAwXSA9IFwiRG9tQ29udGVudExvYWRlZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJMb2FkXCJdID0gMV0gPSBcIkxvYWRcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRnVsbFNuYXBzaG90XCJdID0gMl0gPSBcIkZ1bGxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJJbmNyZW1lbnRhbFNuYXBzaG90XCJdID0gM10gPSBcIkluY3JlbWVudGFsU25hcHNob3RcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTWV0YVwiXSA9IDRdID0gXCJNZXRhXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkN1c3RvbVwiXSA9IDVdID0gXCJDdXN0b21cIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiUGx1Z2luXCJdID0gNl0gPSBcIlBsdWdpblwiO1xuICByZXR1cm4gRXZlbnRUeXBlMjtcbn0pKEV2ZW50VHlwZSB8fCB7fSk7XG52YXIgSW5jcmVtZW50YWxTb3VyY2UgPSAvKiBAX19QVVJFX18gKi8gKChJbmNyZW1lbnRhbFNvdXJjZTIpID0+IHtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk11dGF0aW9uXCJdID0gMF0gPSBcIk11dGF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZU1vdmVcIl0gPSAxXSA9IFwiTW91c2VNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gMl0gPSBcIk1vdXNlSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNjcm9sbFwiXSA9IDNdID0gXCJTY3JvbGxcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlZpZXdwb3J0UmVzaXplXCJdID0gNF0gPSBcIlZpZXdwb3J0UmVzaXplXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJJbnB1dFwiXSA9IDVdID0gXCJJbnB1dFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVG91Y2hNb3ZlXCJdID0gNl0gPSBcIlRvdWNoTW92ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTWVkaWFJbnRlcmFjdGlvblwiXSA9IDddID0gXCJNZWRpYUludGVyYWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZVNoZWV0UnVsZVwiXSA9IDhdID0gXCJTdHlsZVNoZWV0UnVsZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ2FudmFzTXV0YXRpb25cIl0gPSA5XSA9IFwiQ2FudmFzTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkZvbnRcIl0gPSAxMF0gPSBcIkZvbnRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkxvZ1wiXSA9IDExXSA9IFwiTG9nXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJEcmFnXCJdID0gMTJdID0gXCJEcmFnXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZURlY2xhcmF0aW9uXCJdID0gMTNdID0gXCJTdHlsZURlY2xhcmF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTZWxlY3Rpb25cIl0gPSAxNF0gPSBcIlNlbGVjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQWRvcHRlZFN0eWxlU2hlZXRcIl0gPSAxNV0gPSBcIkFkb3B0ZWRTdHlsZVNoZWV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDdXN0b21FbGVtZW50XCJdID0gMTZdID0gXCJDdXN0b21FbGVtZW50XCI7XG4gIHJldHVybiBJbmNyZW1lbnRhbFNvdXJjZTI7XG59KShJbmNyZW1lbnRhbFNvdXJjZSB8fCB7fSk7XG5cbnZhciBDb25maWcgPSB7XG4gICAgREVCVUc6IGZhbHNlLFxuICAgIExJQl9WRVJTSU9OOiAnMi41OC4wJ1xufTtcblxuLy8gc2luY2UgZXM2IGltcG9ydHMgYXJlIHN0YXRpYyBhbmQgd2UgcnVuIHVuaXQgdGVzdHMgZnJvbSB0aGUgY29uc29sZSwgd2luZG93IHdvbid0IGJlIGRlZmluZWQgd2hlbiBpbXBvcnRpbmcgdGhpcyBmaWxlXG52YXIgd2luO1xuaWYgKHR5cGVvZih3aW5kb3cpID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBsb2MgPSB7XG4gICAgICAgIGhvc3RuYW1lOiAnJ1xuICAgIH07XG4gICAgd2luID0ge1xuICAgICAgICBuYXZpZ2F0b3I6IHsgdXNlckFnZW50OiAnJywgb25MaW5lOiB0cnVlIH0sXG4gICAgICAgIGRvY3VtZW50OiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jLFxuICAgICAgICAgICAgcmVmZXJyZXI6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmVlbjogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NcbiAgICB9O1xufSBlbHNlIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59XG5cbnZhciBzZXRJbW1lZGlhdGUgPSB3aW5bJ3NldEltbWVkaWF0ZSddO1xudmFyIGJ1aWx0SW5Qcm9wLCBjeWNsZSwgc2NoZWR1bGluZ1F1ZXVlLFxuICAgIFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICB0aW1lciA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykgP1xuICAgICAgICBmdW5jdGlvbiB0aW1lcihmbikgeyByZXR1cm4gc2V0SW1tZWRpYXRlKGZuKTsgfSA6XG4gICAgICAgIHNldFRpbWVvdXQ7XG5cbi8vIGRhbW1pdCwgSUU4LlxudHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sJ3gnLHt9KTtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCxjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosbmFtZSx7XG4gICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGNvbmZpZyAhPT0gZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmNhdGNoIChlcnIpIHtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCkge1xuICAgICAgICBvYmpbbmFtZV0gPSB2YWw7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbn1cblxuLy8gTm90ZTogdXNpbmcgYSBxdWV1ZSBpbnN0ZWFkIG9mIGFycmF5IGZvciBlZmZpY2llbmN5XG5zY2hlZHVsaW5nUXVldWUgPSAoZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgdmFyIGZpcnN0LCBsYXN0LCBpdGVtO1xuXG4gICAgZnVuY3Rpb24gSXRlbShmbixzZWxmKSB7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy5zZWxmID0gc2VsZjtcbiAgICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGZuLHNlbGYpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBuZXcgSXRlbShmbixzZWxmKTtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5uZXh0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3QgPSBpdGVtO1xuICAgICAgICAgICAgaXRlbSA9IHZvaWQgMDtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhaW46IGZ1bmN0aW9uIGRyYWluKCkge1xuICAgICAgICAgICAgdmFyIGYgPSBmaXJzdDtcbiAgICAgICAgICAgIGZpcnN0ID0gbGFzdCA9IGN5Y2xlID0gdm9pZCAwO1xuXG4gICAgICAgICAgICB3aGlsZSAoZikge1xuICAgICAgICAgICAgICAgIGYuZm4uY2FsbChmLnNlbGYpO1xuICAgICAgICAgICAgICAgIGYgPSBmLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuZnVuY3Rpb24gc2NoZWR1bGUoZm4sc2VsZikge1xuICAgIHNjaGVkdWxpbmdRdWV1ZS5hZGQoZm4sc2VsZik7XG4gICAgaWYgKCFjeWNsZSkge1xuICAgICAgICBjeWNsZSA9IHRpbWVyKHNjaGVkdWxpbmdRdWV1ZS5kcmFpbik7XG4gICAgfVxufVxuXG4vLyBwcm9taXNlIGR1Y2sgdHlwaW5nXG5mdW5jdGlvbiBpc1RoZW5hYmxlKG8pIHtcbiAgICB2YXIgX3RoZW4sIG9UeXBlID0gdHlwZW9mIG87XG5cbiAgICBpZiAobyAhPT0gbnVsbCAmJiAob1R5cGUgPT09ICdvYmplY3QnIHx8IG9UeXBlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBfdGhlbiA9IG8udGhlbjtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBfdGhlbiA9PT0gJ2Z1bmN0aW9uJyA/IF90aGVuIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBub3RpZnlJc29sYXRlZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gMSkgPyB0aGlzLmNoYWluW2ldLnN1Y2Nlc3MgOiB0aGlzLmNoYWluW2ldLmZhaWx1cmUsXG4gICAgICAgICAgICB0aGlzLmNoYWluW2ldXG4gICAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY2hhaW4ubGVuZ3RoID0gMDtcbn1cblxuLy8gTk9URTogVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGlzb2xhdGVcbi8vIHRoZSBgdHJ5Li5jYXRjaGAgc28gdGhhdCBvdGhlciBjb2RlIGNhbiBiZVxuLy8gb3B0aW1pemVkIGJldHRlclxuZnVuY3Rpb24gbm90aWZ5SXNvbGF0ZWQoc2VsZixjYixjaGFpbikge1xuICAgIHZhciByZXQsIF90aGVuO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChjYiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNoYWluLnJlamVjdChzZWxmLm1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBzZWxmLm1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldCA9IGNiLmNhbGwodm9pZCAwLHNlbGYubXNnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJldCA9PT0gY2hhaW4ucHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGNoYWluLnJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGVuID0gaXNUaGVuYWJsZShyZXQpKSB7XG4gICAgICAgICAgICAgICAgX3RoZW4uY2FsbChyZXQsY2hhaW4ucmVzb2x2ZSxjaGFpbi5yZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhaW4ucmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2hhaW4ucmVqZWN0KGVycik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKG1zZykge1xuICAgIHZhciBfdGhlbiwgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYuZGVmO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKG1zZykpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIGRlZldyYXBwZXIgPSBuZXcgTWFrZURlZldyYXBwZXIoc2VsZik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3RoZW4uY2FsbChtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcmVzb2x2ZSQoKXsgcmVzb2x2ZS5hcHBseShkZWZXcmFwcGVyLGFyZ3VtZW50cyk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcmVqZWN0JCgpeyByZWplY3QuYXBwbHkoZGVmV3JhcHBlcixhcmd1bWVudHMpOyB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LmNhbGwoZGVmV3JhcHBlcixlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5tc2cgPSBtc2c7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gMTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZShub3RpZnksc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QuY2FsbChuZXcgTWFrZURlZldyYXBwZXIoc2VsZiksZXJyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChtc2cpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYuZGVmO1xuICAgIH1cblxuICAgIHNlbGYubXNnID0gbXNnO1xuICAgIHNlbGYuc3RhdGUgPSAyO1xuICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixyZXNvbHZlcixyZWplY3Rlcikge1xuICAgIGZvciAodmFyIGlkeD0wOyBpZHg8YXJyLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgKGZ1bmN0aW9uIElJRkUoaWR4KXtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoYXJyW2lkeF0pXG4gICAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRyZXNvbHZlciQobXNnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKGlkeCxtc2cpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWplY3RlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH0pKGlkeCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBNYWtlRGVmV3JhcHBlcihzZWxmKSB7XG4gICAgdGhpcy5kZWYgPSBzZWxmO1xuICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIE1ha2VEZWYoc2VsZikge1xuICAgIHRoaXMucHJvbWlzZSA9IHNlbGY7XG4gICAgdGhpcy5zdGF0ZSA9IDA7XG4gICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNoYWluID0gW107XG4gICAgdGhpcy5tc2cgPSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIE5wb1Byb21pc2UoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1snX19OUE9fXyddICE9PSAwKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgcHJvbWlzZScpO1xuICAgIH1cblxuICAgIC8vIGluc3RhbmNlIHNoYWRvd2luZyB0aGUgaW5oZXJpdGVkIFwiYnJhbmRcIlxuICAgIC8vIHRvIHNpZ25hbCBhbiBhbHJlYWR5IFwiaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG4gICAgdGhpc1snX19OUE9fXyddID0gMTtcblxuICAgIHZhciBkZWYgPSBuZXcgTWFrZURlZih0aGlzKTtcblxuICAgIHRoaXNbJ3RoZW4nXSA9IGZ1bmN0aW9uIHRoZW4oc3VjY2VzcyxmYWlsdXJlKSB7XG4gICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgc3VjY2VzczogdHlwZW9mIHN1Y2Nlc3MgPT09ICdmdW5jdGlvbicgPyBzdWNjZXNzIDogdHJ1ZSxcbiAgICAgICAgICAgIGZhaWx1cmU6IHR5cGVvZiBmYWlsdXJlID09PSAnZnVuY3Rpb24nID8gZmFpbHVyZSA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgICAgICAvLyBOb3RlOiBgdGhlbiguLilgIGl0c2VsZiBjYW4gYmUgYm9ycm93ZWQgdG8gYmUgdXNlZCBhZ2FpbnN0XG4gICAgICAgICAgICAvLyBhIGRpZmZlcmVudCBwcm9taXNlIGNvbnN0cnVjdG9yIGZvciBtYWtpbmcgdGhlIGNoYWluZWQgcHJvbWlzZSxcbiAgICAgICAgICAgIC8vIGJ5IHN1YnN0aXR1dGluZyBhIGRpZmZlcmVudCBgdGhpc2AgYmluZGluZy5cbiAgICAgICAgby5wcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24gZXh0cmFjdENoYWluKHJlc29sdmUscmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgby5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIG8ucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmLmNoYWluLnB1c2gobyk7XG5cbiAgICAgICAgaWYgKGRlZi5zdGF0ZSAhPT0gMCkge1xuICAgICAgICAgICAgc2NoZWR1bGUobm90aWZ5LGRlZik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gby5wcm9taXNlO1xuICAgIH07XG4gICAgdGhpc1snY2F0Y2gnXSA9IGZ1bmN0aW9uICRjYXRjaCQoZmFpbHVyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxmYWlsdXJlKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IuY2FsbChcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1YmxpY1Jlc29sdmUobXNnKXtcbiAgICAgICAgICAgICAgICByZXNvbHZlLmNhbGwoZGVmLG1zZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gcHVibGljUmVqZWN0KG1zZykge1xuICAgICAgICAgICAgICAgIHJlamVjdC5jYWxsKGRlZixtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdC5jYWxsKGRlZixlcnIpO1xuICAgIH1cbn1cblxudmFyIFByb21pc2VQcm90b3R5cGUgPSBidWlsdEluUHJvcCh7fSwnY29uc3RydWN0b3InLE5wb1Byb21pc2UsXG4gICAgLypjb25maWd1cmFibGU9Ki9mYWxzZVxuKTtcblxuICAgIC8vIE5vdGU6IEFuZHJvaWQgNCBjYW5ub3QgdXNlIGBPYmplY3QuZGVmaW5lUHJvcGVydHkoLi4pYCBoZXJlXG5OcG9Qcm9taXNlLnByb3RvdHlwZSA9IFByb21pc2VQcm90b3R5cGU7XG5cbi8vIGJ1aWx0LWluIFwiYnJhbmRcIiB0byBzaWduYWwgYW4gXCJ1bmluaXRpYWxpemVkXCIgcHJvbWlzZVxuYnVpbHRJblByb3AoUHJvbWlzZVByb3RvdHlwZSwnX19OUE9fXycsMCxcbiAgICAvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG4pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdyZXNvbHZlJyxmdW5jdGlvbiBQcm9taXNlJHJlc29sdmUobXNnKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgLy8gbm90ZTogYmVzdCBcImlzUHJvbWlzZVwiIGNoZWNrIHRoYXQncyBwcmFjdGljYWwgZm9yIG5vd1xuICAgIGlmIChtc2cgJiYgdHlwZW9mIG1zZyA9PT0gJ29iamVjdCcgJiYgbXNnWydfX05QT19fJ10gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUobXNnKTtcbiAgICB9KTtcbn0pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdyZWplY3QnLGZ1bmN0aW9uIFByb21pc2UkcmVqZWN0KG1zZykge1xuICAgIHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZWplY3QobXNnKTtcbiAgICB9KTtcbn0pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdhbGwnLGZ1bmN0aW9uIFByb21pc2UkYWxsKGFycikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIGlmIChUb1N0cmluZy5jYWxsKGFycikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoJ05vdCBhbiBhcnJheScpKTtcbiAgICB9XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGgsIG1zZ3MgPSBBcnJheShsZW4pLCBjb3VudCA9IDA7XG5cbiAgICAgICAgaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKSB7XG4gICAgICAgICAgICBtc2dzW2lkeF0gPSBtc2c7XG4gICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtc2dzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxyZWplY3QpO1xuICAgIH0pO1xufSk7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ3JhY2UnLGZ1bmN0aW9uIFByb21pc2UkcmFjZShhcnIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICBpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKCdOb3QgYW4gYXJyYXknKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpe1xuICAgICAgICAgICAgcmVzb2x2ZShtc2cpO1xuICAgICAgICB9LHJlamVjdCk7XG4gICAgfSk7XG59KTtcblxudmFyIFByb21pc2VQb2x5ZmlsbDtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgUHJvbWlzZS50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSAhPT0gLTEpIHtcbiAgICBQcm9taXNlUG9seWZpbGwgPSBQcm9taXNlO1xufSBlbHNlIHtcbiAgICBQcm9taXNlUG9seWZpbGwgPSBOcG9Qcm9taXNlO1xufVxuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiLCBlcWVxZXE6IFwib2ZmXCIgKi9cblxuLy8gTWF4aW11bSBhbGxvd2VkIHNlc3Npb24gcmVjb3JkaW5nIGxlbmd0aFxudmFyIE1BWF9SRUNPUkRJTkdfTVMgPSAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyAyNCBob3Vyc1xuLy8gTWF4aW11bSBhbGxvd2VkIHZhbHVlIGZvciBtaW5pbXVtIHNlc3Npb24gcmVjb3JkaW5nIGxlbmd0aFxudmFyIE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUyA9IDggKiAxMDAwOyAvLyA4IHNlY29uZHNcblxuLypcbiAqIFNhdmVkIHJlZmVyZW5jZXMgdG8gbG9uZyB2YXJpYWJsZSBuYW1lcywgc28gdGhhdCBjbG9zdXJlIGNvbXBpbGVyIGNhblxuICogbWluaW1pemUgZmlsZSBzaXplLlxuICovXG5cbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICB3aW5kb3dDb25zb2xlID0gd2luLmNvbnNvbGUsXG4gICAgbmF2aWdhdG9yID0gd2luLm5hdmlnYXRvcixcbiAgICBkb2N1bWVudCQxID0gd2luLmRvY3VtZW50LFxuICAgIHdpbmRvd09wZXJhID0gd2luLm9wZXJhLFxuICAgIHNjcmVlbiA9IHdpbi5zY3JlZW4sXG4gICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxudmFyIG5hdGl2ZUJpbmQgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVGb3JFYWNoID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgIG5hdGl2ZUluZGV4T2YgPSBBcnJheVByb3RvLmluZGV4T2YsXG4gICAgbmF0aXZlTWFwID0gQXJyYXlQcm90by5tYXAsXG4gICAgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgYnJlYWtlciA9IHt9O1xuXG52YXIgXyA9IHtcbiAgICB0cmltOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0jUG9seWZpbGxcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgIH1cbn07XG5cbi8vIENvbnNvbGUgb3ZlcnJpZGVcbnZhciBjb25zb2xlJDEgPSB7XG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICBsb2c6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5sb2cuYXBwbHkod2luZG93Q29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmxvZyhhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIHdhcm46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCB3YXJuaW5nOiddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUud2Fybi5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS53YXJuKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCBlcnJvcjonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgY3JpdGljYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQod2luZG93Q29uc29sZSkgJiYgd2luZG93Q29uc29sZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbJ01peHBhbmVsIGVycm9yOiddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IuYXBwbHkod2luZG93Q29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IoYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBsb2dfZnVuY193aXRoX3ByZWZpeCA9IGZ1bmN0aW9uKGZ1bmMsIHByZWZpeCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJndW1lbnRzWzBdID0gJ1snICsgcHJlZml4ICsgJ10gJyArIGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29uc29sZSQxLCBhcmd1bWVudHMpO1xuICAgIH07XG59O1xudmFyIGNvbnNvbGVfd2l0aF9wcmVmaXggPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb2c6IGxvZ19mdW5jX3dpdGhfcHJlZml4KGNvbnNvbGUkMS5sb2csIHByZWZpeCksXG4gICAgICAgIGVycm9yOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEuZXJyb3IsIHByZWZpeCksXG4gICAgICAgIGNyaXRpY2FsOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEuY3JpdGljYWwsIHByZWZpeClcbiAgICB9O1xufTtcblxuXG4vLyBVTkRFUlNDT1JFXG4vLyBFbWJlZCBwYXJ0IG9mIHRoZSBVbmRlcnNjb3JlIExpYnJhcnlcbl8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICB2YXIgYXJncywgYm91bmQ7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYm91bmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3RvciA9IHt9O1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgICB2YXIgc2VsZiA9IG5ldyBjdG9yKCk7XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkoc2VsZiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyo9fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uKik9fSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3Q9fSBjb250ZXh0XG4gKi9cbl8uZWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBvYmogJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBicmVha2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5fLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZVtwcm9wXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbl8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8vIGZyb20gYSBjb21tZW50IG9uIGh0dHA6Ly9kYmoub3JnL2Riai8/cD0yODZcbi8vIGZhaWxzIG9uIG9ubHkgb25lIHZlcnkgcmFyZSBhbmQgZGVsaWJlcmF0ZSBjdXN0b20gb2JqZWN0OlxuLy8gdmFyIGJvbWIgPSB7IHRvU3RyaW5nIDogdW5kZWZpbmVkLCB2YWx1ZU9mOiBmdW5jdGlvbihvKSB7IHJldHVybiBcImZ1bmN0aW9uIEJPTUJBIVwiOyB9fTtcbl8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKGYpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gL15cXHMqXFxiZnVuY3Rpb25cXGIvLnRlc3QoZik7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdjYWxsZWUnKSk7XG59O1xuXG5fLnRvQXJyYXkgPSBmdW5jdGlvbihpdGVyYWJsZSkge1xuICAgIGlmICghaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoaXRlcmFibGUudG9BcnJheSkge1xuICAgICAgICByZXR1cm4gaXRlcmFibGUudG9BcnJheSgpO1xuICAgIH1cbiAgICBpZiAoXy5pc0FycmF5KGl0ZXJhYmxlKSkge1xuICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChpdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChfLmlzQXJndW1lbnRzKGl0ZXJhYmxlKSkge1xuICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChpdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBfLnZhbHVlcyhpdGVyYWJsZSk7XG59O1xuXG5fLm1hcCA9IGZ1bmN0aW9uKGFyciwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAobmF0aXZlTWFwICYmIGFyci5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgICAgICByZXR1cm4gYXJyLm1hcChjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgXy5lYWNoKGFyciwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNhbGxiYWNrLmNhbGwoY29udGV4dCwgaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxufTtcblxuXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0ga2V5O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5fLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCkge1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBvYmouaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikge1xuICAgICAgICByZXR1cm4gb2JqLmluZGV4T2YodGFyZ2V0KSAhPSAtMTtcbiAgICB9XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGZvdW5kIHx8IChmb3VuZCA9ICh2YWx1ZSA9PT0gdGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBicmVha2VyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuXy5pbmNsdWRlcyA9IGZ1bmN0aW9uKHN0ciwgbmVlZGxlKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xufTtcblxuLy8gVW5kZXJzY29yZSBBZGRvbnNcbl8uaW5oZXJpdCA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBzdXBlcmNsYXNzKSB7XG4gICAgc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IHN1cGVyY2xhc3MoKTtcbiAgICBzdWJjbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJjbGFzcztcbiAgICBzdWJjbGFzcy5zdXBlcmNsYXNzID0gc3VwZXJjbGFzcy5wcm90b3R5cGU7XG4gICAgcmV0dXJuIHN1YmNsYXNzO1xufTtcblxuXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAob2JqID09PSBPYmplY3Qob2JqKSAmJiAhXy5pc0FycmF5KG9iaikpO1xufTtcblxuXy5pc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKF8uaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbl8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG59O1xuXG5fLmlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbl8uaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG5fLmlzTnVtYmVyID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBOdW1iZXJdJztcbn07XG5cbl8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xufTtcblxuXy5lbmNvZGVEYXRlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgaWYgKF8uaXNEYXRlKHYpKSB7XG4gICAgICAgICAgICBvYmpba10gPSBfLmZvcm1hdERhdGUodik7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdCh2KSkge1xuICAgICAgICAgICAgb2JqW2tdID0gXy5lbmNvZGVEYXRlcyh2KTsgLy8gcmVjdXJzZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbl8udGltZXN0YW1wID0gZnVuY3Rpb24oKSB7XG4gICAgRGF0ZS5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICtuZXcgRGF0ZTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xufTtcblxuXy5mb3JtYXREYXRlID0gZnVuY3Rpb24oZCkge1xuICAgIC8vIFlZWVktTU0tRERUSEg6TU06U1MgaW4gVVRDXG4gICAgZnVuY3Rpb24gcGFkKG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4gOiBuO1xuICAgIH1cbiAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpICsgJy0nICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDRGF0ZSgpKSArICdUJyArXG4gICAgICAgIHBhZChkLmdldFVUQ0hvdXJzKCkpICsgJzonICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDTWludXRlcygpKSArICc6JyArXG4gICAgICAgIHBhZChkLmdldFVUQ1NlY29uZHMoKSk7XG59O1xuXG5fLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIF8uZWFjaChwLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmIChfLmlzU3RyaW5nKHYpICYmIHYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0W2tdID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG4vKlxuICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgY29weSBvZiBvYmplY3QgYWZ0ZXIgdHJ1bmNhdGluZyBpdC4gIElmXG4gKiBwYXNzZWQgYW4gQXJyYXkgb3IgT2JqZWN0IGl0IHdpbGwgaXRlcmF0ZSB0aHJvdWdoIG9iaiBhbmRcbiAqIHRydW5jYXRlIGFsbCB0aGUgdmFsdWVzIHJlY3Vyc2l2ZWx5LlxuICovXG5fLnRydW5jYXRlID0gZnVuY3Rpb24ob2JqLCBsZW5ndGgpIHtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKHR5cGVvZihvYmopID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXQgPSBvYmouc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldCA9IFtdO1xuICAgICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKF8udHJ1bmNhdGUodmFsLCBsZW5ndGgpKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0ID0ge307XG4gICAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgICAgICByZXRba2V5XSA9IF8udHJ1bmNhdGUodmFsLCBsZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbl8uSlNPTkVuY29kZSA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obWl4ZWRfdmFsKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1peGVkX3ZhbDtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgZXNjYXBhYmxlID0gL1tcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgICAgICAgdmFyIG1ldGEgPSB7IC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAgICAgJ1wiJzogJ1xcXFxcIicsXG4gICAgICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID9cbiAgICAgICAgICAgICAgICAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICAgICAgfSkgKyAnXCInIDpcbiAgICAgICAgICAgICAgICAnXCInICsgc3RyaW5nICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3RyID0gZnVuY3Rpb24oa2V5LCBob2xkZXIpIHtcbiAgICAgICAgICAgIHZhciBnYXAgPSAnJztcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSAnICAgICc7XG4gICAgICAgICAgICB2YXIgaSA9IDA7IC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgICAgICB2YXIgayA9ICcnOyAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgICAgIHZhciB2ID0gJyc7IC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHZhciBtaW5kID0gZ2FwO1xuICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhvbGRlcltrZXldO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHlwZSBpcyAnb2JqZWN0Jywgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuICAgICAgICAgICAgICAgICAgICAvLyBudWxsLlxuICAgICAgICAgICAgICAgICAgICAvLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBhbiBhcnJheSB0byBob2xkIHRoZSBwYXJ0aWFsIHJlc3VsdHMgb2Ygc3RyaW5naWZ5aW5nIHRoaXMgb2JqZWN0IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgYW4gYXJyYXkuIFN0cmluZ2lmeSBldmVyeSBlbGVtZW50LiBVc2UgbnVsbCBhcyBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3Igbm9uLUpTT04gdmFsdWVzLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmQgd3JhcCB0aGVtIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBicmFja2V0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA/ICdbXFxuJyArIGdhcCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG4gICAgICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwID8gJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5kICsgJ30nIDogJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG4gICAgICAgIHJldHVybiBzdHIoJycsIHtcbiAgICAgICAgICAgICcnOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi9tYXN0ZXIvanNvbl9wYXJzZS5qc1xuICogU2xpZ2h0bHkgbW9kaWZpZWQgdG8gdGhyb3cgYSByZWFsIEVycm9yIHJhdGhlciB0aGFuIGEgUE9KT1xuICovXG5fLkpTT05EZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGF0LCAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICAgICAgZXNjYXBlZSA9IHtcbiAgICAgICAgICAgICdcIic6ICdcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgICAgICcvJzogJy8nLFxuICAgICAgICAgICAgJ2InOiAnXFxiJyxcbiAgICAgICAgICAgICdmJzogJ1xcZicsXG4gICAgICAgICAgICAnbic6ICdcXG4nLFxuICAgICAgICAgICAgJ3InOiAnXFxyJyxcbiAgICAgICAgICAgICd0JzogJ1xcdCdcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgZXJyb3IgPSBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBTeW50YXhFcnJvcihtKTtcbiAgICAgICAgICAgIGUuYXQgPSBhdDtcbiAgICAgICAgICAgIGUudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0ID0gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgLy8gSWYgYSBjIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdmVyaWZ5IHRoYXQgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCBcXCcnICsgYyArICdcXCcgaW5zdGVhZCBvZiBcXCcnICsgY2ggKyAnXFwnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIG5leHQgY2hhcmFjdGVyLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMsXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgIGNoID0gdGV4dC5jaGFyQXQoYXQpO1xuICAgICAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBudW1iZXIsXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJyc7XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJy0nO1xuICAgICAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCgpICYmIGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignQmFkIG51bWJlcicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYSBzdHJpbmcgdmFsdWUuXG4gICAgICAgICAgICB2YXIgaGV4LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICAgICAgdWZmZmY7XG4gICAgICAgICAgICAvLyBXaGVuIHBhcnNpbmcgZm9yIHN0cmluZyB2YWx1ZXMsIHdlIG11c3QgbG9vayBmb3IgXCIgYW5kIFxcIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBwYXJzZUludChuZXh0KCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVlW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignQmFkIHN0cmluZycpO1xuICAgICAgICB9LFxuICAgICAgICB3aGl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd29yZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgncicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnYScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ24nKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCBcIicgKyBjaCArICdcIicpO1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZSwgLy8gUGxhY2Vob2xkZXIgZm9yIHRoZSB2YWx1ZSBmdW5jdGlvbi5cbiAgICAgICAgYXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnWycpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7IC8vIGVtcHR5IGFycmF5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignQmFkIGFycmF5Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuICAgICAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCd7Jyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7IC8vIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBvYmplY3QnKTtcbiAgICAgICAgfTtcblxuICAgIHZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsXG4gICAgICAgIC8vIGEgbnVtYmVyLCBvciBhIHdvcmQuXG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QoKTtcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheSgpO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoID49ICcwJyAmJiBjaCA8PSAnOScgPyBudW1iZXIoKSA6IHdvcmQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIGpzb25fcGFyc2UgZnVuY3Rpb24uIEl0IHdpbGwgaGF2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZVxuICAgIC8vIGFib3ZlIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICB0ZXh0ID0gc291cmNlO1xuICAgICAgICBhdCA9IDA7XG4gICAgICAgIGNoID0gJyAnO1xuICAgICAgICByZXN1bHQgPSB2YWx1ZSgpO1xuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICBpZiAoY2gpIHtcbiAgICAgICAgICAgIGVycm9yKCdTeW50YXggZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5cbl8uYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBiNjQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgIHZhciBvMSwgbzIsIG8zLCBoMSwgaDIsIGgzLCBoNCwgYml0cywgaSA9IDAsXG4gICAgICAgIGFjID0gMCxcbiAgICAgICAgZW5jID0gJycsXG4gICAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhID0gXy51dGY4RW5jb2RlKGRhdGEpO1xuXG4gICAgZG8geyAvLyBwYWNrIHRocmVlIG9jdGV0cyBpbnRvIGZvdXIgaGV4ZXRzXG4gICAgICAgIG8xID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIG8yID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIG8zID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG5cbiAgICAgICAgYml0cyA9IG8xIDw8IDE2IHwgbzIgPDwgOCB8IG8zO1xuXG4gICAgICAgIGgxID0gYml0cyA+PiAxOCAmIDB4M2Y7XG4gICAgICAgIGgyID0gYml0cyA+PiAxMiAmIDB4M2Y7XG4gICAgICAgIGgzID0gYml0cyA+PiA2ICYgMHgzZjtcbiAgICAgICAgaDQgPSBiaXRzICYgMHgzZjtcblxuICAgICAgICAvLyB1c2UgaGV4ZXRzIHRvIGluZGV4IGludG8gYjY0LCBhbmQgYXBwZW5kIHJlc3VsdCB0byBlbmNvZGVkIHN0cmluZ1xuICAgICAgICB0bXBfYXJyW2FjKytdID0gYjY0LmNoYXJBdChoMSkgKyBiNjQuY2hhckF0KGgyKSArIGI2NC5jaGFyQXQoaDMpICsgYjY0LmNoYXJBdChoNCk7XG4gICAgfSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuICAgIGVuYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICBzd2l0Y2ggKGRhdGEubGVuZ3RoICUgMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBlbmMgPSBlbmMuc2xpY2UoMCwgLTIpICsgJz09JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBlbmMgPSBlbmMuc2xpY2UoMCwgLTEpICsgJz0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuYztcbn07XG5cbl8udXRmOEVuY29kZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IChzdHJpbmcgKyAnJykucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuXG4gICAgdmFyIHV0ZnRleHQgPSAnJyxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZDtcbiAgICB2YXIgc3RyaW5nbCA9IDAsXG4gICAgICAgIG47XG5cbiAgICBzdGFydCA9IGVuZCA9IDA7XG4gICAgc3RyaW5nbCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICBmb3IgKG4gPSAwOyBuIDwgc3RyaW5nbDsgbisrKSB7XG4gICAgICAgIHZhciBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xuICAgICAgICB2YXIgZW5jID0gbnVsbDtcblxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9IGVsc2UgaWYgKChjMSA+IDEyNykgJiYgKGMxIDwgMjA0OCkpIHtcbiAgICAgICAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMxID4+IDYpIHwgMTkyLCAoYzEgJiA2MykgfCAxMjgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYzEgPj4gMTIpIHwgMjI0LCAoKGMxID4+IDYpICYgNjMpIHwgMTI4LCAoYzEgJiA2MykgfCAxMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gc3RyaW5nLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0ZnRleHQgKz0gZW5jO1xuICAgICAgICAgICAgc3RhcnQgPSBlbmQgPSBuICsgMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIHN0cmluZy5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGZ0ZXh0O1xufTtcblxuXy5VVUlEID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gVGltZS1iYXNlZCBlbnRyb3B5XG4gICAgdmFyIFQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpbWUgPSAxICogbmV3IERhdGUoKTsgLy8gY3Jvc3MtYnJvd3NlciB2ZXJzaW9uIG9mIERhdGUubm93KClcbiAgICAgICAgdmFyIHRpY2tzO1xuICAgICAgICBpZiAod2luLnBlcmZvcm1hbmNlICYmIHdpbi5wZXJmb3JtYW5jZS5ub3cpIHtcbiAgICAgICAgICAgIHRpY2tzID0gd2luLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGJ1c3kgbG9vcFxuICAgICAgICAgICAgdGlja3MgPSAwO1xuXG4gICAgICAgICAgICAvLyB0aGlzIHdoaWxlIGxvb3AgZmlndXJlcyBob3cgbWFueSBicm93c2VyIHRpY2tzIGdvIGJ5XG4gICAgICAgICAgICAvLyBiZWZvcmUgMSpuZXcgRGF0ZSgpIHJldHVybnMgYSBuZXcgbnVtYmVyLCBpZSB0aGUgYW1vdW50XG4gICAgICAgICAgICAvLyBvZiB0aWNrcyB0aGF0IGdvIGJ5IHBlciBtaWxsaXNlY29uZFxuICAgICAgICAgICAgd2hpbGUgKHRpbWUgPT0gMSAqIG5ldyBEYXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aWNrcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lLnRvU3RyaW5nKDE2KSArIE1hdGguZmxvb3IodGlja3MpLnRvU3RyaW5nKDE2KTtcbiAgICB9O1xuXG4gICAgLy8gTWF0aC5SYW5kb20gZW50cm9weVxuICAgIHZhciBSID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5yZXBsYWNlKCcuJywgJycpO1xuICAgIH07XG5cbiAgICAvLyBVc2VyIGFnZW50IGVudHJvcHlcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIHRoZSB1c2VyIGFnZW50IHN0cmluZywgYW5kIHRoZW4geG9yc1xuICAgIC8vIHRvZ2V0aGVyIGVhY2ggc2VxdWVuY2Ugb2YgOCBieXRlcy4gIFRoaXMgcHJvZHVjZXMgYSBmaW5hbFxuICAgIC8vIHNlcXVlbmNlIG9mIDggYnl0ZXMgd2hpY2ggaXQgcmV0dXJucyBhcyBoZXguXG4gICAgdmFyIFVBID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1YSA9IHVzZXJBZ2VudCxcbiAgICAgICAgICAgIGksIGNoLCBidWZmZXIgPSBbXSxcbiAgICAgICAgICAgIHJldCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24geG9yKHJlc3VsdCwgYnl0ZV9hcnJheSkge1xuICAgICAgICAgICAgdmFyIGosIHRtcCA9IDA7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYnl0ZV9hcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRtcCB8PSAoYnVmZmVyW2pdIDw8IGogKiA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgXiB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdWEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoID0gdWEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGJ1ZmZlci51bnNoaWZ0KGNoICYgMHhGRik7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0ID0geG9yKHJldCwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0ID0geG9yKHJldCwgYnVmZmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQudG9TdHJpbmcoMTYpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZSA9IChzY3JlZW4uaGVpZ2h0ICogc2NyZWVuLndpZHRoKS50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiAoVCgpICsgJy0nICsgUigpICsgJy0nICsgVUEoKSArICctJyArIHNlICsgJy0nICsgVCgpKTtcbiAgICB9O1xufSkoKTtcblxuLy8gXy5pc0Jsb2NrZWRVQSgpXG4vLyBUaGlzIGlzIHRvIGJsb2NrIHZhcmlvdXMgd2ViIHNwaWRlcnMgZnJvbSBleGVjdXRpbmcgb3VyIEpTIGFuZFxuLy8gc2VuZGluZyBmYWxzZSB0cmFja2luZyBkYXRhXG52YXIgQkxPQ0tFRF9VQV9TVFJTID0gW1xuICAgICdhaHJlZnNib3QnLFxuICAgICdhaHJlZnNzaXRlYXVkaXQnLFxuICAgICdiYWlkdXNwaWRlcicsXG4gICAgJ2Jpbmdib3QnLFxuICAgICdiaW5ncHJldmlldycsXG4gICAgJ2Nocm9tZS1saWdodGhvdXNlJyxcbiAgICAnZmFjZWJvb2tleHRlcm5hbCcsXG4gICAgJ3BldGFsYm90JyxcbiAgICAncGludGVyZXN0JyxcbiAgICAnc2NyZWFtaW5nIGZyb2cnLFxuICAgICd5YWhvbyEgc2x1cnAnLFxuICAgICd5YW5kZXhib3QnLFxuXG4gICAgLy8gYSB3aG9sZSBidW5jaCBvZiBnb29nLXNwZWNpZmljIGNyYXdsZXJzXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2VhcmNoL2RvY3MvYWR2YW5jZWQvY3Jhd2xpbmcvb3ZlcnZpZXctZ29vZ2xlLWNyYXdsZXJzXG4gICAgJ2Fkc2JvdC1nb29nbGUnLFxuICAgICdhcGlzLWdvb2dsZScsXG4gICAgJ2R1cGxleHdlYi1nb29nbGUnLFxuICAgICdmZWVkZmV0Y2hlci1nb29nbGUnLFxuICAgICdnb29nbGUgZmF2aWNvbicsXG4gICAgJ2dvb2dsZSB3ZWIgcHJldmlldycsXG4gICAgJ2dvb2dsZS1yZWFkLWFsb3VkJyxcbiAgICAnZ29vZ2xlYm90JyxcbiAgICAnZ29vZ2xld2VibGlnaHQnLFxuICAgICdtZWRpYXBhcnRuZXJzLWdvb2dsZScsXG4gICAgJ3N0b3JlYm90LWdvb2dsZSdcbl07XG5fLmlzQmxvY2tlZFVBID0gZnVuY3Rpb24odWEpIHtcbiAgICB2YXIgaTtcbiAgICB1YSA9IHVhLnRvTG93ZXJDYXNlKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IEJMT0NLRURfVUFfU1RSUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodWEuaW5kZXhPZihCTE9DS0VEX1VBX1NUUlNbaV0pICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdD19IGZvcm1kYXRhXG4gKiBAcGFyYW0ge3N0cmluZz19IGFyZ19zZXBhcmF0b3JcbiAqL1xuXy5IVFRQQnVpbGRRdWVyeSA9IGZ1bmN0aW9uKGZvcm1kYXRhLCBhcmdfc2VwYXJhdG9yKSB7XG4gICAgdmFyIHVzZV92YWwsIHVzZV9rZXksIHRtcF9hcnIgPSBbXTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKGFyZ19zZXBhcmF0b3IpKSB7XG4gICAgICAgIGFyZ19zZXBhcmF0b3IgPSAnJic7XG4gICAgfVxuXG4gICAgXy5lYWNoKGZvcm1kYXRhLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICB1c2VfdmFsID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbC50b1N0cmluZygpKTtcbiAgICAgICAgdXNlX2tleSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xuICAgICAgICB0bXBfYXJyW3RtcF9hcnIubGVuZ3RoXSA9IHVzZV9rZXkgKyAnPScgKyB1c2VfdmFsO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRtcF9hcnIuam9pbihhcmdfc2VwYXJhdG9yKTtcbn07XG5cbl8uZ2V0UXVlcnlQYXJhbSA9IGZ1bmN0aW9uKHVybCwgcGFyYW0pIHtcbiAgICAvLyBFeHBlY3RzIGEgcmF3IFVSTFxuXG4gICAgcGFyYW0gPSBwYXJhbS5yZXBsYWNlKC9bW10vZywgJ1xcXFxbJykucmVwbGFjZSgvW1xcXV0vZywgJ1xcXFxdJyk7XG4gICAgdmFyIHJlZ2V4UyA9ICdbXFxcXD8mXScgKyBwYXJhbSArICc9KFteJiNdKiknLFxuICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhTKSxcbiAgICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWModXJsKTtcbiAgICBpZiAocmVzdWx0cyA9PT0gbnVsbCB8fCAocmVzdWx0cyAmJiB0eXBlb2YocmVzdWx0c1sxXSkgIT09ICdzdHJpbmcnICYmIHJlc3VsdHNbMV0ubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdHNbMV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignU2tpcHBpbmcgZGVjb2RpbmcgZm9yIG1hbGZvcm1lZCBxdWVyeSBwYXJhbTogJyArIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICB9XG59O1xuXG5cbi8vIF8uY29va2llXG4vLyBNZXRob2RzIHBhcnRpYWxseSBib3Jyb3dlZCBmcm9tIHF1aXJrc21vZGUub3JnL2pzL2Nvb2tpZXMuaHRtbFxuXy5jb29raWUgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBuYW1lRVEgPSBuYW1lICsgJz0nO1xuICAgICAgICB2YXIgY2EgPSBkb2N1bWVudCQxLmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09ICcgJykge1xuICAgICAgICAgICAgICAgIGMgPSBjLnN1YnN0cmluZygxLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBjb29raWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb29raWUgPSBfLkpTT05EZWNvZGUoXy5jb29raWUuZ2V0KG5hbWUpKSB8fCB7fTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICB9LFxuXG4gICAgc2V0X3NlY29uZHM6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBzZWNvbmRzLCBpc19jcm9zc19zdWJkb21haW4sIGlzX3NlY3VyZSwgaXNfY3Jvc3Nfc2l0ZSwgZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgIHZhciBjZG9tYWluID0gJycsXG4gICAgICAgICAgICBleHBpcmVzID0gJycsXG4gICAgICAgICAgICBzZWN1cmUgPSAnJztcblxuICAgICAgICBpZiAoZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgICAgICBjZG9tYWluID0gJzsgZG9tYWluPScgKyBkb21haW5fb3ZlcnJpZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNfY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gZXh0cmFjdF9kb21haW4oZG9jdW1lbnQkMS5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgICAgICBjZG9tYWluID0gZG9tYWluID8gJzsgZG9tYWluPS4nICsgZG9tYWluIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Vjb25kcykge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKHNlY29uZHMgKiAxMDAwKSk7XG4gICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b0dNVFN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzX2Nyb3NzX3NpdGUpIHtcbiAgICAgICAgICAgIGlzX3NlY3VyZSA9IHRydWU7XG4gICAgICAgICAgICBzZWN1cmUgPSAnOyBTYW1lU2l0ZT1Ob25lJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfc2VjdXJlKSB7XG4gICAgICAgICAgICBzZWN1cmUgKz0gJzsgc2VjdXJlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50JDEuY29va2llID0gbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgKyBleHBpcmVzICsgJzsgcGF0aD0vJyArIGNkb21haW4gKyBzZWN1cmU7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUsIGRheXMsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgaXNfc2VjdXJlLCBpc19jcm9zc19zaXRlLCBkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIGNkb21haW4gPSAnJywgZXhwaXJlcyA9ICcnLCBzZWN1cmUgPSAnJztcblxuICAgICAgICBpZiAoZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgICAgICBjZG9tYWluID0gJzsgZG9tYWluPScgKyBkb21haW5fb3ZlcnJpZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNfY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gZXh0cmFjdF9kb21haW4oZG9jdW1lbnQkMS5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgICAgICBjZG9tYWluID0gZG9tYWluID8gJzsgZG9tYWluPS4nICsgZG9tYWluIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKGRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b0dNVFN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzX2Nyb3NzX3NpdGUpIHtcbiAgICAgICAgICAgIGlzX3NlY3VyZSA9IHRydWU7XG4gICAgICAgICAgICBzZWN1cmUgPSAnOyBTYW1lU2l0ZT1Ob25lJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfc2VjdXJlKSB7XG4gICAgICAgICAgICBzZWN1cmUgKz0gJzsgc2VjdXJlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdfY29va2llX3ZhbCA9IG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpICsgZXhwaXJlcyArICc7IHBhdGg9LycgKyBjZG9tYWluICsgc2VjdXJlO1xuICAgICAgICBkb2N1bWVudCQxLmNvb2tpZSA9IG5ld19jb29raWVfdmFsO1xuICAgICAgICByZXR1cm4gbmV3X2Nvb2tpZV92YWw7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24obmFtZSwgaXNfY3Jvc3Nfc3ViZG9tYWluLCBkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgXy5jb29raWUuc2V0KG5hbWUsICcnLCAtMSwgaXNfY3Jvc3Nfc3ViZG9tYWluLCBmYWxzZSwgZmFsc2UsIGRvbWFpbl9vdmVycmlkZSk7XG4gICAgfVxufTtcblxudmFyIF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgPSBudWxsO1xudmFyIGxvY2FsU3RvcmFnZVN1cHBvcnRlZCA9IGZ1bmN0aW9uKHN0b3JhZ2UsIGZvcmNlQ2hlY2spIHtcbiAgICBpZiAoX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCAhPT0gbnVsbCAmJiAhZm9yY2VDaGVjaykge1xuICAgICAgICByZXR1cm4gX2xvY2FsU3RvcmFnZVN1cHBvcnRlZDtcbiAgICB9XG5cbiAgICB2YXIgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBzdG9yYWdlID0gc3RvcmFnZSB8fCB3aW4ubG9jYWxTdG9yYWdlO1xuICAgICAgICB2YXIga2V5ID0gJ19fbXBsc3NfJyArIGNoZWFwX2d1aWQoOCksXG4gICAgICAgICAgICB2YWwgPSAneHl6JztcbiAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsKTtcbiAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXkpICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG59O1xuXG4vLyBfLmxvY2FsU3RvcmFnZVxuXy5sb2NhbFN0b3JhZ2UgPSB7XG4gICAgaXNfc3VwcG9ydGVkOiBmdW5jdGlvbihmb3JjZV9jaGVjaykge1xuICAgICAgICB2YXIgc3VwcG9ydGVkID0gbG9jYWxTdG9yYWdlU3VwcG9ydGVkKG51bGwsIGZvcmNlX2NoZWNrKTtcbiAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignbG9jYWxTdG9yYWdlIHVuc3VwcG9ydGVkOyBmYWxsaW5nIGJhY2sgdG8gY29va2llIHN0b3JlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICB9LFxuXG4gICAgZXJyb3I6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ2xvY2FsU3RvcmFnZSBlcnJvcjogJyArIG1zZyk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbi5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShuYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfLmxvY2FsU3RvcmFnZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIF8uSlNPTkRlY29kZShfLmxvY2FsU3RvcmFnZS5nZXQobmFtZSkpIHx8IHt9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luLmxvY2FsU3RvcmFnZS5zZXRJdGVtKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfLmxvY2FsU3RvcmFnZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKG5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF8ubG9jYWxTdG9yYWdlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5fLnJlZ2lzdGVyX2V2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vIHdyaXR0ZW4gYnkgRGVhbiBFZHdhcmRzLCAyMDA1XG4gICAgLy8gd2l0aCBpbnB1dCBmcm9tIFRpbm8gWmlqZGVsIC0gY3Jpc3BAeHM0YWxsLm5sXG4gICAgLy8gd2l0aCBpbnB1dCBmcm9tIENhcmwgU3ZlcnJlIC0gbWFpbEBjYXJsc3ZlcnJlLmNvbVxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBNaXhwYW5lbFxuICAgIC8vIGh0dHA6Ly9kZWFuLmVkd2FyZHMubmFtZS93ZWJsb2cvMjAwNS8xMC9hZGQtZXZlbnQvXG4gICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTkzMDQ0MFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uKil9IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvbGRTY2hvb2xcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1c2VDYXB0dXJlXG4gICAgICovXG4gICAgdmFyIHJlZ2lzdGVyX2V2ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb2xkU2Nob29sLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdObyB2YWxpZCBlbGVtZW50IHByb3ZpZGVkIHRvIHJlZ2lzdGVyX2V2ZW50Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyICYmICFvbGRTY2hvb2wpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCAhIXVzZUNhcHR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9udHlwZSA9ICdvbicgKyB0eXBlO1xuICAgICAgICAgICAgdmFyIG9sZF9oYW5kbGVyID0gZWxlbWVudFtvbnR5cGVdOyAvLyBjYW4gYmUgdW5kZWZpbmVkXG4gICAgICAgICAgICBlbGVtZW50W29udHlwZV0gPSBtYWtlSGFuZGxlcihlbGVtZW50LCBoYW5kbGVyLCBvbGRfaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZUhhbmRsZXIoZWxlbWVudCwgbmV3X2hhbmRsZXIsIG9sZF9oYW5kbGVycykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IGV2ZW50IHx8IGZpeEV2ZW50KHdpbi5ldmVudCk7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgYmFzaWNhbGx5IGhhcHBlbnMgaW4gZmlyZWZveCB3aGVuZXZlciBhbm90aGVyIHNjcmlwdFxuICAgICAgICAgICAgLy8gb3ZlcndyaXRlcyB0aGUgb25sb2FkIGNhbGxiYWNrIGFuZCBkb2Vzbid0IHBhc3MgdGhlIGV2ZW50XG4gICAgICAgICAgICAvLyBvYmplY3QgdG8gcHJldmlvdXNseSBkZWZpbmVkIGNhbGxiYWNrcy4gIEFsbCB0aGUgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIHRoYXQgZG9uJ3QgZGVmaW5lIHdpbmRvdy5ldmVudCBpbXBsZW1lbnQgYWRkRXZlbnRMaXN0ZW5lclxuICAgICAgICAgICAgLy8gc28gdGhlIGRvbV9sb2FkZWQgaGFuZGxlciB3aWxsIHN0aWxsIGJlIGZpcmVkIGFzIHVzdWFsLlxuICAgICAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZF9yZXN1bHQsIG5ld19yZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2xkX2hhbmRsZXJzKSkge1xuICAgICAgICAgICAgICAgIG9sZF9yZXN1bHQgPSBvbGRfaGFuZGxlcnMoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3X3Jlc3VsdCA9IG5ld19oYW5kbGVyLmNhbGwoZWxlbWVudCwgZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAoKGZhbHNlID09PSBvbGRfcmVzdWx0KSB8fCAoZmFsc2UgPT09IG5ld19yZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZpeEV2ZW50LnByZXZlbnREZWZhdWx0O1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZml4RXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgZml4RXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH07XG4gICAgZml4RXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlZ2lzdGVyX2V2ZW50O1xufSkoKTtcblxuXG52YXIgVE9LRU5fTUFUQ0hfUkVHRVggPSBuZXcgUmVnRXhwKCdeKFxcXFx3KilcXFxcWyhcXFxcdyspKFs9flxcXFx8XFxcXF5cXFxcJFxcXFwqXT8pPT9cIj8oW15cXFxcXVwiXSopXCI/XFxcXF0kJyk7XG5cbl8uZG9tX3F1ZXJ5ID0gKGZ1bmN0aW9uKCkge1xuICAgIC8qIGRvY3VtZW50LmdldEVsZW1lbnRzQnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICAtIHJldHVybnMgYW4gYXJyYXkgb2YgZWxlbWVudCBvYmplY3RzIGZyb20gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICBtYXRjaGluZyB0aGUgQ1NTIHNlbGVjdG9yLiBTZWxlY3RvcnMgY2FuIGNvbnRhaW4gZWxlbWVudCBuYW1lcyxcbiAgICBjbGFzcyBuYW1lcyBhbmQgaWRzIGFuZCBjYW4gYmUgbmVzdGVkLiBGb3IgZXhhbXBsZTpcblxuICAgIGVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVNlbGVjdG9yKCdkaXYjbWFpbiBwIGEuZXh0ZXJuYWwnKVxuXG4gICAgV2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgYWxsICdhJyBlbGVtZW50cyB3aXRoICdleHRlcm5hbCcgaW4gdGhlaXJcbiAgICBjbGFzcyBhdHRyaWJ1dGUgdGhhdCBhcmUgY29udGFpbmVkIGluc2lkZSAncCcgZWxlbWVudHMgdGhhdCBhcmVcbiAgICBjb250YWluZWQgaW5zaWRlIHRoZSAnZGl2JyBlbGVtZW50IHdoaWNoIGhhcyBpZD1cIm1haW5cIlxuXG4gICAgTmV3IGluIHZlcnNpb24gMC40OiBTdXBwb3J0IGZvciBDU1MyIGFuZCBDU1MzIGF0dHJpYnV0ZSBzZWxlY3RvcnM6XG4gICAgU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cbiAgICBWZXJzaW9uIDAuNCAtIFNpbW9uIFdpbGxpc29uLCBNYXJjaCAyNXRoIDIwMDNcbiAgICAtLSBXb3JrcyBpbiBQaG9lbml4IDAuNSwgTW96aWxsYSAxLjMsIE9wZXJhIDcsIEludGVybmV0IEV4cGxvcmVyIDYsIEludGVybmV0IEV4cGxvcmVyIDUgb24gV2luZG93c1xuICAgIC0tIE9wZXJhIDcgZmFpbHNcblxuICAgIFZlcnNpb24gMC41IC0gQ2FybCBTdmVycmUsIEphbiA3dGggMjAxM1xuICAgIC0tIE5vdyB1c2VzIGpRdWVyeS1lc3F1ZSBgaGFzQ2xhc3NgIGZvciB0ZXN0aW5nIGNsYXNzIG5hbWVcbiAgICBlcXVhbGl0eS4gIFRoaXMgZml4ZXMgYSBidWcgcmVsYXRlZCB0byAnLScgY2hhcmFjdGVycyBiZWluZ1xuICAgIGNvbnNpZGVyZWQgbm90IHBhcnQgb2YgYSAnd29yZCcgaW4gcmVnZXguXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldEFsbENoaWxkcmVuKGUpIHtcbiAgICAgICAgLy8gUmV0dXJucyBhbGwgY2hpbGRyZW4gb2YgZWxlbWVudC4gV29ya2Fyb3VuZCByZXF1aXJlZCBmb3IgSUU1L1dpbmRvd3MuIFVnaC5cbiAgICAgICAgcmV0dXJuIGUuYWxsID8gZS5hbGwgOiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyk7XG4gICAgfVxuXG4gICAgdmFyIGJhZF93aGl0ZXNwYWNlID0gL1tcXHRcXHJcXG5dL2c7XG5cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtLCBzZWxlY3Rvcikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJyAnICsgc2VsZWN0b3IgKyAnICc7XG4gICAgICAgIHJldHVybiAoKCcgJyArIGVsZW0uY2xhc3NOYW1lICsgJyAnKS5yZXBsYWNlKGJhZF93aGl0ZXNwYWNlLCAnICcpLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50c0J5U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBmYWlsIGdyYWNlZnVsbHkgaW4gbGVzc2VyIGJyb3dzZXJzXG4gICAgICAgIGlmICghZG9jdW1lbnQkMS5nZXRFbGVtZW50c0J5VGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwbGl0IHNlbGVjdG9yIGluIHRvIHRva2Vuc1xuICAgICAgICB2YXIgdG9rZW5zID0gc2VsZWN0b3Iuc3BsaXQoJyAnKTtcbiAgICAgICAgdmFyIHRva2VuLCBiaXRzLCB0YWdOYW1lLCBmb3VuZCwgZm91bmRDb3VudCwgaSwgaiwgaywgZWxlbWVudHMsIGN1cnJlbnRDb250ZXh0SW5kZXg7XG4gICAgICAgIHZhciBjdXJyZW50Q29udGV4dCA9IFtkb2N1bWVudCQxXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV0ucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgICAgICBpZiAodG9rZW4uaW5kZXhPZignIycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBpcyBhbiBJRCBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGJpdHMgPSB0b2tlbi5zcGxpdCgnIycpO1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSBiaXRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGJpdHNbMV07XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudCQxLmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQgfHwgKHRhZ05hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9IHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgbm90IGZvdW5kIG9yIHRhZyB3aXRoIHRoYXQgSUQgbm90IGZvdW5kLCByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXQgY3VycmVudENvbnRleHQgdG8gY29udGFpbiBqdXN0IHRoaXMgZWxlbWVudFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW2VsZW1lbnRdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRvIG5leHQgdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFRva2VuIGNvbnRhaW5zIGEgY2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBiaXRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gYml0c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gYml0c1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZSA9ICcqJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR2V0IGVsZW1lbnRzIG1hdGNoaW5nIHRhZywgZmlsdGVyIHRoZW0gZm9yIGNsYXNzIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgZm91bmQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudENvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGdldEFsbENoaWxkcmVuKGN1cnJlbnRDb250ZXh0W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gY3VycmVudENvbnRleHRbal0uZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFtmb3VuZENvdW50KytdID0gZWxlbWVudHNba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZm91bmQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kW2pdLmNsYXNzTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgXy5pc1N0cmluZyhmb3VuZFtqXS5jbGFzc05hbWUpICYmIC8vIHNvbWUgU1ZHIGVsZW1lbnRzIGhhdmUgY2xhc3NOYW1lcyB3aGljaCBhcmUgbm90IHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NsYXNzKGZvdW5kW2pdLCBjbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRbY3VycmVudENvbnRleHRJbmRleCsrXSA9IGZvdW5kW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRvIG5leHQgdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvZGUgdG8gZGVhbCB3aXRoIGF0dHJpYnV0ZSBzZWxlY3RvcnNcbiAgICAgICAgICAgIHZhciB0b2tlbl9tYXRjaCA9IHRva2VuLm1hdGNoKFRPS0VOX01BVENIX1JFR0VYKTtcbiAgICAgICAgICAgIGlmICh0b2tlbl9tYXRjaCkge1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSB0b2tlbl9tYXRjaFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSB0b2tlbl9tYXRjaFsyXTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck9wZXJhdG9yID0gdG9rZW5fbWF0Y2hbM107XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHRva2VuX21hdGNoWzRdO1xuICAgICAgICAgICAgICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lID0gJyonO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHcmFiIGFsbCBvZiB0aGUgdGFnTmFtZSBlbGVtZW50cyB3aXRoaW4gY3VycmVudCBjb250ZXh0XG4gICAgICAgICAgICAgICAgZm91bmQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudENvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGdldEFsbENoaWxkcmVuKGN1cnJlbnRDb250ZXh0W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gY3VycmVudENvbnRleHRbal0uZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFtmb3VuZENvdW50KytdID0gZWxlbWVudHNba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tGdW5jdGlvbjsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgdG8gZmlsdGVyIHRoZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXR0ck9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz0nOiAvLyBFcXVhbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSA9PSBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd+JzogLy8gTWF0Y2ggb25lIG9mIHNwYWNlIHNlcGVyYXRlZCB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5tYXRjaChuZXcgUmVnRXhwKCdcXFxcYicgKyBhdHRyVmFsdWUgKyAnXFxcXGInKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd8JzogLy8gTWF0Y2ggc3RhcnQgd2l0aCB2YWx1ZSBmb2xsb3dlZCBieSBvcHRpb25hbCBoeXBoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyBhdHRyVmFsdWUgKyAnLT8nKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdeJzogLy8gTWF0Y2ggc3RhcnRzIHdpdGggdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkuaW5kZXhPZihhdHRyVmFsdWUpID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnJCc6IC8vIE1hdGNoIGVuZHMgd2l0aCB2YWx1ZSAtIGZhaWxzIHdpdGggXCJXYXJuaW5nXCIgaW4gT3BlcmEgN1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5sYXN0SW5kZXhPZihhdHRyVmFsdWUpID09IGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5sZW5ndGggLSBhdHRyVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6IC8vIE1hdGNoIGVuZHMgd2l0aCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5pbmRleE9mKGF0dHJWYWx1ZSkgPiAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IHRlc3QgZm9yIGV4aXN0ZW5jZSBvZiBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0Z1bmN0aW9uKGZvdW5kW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRbY3VycmVudENvbnRleHRJbmRleCsrXSA9IGZvdW5kW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFsZXJ0KCdBdHRyaWJ1dGUgU2VsZWN0b3I6ICcrdGFnTmFtZSsnICcrYXR0ck5hbWUrJyAnK2F0dHJPcGVyYXRvcisnICcrYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdG9rZW4gaXMgSlVTVCBhbiBlbGVtZW50IChub3QgYSBjbGFzcyBvciBJRCBzZWxlY3RvcilcbiAgICAgICAgICAgIHRhZ05hbWUgPSB0b2tlbjtcbiAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICBmb3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyZW50Q29udGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gY3VycmVudENvbnRleHRbal0uZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kW2ZvdW5kQ291bnQrK10gPSBlbGVtZW50c1trXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgaWYgKF8uaXNFbGVtZW50KHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtxdWVyeV07XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChxdWVyeSkgJiYgIV8uaXNVbmRlZmluZWQocXVlcnkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVsZW1lbnRzQnlTZWxlY3Rvci5jYWxsKHRoaXMsIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG52YXIgQ0FNUEFJR05fS0VZV09SRFMgPSBbJ3V0bV9zb3VyY2UnLCAndXRtX21lZGl1bScsICd1dG1fY2FtcGFpZ24nLCAndXRtX2NvbnRlbnQnLCAndXRtX3Rlcm0nLCAndXRtX2lkJywgJ3V0bV9zb3VyY2VfcGxhdGZvcm0nLCd1dG1fY2FtcGFpZ25faWQnLCAndXRtX2NyZWF0aXZlX2Zvcm1hdCcsICd1dG1fbWFya2V0aW5nX3RhY3RpYyddO1xudmFyIENMSUNLX0lEUyA9IFsnZGNsaWQnLCAnZmJjbGlkJywgJ2djbGlkJywgJ2tvX2NsaWNrX2lkJywgJ2xpX2ZhdF9pZCcsICdtc2Nsa2lkJywgJ3NjY2lkJywgJ3R0Y2xpZCcsICd0d2NsaWQnLCAnd2JyYWlkJ107XG5cbl8uaW5mbyA9IHtcbiAgICBjYW1wYWlnblBhcmFtczogZnVuY3Rpb24oZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICB2YXIga3cgPSAnJyxcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICBfLmVhY2goQ0FNUEFJR05fS0VZV09SRFMsIGZ1bmN0aW9uKGt3a2V5KSB7XG4gICAgICAgICAgICBrdyA9IF8uZ2V0UXVlcnlQYXJhbShkb2N1bWVudCQxLlVSTCwga3drZXkpO1xuICAgICAgICAgICAgaWYgKGt3Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trd2tleV0gPSBrdztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2t3a2V5XSA9IGRlZmF1bHRfdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIGNsaWNrUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlkID0gJycsXG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgXy5lYWNoKENMSUNLX0lEUywgZnVuY3Rpb24oaWRrZXkpIHtcbiAgICAgICAgICAgIGlkID0gXy5nZXRRdWVyeVBhcmFtKGRvY3VtZW50JDEuVVJMLCBpZGtleSk7XG4gICAgICAgICAgICBpZiAoaWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2lka2V5XSA9IGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG5cbiAgICBtYXJrZXRpbmdQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5leHRlbmQoXy5pbmZvLmNhbXBhaWduUGFyYW1zKCksIF8uaW5mby5jbGlja1BhcmFtcygpKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoRW5naW5lOiBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgICAgICBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopZ29vZ2xlLihbXi8/XSopJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnZ29vZ2xlJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKiliaW5nLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2JpbmcnO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKXlhaG9vLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3lhaG9vJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKilkdWNrZHVja2dvLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2R1Y2tkdWNrZ28nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VhcmNoSW5mbzogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgdmFyIHNlYXJjaCA9IF8uaW5mby5zZWFyY2hFbmdpbmUocmVmZXJyZXIpLFxuICAgICAgICAgICAgcGFyYW0gPSAoc2VhcmNoICE9ICd5YWhvbycpID8gJ3EnIDogJ3AnLFxuICAgICAgICAgICAgcmV0ID0ge307XG5cbiAgICAgICAgaWYgKHNlYXJjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0Wyckc2VhcmNoX2VuZ2luZSddID0gc2VhcmNoO1xuXG4gICAgICAgICAgICB2YXIga2V5d29yZCA9IF8uZ2V0UXVlcnlQYXJhbShyZWZlcnJlciwgcGFyYW0pO1xuICAgICAgICAgICAgaWYgKGtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0WydtcF9rZXl3b3JkJ10gPSBrZXl3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoaWNoIGJyb3dzZXIgaXMgcnVubmluZyB0aGlzIHNjcmlwdC5cbiAgICAgKiBUaGUgb3JkZXIgb2YgdGhlIGNoZWNrcyBhcmUgaW1wb3J0YW50IHNpbmNlIG1hbnkgdXNlciBhZ2VudHNcbiAgICAgKiBpbmNsdWRlIGtleSB3b3JkcyB1c2VkIGluIGxhdGVyIGNoZWNrcy5cbiAgICAgKi9cbiAgICBicm93c2VyOiBmdW5jdGlvbih1c2VyX2FnZW50LCB2ZW5kb3IsIG9wZXJhKSB7XG4gICAgICAgIHZlbmRvciA9IHZlbmRvciB8fCAnJzsgLy8gdmVuZG9yIGlzIHVuZGVmaW5lZCBmb3IgYXQgbGVhc3QgSUU5XG4gICAgICAgIGlmIChvcGVyYSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICcgT1BSLycpKSB7XG4gICAgICAgICAgICBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnTWluaScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdPcGVyYSBNaW5pJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnT3BlcmEnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQmxhY2tCZXJyeSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnSUVNb2JpbGUnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdXUERlc2t0b3AnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlcm5ldCBFeHBsb3JlciBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1NhbXN1bmdCcm93c2VyLycpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5zYW1zdW5nLmNvbS9pbnRlcm5ldC91c2VyLWFnZW50LXN0cmluZy1mb3JtYXRcbiAgICAgICAgICAgIHJldHVybiAnU2Ftc3VuZyBJbnRlcm5ldCc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRWRnZScpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0VkZy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdNaWNyb3NvZnQgRWRnZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRkJJT1MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGYWNlYm9vayBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0Nocm9tZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnQ3JpT1MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUgaU9TJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdVQ1dFQicpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1VDQnJvd3NlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1VDIEJyb3dzZXInO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0Z4aU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmlyZWZveCBpT1MnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModmVuZG9yLCAnQXBwbGUnKSkge1xuICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01vYmlsZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNb2JpbGUgU2FmYXJpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnU2FmYXJpJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdBbmRyb2lkJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQW5kcm9pZCBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0tvbnF1ZXJvcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0tvbnF1ZXJvcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRmlyZWZveCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZpcmVmb3gnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01TSUUnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdUcmlkZW50LycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ludGVybmV0IEV4cGxvcmVyJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdHZWNrbycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01vemlsbGEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGljaCBicm93c2VyIHZlcnNpb24gaXMgcnVubmluZyB0aGlzIHNjcmlwdCxcbiAgICAgKiBwYXJzaW5nIG1ham9yIGFuZCBtaW5vciB2ZXJzaW9uIChlLmcuLCA0Mi4xKS4gVXNlciBhZ2VudCBzdHJpbmdzIGZyb206XG4gICAgICogaHR0cDovL3d3dy51c2VyYWdlbnRzdHJpbmcuY29tL3BhZ2VzL3VzZXJhZ2VudHN0cmluZy5waHBcbiAgICAgKi9cbiAgICBicm93c2VyVmVyc2lvbjogZnVuY3Rpb24odXNlckFnZW50LCB2ZW5kb3IsIG9wZXJhKSB7XG4gICAgICAgIHZhciBicm93c2VyID0gXy5pbmZvLmJyb3dzZXIodXNlckFnZW50LCB2ZW5kb3IsIG9wZXJhKTtcbiAgICAgICAgdmFyIHZlcnNpb25SZWdleHMgPSB7XG4gICAgICAgICAgICAnSW50ZXJuZXQgRXhwbG9yZXIgTW9iaWxlJzogL3J2OihcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ01pY3Jvc29mdCBFZGdlJzogL0VkZ2U/XFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQ2hyb21lJzogL0Nocm9tZVxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0Nocm9tZSBpT1MnOiAvQ3JpT1NcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdVQyBCcm93c2VyJyA6IC8oVUNCcm93c2VyfFVDV0VCKVxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ1NhZmFyaSc6IC9WZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnTW9iaWxlIFNhZmFyaSc6IC9WZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnT3BlcmEnOiAvKE9wZXJhfE9QUilcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdGaXJlZm94JzogL0ZpcmVmb3hcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdGaXJlZm94IGlPUyc6IC9GeGlPU1xcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0tvbnF1ZXJvcic6IC9Lb25xdWVyb3I6KFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQmxhY2tCZXJyeSc6IC9CbGFja0JlcnJ5IChcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0FuZHJvaWQgTW9iaWxlJzogL2FuZHJvaWRcXHMoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdTYW1zdW5nIEludGVybmV0JzogL1NhbXN1bmdCcm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnSW50ZXJuZXQgRXhwbG9yZXInOiAvKHJ2OnxNU0lFICkoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdNb3ppbGxhJzogL3J2OihcXGQrKFxcLlxcZCspPykvXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZWdleCA9IHZlcnNpb25SZWdleHNbYnJvd3Nlcl07XG4gICAgICAgIGlmIChyZWdleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHVzZXJBZ2VudC5tYXRjaChyZWdleCk7XG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDJdKTtcbiAgICB9LFxuXG4gICAgb3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IHVzZXJBZ2VudDtcbiAgICAgICAgaWYgKC9XaW5kb3dzL2kudGVzdChhKSkge1xuICAgICAgICAgICAgaWYgKC9QaG9uZS8udGVzdChhKSB8fCAvV1BEZXNrdG9wLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdXaW5kb3dzIFBob25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnV2luZG93cyc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhpUGhvbmV8aVBhZHxpUG9kKS8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdpT1MnO1xuICAgICAgICB9IGVsc2UgaWYgKC9BbmRyb2lkLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQmxhY2tCZXJyeSc7XG4gICAgICAgIH0gZWxzZSBpZiAoL01hYy9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWFjIE9TIFgnO1xuICAgICAgICB9IGVsc2UgaWYgKC9MaW51eC8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdMaW51eCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL0NyT1MvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lIE9TJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXZpY2U6IGZ1bmN0aW9uKHVzZXJfYWdlbnQpIHtcbiAgICAgICAgaWYgKC9XaW5kb3dzIFBob25lL2kudGVzdCh1c2VyX2FnZW50KSB8fCAvV1BEZXNrdG9wLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MgUGhvbmUnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUGFkLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQYWQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUG9kLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQb2QgVG91Y2gnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUGhvbmUvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaVBob25lJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKC9BbmRyb2lkLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlZmVycmluZ0RvbWFpbjogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gcmVmZXJyZXIuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRbMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICBjdXJyZW50VXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbi5sb2NhdGlvbi5ocmVmO1xuICAgIH0sXG5cbiAgICBwcm9wZXJ0aWVzOiBmdW5jdGlvbihleHRyYV9wcm9wcykge1xuICAgICAgICBpZiAodHlwZW9mIGV4dHJhX3Byb3BzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZXh0cmFfcHJvcHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXy5leHRlbmQoXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICckb3MnOiBfLmluZm8ub3MoKSxcbiAgICAgICAgICAgICckYnJvd3Nlcic6IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpLFxuICAgICAgICAgICAgJyRyZWZlcnJlcic6IGRvY3VtZW50JDEucmVmZXJyZXIsXG4gICAgICAgICAgICAnJHJlZmVycmluZ19kb21haW4nOiBfLmluZm8ucmVmZXJyaW5nRG9tYWluKGRvY3VtZW50JDEucmVmZXJyZXIpLFxuICAgICAgICAgICAgJyRkZXZpY2UnOiBfLmluZm8uZGV2aWNlKHVzZXJBZ2VudClcbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgICckY3VycmVudF91cmwnOiBfLmluZm8uY3VycmVudFVybCgpLFxuICAgICAgICAgICAgJyRicm93c2VyX3ZlcnNpb24nOiBfLmluZm8uYnJvd3NlclZlcnNpb24odXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSksXG4gICAgICAgICAgICAnJHNjcmVlbl9oZWlnaHQnOiBzY3JlZW4uaGVpZ2h0LFxuICAgICAgICAgICAgJyRzY3JlZW5fd2lkdGgnOiBzY3JlZW4ud2lkdGgsXG4gICAgICAgICAgICAnbXBfbGliJzogJ3dlYicsXG4gICAgICAgICAgICAnJGxpYl92ZXJzaW9uJzogQ29uZmlnLkxJQl9WRVJTSU9OLFxuICAgICAgICAgICAgJyRpbnNlcnRfaWQnOiBjaGVhcF9ndWlkKCksXG4gICAgICAgICAgICAndGltZSc6IF8udGltZXN0YW1wKCkgLyAxMDAwIC8vIGVwb2NoIHRpbWUgaW4gc2Vjb25kc1xuICAgICAgICB9LCBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoZXh0cmFfcHJvcHMpKTtcbiAgICB9LFxuXG4gICAgcGVvcGxlX3Byb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5leHRlbmQoXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICckb3MnOiBfLmluZm8ub3MoKSxcbiAgICAgICAgICAgICckYnJvd3Nlcic6IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICAnJGJyb3dzZXJfdmVyc2lvbic6IF8uaW5mby5icm93c2VyVmVyc2lvbih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbXBQYWdlVmlld1Byb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICdjdXJyZW50X3BhZ2VfdGl0bGUnOiBkb2N1bWVudCQxLnRpdGxlLFxuICAgICAgICAgICAgJ2N1cnJlbnRfZG9tYWluJzogd2luLmxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3BhdGgnOiB3aW4ubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgICAnY3VycmVudF91cmxfcHJvdG9jb2wnOiB3aW4ubG9jYXRpb24ucHJvdG9jb2wsXG4gICAgICAgICAgICAnY3VycmVudF91cmxfc2VhcmNoJzogd2luLmxvY2F0aW9uLnNlYXJjaFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG52YXIgY2hlYXBfZ3VpZCA9IGZ1bmN0aW9uKG1heGxlbikge1xuICAgIHZhciBndWlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG4gICAgcmV0dXJuIG1heGxlbiA/IGd1aWQuc3Vic3RyaW5nKDAsIG1heGxlbikgOiBndWlkO1xufTtcblxuLy8gbmFpdmUgd2F5IHRvIGV4dHJhY3QgZG9tYWluIG5hbWUgKGV4YW1wbGUuY29tKSBmcm9tIGZ1bGwgaG9zdG5hbWUgKG15LnN1Yi5leGFtcGxlLmNvbSlcbnZhciBTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYID0gL1thLXowLTldW2EtejAtOS1dKlxcLlthLXpdKyQvaTtcbi8vIHRoaXMgbmV4dCBvbmUgYXR0ZW1wdHMgdG8gYWNjb3VudCBmb3Igc29tZSBjY1NMRHMsIGUuZy4gZXh0cmFjdGluZyBveGZvcmQuYWMudWsgZnJvbSB3d3cub3hmb3JkLmFjLnVrXG52YXIgRE9NQUlOX01BVENIX1JFR0VYID0gL1thLXowLTldW2EtejAtOS1dK1xcLlthLXouXXsyLDZ9JC9pO1xuLyoqXG4gKiBBdHRlbXB0cyB0byBleHRyYWN0IG1haW4gZG9tYWluIG5hbWUgZnJvbSBmdWxsIGhvc3RuYW1lLCB1c2luZyBhIGZldyBibHVudCBoZXVyaXN0aWNzLiBGb3JcbiAqIGNvbW1vbiBUTERzIGxpa2UgLmNvbS8ub3JnIHRoYXQgYWx3YXlzIGhhdmUgYSBzaW1wbGUgU0xELlRMRCBzdHJ1Y3R1cmUgKGV4YW1wbGUuY29tKSwgd2VcbiAqIHNpbXBseSBleHRyYWN0IHRoZSBsYXN0IHR3byAuLXNlcGFyYXRlZCBwYXJ0cyBvZiB0aGUgaG9zdG5hbWUgKFNJTVBMRV9ET01BSU5fTUFUQ0hfUkVHRVgpLlxuICogRm9yIG90aGVycywgd2UgYXR0ZW1wdCB0byBhY2NvdW50IGZvciBzaG9ydCBjY1NMRCtUTEQgY29tYm9zICguYWMudWspIHdpdGggdGhlIGxlZ2FjeVxuICogRE9NQUlOX01BVENIX1JFR0VYIChrZXB0IHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgTWl4cGFuZWxcbiAqIGludGVncmF0aW9ucykuIFRoZSBvbmx5IF9yZWxpYWJsZV8gd2F5IHRvIGV4dHJhY3QgZG9tYWluIGZyb20gaG9zdG5hbWUgaXMgd2l0aCBhbiB1cC10by1kYXRlXG4gKiBsaXN0IGxpa2UgYXQgaHR0cHM6Ly9wdWJsaWNzdWZmaXgub3JnLyBzbyBmb3IgY2FzZXMgdGhhdCB0aGlzIGhlbHBlciBmYWlscyBhdCwgdGhlIFNES1xuICogb2ZmZXJzIHRoZSAnY29va2llX2RvbWFpbicgY29uZmlnIG9wdGlvbiB0byBzZXQgaXQgZXhwbGljaXRseS5cbiAqIEBleGFtcGxlXG4gKiBleHRyYWN0X2RvbWFpbignbXkuc3ViLmV4YW1wbGUuY29tJylcbiAqIC8vICdleGFtcGxlLmNvbSdcbiAqL1xudmFyIGV4dHJhY3RfZG9tYWluID0gZnVuY3Rpb24oaG9zdG5hbWUpIHtcbiAgICB2YXIgZG9tYWluX3JlZ2V4ID0gRE9NQUlOX01BVENIX1JFR0VYO1xuICAgIHZhciBwYXJ0cyA9IGhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgdmFyIHRsZCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0bGQubGVuZ3RoID4gNCB8fCB0bGQgPT09ICdjb20nIHx8IHRsZCA9PT0gJ29yZycpIHtcbiAgICAgICAgZG9tYWluX3JlZ2V4ID0gU0lNUExFX0RPTUFJTl9NQVRDSF9SRUdFWDtcbiAgICB9XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0bmFtZS5tYXRjaChkb21haW5fcmVnZXgpO1xuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1swXSA6ICcnO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHdlIGhhdmUgbmV0d29yayBjb25uZWN0aW9uLiBkZWZhdWx0IHRvIHRydWUgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBuYXZpZ2F0b3Iub25MaW5lIChJRSlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgaXNPbmxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb25MaW5lID0gd2luLm5hdmlnYXRvclsnb25MaW5lJ107XG4gICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob25MaW5lKSB8fCBvbkxpbmU7XG59O1xuXG52YXIgSlNPTlN0cmluZ2lmeSA9IG51bGwsIEpTT05QYXJzZSA9IG51bGw7XG5pZiAodHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgSlNPTlN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuICAgIEpTT05QYXJzZSA9IEpTT04ucGFyc2U7XG59XG5KU09OU3RyaW5naWZ5ID0gSlNPTlN0cmluZ2lmeSB8fCBfLkpTT05FbmNvZGU7XG5KU09OUGFyc2UgPSBKU09OUGFyc2UgfHwgXy5KU09ORGVjb2RlO1xuXG4vLyBFWFBPUlRTIChmb3IgY2xvc3VyZSBjb21waWxlcilcbl9bJ3RvQXJyYXknXSAgICAgICAgICAgICAgICA9IF8udG9BcnJheTtcbl9bJ2lzT2JqZWN0J10gICAgICAgICAgICAgICA9IF8uaXNPYmplY3Q7XG5fWydKU09ORW5jb2RlJ10gICAgICAgICAgICAgPSBfLkpTT05FbmNvZGU7XG5fWydKU09ORGVjb2RlJ10gICAgICAgICAgICAgPSBfLkpTT05EZWNvZGU7XG5fWydpc0Jsb2NrZWRVQSddICAgICAgICAgICAgPSBfLmlzQmxvY2tlZFVBO1xuX1snaXNFbXB0eU9iamVjdCddICAgICAgICAgID0gXy5pc0VtcHR5T2JqZWN0O1xuX1snaW5mbyddICAgICAgICAgICAgICAgICAgID0gXy5pbmZvO1xuX1snaW5mbyddWydkZXZpY2UnXSAgICAgICAgID0gXy5pbmZvLmRldmljZTtcbl9bJ2luZm8nXVsnYnJvd3NlciddICAgICAgICA9IF8uaW5mby5icm93c2VyO1xuX1snaW5mbyddWydicm93c2VyVmVyc2lvbiddID0gXy5pbmZvLmJyb3dzZXJWZXJzaW9uO1xuX1snaW5mbyddWydwcm9wZXJ0aWVzJ10gICAgID0gXy5pbmZvLnByb3BlcnRpZXM7XG5fWydOUE8nXSAgICAgICAgICAgICAgICAgICAgPSBOcG9Qcm9taXNlO1xuXG4vKipcbiAqIEdEUFIgdXRpbHNcbiAqXG4gKiBUaGUgR2VuZXJhbCBEYXRhIFByb3RlY3Rpb24gUmVndWxhdGlvbiAoR0RQUikgaXMgYSByZWd1bGF0aW9uIGluIEVVIGxhdyBvbiBkYXRhIHByb3RlY3Rpb25cbiAqIGFuZCBwcml2YWN5IGZvciBhbGwgaW5kaXZpZHVhbHMgd2l0aGluIHRoZSBFdXJvcGVhbiBVbmlvbi4gSXQgYWRkcmVzc2VzIHRoZSBleHBvcnQgb2YgcGVyc29uYWxcbiAqIGRhdGEgb3V0c2lkZSB0aGUgRVUuIFRoZSBHRFBSIGFpbXMgcHJpbWFyaWx5IHRvIGdpdmUgY29udHJvbCBiYWNrIHRvIGNpdGl6ZW5zIGFuZCByZXNpZGVudHNcbiAqIG92ZXIgdGhlaXIgcGVyc29uYWwgZGF0YSBhbmQgdG8gc2ltcGxpZnkgdGhlIHJlZ3VsYXRvcnkgZW52aXJvbm1lbnQgZm9yIGludGVybmF0aW9uYWwgYnVzaW5lc3NcbiAqIGJ5IHVuaWZ5aW5nIHRoZSByZWd1bGF0aW9uIHdpdGhpbiB0aGUgRVUuXG4gKlxuICogVGhpcyBzZXQgb2YgdXRpbGl0aWVzIGlzIGludGVuZGVkIHRvIGVuYWJsZSBvcHQgaW4vb3V0IGZ1bmN0aW9uYWxpdHkgaW4gdGhlIE1peHBhbmVsIEpTIFNESy5cbiAqIFRoZXNlIGZ1bmN0aW9ucyBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBTREsgYW5kIGFyZSBub3QgaW50ZW5kZWQgdG8gYmUgcHVibGljbHkgZXhwb3NlZC5cbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdXNlZCB0byB0cmFjayBhIE1peHBhbmVsIGV2ZW50IChlLmcuIE1peHBhbmVsTGliLnRyYWNrKVxuICogQGNhbGxiYWNrIHRyYWNrRnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC4gVGhpcyBjYW4gYmUgYW55dGhpbmcgdGhlIHVzZXIgZG9lcyAtICdCdXR0b24gQ2xpY2snLCAnU2lnbiBVcCcsICdJdGVtIFB1cmNoYXNlZCcsIGV0Yy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gQSBzZXQgb2YgcHJvcGVydGllcyB0byBpbmNsdWRlIHdpdGggdGhlIGV2ZW50IHlvdSdyZSBzZW5kaW5nLiBUaGVzZSBkZXNjcmliZSB0aGUgdXNlciB3aG8gZGlkIHRoZSBldmVudCBvciBkZXRhaWxzIGFib3V0IHRoZSBldmVudCBpdHNlbGYuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICovXG5cbi8qKiBQdWJsaWMgKiovXG5cbnZhciBHRFBSX0RFRkFVTFRfUEVSU0lTVEVOQ0VfUFJFRklYID0gJ19fbXBfb3B0X2luX291dF8nO1xuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3RyYWNrRnVuY3Rpb259IFtvcHRpb25zLnRyYWNrXSAtIGZ1bmN0aW9uIHVzZWQgZm9yIHRyYWNraW5nIGEgTWl4cGFuZWwgZXZlbnQgdG8gcmVjb3JkIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhY2tFdmVudE5hbWVdIC0gZXZlbnQgbmFtZSB0byBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRyYWNrUHJvcGVydGllc10gLSBzZXQgb2YgcHJvcGVydGllcyB0byBiZSB0cmFja2VkIGFsb25nIHdpdGggdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZURvbWFpbl0gLSBjdXN0b20gY29va2llIGRvbWFpblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1NpdGVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gb3B0SW4odG9rZW4sIG9wdGlvbnMpIHtcbiAgICBfb3B0SW5PdXQodHJ1ZSwgdG9rZW4sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LW91dCBjb29raWUgZXhwaXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZURvbWFpbl0gLSBjdXN0b20gY29va2llIGRvbWFpblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1NpdGVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1vdXQgY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtb3V0IGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBvcHRPdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBfb3B0SW5PdXQoZmFsc2UsIHRva2VuLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBpbiB0byB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gaGFzT3B0ZWRJbih0b2tlbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSA9PT0gJzEnO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlRG50XSAtIGZsYWcgdG8gaWdub3JlIGJyb3dzZXIgRE5UIHNldHRpbmdzIGFuZCBhbHdheXMgcmV0dXJuIGZhbHNlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0IG9mIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBoYXNPcHRlZE91dCh0b2tlbiwgb3B0aW9ucykge1xuICAgIGlmIChfaGFzRG9Ob3RUcmFja0ZsYWdPbihvcHRpb25zKSkge1xuICAgICAgICBjb25zb2xlJDEud2FybignVGhpcyBicm93c2VyIGhhcyBcIkRvIE5vdCBUcmFja1wiIGVuYWJsZWQuIFRoaXMgd2lsbCBwcmV2ZW50IHRoZSBNaXhwYW5lbCBTREsgZnJvbSBzZW5kaW5nIGFueSBkYXRhLiBUbyBpZ25vcmUgdGhlIFwiRG8gTm90IFRyYWNrXCIgYnJvd3NlciBzZXR0aW5nLCBpbml0aWFsaXplIHRoZSBNaXhwYW5lbCBpbnN0YW5jZSB3aXRoIHRoZSBjb25maWcgXCJpZ25vcmVfZG50OiB0cnVlXCInKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBvcHRlZE91dCA9IF9nZXRTdG9yYWdlVmFsdWUodG9rZW4sIG9wdGlvbnMpID09PSAnMCc7XG4gICAgaWYgKG9wdGVkT3V0KSB7XG4gICAgICAgIGNvbnNvbGUkMS53YXJuKCdZb3UgYXJlIG9wdGVkIG91dCBvZiBNaXhwYW5lbCB0cmFja2luZy4gVGhpcyB3aWxsIHByZXZlbnQgdGhlIE1peHBhbmVsIFNESyBmcm9tIHNlbmRpbmcgYW55IGRhdGEuJyk7XG4gICAgfVxuICAgIHJldHVybiBvcHRlZE91dDtcbn1cblxuLyoqXG4gKiBXcmFwIGEgTWl4cGFuZWxMaWIgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKG1ldGhvZCkge1xuICAgIHJldHVybiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsUGVvcGxlIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShtZXRob2QpIHtcbiAgICByZXR1cm4gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2NvbmZpZyhuYW1lKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgTWl4cGFuZWxHcm91cCBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChtZXRob2QpIHtcbiAgICByZXR1cm4gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2NvbmZpZyhuYW1lKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgdXNlcidzIG9wdCBpbi9vdXQgc3RhdHVzIG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZURvbWFpbl0gLSBjdXN0b20gY29va2llIGRvbWFpblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1NpdGVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gY2xlYXJPcHRJbk91dCh0b2tlbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF9nZXRTdG9yYWdlKG9wdGlvbnMpLnJlbW92ZShcbiAgICAgICAgX2dldFN0b3JhZ2VLZXkodG9rZW4sIG9wdGlvbnMpLCAhIW9wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWUsIG9wdGlvbnMuY29va2llRG9tYWluXG4gICAgKTtcbn1cblxuLyoqIFByaXZhdGUgKiovXG5cbi8qKlxuICogR2V0IHN0b3JhZ2UgdXRpbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV1cbiAqIEByZXR1cm5zIHtvYmplY3R9IGVpdGhlciBfLmNvb2tpZSBvciBfLmxvY2Fsc3RvcmFnZVxuICovXG5mdW5jdGlvbiBfZ2V0U3RvcmFnZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG9wdGlvbnMucGVyc2lzdGVuY2VUeXBlID09PSAnbG9jYWxTdG9yYWdlJyA/IF8ubG9jYWxTdG9yYWdlIDogXy5jb29raWU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjb29raWUgdGhhdCBpcyB1c2VkIGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGUgKHRyYWNraW5nLCBjb29raWUsIGV0Yy4pXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgbmFtZSBvZiB0aGUgY29va2llIGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gX2dldFN0b3JhZ2VLZXkodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gKG9wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXggfHwgR0RQUl9ERUZBVUxUX1BFUlNJU1RFTkNFX1BSRUZJWCkgKyB0b2tlbjtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBjb29raWUgdGhhdCBpcyB1c2VkIGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGUgKHRyYWNraW5nLCBjb29raWUsIGV0Yy4pXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdmFsdWUgb2YgdGhlIGNvb2tpZSBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdG9yYWdlVmFsdWUodG9rZW4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldFN0b3JhZ2Uob3B0aW9ucykuZ2V0KF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgc2V0IHRoZSBETlQvZG9Ob3RUcmFjayBzZXR0aW5nIHRvIHRydWUgaW4gdGhlaXIgYnJvd3NlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLndpbmRvd10gLSBhbHRlcm5hdGUgd2luZG93IG9iamVjdCB0byBjaGVjazsgdXNlZCB0byBmb3JjZSB2YXJpb3VzIEROVCBzZXR0aW5ncyBpbiBicm93c2VyIHRlc3RzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZURudF0gLSBmbGFnIHRvIGlnbm9yZSBicm93c2VyIEROVCBzZXR0aW5ncyBhbmQgYWx3YXlzIHJldHVybiBmYWxzZVxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIEROVCBzZXR0aW5nIGlzIHRydWVcbiAqL1xuZnVuY3Rpb24gX2hhc0RvTm90VHJhY2tGbGFnT24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWdub3JlRG50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHdpbiQxID0gKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3cpIHx8IHdpbjtcbiAgICB2YXIgbmF2ID0gd2luJDFbJ25hdmlnYXRvciddIHx8IHt9O1xuICAgIHZhciBoYXNEbnRPbiA9IGZhbHNlO1xuXG4gICAgXy5lYWNoKFtcbiAgICAgICAgbmF2Wydkb05vdFRyYWNrJ10sIC8vIHN0YW5kYXJkXG4gICAgICAgIG5hdlsnbXNEb05vdFRyYWNrJ10sXG4gICAgICAgIHdpbiQxWydkb05vdFRyYWNrJ11cbiAgICBdLCBmdW5jdGlvbihkbnRWYWx1ZSkge1xuICAgICAgICBpZiAoXy5pbmNsdWRlcyhbdHJ1ZSwgMSwgJzEnLCAneWVzJ10sIGRudFZhbHVlKSkge1xuICAgICAgICAgICAgaGFzRG50T24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGFzRG50T247XG59XG5cbi8qKlxuICogU2V0IGNvb2tpZS9sb2NhbHN0b3JhZ2UgZm9yIHRoZSB1c2VyIGluZGljYXRpbmcgdGhhdCB0aGV5IGFyZSBvcHRlZCBpbiBvciBvdXQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICogQHBhcmFtIHtib29sZWFufSBvcHRWYWx1ZSAtIHdoZXRoZXIgdG8gb3B0IHRoZSB1c2VyIGluIG9yIG91dCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3RyYWNrRnVuY3Rpb259IFtvcHRpb25zLnRyYWNrXSAtIGZ1bmN0aW9uIHVzZWQgZm9yIHRyYWNraW5nIGEgTWl4cGFuZWwgZXZlbnQgdG8gcmVjb3JkIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhY2tFdmVudE5hbWVdIC0gZXZlbnQgbmFtZSB0byBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRyYWNrUHJvcGVydGllc10gLSBzZXQgb2YgcHJvcGVydGllcyB0byBiZSB0cmFja2VkIGFsb25nIHdpdGggdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIF9vcHRJbk91dChvcHRWYWx1ZSwgdG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcodG9rZW4pIHx8ICF0b2tlbi5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdnZHByLicgKyAob3B0VmFsdWUgPyAnb3B0SW4nIDogJ29wdE91dCcpICsgJyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIHRva2VuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIF9nZXRTdG9yYWdlKG9wdGlvbnMpLnNldChcbiAgICAgICAgX2dldFN0b3JhZ2VLZXkodG9rZW4sIG9wdGlvbnMpLFxuICAgICAgICBvcHRWYWx1ZSA/IDEgOiAwLFxuICAgICAgICBfLmlzTnVtYmVyKG9wdGlvbnMuY29va2llRXhwaXJhdGlvbikgPyBvcHRpb25zLmNvb2tpZUV4cGlyYXRpb24gOiBudWxsLFxuICAgICAgICAhIW9wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWUsXG4gICAgICAgICEhb3B0aW9ucy5zZWN1cmVDb29raWUsXG4gICAgICAgICEhb3B0aW9ucy5jcm9zc1NpdGVDb29raWUsXG4gICAgICAgIG9wdGlvbnMuY29va2llRG9tYWluXG4gICAgKTtcblxuICAgIGlmIChvcHRpb25zLnRyYWNrICYmIG9wdFZhbHVlKSB7IC8vIG9ubHkgdHJhY2sgZXZlbnQgaWYgb3B0aW5nIGluIChvcHRWYWx1ZT10cnVlKVxuICAgICAgICBvcHRpb25zLnRyYWNrKG9wdGlvbnMudHJhY2tFdmVudE5hbWUgfHwgJyRvcHRfaW4nLCBvcHRpb25zLnRyYWNrUHJvcGVydGllcywge1xuICAgICAgICAgICAgJ3NlbmRfaW1tZWRpYXRlbHknOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBXcmFwIGEgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0Q29uZmlnVmFsdWUgLSBnZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBNaXhwYW5lbCBBUEkgdG9rZW4gYW5kIG90aGVyIG9wdGlvbnMgdG8gYmUgdXNlZCB3aXRoIG9wdC1vdXQgY2hlY2tcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZ2V0Q29uZmlnVmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRlZE91dCA9IGZhbHNlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICd0b2tlbicpO1xuICAgICAgICAgICAgdmFyIGlnbm9yZURudCA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ2lnbm9yZV9kbnQnKTtcbiAgICAgICAgICAgIHZhciBwZXJzaXN0ZW5jZVR5cGUgPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBwZXJzaXN0ZW5jZVByZWZpeCA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCcpO1xuICAgICAgICAgICAgdmFyIHdpbiA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ3dpbmRvdycpOyAvLyB1c2VkIHRvIG92ZXJyaWRlIHdpbmRvdyBkdXJpbmcgYnJvd3NlciB0ZXN0c1xuXG4gICAgICAgICAgICBpZiAodG9rZW4pIHsgLy8gaWYgdGhlcmUgd2FzIGFuIGlzc3VlIGdldHRpbmcgdGhlIHRva2VuLCBjb250aW51ZSBtZXRob2QgZXhlY3V0aW9uIGFzIG5vcm1hbFxuICAgICAgICAgICAgICAgIG9wdGVkT3V0ID0gaGFzT3B0ZWRPdXQodG9rZW4sIHtcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlRG50OiBpZ25vcmVEbnQsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlbmNlVHlwZTogcGVyc2lzdGVuY2VUeXBlLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZW5jZVByZWZpeDogcGVyc2lzdGVuY2VQcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdzogd2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3Igd2hlbiBjaGVja2luZyB0cmFja2luZyBvcHQtb3V0IHN0YXR1czogJyArIGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGVkT3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgfTtcbn1cblxudmFyIGxvZ2dlciQ0ID0gY29uc29sZV93aXRoX3ByZWZpeCgnbG9jaycpO1xuXG4vKipcbiAqIFNoYXJlZExvY2s6IGEgbXV0ZXggYnVpbHQgb24gSFRNTDUgbG9jYWxTdG9yYWdlLCB0byBlbnN1cmUgdGhhdCBvbmx5IG9uZSBicm93c2VyXG4gKiB3aW5kb3cvdGFiIGF0IGEgdGltZSB3aWxsIGJlIGFibGUgdG8gYWNjZXNzIHNoYXJlZCByZXNvdXJjZXMuXG4gKlxuICogQmFzZWQgb24gdGhlIEFsdXIgYW5kIFRhdWJlbmZlbGQgZmFzdCBsb2NrXG4gKiAoaHR0cDovL3d3dy5jcy5yb2NoZXN0ZXIuZWR1L3Jlc2VhcmNoL3N5bmNocm9uaXphdGlvbi9wc2V1ZG9jb2RlL2Zhc3Rsb2NrLmh0bWwpXG4gKiB3aXRoIGFuIGFkZGVkIHRpbWVvdXQgdG8gZW5zdXJlIHRoZXJlIHdpbGwgYmUgZXZlbnR1YWwgcHJvZ3Jlc3MgaW4gdGhlIGV2ZW50XG4gKiB0aGF0IGEgd2luZG93IGlzIGNsb3NlZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgdmVyc2lvbiBieSBEYXZpZCBXb2xldmVyIChodHRwczovL2dpdGh1Yi5jb20vd29sZXZlcilcbiAqIGF0IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3dvbGV2ZXIvNWZkNzU3M2QxZWY2MTY2ZThmOGM0YWYyODZhNjk0MzIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG15TG9jayA9IG5ldyBTaGFyZWRMb2NrKCdzb21lLWtleScpO1xuICogbXlMb2NrLndpdGhMb2NrKGZ1bmN0aW9uKCkge1xuICogICBjb25zb2xlLmxvZygnSSBob2xkIHRoZSBtdXRleCEnKTtcbiAqIH0pO1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2hhcmVkTG9jayA9IGZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5zdG9yYWdlS2V5ID0ga2V5O1xuICAgIHRoaXMuc3RvcmFnZSA9IG9wdGlvbnMuc3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgIHRoaXMucG9sbEludGVydmFsTVMgPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1TIHx8IDEwMDtcbiAgICB0aGlzLnRpbWVvdXRNUyA9IG9wdGlvbnMudGltZW91dE1TIHx8IDIwMDA7XG5cbiAgICAvLyBkZXBlbmRlbmN5LWluamVjdCBwcm9taXNlIGltcGxlbWVudGF0aW9uIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAgdGhpcy5wcm9taXNlSW1wbCA9IG9wdGlvbnMucHJvbWlzZUltcGwgfHwgUHJvbWlzZVBvbHlmaWxsO1xufTtcblxuLy8gcGFzcyBpbiBhIHNwZWNpZmljIHBpZCB0byB0ZXN0IGNvbnRlbnRpb24gc2NlbmFyaW9zOyBvdGhlcndpc2Vcbi8vIGl0IGlzIGNob3NlbiByYW5kb21seSBmb3IgZWFjaCBhY3F1aXNpdGlvbiBhdHRlbXB0XG5TaGFyZWRMb2NrLnByb3RvdHlwZS53aXRoTG9jayA9IGZ1bmN0aW9uKGxvY2tlZENCLCBwaWQpIHtcbiAgICB2YXIgUHJvbWlzZSA9IHRoaXMucHJvbWlzZUltcGw7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKF8uYmluZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBpID0gcGlkIHx8IChuZXcgRGF0ZSgpLmdldFRpbWUoKSArICd8JyArIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgdmFyIGtleSA9IHRoaXMuc3RvcmFnZUtleTtcbiAgICAgICAgdmFyIHBvbGxJbnRlcnZhbE1TID0gdGhpcy5wb2xsSW50ZXJ2YWxNUztcbiAgICAgICAgdmFyIHRpbWVvdXRNUyA9IHRoaXMudGltZW91dE1TO1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuc3RvcmFnZTtcblxuICAgICAgICB2YXIga2V5WCA9IGtleSArICc6WCc7XG4gICAgICAgIHZhciBrZXlZID0ga2V5ICsgJzpZJztcbiAgICAgICAgdmFyIGtleVogPSBrZXkgKyAnOlonO1xuXG4gICAgICAgIHZhciBkZWxheSA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUgPiB0aW1lb3V0TVMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkNC5lcnJvcignVGltZW91dCB3YWl0aW5nIGZvciBtdXRleCBvbiAnICsga2V5ICsgJzsgY2xlYXJpbmcgbG9jay4gWycgKyBpICsgJ10nKTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5Wik7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVkpO1xuICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcG9sbEludGVydmFsTVMgKiAoTWF0aC5yYW5kb20oKSArIDAuMSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB3YWl0Rm9yID0gZnVuY3Rpb24ocHJlZGljYXRlLCBjYikge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSgpKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRGb3IocHJlZGljYXRlLCBjYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFNldFkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWxZID0gc3RvcmFnZS5nZXRJdGVtKGtleVkpO1xuICAgICAgICAgICAgaWYgKHZhbFkgJiYgdmFsWSAhPT0gaSkgeyAvLyBpZiBZID09IGkgdGhlbiB0aGlzIHByb2Nlc3MgYWxyZWFkeSBoYXMgdGhlIGxvY2sgKHVzZWZ1bCBmb3IgdGVzdCBjYXNlcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlZLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVkpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxTdG9yYWdlU3VwcG9ydGVkKHN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBkcm9wcGVkIHdoaWxlIGFjcXVpcmluZyBsb2NrJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlYLCBpKTtcblxuICAgICAgICAgICAgd2FpdEZvcihnZXRTZXRZLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVgpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyaXRpY2FsU2VjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WSkgIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzdG9yYWdlLmdldEl0ZW0oa2V5Wik7XG4gICAgICAgICAgICAgICAgICAgIH0sIGNyaXRpY2FsU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY3JpdGljYWxTZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WiwgJzEnKTtcbiAgICAgICAgICAgIHZhciByZW1vdmVMb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlaKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVkpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlYKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5WCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbG9ja2VkQ0IoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJldCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlU3VwcG9ydGVkKHN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvY2FsU3RvcmFnZSBzdXBwb3J0IGNoZWNrIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vd3JhcHBlcicpLlN0b3JhZ2VXcmFwcGVyfVxuICovXG5cbi8qKlxuICogQHR5cGUge1N0b3JhZ2VXcmFwcGVyfVxuICovXG52YXIgTG9jYWxTdG9yYWdlV3JhcHBlciA9IGZ1bmN0aW9uIChzdG9yYWdlT3ZlcnJpZGUpIHtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlT3ZlcnJpZGUgfHwgbG9jYWxTdG9yYWdlO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnNldEl0ZW0gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKF8uYmluZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICB9LCB0aGlzKSk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKF8uYmluZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgdGhpcykpO1xufTtcblxudmFyIGxvZ2dlciQzID0gY29uc29sZV93aXRoX3ByZWZpeCgnYmF0Y2gnKTtcblxuLyoqXG4gKiBSZXF1ZXN0UXVldWU6IHF1ZXVlIGZvciBiYXRjaGluZyBBUEkgcmVxdWVzdHMgd2l0aCBsb2NhbFN0b3JhZ2UgYmFja3VwIGZvciByZXRyaWVzLlxuICogTWFpbnRhaW5zIGFuIGluLW1lbW9yeSBxdWV1ZSB3aGljaCByZXByZXNlbnRzIHRoZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHRoZSBjdXJyZW50XG4gKiBwYWdlLCBidXQgYWxzbyB3cml0ZXMgYWxsIGl0ZW1zIG91dCB0byBhIGNvcHkgaW4gdGhlIGJyb3dzZXIncyBsb2NhbFN0b3JhZ2UsIHdoaWNoXG4gKiBjYW4gYmUgcmVhZCBvbiBzdWJzZXF1ZW50IHBhZ2Vsb2FkcyBhbmQgcmV0cmllZC4gRm9yIGJhdGNoYWJpbGl0eSwgYWxsIHRoZSByZXF1ZXN0XG4gKiBpdGVtcyBpbiB0aGUgcXVldWUgc2hvdWxkIGJlIG9mIHRoZSBzYW1lIHR5cGUgKGV2ZW50cywgcGVvcGxlIHVwZGF0ZXMsIGdyb3VwIHVwZGF0ZXMpXG4gKiBzbyB0aGV5IGNhbiBiZSBzZW50IGluIGEgc2luZ2xlIHJlcXVlc3QgdG8gdGhlIHNhbWUgQVBJIGVuZHBvaW50LlxuICpcbiAqIExvY2FsU3RvcmFnZSBrZXlpbmcgYW5kIGxvY2tpbmc6IEluIG9yZGVyIGZvciByZWxvYWRzIGFuZCBzdWJzZXF1ZW50IHBhZ2Vsb2FkcyBvZlxuICogdGhlIHNhbWUgc2l0ZSB0byBhY2Nlc3MgdGhlIHNhbWUgcGVyc2lzdGVkIGRhdGEsIHRoZXkgbXVzdCBzaGFyZSB0aGUgc2FtZSBsb2NhbFN0b3JhZ2VcbiAqIGtleSAoZm9yIGluc3RhbmNlIGJhc2VkIG9uIHByb2plY3QgdG9rZW4gYW5kIHF1ZXVlIHR5cGUpLiBUaGVyZWZvcmUgYWNjZXNzIHRvIHRoZVxuICogbG9jYWxTdG9yYWdlIGVudHJ5IGlzIGd1YXJkZWQgYnkgYW4gYXN5bmNocm9ub3VzIG11dGV4IChTaGFyZWRMb2NrKSB0byBwcmV2ZW50XG4gKiBzaW11bHRhbmVvdXNseSBvcGVuIHdpbmRvd3MvdGFicyBmcm9tIG92ZXJ3cml0aW5nIGVhY2ggb3RoZXIncyBkYXRhICh3aGljaCB3b3VsZCBsZWFkXG4gKiB0byBkYXRhIGxvc3MgaW4gc29tZSBzaXR1YXRpb25zKS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUmVxdWVzdFF1ZXVlID0gZnVuY3Rpb24gKHN0b3JhZ2VLZXksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzdG9yYWdlS2V5O1xuICAgIHRoaXMudXNlUGVyc2lzdGVuY2UgPSBvcHRpb25zLnVzZVBlcnNpc3RlbmNlO1xuICAgIGlmICh0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHRoaXMucXVldWVTdG9yYWdlID0gb3B0aW9ucy5xdWV1ZVN0b3JhZ2UgfHwgbmV3IExvY2FsU3RvcmFnZVdyYXBwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NrID0gbmV3IFNoYXJlZExvY2soc3RvcmFnZUtleSwgeyBzdG9yYWdlOiBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2UgfSk7XG4gICAgICAgIHRoaXMucXVldWVTdG9yYWdlLmluaXQoKTtcbiAgICB9XG4gICAgdGhpcy5yZXBvcnRFcnJvciA9IG9wdGlvbnMuZXJyb3JSZXBvcnRlciB8fCBfLmJpbmQobG9nZ2VyJDMuZXJyb3IsIGxvZ2dlciQzKTtcblxuICAgIHRoaXMucGlkID0gb3B0aW9ucy5waWQgfHwgbnVsbDsgLy8gcGFzcyBwaWQgdG8gdGVzdCBvdXQgc3RvcmFnZSBsb2NrIGNvbnRlbnRpb24gc2NlbmFyaW9zXG5cbiAgICB0aGlzLm1lbVF1ZXVlID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xufTtcblxuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5lbnN1cmVJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZVxuICAgICAgICAuaW5pdCgpXG4gICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIHF1ZXVlIHBlcnNpc3RlbmNlLiBEaXNhYmxpbmcgcGVyc2lzdGVuY2UnLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVzZVBlcnNpc3RlbmNlID0gZmFsc2U7XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogQWRkIG9uZSBpdGVtIHRvIHF1ZXVlcyAobWVtb3J5IGFuZCBsb2NhbFN0b3JhZ2UpLiBUaGUgcXVldWVkIGVudHJ5IGluY2x1ZGVzXG4gKiB0aGUgZ2l2ZW4gaXRlbSBhbG9uZyB3aXRoIGFuIGF1dG8tZ2VuZXJhdGVkIElEIGFuZCBhIFwiZmx1c2gtYWZ0ZXJcIiB0aW1lc3RhbXAuXG4gKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoZSBpdGVtIHdpbGwgYmUgc2VudCBvdmVyIHRoZSBuZXR3b3JrIGFuZCBkZXF1ZXVlZFxuICogYmVmb3JlIHRoZSBmbHVzaC1hZnRlciB0aW1lOyBpZiB0aGlzIGRvZXNuJ3QgaGFwcGVuIGl0IGlzIGNvbnNpZGVyZWQgb3JwaGFuZWRcbiAqIChlLmcuLCB0aGUgb3JpZ2luYWwgdGFiIHdoZXJlIGl0IHdhcyBlbnF1ZXVlZCBnb3QgY2xvc2VkIGJlZm9yZSBpdCBjb3VsZCBiZVxuICogc2VudCkgYW5kIHRoZSBpdGVtIGNhbiBiZSBzZW50IGJ5IGFueSB0YWIgdGhhdCBmaW5kcyBpdCBpbiBsb2NhbFN0b3JhZ2UuXG4gKlxuICogVGhlIGZpbmFsIGNhbGxiYWNrIHBhcmFtIGlzIGNhbGxlZCB3aXRoIGEgcGFyYW0gaW5kaWNhdGluZyBzdWNjZXNzIG9yXG4gKiBmYWlsdXJlIG9mIHRoZSBlbnF1ZXVlIG9wZXJhdGlvbjsgaXQgaXMgYXN5bmNocm9ub3VzIGJlY2F1c2UgdGhlIGxvY2FsU3RvcmFnZVxuICogbG9jayBpcyBhc3luY2hyb25vdXMuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIChpdGVtLCBmbHVzaEludGVydmFsKSB7XG4gICAgdmFyIHF1ZXVlRW50cnkgPSB7XG4gICAgICAgICdpZCc6IGNoZWFwX2d1aWQoKSxcbiAgICAgICAgJ2ZsdXNoQWZ0ZXInOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGZsdXNoSW50ZXJ2YWwgKiAyLFxuICAgICAgICAncGF5bG9hZCc6IGl0ZW1cbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHRoaXMubWVtUXVldWUucHVzaChxdWV1ZUVudHJ5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKHRydWUpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIGVucXVldWVJdGVtID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUucHVzaChxdWV1ZUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRvU3RvcmFnZShzdG9yZWRRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBhZGQgdG8gaW4tbWVtb3J5IHF1ZXVlIHdoZW4gc3RvcmFnZSBzdWNjZWVkc1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbVF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2NlZWRlZDtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgZW5xdWV1ZWluZyBpdGVtJywgZXJyLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAgICAgLndpdGhMb2NrKGVucXVldWVJdGVtLCB0aGlzLnBpZClcbiAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlYWQgb3V0IHRoZSBnaXZlbiBudW1iZXIgb2YgcXVldWUgZW50cmllcy4gSWYgdGhpcy5tZW1RdWV1ZVxuICogaGFzIGZld2VyIHRoYW4gYmF0Y2hTaXplIGl0ZW1zLCB0aGVuIGxvb2sgZm9yIFwib3JwaGFuZWRcIiBpdGVtc1xuICogaW4gdGhlIHBlcnNpc3RlZCBxdWV1ZSAoaXRlbXMgd2hlcmUgdGhlICdmbHVzaEFmdGVyJyB0aW1lIGhhc1xuICogYWxyZWFkeSBwYXNzZWQpLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmZpbGxCYXRjaCA9IGZ1bmN0aW9uIChiYXRjaFNpemUpIHtcbiAgICB2YXIgYmF0Y2ggPSB0aGlzLm1lbVF1ZXVlLnNsaWNlKDAsIGJhdGNoU2l6ZSk7XG4gICAgaWYgKHRoaXMudXNlUGVyc2lzdGVuY2UgJiYgYmF0Y2gubGVuZ3RoIDwgYmF0Y2hTaXplKSB7XG4gICAgICAgIC8vIGRvbid0IG5lZWQgbG9jayBqdXN0IHRvIHJlYWQgZXZlbnRzOyBsb2NhbFN0b3JhZ2UgaXMgdGhyZWFkLXNhZmVcbiAgICAgICAgLy8gYW5kIHRoZSB3b3JzdCB0aGF0IGNvdWxkIGhhcHBlbiBpcyBhIGR1cGxpY2F0ZSBzZW5kIG9mIHNvbWVcbiAgICAgICAgLy8gb3JwaGFuZWQgZXZlbnRzLCB3aGljaCB3aWxsIGJlIGRlZHVwbGljYXRlZCBvbiB0aGUgc2VydmVyIHNpZGVcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlZFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGl0ZW0gSURzIGFscmVhZHkgaW4gYmF0Y2g7IGRvbid0IGR1cGxpY2F0ZSBvdXQgb2Ygc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaWRzSW5CYXRjaCA9IHt9OyAvLyBwb29yIG1hbidzIFNldFxuICAgICAgICAgICAgICAgICAgICBfLmVhY2goYmF0Y2gsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHNJbkJhdGNoW2l0ZW1bJ2lkJ11dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdG9yZWRRdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IGl0ZW1bJ2ZsdXNoQWZ0ZXInXSAmJiAhaWRzSW5CYXRjaFtpdGVtWydpZCddXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3JwaGFuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA+PSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZShiYXRjaCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgaXRlbXMgd2l0aCBtYXRjaGluZyAnaWQnIGZyb20gYXJyYXkgKGltbXV0YWJseSlcbiAqIGFsc28gcmVtb3ZlIGFueSBpdGVtIHdpdGhvdXQgYSB2YWxpZCBpZCAoZS5nLiwgbWFsZm9ybWVkXG4gKiBzdG9yYWdlIGVudHJpZXMpLlxuICovXG52YXIgZmlsdGVyT3V0SURzQW5kSW52YWxpZCA9IGZ1bmN0aW9uIChpdGVtcywgaWRTZXQpIHtcbiAgICB2YXIgZmlsdGVyZWRJdGVtcyA9IFtdO1xuICAgIF8uZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW1bJ2lkJ10gJiYgIWlkU2V0W2l0ZW1bJ2lkJ11dKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmlsdGVyZWRJdGVtcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGl0ZW1zIHdpdGggbWF0Y2hpbmcgSURzIGZyb20gYm90aCBpbi1tZW1vcnkgcXVldWVcbiAqIGFuZCBwZXJzaXN0ZWQgcXVldWVcbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5yZW1vdmVJdGVtc0J5SUQgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdmFyIGlkU2V0ID0ge307IC8vIHBvb3IgbWFuJ3MgU2V0XG4gICAgXy5lYWNoKGlkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlkU2V0W2lkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1lbVF1ZXVlID0gZmlsdGVyT3V0SURzQW5kSW52YWxpZCh0aGlzLm1lbVF1ZXVlLCBpZFNldCk7XG4gICAgaWYgKCF0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVtb3ZlRnJvbVN0b3JhZ2UgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZWRRdWV1ZSA9IGZpbHRlck91dElEc0FuZEludmFsaWQoc3RvcmVkUXVldWUsIGlkU2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRvU3RvcmFnZShzdG9yZWRRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBleHRyYSBjaGVjazogZGlkIHN0b3JhZ2UgcmVwb3J0IHN1Y2Nlc3MgYnV0IHNvbWVob3dcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGl0ZW1zIGFyZSBzdGlsbCB0aGVyZT9cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdG9yZWRRdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtWydpZCddICYmICEhaWRTZXRbaXRlbVsnaWQnXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZW0gbm90IHJlbW92ZWQgZnJvbSBzdG9yYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHJlbW92aW5nIGl0ZW1zJywgZXJyLCBpZHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgICAgICAud2l0aExvY2socmVtb3ZlRnJvbVN0b3JhZ2UsIHRoaXMucGlkKVxuICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgYWNxdWlyaW5nIHN0b3JhZ2UgbG9jaycsIGVycik7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQodGhpcy5xdWV1ZVN0b3JhZ2Uuc3RvcmFnZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9va3MgbGlrZSBsb2NhbFN0b3JhZ2Ugd3JpdGVzIGhhdmUgc3RvcHBlZCB3b3JraW5nIHNvbWV0aW1lIGFmdGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemF0aW9uIChwcm9iYWJseSBmdWxsKSwgYW5kIHNvIG5vYm9keSBjYW4gYWNxdWlyZSBsb2Nrc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbnltb3JlLiBDb25zaWRlciBpdCB0ZW1wb3JhcmlseSBzYWZlIHRvIHJlbW92ZSBpdGVtcyB3aXRob3V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBsb2NrLCBzaW5jZSBub2JvZHkncyB3cml0aW5nIHN1Y2Nlc3NmdWxseSBhbnl3YXkuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVGcm9tU3RvcmFnZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT0ssIHdlIGNvdWxkbid0IGV2ZW4gd3JpdGUgb3V0IHRoZSBzbWFsbGVyIHF1ZXVlLiBUcnkgY2xlYXJpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuc3RvcmFnZUtleSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBjbGVhcmluZyBxdWV1ZScsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfVxufTtcblxuLy8gaW50ZXJuYWwgaGVscGVyIGZvciBSZXF1ZXN0UXVldWUudXBkYXRlUGF5bG9hZHNcbnZhciB1cGRhdGVQYXlsb2FkcyA9IGZ1bmN0aW9uIChleGlzdGluZ0l0ZW1zLCBpdGVtc1RvVXBkYXRlKSB7XG4gICAgdmFyIG5ld0l0ZW1zID0gW107XG4gICAgXy5lYWNoKGV4aXN0aW5nSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpZCA9IGl0ZW1bJ2lkJ107XG4gICAgICAgIGlmIChpZCBpbiBpdGVtc1RvVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgbmV3UGF5bG9hZCA9IGl0ZW1zVG9VcGRhdGVbaWRdO1xuICAgICAgICAgICAgaWYgKG5ld1BheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVtWydwYXlsb2FkJ10gPSBuZXdQYXlsb2FkO1xuICAgICAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyB1cGRhdGVcbiAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3SXRlbXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBwYXlsb2FkcyBvZiBnaXZlbiBpdGVtcyBpbiBib3RoIGluLW1lbW9yeSBxdWV1ZSBhbmRcbiAqIHBlcnNpc3RlZCBxdWV1ZS4gSXRlbXMgc2V0IHRvIG51bGwgYXJlIHJlbW92ZWQgZnJvbSBxdWV1ZXMuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUudXBkYXRlUGF5bG9hZHMgPSBmdW5jdGlvbiAoaXRlbXNUb1VwZGF0ZSkge1xuICAgIHRoaXMubWVtUXVldWUgPSB1cGRhdGVQYXlsb2Fkcyh0aGlzLm1lbVF1ZXVlLCBpdGVtc1RvVXBkYXRlKTtcbiAgICBpZiAoIXRoaXMudXNlUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2tcbiAgICAgICAgICAgIC53aXRoTG9jayhfLmJpbmQoZnVuY3Rpb24gbG9ja0FjcXVpcmVkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRRdWV1ZSA9IHVwZGF0ZVBheWxvYWRzKHN0b3JlZFF1ZXVlLCBpdGVtc1RvVXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciB1cGRhdGluZyBpdGVtcycsIGl0ZW1zVG9VcGRhdGUsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpLCB0aGlzLnBpZClcbiAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlYWQgYW5kIHBhcnNlIGl0ZW1zIGFycmF5IGZyb20gbG9jYWxTdG9yYWdlIGVudHJ5LCBoYW5kbGluZ1xuICogbWFsZm9ybWVkL21pc3NpbmcgZGF0YSBpZiBuZWNlc3NhcnkuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUucmVhZEZyb21TdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmFnZUVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoc3RvcmFnZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZUVudHJ5ID0gSlNPTlBhcnNlKHN0b3JhZ2VFbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKCFfLmlzQXJyYXkoc3RvcmFnZUVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdJbnZhbGlkIHN0b3JhZ2UgZW50cnk6Jywgc3RvcmFnZUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZUVudHJ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZUVudHJ5IHx8IFtdO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciByZXRyaWV2aW5nIHF1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGl0ZW1zIGFycmF5IHRvIGxvY2FsU3RvcmFnZS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5zYXZlVG9TdG9yYWdlID0gZnVuY3Rpb24gKHF1ZXVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBKU09OU3RyaW5naWZ5KHF1ZXVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3Igc2VyaWFsaXppbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHNhdmluZyBxdWV1ZScsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgb3V0IHF1ZXVlcyAobWVtb3J5IGFuZCBsb2NhbFN0b3JhZ2UpLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubWVtUXVldWUgPSBbXTtcblxuICAgIGlmICh0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgIH1cbn07XG5cbi8vIG1heGltdW0gaW50ZXJ2YWwgYmV0d2VlbiByZXF1ZXN0IHJldHJpZXMgYWZ0ZXIgZXhwb25lbnRpYWwgYmFja29mZlxudmFyIE1BWF9SRVRSWV9JTlRFUlZBTF9NUyA9IDEwICogNjAgKiAxMDAwOyAvLyAxMCBtaW51dGVzXG5cbnZhciBsb2dnZXIkMiA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ2JhdGNoJyk7XG5cbi8qKlxuICogUmVxdWVzdEJhdGNoZXI6IG1hbmFnZXMgdGhlIHF1ZXVlaW5nLCBmbHVzaGluZywgcmV0cnkgZXRjIG9mIHJlcXVlc3RzIG9mIG9uZVxuICogdHlwZSAoZXZlbnRzLCBwZW9wbGUsIGdyb3VwcykuXG4gKiBVc2VzIFJlcXVlc3RRdWV1ZSB0byBtYW5hZ2UgdGhlIGJhY2tpbmcgc3RvcmUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJlcXVlc3RCYXRjaGVyID0gZnVuY3Rpb24oc3RvcmFnZUtleSwgb3B0aW9ucykge1xuICAgIHRoaXMuZXJyb3JSZXBvcnRlciA9IG9wdGlvbnMuZXJyb3JSZXBvcnRlcjtcbiAgICB0aGlzLnF1ZXVlID0gbmV3IFJlcXVlc3RRdWV1ZShzdG9yYWdlS2V5LCB7XG4gICAgICAgIGVycm9yUmVwb3J0ZXI6IF8uYmluZCh0aGlzLnJlcG9ydEVycm9yLCB0aGlzKSxcbiAgICAgICAgcXVldWVTdG9yYWdlOiBvcHRpb25zLnF1ZXVlU3RvcmFnZSxcbiAgICAgICAgc2hhcmVkTG9ja1N0b3JhZ2U6IG9wdGlvbnMuc2hhcmVkTG9ja1N0b3JhZ2UsXG4gICAgICAgIHVzZVBlcnNpc3RlbmNlOiBvcHRpb25zLnVzZVBlcnNpc3RlbmNlXG4gICAgfSk7XG5cbiAgICB0aGlzLmxpYkNvbmZpZyA9IG9wdGlvbnMubGliQ29uZmlnO1xuICAgIHRoaXMuc2VuZFJlcXVlc3QgPSBvcHRpb25zLnNlbmRSZXF1ZXN0RnVuYztcbiAgICB0aGlzLmJlZm9yZVNlbmRIb29rID0gb3B0aW9ucy5iZWZvcmVTZW5kSG9vaztcbiAgICB0aGlzLnN0b3BBbGxCYXRjaGluZyA9IG9wdGlvbnMuc3RvcEFsbEJhdGNoaW5nRnVuYztcblxuICAgIC8vIHNlZWQgdmFyaWFibGUgYmF0Y2ggc2l6ZSArIGZsdXNoIGludGVydmFsIHdpdGggY29uZmlndXJlZCB2YWx1ZXNcbiAgICB0aGlzLmJhdGNoU2l6ZSA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9zaXplJ107XG4gICAgdGhpcy5mbHVzaEludGVydmFsID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJ107XG5cbiAgICB0aGlzLnN0b3BwZWQgPSAhdGhpcy5saWJDb25maWdbJ2JhdGNoX2F1dG9zdGFydCddO1xuICAgIHRoaXMuY29uc2VjdXRpdmVSZW1vdmFsRmFpbHVyZXMgPSAwO1xuXG4gICAgLy8gZXh0cmEgY2xpZW50LXNpZGUgZGVkdXBlXG4gICAgdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseSA9IHt9O1xuXG4gICAgLy8gTWFrZSB0aGUgZmx1c2ggb2NjdXIgYXQgdGhlIGludGVydmFsIHNwZWNpZmllZCBieSBmbHVzaEludGVydmFsTXMsIGRlZmF1bHQgYmVoYXZpb3Igd2lsbCBhdHRlbXB0IGNvbnNlY3V0aXZlIGZsdXNoZXNcbiAgICAvLyBhcyBsb25nIGFzIHRoZSBxdWV1ZSBpcyBub3QgZW1wdHkuIFRoaXMgaXMgdXNlZnVsIGZvciBoaWdoLWZyZXF1ZW5jeSBldmVudHMgbGlrZSBTZXNzaW9uIFJlcGxheSB3aGVyZSB3ZSBtaWdodCBlbmQgdXBcbiAgICAvLyBpbiBhIHJlcXVlc3QgbG9vcCBhbmQgZ2V0IHJhdGVsaW1pdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgdGhpcy5mbHVzaE9ubHlPbkludGVydmFsID0gb3B0aW9ucy5mbHVzaE9ubHlPbkludGVydmFsIHx8IGZhbHNlO1xufTtcblxuLyoqXG4gKiBBZGQgb25lIGl0ZW0gdG8gcXVldWUuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmVucXVldWUoaXRlbSwgdGhpcy5mbHVzaEludGVydmFsKTtcbn07XG5cbi8qKlxuICogU3RhcnQgZmx1c2hpbmcgYmF0Y2hlcyBhdCB0aGUgY29uZmlndXJlZCB0aW1lIGludGVydmFsLiBNdXN0IGNhbGxcbiAqIHRoaXMgbWV0aG9kIHVwb24gU0RLIGluaXQgaW4gb3JkZXIgdG8gc2VuZCBhbnl0aGluZyBvdmVyIHRoZSBuZXR3b3JrLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcbiAgICByZXR1cm4gdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBTdG9wIGZsdXNoaW5nIGJhdGNoZXMuIENhbiBiZSByZXN0YXJ0ZWQgYnkgY2FsbGluZyBzdGFydCgpLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMudGltZW91dElEKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJRCk7XG4gICAgICAgIHRoaXMudGltZW91dElEID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFyIG91dCBxdWV1ZS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWUuY2xlYXIoKTtcbn07XG5cbi8qKlxuICogUmVzdG9yZSBiYXRjaCBzaXplIGNvbmZpZ3VyYXRpb24gdG8gd2hhdGV2ZXIgaXMgc2V0IGluIHRoZSBtYWluIFNESy5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnJlc2V0QmF0Y2hTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5iYXRjaFNpemUgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlIGZsdXNoIGludGVydmFsIHRpbWUgY29uZmlndXJhdGlvbiB0byB3aGF0ZXZlciBpcyBzZXQgaW4gdGhlIG1haW4gU0RLLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUucmVzZXRGbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2NoZWR1bGVGbHVzaCh0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnXSk7XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlIHRoZSBuZXh0IGZsdXNoIGluIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc2NoZWR1bGVGbHVzaCA9IGZ1bmN0aW9uKGZsdXNoTVMpIHtcbiAgICB0aGlzLmZsdXNoSW50ZXJ2YWwgPSBmbHVzaE1TO1xuICAgIGlmICghdGhpcy5zdG9wcGVkKSB7IC8vIGRvbid0IHNjaGVkdWxlIGFueW1vcmUgaWYgYmF0Y2hpbmcgaGFzIGJlZW4gc3RvcHBlZFxuICAgICAgICB0aGlzLnRpbWVvdXRJRCA9IHNldFRpbWVvdXQoXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpLCB0aGlzLmZsdXNoSW50ZXJ2YWwpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2VuZCBhIHJlcXVlc3QgdXNpbmcgdGhlIHNlbmRSZXF1ZXN0IGNhbGxiYWNrLCBidXQgcHJvbWlzaWZpZWQuXG4gKiBUT0RPOiBzZW5kUmVxdWVzdCBzaG91bGQgYmUgcHJvbWlzaWZpZWQgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc2VuZFJlcXVlc3RQcm9taXNlID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKF8uYmluZChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoZGF0YSwgb3B0aW9ucywgcmVzb2x2ZSk7XG4gICAgfSwgdGhpcykpO1xufTtcblxuXG4vKipcbiAqIEZsdXNoIG9uZSBiYXRjaCB0byBuZXR3b3JrLiBEZXBlbmRpbmcgb24gc3VjY2Vzcy9mYWlsdXJlIG1vZGVzLCBpdCB3aWxsIGVpdGhlclxuICogcmVtb3ZlIHRoZSBiYXRjaCBmcm9tIHRoZSBxdWV1ZSBvciBsZWF2ZSBpdCBpbiBmb3IgcmV0cnksIGFuZCBzY2hlZHVsZSB0aGUgbmV4dFxuICogZmx1c2guIEluIGNhc2VzIG9mIG1vc3QgbmV0d29yayBvciBBUEkgZmFpbHVyZXMsIGl0IHdpbGwgYmFjayBvZmYgZXhwb25lbnRpYWxseVxuICogd2hlbiByZXRyeWluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VuZEJlYWNvbl0gLSB3aGV0aGVyIHRvIHNlbmQgYmF0Y2ggd2l0aFxuICogbmF2aWdhdG9yLnNlbmRCZWFjb24gKG9ubHkgdXNlZnVsIGZvciBzZW5kaW5nIGJhdGNoZXMgYmVmb3JlIHBhZ2UgdW5sb2FkcywgYXNcbiAqIHNlbmRCZWFjb24gb2ZmZXJzIG5vIGNhbGxiYWNrcyBvciBzdGF0dXMgaW5kaWNhdGlvbnMpXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcykge1xuICAgICAgICBsb2dnZXIkMi5sb2coJ0ZsdXNoOiBSZXF1ZXN0IGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcyA9IHRydWU7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdGltZW91dE1TID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX3JlcXVlc3RfdGltZW91dF9tcyddO1xuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgY3VycmVudEJhdGNoU2l6ZSA9IHRoaXMuYmF0Y2hTaXplO1xuXG4gICAgcmV0dXJuIHRoaXMucXVldWUuZmlsbEJhdGNoKGN1cnJlbnRCYXRjaFNpemUpXG4gICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbihiYXRjaCkge1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG1vcmUgaXRlbXMgaW4gdGhlIHF1ZXVlIHRoYW4gdGhlIGJhdGNoIHNpemUsIGF0dGVtcHRcbiAgICAgICAgICAgIC8vIHRvIGZsdXNoIGFnYWluIGFmdGVyIHRoZSBjdXJyZW50IGJhdGNoIGlzIGRvbmUuXG4gICAgICAgICAgICB2YXIgYXR0ZW1wdFNlY29uZGFyeUZsdXNoID0gYmF0Y2gubGVuZ3RoID09PSBjdXJyZW50QmF0Y2hTaXplO1xuICAgICAgICAgICAgdmFyIGRhdGFGb3JSZXF1ZXN0ID0gW107XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRJdGVtcyA9IHt9O1xuICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBpdGVtWydwYXlsb2FkJ107XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmVmb3JlU2VuZEhvb2sgJiYgIWl0ZW0ub3JwaGFuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IHRoaXMuYmVmb3JlU2VuZEhvb2socGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1wX3NlbnRfYnlfbGliX3ZlcnNpb24gcHJvcCBjYXB0dXJlcyB3aGljaCBsaWIgdmVyc2lvbiBhY3R1YWxseVxuICAgICAgICAgICAgICAgICAgICAvLyBzZW5kcyBlYWNoIGV2ZW50IChyZWdhcmRsZXNzIG9mIHdoaWNoIHZlcnNpb24gb3JpZ2luYWxseSBxdWV1ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgZm9yIHNlbmRpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkWydldmVudCddICYmIHBheWxvYWRbJ3Byb3BlcnRpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsncHJvcGVydGllcyddID0gXy5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsncHJvcGVydGllcyddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsnbXBfc2VudF9ieV9saWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTn1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZFBheWxvYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gfHwgMCkgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGl0ZW0gSUQgc2VudCB0b28gbWFueSB0aW1lcywgbm90IHNlbmRpbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZTogYmF0Y2gubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc1NlbnQ6IHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBheWxvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBmb3VuZCBpdGVtIHdpdGggbm8gSUQnLCB7aXRlbTogaXRlbX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFGb3JSZXF1ZXN0LnB1c2gocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRJdGVtc1tpdGVtWydpZCddXSA9IHBheWxvYWQ7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGRhdGFGb3JSZXF1ZXN0Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7IC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlbW92ZUl0ZW1zRnJvbVF1ZXVlID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlSXRlbXNCeUlEKFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5tYXAoYmF0Y2gsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZSBkZWR1cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChiYXRjaCwgXy5iaW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSA9IHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBpdGVtIElEIHNlbnQgdG9vIG1hbnkgdGltZXMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemU6IGJhdGNoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc1NlbnQ6IHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gZm91bmQgaXRlbSB3aXRoIG5vIElEIHdoaWxlIHJlbW92aW5nJywge2l0ZW06IGl0ZW19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbHVzaE9ubHlPbkludGVydmFsICYmICFhdHRlbXB0U2Vjb25kYXJ5Rmx1c2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7IC8vIHNjaGVkdWxlIG5leHQgYmF0Y2ggd2l0aCBhIGRlbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoKCk7IC8vIGhhbmRsZSBuZXh0IGJhdGNoIGlmIHRoZSBxdWV1ZSBpc24ndCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignVG9vIG1hbnkgcXVldWUgZmFpbHVyZXM7IGRpc2FibGluZyBiYXRjaGluZyBzeXN0ZW0uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEFsbEJhdGNoaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGJhdGNoU2VuZENhbGxiYWNrID0gXy5iaW5kKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIEFQSSByZXNwb25zZSBpbiBhIHRyeS1jYXRjaCB0byBtYWtlIHN1cmUgd2UgY2FuIHJlc2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBmbHVzaCBvcGVyYXRpb24gaWYgc29tZXRoaW5nIGdvZXMgd3JvbmdcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy51bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwZXJzaXN0ZWQgZGF0YSB0byBpbmNsdWRlIGhvb2sgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS51cGRhdGVQYXlsb2Fkcyh0cmFuc2Zvcm1lZEl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNPYmplY3QocmVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lcnJvciA9PT0gJ3RpbWVvdXQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUgPj0gdGltZW91dE1TXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignTmV0d29yayB0aW1lb3V0OyByZXRyeWluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNPYmplY3QocmVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmh0dHBTdGF0dXNDb2RlID49IDUwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCByZXMuaHR0cFN0YXR1c0NvZGUgPT09IDQyOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAocmVzLmh0dHBTdGF0dXNDb2RlIDw9IDAgJiYgIWlzT25saW5lKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHJlcy5lcnJvciA9PT0gJ3RpbWVvdXQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldHdvcmsgb3IgQVBJIGVycm9yLCBvciA0MjkgVG9vIE1hbnkgUmVxdWVzdHMsIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0cnlNUyA9IHRoaXMuZmx1c2hJbnRlcnZhbCAqIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLnJldHJ5QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeU1TID0gKHBhcnNlSW50KHJlcy5yZXRyeUFmdGVyLCAxMCkgKiAxMDAwKSB8fCByZXRyeU1TO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlNUyA9IE1hdGgubWluKE1BWF9SRVRSWV9JTlRFUlZBTF9NUywgcmV0cnlNUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvcjsgcmV0cnkgaW4gJyArIHJldHJ5TVMgKyAnIG1zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlRmx1c2gocmV0cnlNUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHJlcykgJiYgcmVzLmh0dHBTdGF0dXNDb2RlID09PSA0MTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQxMyBQYXlsb2FkIFRvbyBMYXJnZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFsdmVkQmF0Y2hTaXplID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihjdXJyZW50QmF0Y2hTaXplIC8gMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplID0gTWF0aC5taW4odGhpcy5iYXRjaFNpemUsIGhhbHZlZEJhdGNoU2l6ZSwgYmF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignNDEzIHJlc3BvbnNlOyByZWR1Y2luZyBiYXRjaCBzaXplIHRvICcgKyB0aGlzLmJhdGNoU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1NpbmdsZS1ldmVudCByZXF1ZXN0IHRvbyBsYXJnZTsgZHJvcHBpbmcnLCBiYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEJhdGNoU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVJdGVtc0Zyb21RdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBuZXR3b3JrIHJlcXVlc3QrcmVzcG9uc2U7IHJlbW92ZSBlYWNoIGl0ZW0gaW4gYmF0Y2ggZnJvbSBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGV2ZW4gaWYgaXQgd2FzIGUuZy4gYSA0MDAsIGluIHdoaWNoIGNhc2UgcmV0cnlpbmcgd29uJ3QgaGVscClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVJdGVtc0Zyb21RdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgaGFuZGxpbmcgQVBJIHJlc3BvbnNlJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgdmVyYm9zZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVfanNvbl9lcnJvcnM6IHRydWUsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICAgICAgdGltZW91dF9tczogdGltZW91dE1TIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMudHJhbnNwb3J0ID0gJ3NlbmRCZWFjb24nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyJDIubG9nKCdNSVhQQU5FTCBSRVFVRVNUOicsIGRhdGFGb3JSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0UHJvbWlzZShkYXRhRm9yUmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpLnRoZW4oYmF0Y2hTZW5kQ2FsbGJhY2spO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGZsdXNoaW5nIHJlcXVlc3QgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogTG9nIGVycm9yIHRvIGdsb2JhbCBsb2dnZXIgYW5kIG9wdGlvbmFsIHVzZXItZGVmaW5lZCBsb2dnZXIuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgbG9nZ2VyJDIuZXJyb3IuYXBwbHkobG9nZ2VyJDIuZXJyb3IsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuZXJyb3JSZXBvcnRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVwb3J0ZXIobXNnLCBlcnIpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyJDIuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBsb2dnZXIkMSA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ3JlY29yZGVyJyk7XG52YXIgQ29tcHJlc3Npb25TdHJlYW0gPSB3aW5bJ0NvbXByZXNzaW9uU3RyZWFtJ107XG5cbnZhciBSRUNPUkRFUl9CQVRDSEVSX0xJQl9DT05GSUcgPSB7XG4gICAgJ2JhdGNoX3NpemUnOiAxMDAwLFxuICAgICdiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyc6IDEwICogMTAwMCxcbiAgICAnYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJzogOTAgKiAxMDAwLFxuICAgICdiYXRjaF9hdXRvc3RhcnQnOiB0cnVlXG59O1xuXG52YXIgQUNUSVZFX1NPVVJDRVMgPSBuZXcgU2V0KFtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZU1vdmUsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbixcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5TY3JvbGwsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemUsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlLFxuICAgIEluY3JlbWVudGFsU291cmNlLk1lZGlhSW50ZXJhY3Rpb24sXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuRHJhZyxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb24sXG5dKTtcblxuZnVuY3Rpb24gaXNVc2VyRXZlbnQoZXYpIHtcbiAgICByZXR1cm4gZXYudHlwZSA9PT0gRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiYgQUNUSVZFX1NPVVJDRVMuaGFzKGV2LmRhdGEuc291cmNlKTtcbn1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIGVuY2Fwc3VsYXRlcyBhIHNpbmdsZSBzZXNzaW9uIHJlY29yZGluZyBhbmQgaXRzIGxpZmVjeWNsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5taXhwYW5lbEluc3RhbmNlXSAtIHJlZmVyZW5jZSB0byB0aGUgY29yZSBNaXhwYW5lbExpYlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlcGxheUlkXSAtIHVuaXF1ZSB1dWlkIGZvciBhIHNpbmdsZSByZXBsYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uSWRsZVRpbWVvdXRdIC0gY2FsbGJhY2sgd2hlbiBhIHJlY29yZGluZyByZWFjaGVzIGlkbGUgdGltZW91dFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25NYXhMZW5ndGhSZWFjaGVkXSAtIGNhbGxiYWNrIHdoZW4gYSByZWNvcmRpbmcgcmVhY2hlcyBpdHMgbWF4aW11bSBsZW5ndGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnJyd2ViUmVjb3JkXSAtIHJyd2ViJ3MgYHJlY29yZGAgZnVuY3Rpb25cbiAqL1xudmFyIFNlc3Npb25SZWNvcmRpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5fbWl4cGFuZWwgPSBvcHRpb25zLm1peHBhbmVsSW5zdGFuY2U7XG4gICAgdGhpcy5fb25JZGxlVGltZW91dCA9IG9wdGlvbnMub25JZGxlVGltZW91dDtcbiAgICB0aGlzLl9vbk1heExlbmd0aFJlYWNoZWQgPSBvcHRpb25zLm9uTWF4TGVuZ3RoUmVhY2hlZDtcbiAgICB0aGlzLl9ycndlYlJlY29yZCA9IG9wdGlvbnMucnJ3ZWJSZWNvcmQ7XG5cbiAgICB0aGlzLnJlcGxheUlkID0gb3B0aW9ucy5yZXBsYXlJZDtcblxuICAgIC8vIGludGVybmFsIHJyd2ViIHN0b3BSZWNvcmRpbmcgZnVuY3Rpb25cbiAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gbnVsbDtcblxuICAgIHRoaXMuc2VxTm8gPSAwO1xuICAgIHRoaXMucmVwbGF5U3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLnJlcGxheVN0YXJ0VXJsID0gbnVsbDtcbiAgICB0aGlzLmJhdGNoU3RhcnRVcmwgPSBudWxsO1xuXG4gICAgdGhpcy5pZGxlVGltZW91dElkID0gbnVsbDtcbiAgICB0aGlzLm1heFRpbWVvdXRJZCA9IG51bGw7XG5cbiAgICB0aGlzLnJlY29yZE1heE1zID0gTUFYX1JFQ09SRElOR19NUztcbiAgICB0aGlzLnJlY29yZE1pbk1zID0gMDtcblxuICAgIC8vIGVhY2ggcmVwbGF5IGhhcyBpdHMgb3duIGJhdGNoZXIga2V5IHRvIGF2b2lkIGNvbmZsaWN0cyBiZXR3ZWVuIHJyd2ViIGV2ZW50cyBvZiBkaWZmZXJlbnQgcmVjb3JkaW5nc1xuICAgIC8vIHRoaXMgd2lsbCBiZSBpbXBvcnRhbnQgd2hlbiBwZXJzaXN0ZW5jZSBpcyBpbnRyb2R1Y2VkXG4gICAgdmFyIGJhdGNoZXJLZXkgPSAnX19tcHJlY18nICsgdGhpcy5nZXRDb25maWcoJ3Rva2VuJykgKyAnXycgKyB0aGlzLnJlcGxheUlkO1xuICAgIHRoaXMuYmF0Y2hlciA9IG5ldyBSZXF1ZXN0QmF0Y2hlcihiYXRjaGVyS2V5LCB7XG4gICAgICAgIGVycm9yUmVwb3J0ZXI6IF8uYmluZCh0aGlzLnJlcG9ydEVycm9yLCB0aGlzKSxcbiAgICAgICAgZmx1c2hPbmx5T25JbnRlcnZhbDogdHJ1ZSxcbiAgICAgICAgbGliQ29uZmlnOiBSRUNPUkRFUl9CQVRDSEVSX0xJQl9DT05GSUcsXG4gICAgICAgIHNlbmRSZXF1ZXN0RnVuYzogXy5iaW5kKHRoaXMuZmx1c2hFdmVudHNXaXRoT3B0T3V0LCB0aGlzKSxcbiAgICAgICAgdXNlUGVyc2lzdGVuY2U6IGZhbHNlXG4gICAgfSk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbihjb25maWdWYXIpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuZ2V0X2NvbmZpZyhjb25maWdWYXIpO1xufTtcblxuLy8gQWxpYXMgZm9yIGdldENvbmZpZywgdXNlZCBieSB0aGUgY29tbW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIgZnVuY3Rpb24gd2hpY2hcbi8vIHJlYWNoZXMgaW50byB0aGlzIGNsYXNzIGluc3RhbmNlIGFuZCBleHBlY3RzIHRoZSBzbmFrZSBjYXNlIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZ1Zhcikge1xuICAgIHJldHVybiB0aGlzLmdldENvbmZpZyhjb25maWdWYXIpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuc3RhcnRSZWNvcmRpbmcgPSBmdW5jdGlvbiAoc2hvdWxkU3RvcEJhdGNoZXIpIHtcbiAgICBpZiAodGhpcy5fc3RvcFJlY29yZGluZyAhPT0gbnVsbCkge1xuICAgICAgICBsb2dnZXIkMS5sb2coJ1JlY29yZGluZyBhbHJlYWR5IGluIHByb2dyZXNzLCBza2lwcGluZyBzdGFydFJlY29yZGluZy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVjb3JkTWF4TXMgPSB0aGlzLmdldENvbmZpZygncmVjb3JkX21heF9tcycpO1xuICAgIGlmICh0aGlzLnJlY29yZE1heE1zID4gTUFYX1JFQ09SRElOR19NUykge1xuICAgICAgICB0aGlzLnJlY29yZE1heE1zID0gTUFYX1JFQ09SRElOR19NUztcbiAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ3JlY29yZF9tYXhfbXMgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAnICsgTUFYX1JFQ09SRElOR19NUyArICdtcy4gQ2FwcGluZyB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlY29yZE1pbk1zID0gdGhpcy5nZXRDb25maWcoJ3JlY29yZF9taW5fbXMnKTtcbiAgICBpZiAodGhpcy5yZWNvcmRNaW5NcyA+IE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUykge1xuICAgICAgICB0aGlzLnJlY29yZE1pbk1zID0gTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TO1xuICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgncmVjb3JkX21pbl9tcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICcgKyBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMgKyAnbXMuIENhcHBpbmcgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXBsYXlTdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB0aGlzLmJhdGNoU3RhcnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgIHRoaXMucmVwbGF5U3RhcnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuXG4gICAgaWYgKHNob3VsZFN0b3BCYXRjaGVyIHx8IHRoaXMucmVjb3JkTWluTXMgPiAwKSB7XG4gICAgICAgIC8vIHRoZSBwcmltYXJ5IGNhc2UgZm9yIHNob3VsZFN0b3BCYXRjaGVyIGlzIHdoZW4gd2UncmUgc3RhcnRpbmcgcmVjb3JkaW5nIGFmdGVyIGEgcmVzZXRcbiAgICAgICAgLy8gYW5kIGRvbid0IHdhbnQgdG8gc2VuZCBhbnl0aGluZyBvdmVyIHRoZSBuZXR3b3JrIHVudGlsIHRoZXJlJ3NcbiAgICAgICAgLy8gYWN0dWFsIHVzZXIgYWN0aXZpdHlcbiAgICAgICAgLy8gdGhpcyBhbHNvIGFwcGxpZXMgaWYgdGhlIG1pbmltdW0gcmVjb3JkaW5nIGxlbmd0aCBoYXMgbm90IGJlZW4gaGl0IHlldFxuICAgICAgICAvLyBzbyB0aGF0IHdlIGRvbid0IHNlbmQgZGF0YSB1bnRpbCB3ZSBrbm93IHRoZSByZWNvcmRpbmcgd2lsbCBiZSBsb25nIGVub3VnaFxuICAgICAgICB0aGlzLmJhdGNoZXIuc3RvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmF0Y2hlci5zdGFydCgpO1xuICAgIH1cblxuICAgIHZhciByZXNldElkbGVUaW1lb3V0ID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fb25JZGxlVGltZW91dCwgdGhpcy5nZXRDb25maWcoJ3JlY29yZF9pZGxlX3RpbWVvdXRfbXMnKSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB2YXIgYmxvY2tTZWxlY3RvciA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfYmxvY2tfc2VsZWN0b3InKTtcbiAgICBpZiAoYmxvY2tTZWxlY3RvciA9PT0gJycgfHwgYmxvY2tTZWxlY3RvciA9PT0gbnVsbCkge1xuICAgICAgICBibG9ja1NlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcgPSB0aGlzLl9ycndlYlJlY29yZCh7XG4gICAgICAgICdlbWl0JzogXy5iaW5kKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdGhpcy5iYXRjaGVyLmVucXVldWUoZXYpO1xuICAgICAgICAgICAgaWYgKGlzVXNlckV2ZW50KGV2KSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhdGNoZXIuc3RvcHBlZCAmJiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMucmVwbGF5U3RhcnRUaW1lID49IHRoaXMucmVjb3JkTWluTXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgZmx1c2hpbmcgYWdhaW4gYWZ0ZXIgdXNlciBhY3Rpdml0eVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhdGNoZXIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzZXRJZGxlVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgJ2Jsb2NrQ2xhc3MnOiB0aGlzLmdldENvbmZpZygncmVjb3JkX2Jsb2NrX2NsYXNzJyksXG4gICAgICAgICdibG9ja1NlbGVjdG9yJzogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgJ2NvbGxlY3RGb250cyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfY29sbGVjdF9mb250cycpLFxuICAgICAgICAnZGF0YVVSTE9wdGlvbnMnOiB7IC8vIGNhbnZhcyBpbWFnZSBvcHRpb25zIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvdG9EYXRhVVJMKVxuICAgICAgICAgICAgJ3R5cGUnOiAnaW1hZ2Uvd2VicCcsXG4gICAgICAgICAgICAncXVhbGl0eSc6IDAuNlxuICAgICAgICB9LFxuICAgICAgICAnbWFza0FsbElucHV0cyc6IHRydWUsXG4gICAgICAgICdtYXNrVGV4dENsYXNzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXNrX3RleHRfY2xhc3MnKSxcbiAgICAgICAgJ21hc2tUZXh0U2VsZWN0b3InOiB0aGlzLmdldENvbmZpZygncmVjb3JkX21hc2tfdGV4dF9zZWxlY3RvcicpLFxuICAgICAgICAncmVjb3JkQ2FudmFzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9jYW52YXMnKSxcbiAgICAgICAgJ3NhbXBsaW5nJzoge1xuICAgICAgICAgICAgJ2NhbnZhcyc6IDE1XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5fc3RvcFJlY29yZGluZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdycndlYiBmYWlsZWQgdG8gc3RhcnQsIHNraXBwaW5nIHRoaXMgcmVjb3JkaW5nLicpO1xuICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nKCk7IC8vIHN0b3AgYmF0Y2hlciBsb29waW5nIGFuZCBhbnkgdGltZW91dHNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc2V0SWRsZVRpbWVvdXQoKTtcblxuICAgIHRoaXMubWF4VGltZW91dElkID0gc2V0VGltZW91dChfLmJpbmQodGhpcy5fb25NYXhMZW5ndGhSZWFjaGVkLCB0aGlzKSwgdGhpcy5yZWNvcmRNYXhNcyk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5zdG9wUmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3Igd2l0aCBycndlYiBzdG9wUmVjb3JkaW5nJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iYXRjaGVyLnN0b3BwZWQpIHtcbiAgICAgICAgLy8gbmV2ZXIgZ290IHVzZXIgYWN0aXZpdHkgdG8gZmx1c2ggYWZ0ZXIgcmVzZXQsIHNvIGp1c3QgY2xlYXIgdGhlIGJhdGNoZXJcbiAgICAgICAgdGhpcy5iYXRjaGVyLmNsZWFyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmx1c2ggYW55IHJlbWFpbmluZyBldmVudHMgZnJvbSBydW5uaW5nIGJhdGNoZXJcbiAgICAgICAgdGhpcy5iYXRjaGVyLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuYmF0Y2hlci5zdG9wKCk7XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRJZCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubWF4VGltZW91dElkKTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLmlzUnJ3ZWJTdG9wcGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9wUmVjb3JkaW5nID09PSBudWxsO1xufTtcblxuLyoqXG4gKiBGbHVzaGVzIHRoZSBjdXJyZW50IGJhdGNoIG9mIGV2ZW50cyB0byB0aGUgc2VydmVyLCBidXQgcGFzc2VzIGFuIG9wdC1vdXQgY2FsbGJhY2sgdG8gbWFrZSBzdXJlXG4gKiB3ZSBzdG9wIHJlY29yZGluZyBhbmQgZHVtcCBhbnkgcXVldWVkIGV2ZW50cyBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LlxuICovXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5mbHVzaEV2ZW50c1dpdGhPcHRPdXQgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICB0aGlzLl9mbHVzaEV2ZW50cyhkYXRhLCBvcHRpb25zLCBjYiwgXy5iaW5kKHRoaXMuX29uT3B0T3V0LCB0aGlzKSk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5fb25PcHRPdXQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIC8vIGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIgaW52b2tlcyB0aGlzIGZ1bmN0aW9uIHdpdGggY29kZT0wIHdoZW4gdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpO1xuICAgIH1cbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLl9zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uKGN1cnJlbnRSZXBsYXlJZCwgcmVxUGFyYW1zLCByZXFCb2R5LCBjYWxsYmFjaykge1xuICAgIHZhciBvblN1Y2Nlc3MgPSBfLmJpbmQoZnVuY3Rpb24gKHJlc3BvbnNlLCByZXNwb25zZUJvZHkpIHtcbiAgICAgICAgLy8gVXBkYXRlIGJhdGNoIHNwZWNpZmljIHByb3BzIG9ubHkgaWYgdGhlIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWwgdG8gZ3VhcmFudGVlIG9yZGVyaW5nLlxuICAgICAgICAvLyBSZXF1ZXN0QmF0Y2hlciB3aWxsIGFsd2F5cyBmbHVzaCB0aGUgbmV4dCBiYXRjaCBhZnRlciB0aGUgcHJldmlvdXMgb25lIHN1Y2NlZWRzLlxuICAgICAgICAvLyBleHRyYSBjaGVjayB0byBzZWUgaWYgdGhlIHJlcGxheSBJRCBoYXMgY2hhbmdlZCBzbyB0aGF0IHdlIGRvbid0IGluY3JlbWVudCB0aGUgc2VxTm8gb24gdGhlIHdyb25nIHJlcGxheVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgJiYgdGhpcy5yZXBsYXlJZCA9PT0gY3VycmVudFJlcGxheUlkKSB7XG4gICAgICAgICAgICB0aGlzLnNlcU5vKys7XG4gICAgICAgICAgICB0aGlzLmJhdGNoU3RhcnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgICAgIGh0dHBTdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICByZXNwb25zZUJvZHk6IHJlc3BvbnNlQm9keSxcbiAgICAgICAgICAgIHJldHJ5QWZ0ZXI6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdSZXRyeS1BZnRlcicpXG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgd2luWydmZXRjaCddKHRoaXMuZ2V0Q29uZmlnKCdhcGlfaG9zdCcpICsgJy8nICsgdGhpcy5nZXRDb25maWcoJ2FwaV9yb3V0ZXMnKVsncmVjb3JkJ10gKyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHJlcVBhcmFtcyksIHtcbiAgICAgICAgJ21ldGhvZCc6ICdQT1NUJyxcbiAgICAgICAgJ2hlYWRlcnMnOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCYXNpYyAnICsgYnRvYSh0aGlzLmdldENvbmZpZygndG9rZW4nKSArICc6JyksXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ2JvZHknOiByZXFCb2R5LFxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc3BvbnNlLmpzb24oKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgIG9uU3VjY2VzcyhyZXNwb25zZSwgcmVzcG9uc2VCb2R5KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7ZXJyb3I6IGVycm9yfSk7XG4gICAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayh7ZXJyb3I6IGVycm9yLCBodHRwU3RhdHVzQ29kZTogMH0pO1xuICAgIH0pO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuX2ZsdXNoRXZlbnRzID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBudW1FdmVudHMgPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmIChudW1FdmVudHMgPiAwKSB7XG4gICAgICAgIHZhciByZXBsYXlJZCA9IHRoaXMucmVwbGF5SWQ7XG4gICAgICAgIC8vIGVhY2ggcnJ3ZWIgZXZlbnQgaGFzIGEgdGltZXN0YW1wIC0gbGV2ZXJhZ2UgdGhvc2UgdG8gZ2V0IHRpbWUgcHJvcGVydGllc1xuICAgICAgICB2YXIgYmF0Y2hTdGFydFRpbWUgPSBkYXRhWzBdLnRpbWVzdGFtcDtcbiAgICAgICAgaWYgKHRoaXMuc2VxTm8gPT09IDAgfHwgIXRoaXMucmVwbGF5U3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAvLyBleHRyYSBzYWZldHkgbmV0IHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCBhIG51bGwgcmVwbGF5IHN0YXJ0IHRpbWVcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcU5vICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignUmVwbGF5IHN0YXJ0IHRpbWUgbm90IHNldCBidXQgc2VxTm8gaXMgbm90IDAuIFVzaW5nIGN1cnJlbnQgYmF0Y2ggc3RhcnQgdGltZSBhcyBhIGZhbGxiYWNrLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IGJhdGNoU3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXBsYXlMZW5ndGhNcyA9IGRhdGFbbnVtRXZlbnRzIC0gMV0udGltZXN0YW1wIC0gdGhpcy5yZXBsYXlTdGFydFRpbWU7XG5cbiAgICAgICAgdmFyIHJlcVBhcmFtcyA9IHtcbiAgICAgICAgICAgICckY3VycmVudF91cmwnOiB0aGlzLmJhdGNoU3RhcnRVcmwsXG4gICAgICAgICAgICAnJGxpYl92ZXJzaW9uJzogQ29uZmlnLkxJQl9WRVJTSU9OLFxuICAgICAgICAgICAgJ2JhdGNoX3N0YXJ0X3RpbWUnOiBiYXRjaFN0YXJ0VGltZSAvIDEwMDAsXG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBTdHJpbmcodGhpcy5fbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCkpLFxuICAgICAgICAgICAgJ21wX2xpYic6ICd3ZWInLFxuICAgICAgICAgICAgJ3JlcGxheV9pZCc6IHJlcGxheUlkLFxuICAgICAgICAgICAgJ3JlcGxheV9sZW5ndGhfbXMnOiByZXBsYXlMZW5ndGhNcyxcbiAgICAgICAgICAgICdyZXBsYXlfc3RhcnRfdGltZSc6IHRoaXMucmVwbGF5U3RhcnRUaW1lIC8gMTAwMCxcbiAgICAgICAgICAgICdyZXBsYXlfc3RhcnRfdXJsJzogdGhpcy5yZXBsYXlTdGFydFVybCxcbiAgICAgICAgICAgICdzZXEnOiB0aGlzLnNlcU5vXG4gICAgICAgIH07XG4gICAgICAgIHZhciBldmVudHNKc29uID0gXy5KU09ORW5jb2RlKGRhdGEpO1xuXG4gICAgICAgIC8vIHNlbmQgSUQgbWFuYWdlbWVudCBwcm9wcyBpZiB0aGV5IGV4aXN0XG4gICAgICAgIHZhciBkZXZpY2VJZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJGRldmljZV9pZCcpO1xuICAgICAgICBpZiAoZGV2aWNlSWQpIHtcbiAgICAgICAgICAgIHJlcVBhcmFtc1snJGRldmljZV9pZCddID0gZGV2aWNlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVzZXJJZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJHVzZXJfaWQnKTtcbiAgICAgICAgaWYgKHVzZXJJZCkge1xuICAgICAgICAgICAgcmVxUGFyYW1zWyckdXNlcl9pZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbXByZXNzaW9uU3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIganNvblN0cmVhbSA9IG5ldyBCbG9iKFtldmVudHNKc29uXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qc29uJ30pLnN0cmVhbSgpO1xuICAgICAgICAgICAgdmFyIGd6aXBTdHJlYW0gPSBqc29uU3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBDb21wcmVzc2lvblN0cmVhbSgnZ3ppcCcpKTtcbiAgICAgICAgICAgIG5ldyBSZXNwb25zZShnemlwU3RyZWFtKVxuICAgICAgICAgICAgICAgIC5ibG9iKClcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24oY29tcHJlc3NlZEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxUGFyYW1zWydmb3JtYXQnXSA9ICdnemlwJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZFJlcXVlc3QocmVwbGF5SWQsIHJlcVBhcmFtcywgY29tcHJlc3NlZEJsb2IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXFQYXJhbXNbJ2Zvcm1hdCddID0gJ2JvZHknO1xuICAgICAgICAgICAgdGhpcy5fc2VuZFJlcXVlc3QocmVwbGF5SWQsIHJlcVBhcmFtcywgZXZlbnRzSnNvbiwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihtc2csIGVycikge1xuICAgIGxvZ2dlciQxLmVycm9yLmFwcGx5KGxvZ2dlciQxLmVycm9yLCBhcmd1bWVudHMpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghZXJyICYmICEobXNnIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICBtc2cgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldENvbmZpZygnZXJyb3JfcmVwb3J0ZXInKShtc2csIGVycik7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgbG9nZ2VyJDEuZXJyb3IoZXJyKTtcbiAgICB9XG59O1xuXG52YXIgbG9nZ2VyID0gY29uc29sZV93aXRoX3ByZWZpeCgncmVjb3JkZXInKTtcblxuLyoqXG4gKiBSZWNvcmRlciBBUEk6IG1hbmFnZXMgcmVjb3JkaW5ncyBhbmQgZXhwb3NlcyBtZXRob2RzIHB1YmxpYyB0byB0aGUgY29yZSBNaXhwYW5lbCBsaWJyYXJ5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1peHBhbmVsSW5zdGFuY2VdIC0gcmVmZXJlbmNlIHRvIHRoZSBjb3JlIE1peHBhbmVsTGliXG4gKi9cbnZhciBNaXhwYW5lbFJlY29yZGVyID0gZnVuY3Rpb24obWl4cGFuZWxJbnN0YW5jZSkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxJbnN0YW5jZTtcbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG51bGw7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5zdGFydFJlY29yZGluZyA9IGZ1bmN0aW9uKHNob3VsZFN0b3BCYXRjaGVyKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nICYmICF0aGlzLmFjdGl2ZVJlY29yZGluZy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ1JlY29yZGluZyBhbHJlYWR5IGluIHByb2dyZXNzLCBza2lwcGluZyBzdGFydFJlY29yZGluZy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvbklkbGVUaW1lb3V0ID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSWRsZSB0aW1lb3V0IHJlYWNoZWQsIHJlc3RhcnRpbmcgcmVjb3JkaW5nLicpO1xuICAgICAgICB0aGlzLnJlc2V0UmVjb3JkaW5nKCk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB2YXIgb25NYXhMZW5ndGhSZWFjaGVkID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnTWF4IHJlY29yZGluZyBsZW5ndGggcmVhY2hlZCwgc3RvcHBpbmcgcmVjb3JkaW5nLicpO1xuICAgICAgICB0aGlzLnJlc2V0UmVjb3JkaW5nKCk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG5ldyBTZXNzaW9uUmVjb3JkaW5nKHtcbiAgICAgICAgbWl4cGFuZWxJbnN0YW5jZTogdGhpcy5fbWl4cGFuZWwsXG4gICAgICAgIG9uSWRsZVRpbWVvdXQ6IG9uSWRsZVRpbWVvdXQsXG4gICAgICAgIG9uTWF4TGVuZ3RoUmVhY2hlZDogb25NYXhMZW5ndGhSZWFjaGVkLFxuICAgICAgICByZXBsYXlJZDogXy5VVUlEKCksXG4gICAgICAgIHJyd2ViUmVjb3JkOiByZWNvcmRcbiAgICB9KTtcblxuICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnN0YXJ0UmVjb3JkaW5nKHNob3VsZFN0b3BCYXRjaGVyKTtcbn07XG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLnN0b3BSZWNvcmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZWNvcmRpbmcpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcuc3RvcFJlY29yZGluZygpO1xuICAgICAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG51bGw7XG4gICAgfVxufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUucmVzZXRSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9wUmVjb3JkaW5nKCk7XG4gICAgdGhpcy5zdGFydFJlY29yZGluZyh0cnVlKTtcbn07XG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLmdldEFjdGl2ZVJlcGxheUlkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlY29yZGluZyAmJiAhdGhpcy5hY3RpdmVSZWNvcmRpbmcuaXNScndlYlN0b3BwZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVSZWNvcmRpbmcucmVwbGF5SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLy8gZ2V0dGVyIHNvIHRoYXQgb2xkZXIgbWl4cGFuZWwtY29yZSB2ZXJzaW9ucyBjYW4gc3RpbGwgcmV0cmlldmUgdGhlIHJlcGxheSBJRFxuLy8gd2hlbiBwdWxsaW5nIHRoZSBsYXRlc3QgcmVjb3JkZXIgYnVuZGxlIGZyb20gdGhlIENETlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLCAncmVwbGF5SWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZVJlcGxheUlkKCk7XG4gICAgfVxufSk7XG5cbndpblsnX19tcF9yZWNvcmRlciddID0gTWl4cGFuZWxSZWNvcmRlcjtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKipcbiAqIERvbVRyYWNrZXIgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERvbVRyYWNrZXIgPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8vIGludGVyZmFjZVxuRG9tVHJhY2tlci5wcm90b3R5cGUuY3JlYXRlX3Byb3BlcnRpZXMgPSBmdW5jdGlvbigpIHt9O1xuRG9tVHJhY2tlci5wcm90b3R5cGUuZXZlbnRfaGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG5Eb21UcmFja2VyLnByb3RvdHlwZS5hZnRlcl90cmFja19oYW5kbGVyID0gZnVuY3Rpb24oKSB7fTtcblxuRG9tVHJhY2tlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG1peHBhbmVsX2luc3RhbmNlKSB7XG4gICAgdGhpcy5tcCA9IG1peHBhbmVsX2luc3RhbmNlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uPX0gdXNlcl9jYWxsYmFja1xuICovXG5Eb21UcmFja2VyLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uKHF1ZXJ5LCBldmVudF9uYW1lLCBwcm9wZXJ0aWVzLCB1c2VyX2NhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBlbGVtZW50cyA9IF8uZG9tX3F1ZXJ5KHF1ZXJ5KTtcblxuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdUaGUgRE9NIHF1ZXJ5ICgnICsgcXVlcnkgKyAnKSByZXR1cm5lZCAwIGVsZW1lbnRzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfLmVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgXy5yZWdpc3Rlcl9ldmVudChlbGVtZW50LCB0aGlzLm92ZXJyaWRlX2V2ZW50LCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb3BzID0gdGhhdC5jcmVhdGVfcHJvcGVydGllcyhwcm9wZXJ0aWVzLCB0aGlzKTtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gdGhhdC5tcC5nZXRfY29uZmlnKCd0cmFja19saW5rc190aW1lb3V0Jyk7XG5cbiAgICAgICAgICAgIHRoYXQuZXZlbnRfaGFuZGxlcihlLCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgbWl4cGFuZWwgc2VydmVycyBkb24ndCBnZXQgYmFjayB0byB1cyBpbiB0aW1lXG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCh0aGF0LnRyYWNrX2NhbGxiYWNrKHVzZXJfY2FsbGJhY2ssIHByb3BzLCBvcHRpb25zLCB0cnVlKSwgdGltZW91dCk7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgdGhlIHRyYWNraW5nIGV2ZW50XG4gICAgICAgICAgICB0aGF0Lm1wLnRyYWNrKGV2ZW50X25hbWUsIHByb3BzLCB0aGF0LnRyYWNrX2NhbGxiYWNrKHVzZXJfY2FsbGJhY2ssIHByb3BzLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHVzZXJfY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtib29sZWFuPX0gdGltZW91dF9vY2N1cmVkXG4gKi9cbkRvbVRyYWNrZXIucHJvdG90eXBlLnRyYWNrX2NhbGxiYWNrID0gZnVuY3Rpb24odXNlcl9jYWxsYmFjaywgcHJvcHMsIG9wdGlvbnMsIHRpbWVvdXRfb2NjdXJlZCkge1xuICAgIHRpbWVvdXRfb2NjdXJlZCA9IHRpbWVvdXRfb2NjdXJlZCB8fCBmYWxzZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG9wdGlvbnMgaXMgcmVmZXJlbmNlZCBmcm9tIGJvdGggY2FsbGJhY2tzLCBzbyB3ZSBjYW4gaGF2ZVxuICAgICAgICAvLyBhICdsb2NrJyBvZiBzb3J0cyB0byBlbnN1cmUgb25seSBvbmUgZmlyZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2tfZmlyZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2tfZmlyZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh1c2VyX2NhbGxiYWNrICYmIHVzZXJfY2FsbGJhY2sodGltZW91dF9vY2N1cmVkLCBwcm9wcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyB1c2VyIGNhbiBwcmV2ZW50IHRoZSBkZWZhdWx0IGZ1bmN0aW9uYWxpdHkgYnlcbiAgICAgICAgICAgIC8vIHJldHVybmluZyBmYWxzZSBmcm9tIHRoZWlyIGNhbGxiYWNrXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0LmFmdGVyX3RyYWNrX2hhbmRsZXIocHJvcHMsIG9wdGlvbnMsIHRpbWVvdXRfb2NjdXJlZCk7XG4gICAgfTtcbn07XG5cbkRvbVRyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydGllcywgZWxlbWVudCkge1xuICAgIHZhciBwcm9wcztcblxuICAgIGlmICh0eXBlb2YocHJvcGVydGllcykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wZXJ0aWVzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BzID0gXy5leHRlbmQoe30sIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbi8qKlxuICogTGlua1RyYWNrZXIgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERvbVRyYWNrZXJcbiAqL1xudmFyIExpbmtUcmFja2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vdmVycmlkZV9ldmVudCA9ICdjbGljayc7XG59O1xuXy5pbmhlcml0KExpbmtUcmFja2VyLCBEb21UcmFja2VyKTtcblxuTGlua1RyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydGllcywgZWxlbWVudCkge1xuICAgIHZhciBwcm9wcyA9IExpbmtUcmFja2VyLnN1cGVyY2xhc3MuY3JlYXRlX3Byb3BlcnRpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmIChlbGVtZW50LmhyZWYpIHsgcHJvcHNbJ3VybCddID0gZWxlbWVudC5ocmVmOyB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG5MaW5rVHJhY2tlci5wcm90b3R5cGUuZXZlbnRfaGFuZGxlciA9IGZ1bmN0aW9uKGV2dCwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMubmV3X3RhYiA9IChcbiAgICAgICAgZXZ0LndoaWNoID09PSAyIHx8XG4gICAgICAgIGV2dC5tZXRhS2V5IHx8XG4gICAgICAgIGV2dC5jdHJsS2V5IHx8XG4gICAgICAgIGVsZW1lbnQudGFyZ2V0ID09PSAnX2JsYW5rJ1xuICAgICk7XG4gICAgb3B0aW9ucy5ocmVmID0gZWxlbWVudC5ocmVmO1xuXG4gICAgaWYgKCFvcHRpb25zLm5ld190YWIpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxuTGlua1RyYWNrZXIucHJvdG90eXBlLmFmdGVyX3RyYWNrX2hhbmRsZXIgPSBmdW5jdGlvbihwcm9wcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLm5ld190YWIpIHsgcmV0dXJuOyB9XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSBvcHRpb25zLmhyZWY7XG4gICAgfSwgMCk7XG59O1xuXG4vKipcbiAqIEZvcm1UcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEb21UcmFja2VyXG4gKi9cbnZhciBGb3JtVHJhY2tlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3ZlcnJpZGVfZXZlbnQgPSAnc3VibWl0Jztcbn07XG5fLmluaGVyaXQoRm9ybVRyYWNrZXIsIERvbVRyYWNrZXIpO1xuXG5Gb3JtVHJhY2tlci5wcm90b3R5cGUuZXZlbnRfaGFuZGxlciA9IGZ1bmN0aW9uKGV2dCwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG5Gb3JtVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKHByb3BzLCBvcHRpb25zKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb3B0aW9ucy5lbGVtZW50LnN1Ym1pdCgpO1xuICAgIH0sIDApO1xufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKiogQGNvbnN0ICovIHZhciBTRVRfQUNUSU9OICAgICAgPSAnJHNldCc7XG4vKiogQGNvbnN0ICovIHZhciBTRVRfT05DRV9BQ1RJT04gPSAnJHNldF9vbmNlJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOU0VUX0FDVElPTiAgICA9ICckdW5zZXQnO1xuLyoqIEBjb25zdCAqLyB2YXIgQUREX0FDVElPTiAgICAgID0gJyRhZGQnO1xuLyoqIEBjb25zdCAqLyB2YXIgQVBQRU5EX0FDVElPTiAgID0gJyRhcHBlbmQnO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5JT05fQUNUSU9OICAgID0gJyR1bmlvbic7XG4vKiogQGNvbnN0ICovIHZhciBSRU1PVkVfQUNUSU9OICAgPSAnJHJlbW92ZSc7XG4vKiogQGNvbnN0ICovIHZhciBERUxFVEVfQUNUSU9OICAgPSAnJGRlbGV0ZSc7XG5cbi8vIENvbW1vbiBpbnRlcm5hbCBtZXRob2RzIGZvciBtaXhwYW5lbC5wZW9wbGUgYW5kIG1peHBhbmVsLmdyb3VwIEFQSXMuXG4vLyBUaGVzZSBtZXRob2RzIHNob3VsZG4ndCBpbnZvbHZlIG5ldHdvcmsgSS9PLlxudmFyIGFwaUFjdGlvbnMgPSB7XG4gICAgc2V0X2FjdGlvbjogZnVuY3Rpb24ocHJvcCwgdG8pIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRzZXQgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkc2V0W2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzZXRbcHJvcF0gPSB0bztcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbU0VUX0FDVElPTl0gPSAkc2V0O1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgdW5zZXRfYWN0aW9uOiBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkdW5zZXQgPSBbXTtcbiAgICAgICAgaWYgKCFfLmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgICAgIHByb3AgPSBbcHJvcF07XG4gICAgICAgIH1cblxuICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICR1bnNldC5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBkYXRhW1VOU0VUX0FDVElPTl0gPSAkdW5zZXQ7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBzZXRfb25jZV9hY3Rpb246IGZ1bmN0aW9uKHByb3AsIHRvKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkc2V0X29uY2UgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkc2V0X29uY2Vba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNldF9vbmNlW3Byb3BdID0gdG87XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtTRVRfT05DRV9BQ1RJT05dID0gJHNldF9vbmNlO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgdW5pb25fYWN0aW9uOiBmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHVuaW9uID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgICAgIF8uZWFjaChsaXN0X25hbWUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICR1bmlvbltrXSA9IF8uaXNBcnJheSh2KSA/IHYgOiBbdl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkdW5pb25bbGlzdF9uYW1lXSA9IF8uaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzIDogW3ZhbHVlc107XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtVTklPTl9BQ1RJT05dID0gJHVuaW9uO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgYXBwZW5kX2FjdGlvbjogZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJGFwcGVuZCA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgICAgICBfLmVhY2gobGlzdF9uYW1lLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkYXBwZW5kW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhcHBlbmRbbGlzdF9uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbQVBQRU5EX0FDVElPTl0gPSAkYXBwZW5kO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlX2FjdGlvbjogZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHJlbW92ZSA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgICAgICBfLmVhY2gobGlzdF9uYW1lLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkcmVtb3ZlW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRyZW1vdmVbbGlzdF9uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbUkVNT1ZFX0FDVElPTl0gPSAkcmVtb3ZlO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgZGVsZXRlX2FjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIGRhdGFbREVMRVRFX0FDVElPTl0gPSAnJztcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKipcbiAqIE1peHBhbmVsIEdyb3VwIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbEdyb3VwID0gZnVuY3Rpb24oKSB7fTtcblxuXy5leHRlbmQoTWl4cGFuZWxHcm91cC5wcm90b3R5cGUsIGFwaUFjdGlvbnMpO1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKG1peHBhbmVsX2luc3RhbmNlLCBncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgdGhpcy5fbWl4cGFuZWwgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbiAgICB0aGlzLl9ncm91cF9rZXkgPSBncm91cF9rZXk7XG4gICAgdGhpcy5fZ3JvdXBfaWQgPSBncm91cF9pZDtcbn07XG5cbi8qKlxuICogU2V0IHByb3BlcnRpZXMgb24gYSBncm91cC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldCgnTG9jYXRpb24nLCAnNDA1IEhvd2FyZCcpO1xuICpcbiAqICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0KHtcbiAqICAgICAgICAgICdMb2NhdGlvbic6ICc0MDUgSG93YXJkJyxcbiAqICAgICAgICAgICdGb3VuZGVkJyA6IDIwMDksXG4gKiAgICAgfSk7XG4gKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMsIGRhdGVzLCBvciBsaXN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBTZXQgcHJvcGVydGllcyBvbiBhIGdyb3VwLCBvbmx5IGlmIHRoZXkgZG8gbm90IHlldCBleGlzdC5cbiAqIFRoaXMgd2lsbCBub3Qgb3ZlcndyaXRlIHByZXZpb3VzIGdyb3VwIHByb3BlcnR5IHZhbHVlcywgdW5saWtlXG4gKiBncm91cC5zZXQoKS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldF9vbmNlKCdMb2NhdGlvbicsICc0MDUgSG93YXJkJyk7XG4gKlxuICogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXRfb25jZSh7XG4gKiAgICAgICAgICAnTG9jYXRpb24nOiAnNDA1IEhvd2FyZCcsXG4gKiAgICAgICAgICAnRm91bmRlZCcgOiAyMDA5LFxuICogICAgIH0pO1xuICogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzLCBsaXN0cyBvciBkYXRlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldF9vbmNlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfb25jZV9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogVW5zZXQgcHJvcGVydGllcyBvbiBhIGdyb3VwIHBlcm1hbmVudGx5LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykudW5zZXQoJ0ZvdW5kZWQnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuc2V0X2FjdGlvbihwcm9wKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIE1lcmdlIGEgZ2l2ZW4gbGlzdCB3aXRoIGEgbGlzdC12YWx1ZWQgZ3JvdXAgcHJvcGVydHksIGV4Y2x1ZGluZyBkdXBsaWNhdGUgdmFsdWVzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gbWVyZ2UgYSB2YWx1ZSB0byBhIGxpc3QsIGNyZWF0aW5nIGl0IGlmIG5lZWRlZFxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnVuaW9uKCdMb2NhdGlvbicsIFsnU2FuIEZyYW5jaXNjbycsICdMb25kb24nXSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxpc3RfbmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBWYWx1ZXMgdG8gbWVyZ2Ugd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydHlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5pb24gPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlcztcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuaW9uX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlcyk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBQZXJtYW5lbnRseSBkZWxldGUgYSBncm91cC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLmRlbGV0ZSgpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgLy8gYnJhY2tldCBub3RhdGlvbiBhYm92ZSBwcmV2ZW50cyBhIG1pbmlmaWNhdGlvbiBlcnJvciByZWxhdGVkIHRvIHJlc2VydmVkIHdvcmRzXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRlbGV0ZV9hY3Rpb24oKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFJlbW92ZSBhIHByb3BlcnR5IGZyb20gYSBncm91cC4gVGhlIHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpZiBkb2Vzbid0IGV4aXN0LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykucmVtb3ZlKCdMb2NhdGlvbicsICdMb25kb24nKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGlzdF9uYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFZhbHVlIHRvIHJlbW92ZSBmcm9tIHRoZSBnaXZlbiBncm91cCBwcm9wZXJ0eVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5yZW1vdmUgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMucmVtb3ZlX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5fc2VuZF9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgICBkYXRhWyckZ3JvdXBfa2V5J10gPSB0aGlzLl9ncm91cF9rZXk7XG4gICAgZGF0YVsnJGdyb3VwX2lkJ10gPSB0aGlzLl9ncm91cF9pZDtcbiAgICBkYXRhWyckdG9rZW4nXSA9IHRoaXMuX2dldF9jb25maWcoJ3Rva2VuJyk7XG5cbiAgICB2YXIgZGF0ZV9lbmNvZGVkX2RhdGEgPSBfLmVuY29kZURhdGVzKGRhdGEpO1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5fdHJhY2tfb3JfYmF0Y2goe1xuICAgICAgICB0eXBlOiAnZ3JvdXBzJyxcbiAgICAgICAgZGF0YTogZGF0ZV9lbmNvZGVkX2RhdGEsXG4gICAgICAgIGVuZHBvaW50OiB0aGlzLl9nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgJy8nICsgIHRoaXMuX2dldF9jb25maWcoJ2FwaV9yb3V0ZXMnKVsnZ3JvdXBzJ10sXG4gICAgICAgIGJhdGNoZXI6IHRoaXMuX21peHBhbmVsLnJlcXVlc3RfYmF0Y2hlcnMuZ3JvdXBzXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2lzX3Jlc2VydmVkX3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBwcm9wID09PSAnJGdyb3VwX2tleScgfHwgcHJvcCA9PT0gJyRncm91cF9pZCc7XG59O1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5fZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmYpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuZ2V0X2NvbmZpZyhjb25mKTtcbn07XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLnRvU3RyaW5nKCkgKyAnLmdyb3VwLicgKyB0aGlzLl9ncm91cF9rZXkgKyAnLicgKyB0aGlzLl9ncm91cF9pZDtcbn07XG5cbi8vIE1peHBhbmVsR3JvdXAgRXhwb3J0c1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3JlbW92ZSddICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5yZW1vdmU7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnc2V0J10gICAgICA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldDtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydzZXRfb25jZSddID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0X29uY2U7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsndW5pb24nXSAgICA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuaW9uO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3Vuc2V0J10gICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bnNldDtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWyd0b1N0cmluZyddID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqXG4gKiBNaXhwYW5lbCBQZW9wbGUgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsUGVvcGxlID0gZnVuY3Rpb24oKSB7fTtcblxuXy5leHRlbmQoTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLCBhcGlBY3Rpb25zKTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24obWl4cGFuZWxfaW5zdGFuY2UpIHtcbiAgICB0aGlzLl9taXhwYW5lbCA9IG1peHBhbmVsX2luc3RhbmNlO1xufTtcblxuLypcbiogU2V0IHByb3BlcnRpZXMgb24gYSB1c2VyIHJlY29yZC5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldCgnZ2VuZGVyJywgJ20nKTtcbipcbiogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXQoe1xuKiAgICAgICAgICdDb21wYW55JzogJ0FjbWUnLFxuKiAgICAgICAgICdQbGFuJzogJ1ByZW1pdW0nLFxuKiAgICAgICAgICdVcGdyYWRlIGRhdGUnOiBuZXcgRGF0ZSgpXG4qICAgICB9KTtcbiogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzLCBkYXRlcywgb3IgbGlzdHNcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgcmVmZXJyZXIgaW5mbyBoYXMgYmVlbiB1cGRhdGVkIGFuZCBzYXZlZFxuICAgIGlmICh0aGlzLl9nZXRfY29uZmlnKCdzYXZlX3JlZmVycmVyJykpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX3JlZmVycmVyX2luZm8oZG9jdW1lbnQucmVmZXJyZXIpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSAkc2V0IG9iamVjdCB3aXRoIGRlZmF1bHQgcGVvcGxlIHByb3BlcnRpZXNcbiAgICBkYXRhW1NFVF9BQ1RJT05dID0gXy5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBfLmluZm8ucGVvcGxlX3Byb3BlcnRpZXMoKSxcbiAgICAgICAgZGF0YVtTRVRfQUNUSU9OXVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogU2V0IHByb3BlcnRpZXMgb24gYSB1c2VyIHJlY29yZCwgb25seSBpZiB0aGV5IGRvIG5vdCB5ZXQgZXhpc3QuXG4qIFRoaXMgd2lsbCBub3Qgb3ZlcndyaXRlIHByZXZpb3VzIHBlb3BsZSBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZVxuKiBwZW9wbGUuc2V0KCkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXRfb25jZSgnRmlyc3QgTG9naW4gRGF0ZScsIG5ldyBEYXRlKCkpO1xuKlxuKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldF9vbmNlKHtcbiogICAgICAgICAnRmlyc3QgTG9naW4gRGF0ZSc6IG5ldyBEYXRlKCksXG4qICAgICAgICAgJ1N0YXJ0aW5nIFBsYW4nOiAnUHJlbWl1bSdcbiogICAgIH0pO1xuKlxuKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMgb3IgZGF0ZXNcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5zZXRfb25jZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9vbmNlX2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogVW5zZXQgcHJvcGVydGllcyBvbiBhIHVzZXIgcmVjb3JkIChwZXJtYW5lbnRseSByZW1vdmVzIHRoZSBwcm9wZXJ0aWVzIGFuZCB0aGVpciB2YWx1ZXMgZnJvbSBhIHByb2ZpbGUpLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5zZXQoJ2dlbmRlcicpO1xuKlxuKiAgICAgLy8gb3IgdW5zZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5zZXQoWydnZW5kZXInLCAnQ29tcGFueSddKTtcbipcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBhcnJheSwgdGhpcyBpcyBhIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMuXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy51bnNldF9hY3Rpb24ocHJvcCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogSW5jcmVtZW50L2RlY3JlbWVudCBudW1lcmljIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydGllcy5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgncGFnZV92aWV3cycsIDEpO1xuKlxuKiAgICAgLy8gb3IsIGZvciBjb252ZW5pZW5jZSwgaWYgeW91J3JlIGp1c3QgaW5jcmVtZW50aW5nIGEgY291bnRlciBieVxuKiAgICAgLy8gMSwgeW91IGNhbiBzaW1wbHkgZG9cbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ3BhZ2Vfdmlld3MnKTtcbipcbiogICAgIC8vIHRvIGRlY3JlbWVudCBhIGNvdW50ZXIsIHBhc3MgYSBuZWdhdGl2ZSBudW1iZXJcbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ2NyZWRpdHNfbGVmdCcsIC0xKTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLnNldCgpLCB5b3UgY2FuIGluY3JlbWVudCBtdWx0aXBsZVxuKiAgICAgLy8gcHJvcGVydGllcyBhdCBvbmNlOlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCh7XG4qICAgICAgICAgY291bnRlcjE6IDEsXG4qICAgICAgICAgY291bnRlcjI6IDZcbiogICAgIH0pO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIG51bWVyaWMgdmFsdWVzLlxuKiBAcGFyYW0ge051bWJlcn0gW2J5XSBBbiBhbW91bnQgdG8gaW5jcmVtZW50IHRoZSBnaXZlbiBwcm9wZXJ0eVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIGJ5LCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0ge307XG4gICAgdmFyICRhZGQgPSB7fTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihwYXJzZUZsb2F0KHYpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ0ludmFsaWQgaW5jcmVtZW50IHZhbHVlIHBhc3NlZCB0byBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50IC0gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGFkZFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgY2FsbGJhY2sgPSBieTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb252ZW5pZW5jZTogbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgncHJvcGVydHknKTsgd2lsbFxuICAgICAgICAvLyBpbmNyZW1lbnQgJ3Byb3BlcnR5JyBieSAxXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGJ5KSkge1xuICAgICAgICAgICAgYnkgPSAxO1xuICAgICAgICB9XG4gICAgICAgICRhZGRbcHJvcF0gPSBieTtcbiAgICB9XG4gICAgZGF0YVtBRERfQUNUSU9OXSA9ICRhZGQ7XG5cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBBcHBlbmQgYSB2YWx1ZSB0byBhIGxpc3QtdmFsdWVkIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydHkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIC8vIGFwcGVuZCBhIHZhbHVlIHRvIGEgbGlzdCwgY3JlYXRpbmcgaXQgaWYgbmVlZGVkXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuYXBwZW5kKCdwYWdlc192aXNpdGVkJywgJ2hvbWVwYWdlJyk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5zZXQoKSwgeW91IGNhbiBhcHBlbmQgbXVsdGlwbGVcbiogICAgIC8vIHByb3BlcnRpZXMgYXQgb25jZTpcbiogICAgIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoe1xuKiAgICAgICAgIGxpc3QxOiAnYm9iJyxcbiogICAgICAgICBsaXN0MjogMTIzXG4qICAgICB9KTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsaXN0X25hbWUgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdmFsdWVdIHZhbHVlIEFuIGl0ZW0gdG8gYXBwZW5kIHRvIHRoZSBsaXN0XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmFwcGVuZCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWU7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy5hcHBlbmRfYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFJlbW92ZSBhIHZhbHVlIGZyb20gYSBsaXN0LXZhbHVlZCBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnR5LlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUucmVtb3ZlKCdTY2hvb2wnLCAnVUNCJyk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSB2YWx1ZSBJdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnJlbW92ZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWU7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy5yZW1vdmVfYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIE1lcmdlIGEgZ2l2ZW4gbGlzdCB3aXRoIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eSxcbiogZXhjbHVkaW5nIGR1cGxpY2F0ZSB2YWx1ZXMuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIC8vIG1lcmdlIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bmlvbigncGFnZXNfdmlzaXRlZCcsICdob21lcGFnZScpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gYXBwZW5kIG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5pb24oe1xuKiAgICAgICAgIGxpc3QxOiAnYm9iJyxcbiogICAgICAgICBsaXN0MjogMTIzXG4qICAgICB9KTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZVxuKiAgICAgLy8gdmFsdWVzIHRvIHRoZSBzYW1lIGxpc3Q6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5pb24oe1xuKiAgICAgICAgIGxpc3QxOiBbJ2JvYicsICdiaWxseSddXG4qICAgICB9KTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsaXN0X25hbWUgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdmFsdWVdIFZhbHVlIC8gdmFsdWVzIHRvIG1lcmdlIHdpdGggdGhlIGdpdmVuIHByb3BlcnR5XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuaW9uID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlcywgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWVzO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMudW5pb25fYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuICogUmVjb3JkIHRoYXQgeW91IGhhdmUgY2hhcmdlZCB0aGUgY3VycmVudCB1c2VyIGEgY2VydGFpbiBhbW91bnRcbiAqIG9mIG1vbmV5LiBDaGFyZ2VzIHJlY29yZGVkIHdpdGggdHJhY2tfY2hhcmdlKCkgd2lsbCBhcHBlYXIgaW4gdGhlXG4gKiBNaXhwYW5lbCByZXZlbnVlIHJlcG9ydC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIGNoYXJnZSBhIHVzZXIgJDUwXG4gKiAgICAgbWl4cGFuZWwucGVvcGxlLnRyYWNrX2NoYXJnZSg1MCk7XG4gKlxuICogICAgIC8vIGNoYXJnZSBhIHVzZXIgJDMwLjUwIG9uIHRoZSAybmQgb2YgamFudWFyeVxuICogICAgIG1peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UoMzAuNTAsIHtcbiAqICAgICAgICAgJyR0aW1lJzogbmV3IERhdGUoJ2phbiAxIDIwMTInKVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIGFtb3VudCBvZiBtb25leSBjaGFyZ2VkIHRvIHRoZSBjdXJyZW50IHVzZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gQW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgcHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhlIGNoYXJnZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHNlcnZlciByZXNwb25kc1xuICogQGRlcHJlY2F0ZWRcbiAqL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRyYWNrX2NoYXJnZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24oYW1vdW50LCBwcm9wZXJ0aWVzLCBjYWxsYmFjaykge1xuICAgIGlmICghXy5pc051bWJlcihhbW91bnQpKSB7XG4gICAgICAgIGFtb3VudCA9IHBhcnNlRmxvYXQoYW1vdW50KTtcbiAgICAgICAgaWYgKGlzTmFOKGFtb3VudCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCB2YWx1ZSBwYXNzZWQgdG8gbWl4cGFuZWwucGVvcGxlLnRyYWNrX2NoYXJnZSAtIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGVuZCgnJHRyYW5zYWN0aW9ucycsIF8uZXh0ZW5kKHtcbiAgICAgICAgJyRhbW91bnQnOiBhbW91bnRcbiAgICB9LCBwcm9wZXJ0aWVzKSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4gKiBQZXJtYW5lbnRseSBjbGVhciBhbGwgcmV2ZW51ZSByZXBvcnQgdHJhbnNhY3Rpb25zIGZyb20gdGhlXG4gKiBjdXJyZW50IHVzZXIncyBwZW9wbGUgYW5hbHl0aWNzIHByb2ZpbGUuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5wZW9wbGUuY2xlYXJfY2hhcmdlcygpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKiBAZGVwcmVjYXRlZFxuICovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuY2xlYXJfY2hhcmdlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KCckdHJhbnNhY3Rpb25zJywgW10sIGNhbGxiYWNrKTtcbn07XG5cbi8qXG4qIFBlcm1hbmVudGx5IGRlbGV0ZXMgdGhlIGN1cnJlbnQgcGVvcGxlIGFuYWx5dGljcyBwcm9maWxlIGZyb21cbiogTWl4cGFuZWwgKHVzaW5nIHRoZSBjdXJyZW50IGRpc3RpbmN0X2lkKS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgLy8gcmVtb3ZlIHRoZSBhbGwgZGF0YSB5b3UgaGF2ZSBzdG9yZWQgYWJvdXQgdGhlIGN1cnJlbnQgdXNlclxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmRlbGV0ZV91c2VyKCk7XG4qXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmRlbGV0ZV91c2VyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pZGVudGlmeV9jYWxsZWQoKSkge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ21peHBhbmVsLnBlb3BsZS5kZWxldGVfdXNlcigpIHJlcXVpcmVzIHlvdSB0byBjYWxsIGlkZW50aWZ5KCkgZmlyc3QnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHsnJGRlbGV0ZSc6IHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpfTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEpO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLnRvU3RyaW5nKCkgKyAnLnBlb3BsZSc7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgZGF0YVsnJHRva2VuJ10gPSB0aGlzLl9nZXRfY29uZmlnKCd0b2tlbicpO1xuICAgIGRhdGFbJyRkaXN0aW5jdF9pZCddID0gdGhpcy5fbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gICAgdmFyIGRldmljZV9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJGRldmljZV9pZCcpO1xuICAgIHZhciB1c2VyX2lkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckdXNlcl9pZCcpO1xuICAgIHZhciBoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCcpO1xuICAgIGlmIChkZXZpY2VfaWQpIHtcbiAgICAgICAgZGF0YVsnJGRldmljZV9pZCddID0gZGV2aWNlX2lkO1xuICAgIH1cbiAgICBpZiAodXNlcl9pZCkge1xuICAgICAgICBkYXRhWyckdXNlcl9pZCddID0gdXNlcl9pZDtcbiAgICB9XG4gICAgaWYgKGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQpIHtcbiAgICAgICAgZGF0YVsnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnXSA9IGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQ7XG4gICAgfVxuXG4gICAgdmFyIGRhdGVfZW5jb2RlZF9kYXRhID0gXy5lbmNvZGVEYXRlcyhkYXRhKTtcblxuICAgIGlmICghdGhpcy5faWRlbnRpZnlfY2FsbGVkKCkpIHtcbiAgICAgICAgdGhpcy5fZW5xdWV1ZShkYXRhKTtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldF9jb25maWcoJ3ZlcmJvc2UnKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtzdGF0dXM6IC0xLCBlcnJvcjogbnVsbH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8udHJ1bmNhdGUoZGF0ZV9lbmNvZGVkX2RhdGEsIDI1NSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdwZW9wbGUnLFxuICAgICAgICBkYXRhOiBkYXRlX2VuY29kZWRfZGF0YSxcbiAgICAgICAgZW5kcG9pbnQ6IHRoaXMuX2dldF9jb25maWcoJ2FwaV9ob3N0JykgKyAnLycgKyAgdGhpcy5fZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpWydlbmdhZ2UnXSxcbiAgICAgICAgYmF0Y2hlcjogdGhpcy5fbWl4cGFuZWwucmVxdWVzdF9iYXRjaGVycy5wZW9wbGVcbiAgICB9LCBjYWxsYmFjayk7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2dldF9jb25maWcgPSBmdW5jdGlvbihjb25mX3Zhcikge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5nZXRfY29uZmlnKGNvbmZfdmFyKTtcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5faWRlbnRpZnlfY2FsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLl9mbGFncy5pZGVudGlmeV9jYWxsZWQgPT09IHRydWU7XG59O1xuXG4vLyBRdWV1ZSB1cCBlbmdhZ2Ugb3BlcmF0aW9ucyBpZiBpZGVudGlmeSBoYXNuJ3QgYmVlbiBjYWxsZWQgeWV0LlxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9lbnF1ZXVlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChTRVRfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoU0VUX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChTRVRfT05DRV9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShTRVRfT05DRV9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoVU5TRVRfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKEFERF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShBRERfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKEFQUEVORF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFJFTU9WRV9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShSRU1PVkVfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFVOSU9OX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFVOSU9OX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIGNhbGwgdG8gX2VucXVldWUoKTonLCBkYXRhKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2ZsdXNoX29uZV9xdWV1ZSA9IGZ1bmN0aW9uKGFjdGlvbiwgYWN0aW9uX21ldGhvZCwgY2FsbGJhY2ssIHF1ZXVlX3RvX3BhcmFtc19mbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHF1ZXVlZF9kYXRhID0gXy5leHRlbmQoe30sIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoYWN0aW9uKSk7XG4gICAgdmFyIGFjdGlvbl9wYXJhbXMgPSBxdWV1ZWRfZGF0YTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChxdWV1ZWRfZGF0YSkgJiYgXy5pc09iamVjdChxdWV1ZWRfZGF0YSkgJiYgIV8uaXNFbXB0eU9iamVjdChxdWV1ZWRfZGF0YSkpIHtcbiAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoYWN0aW9uLCBxdWV1ZWRfZGF0YSk7XG4gICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5zYXZlKCk7XG4gICAgICAgIGlmIChxdWV1ZV90b19wYXJhbXNfZm4pIHtcbiAgICAgICAgICAgIGFjdGlvbl9wYXJhbXMgPSBxdWV1ZV90b19wYXJhbXNfZm4ocXVldWVkX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbl9tZXRob2QuY2FsbChfdGhpcywgYWN0aW9uX3BhcmFtcywgZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIG9uIGJhZCByZXNwb25zZSwgd2Ugd2FudCB0byBhZGQgaXQgYmFjayB0byB0aGUgcXVldWVcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShhY3Rpb24sIHF1ZXVlZF9kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8vIEZsdXNoIHF1ZXVlZCBlbmdhZ2Ugb3BlcmF0aW9ucyAtIG9yZGVyIGRvZXMgbm90IG1hdHRlcixcbi8vIGFuZCB0aGVyZSBhcmUgbmV0d29yayBsZXZlbCByYWNlIGNvbmRpdGlvbnMgYW55d2F5XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24oXG4gICAgX3NldF9jYWxsYmFjaywgX2FkZF9jYWxsYmFjaywgX2FwcGVuZF9jYWxsYmFjaywgX3NldF9vbmNlX2NhbGxiYWNrLCBfdW5pb25fY2FsbGJhY2ssIF91bnNldF9jYWxsYmFjaywgX3JlbW92ZV9jYWxsYmFja1xuKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShTRVRfQUNUSU9OLCB0aGlzLnNldCwgX3NldF9jYWxsYmFjayk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiwgdGhpcy5zZXRfb25jZSwgX3NldF9vbmNlX2NhbGxiYWNrKTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoVU5TRVRfQUNUSU9OLCB0aGlzLnVuc2V0LCBfdW5zZXRfY2FsbGJhY2ssIGZ1bmN0aW9uKHF1ZXVlKSB7IHJldHVybiBfLmtleXMocXVldWUpOyB9KTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoQUREX0FDVElPTiwgdGhpcy5pbmNyZW1lbnQsIF9hZGRfY2FsbGJhY2spO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShVTklPTl9BQ1RJT04sIHRoaXMudW5pb24sIF91bmlvbl9jYWxsYmFjayk7XG5cbiAgICAvLyB3ZSBoYXZlIHRvIGZpcmUgb2ZmIGVhY2ggJGFwcGVuZCBpbmRpdmlkdWFsbHkgc2luY2UgdGhlcmUgaXNcbiAgICAvLyBubyBjb25jYXQgbWV0aG9kIHNlcnZlciBzaWRlXG4gICAgdmFyICRhcHBlbmRfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKEFQUEVORF9BQ1RJT04pO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCgkYXBwZW5kX3F1ZXVlKSAmJiBfLmlzQXJyYXkoJGFwcGVuZF9xdWV1ZSkgJiYgJGFwcGVuZF9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyICRhcHBlbmRfaXRlbTtcbiAgICAgICAgdmFyIGFwcGVuZF9jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoQVBQRU5EX0FDVElPTiwgJGFwcGVuZF9pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChfYXBwZW5kX2NhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIF9hcHBlbmRfY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gJGFwcGVuZF9xdWV1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgJGFwcGVuZF9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoQVBQRU5EX0FDVElPTik7XG4gICAgICAgICAgICAkYXBwZW5kX2l0ZW0gPSAkYXBwZW5kX3F1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnNhdmUoKTtcbiAgICAgICAgICAgIGlmICghXy5pc0VtcHR5T2JqZWN0KCRhcHBlbmRfaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hcHBlbmQoJGFwcGVuZF9pdGVtLCBhcHBlbmRfY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2FtZSBmb3IgJHJlbW92ZVxuICAgIHZhciAkcmVtb3ZlX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShSRU1PVkVfQUNUSU9OKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoJHJlbW92ZV9xdWV1ZSkgJiYgXy5pc0FycmF5KCRyZW1vdmVfcXVldWUpICYmICRyZW1vdmVfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciAkcmVtb3ZlX2l0ZW07XG4gICAgICAgIHZhciByZW1vdmVfY2FsbGJhY2sgPSBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sICRyZW1vdmVfaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoX3JlbW92ZV9jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBfcmVtb3ZlX2NhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaiA9ICRyZW1vdmVfcXVldWUubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICRyZW1vdmVfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKFJFTU9WRV9BQ1RJT04pO1xuICAgICAgICAgICAgJHJlbW92ZV9pdGVtID0gJHJlbW92ZV9xdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5zYXZlKCk7XG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eU9iamVjdCgkcmVtb3ZlX2l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlKCRyZW1vdmVfaXRlbSwgcmVtb3ZlX2NhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5faXNfcmVzZXJ2ZWRfcHJvcGVydHkgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgPT09ICckZGlzdGluY3RfaWQnIHx8IHByb3AgPT09ICckdG9rZW4nIHx8IHByb3AgPT09ICckZGV2aWNlX2lkJyB8fCBwcm9wID09PSAnJHVzZXJfaWQnIHx8IHByb3AgPT09ICckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCc7XG59O1xuXG4vLyBNaXhwYW5lbFBlb3BsZSBFeHBvcnRzXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3NldCddICAgICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5zZXQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3NldF9vbmNlJ10gICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5zZXRfb25jZTtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndW5zZXQnXSAgICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuc2V0O1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydpbmNyZW1lbnQnXSAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuaW5jcmVtZW50O1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydhcHBlbmQnXSAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuYXBwZW5kO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydyZW1vdmUnXSAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUucmVtb3ZlO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd1bmlvbiddICAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5pb247XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3RyYWNrX2NoYXJnZSddICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50cmFja19jaGFyZ2U7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2NsZWFyX2NoYXJnZXMnXSA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5jbGVhcl9jaGFyZ2VzO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydkZWxldGVfdXNlciddICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuZGVsZXRlX3VzZXI7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3RvU3RyaW5nJ10gICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50b1N0cmluZztcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKlxuICogQ29uc3RhbnRzXG4gKi9cbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9RVUVVRV9LRVkgICAgICAgICAgPSAnX19tcHMnO1xuLyoqIEBjb25zdCAqLyB2YXIgU0VUX09OQ0VfUVVFVUVfS0VZICAgICA9ICdfX21wc28nO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5TRVRfUVVFVUVfS0VZICAgICAgICA9ICdfX21wdXMnO1xuLyoqIEBjb25zdCAqLyB2YXIgQUREX1FVRVVFX0tFWSAgICAgICAgICA9ICdfX21wYSc7XG4vKiogQGNvbnN0ICovIHZhciBBUFBFTkRfUVVFVUVfS0VZICAgICAgID0gJ19fbXBhcCc7XG4vKiogQGNvbnN0ICovIHZhciBSRU1PVkVfUVVFVUVfS0VZICAgICAgID0gJ19fbXByJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOSU9OX1FVRVVFX0tFWSAgICAgICAgPSAnX19tcHUnO1xuLy8gVGhpcyBrZXkgaXMgZGVwcmVjYXRlZCwgYnV0IHdlIHdhbnQgdG8gY2hlY2sgZm9yIGl0IHRvIHNlZSB3aGV0aGVyIGFsaWFzaW5nIGlzIGFsbG93ZWQuXG4vKiogQGNvbnN0ICovIHZhciBQRU9QTEVfRElTVElOQ1RfSURfS0VZID0gJyRwZW9wbGVfZGlzdGluY3RfaWQnO1xuLyoqIEBjb25zdCAqLyB2YXIgQUxJQVNfSURfS0VZICAgICAgICAgICA9ICdfX2FsaWFzJztcbi8qKiBAY29uc3QgKi8gdmFyIEVWRU5UX1RJTUVSU19LRVkgICAgICAgPSAnX190aW1lcnMnO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVTRVJWRURfUFJPUEVSVElFUyA9IFtcbiAgICBTRVRfUVVFVUVfS0VZLFxuICAgIFNFVF9PTkNFX1FVRVVFX0tFWSxcbiAgICBVTlNFVF9RVUVVRV9LRVksXG4gICAgQUREX1FVRVVFX0tFWSxcbiAgICBBUFBFTkRfUVVFVUVfS0VZLFxuICAgIFJFTU9WRV9RVUVVRV9LRVksXG4gICAgVU5JT05fUVVFVUVfS0VZLFxuICAgIFBFT1BMRV9ESVNUSU5DVF9JRF9LRVksXG4gICAgQUxJQVNfSURfS0VZLFxuICAgIEVWRU5UX1RJTUVSU19LRVlcbl07XG5cbi8qKlxuICogTWl4cGFuZWwgUGVyc2lzdGVuY2UgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsUGVyc2lzdGVuY2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzWydwcm9wcyddID0ge307XG4gICAgdGhpcy5jYW1wYWlnbl9wYXJhbXNfc2F2ZWQgPSBmYWxzZTtcblxuICAgIGlmIChjb25maWdbJ3BlcnNpc3RlbmNlX25hbWUnXSkge1xuICAgICAgICB0aGlzLm5hbWUgPSAnbXBfJyArIGNvbmZpZ1sncGVyc2lzdGVuY2VfbmFtZSddO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICdtcF8nICsgY29uZmlnWyd0b2tlbiddICsgJ19taXhwYW5lbCc7XG4gICAgfVxuXG4gICAgdmFyIHN0b3JhZ2VfdHlwZSA9IGNvbmZpZ1sncGVyc2lzdGVuY2UnXTtcbiAgICBpZiAoc3RvcmFnZV90eXBlICE9PSAnY29va2llJyAmJiBzdG9yYWdlX3R5cGUgIT09ICdsb2NhbFN0b3JhZ2UnKSB7XG4gICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbCgnVW5rbm93biBwZXJzaXN0ZW5jZSB0eXBlICcgKyBzdG9yYWdlX3R5cGUgKyAnOyBmYWxsaW5nIGJhY2sgdG8gY29va2llJyk7XG4gICAgICAgIHN0b3JhZ2VfdHlwZSA9IGNvbmZpZ1sncGVyc2lzdGVuY2UnXSA9ICdjb29raWUnO1xuICAgIH1cblxuICAgIGlmIChzdG9yYWdlX3R5cGUgPT09ICdsb2NhbFN0b3JhZ2UnICYmIF8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCgpKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IF8ubG9jYWxTdG9yYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IF8uY29va2llO1xuICAgIH1cblxuICAgIHRoaXMubG9hZCgpO1xuICAgIHRoaXMudXBkYXRlX2NvbmZpZyhjb25maWcpO1xuICAgIHRoaXMudXBncmFkZSgpO1xuICAgIHRoaXMuc2F2ZSgpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwID0ge307XG5cbiAgICB0aGlzLmxvYWQoKTtcblxuICAgIC8vIEZpbHRlciBvdXQgcmVzZXJ2ZWQgcHJvcGVydGllc1xuICAgIF8uZWFjaCh0aGlzWydwcm9wcyddLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmICghXy5pbmNsdWRlKFJFU0VSVkVEX1BST1BFUlRJRVMsIGspKSB7XG4gICAgICAgICAgICBwW2tdID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zdG9yYWdlLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgdGhpc1sncHJvcHMnXSA9IF8uZXh0ZW5kKHt9LCBlbnRyeSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBncmFkZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbGRfY29va2llLFxuICAgICAgICBvbGRfbG9jYWxzdG9yYWdlO1xuXG4gICAgLy8gaWYgdHJhbnNmZXJyaW5nIGZyb20gY29va2llIHRvIGxvY2FsU3RvcmFnZSBvciB2aWNlLXZlcnNhLCBjb3B5IGV4aXN0aW5nXG4gICAgLy8gc3VwZXIgcHJvcGVydGllcyBvdmVyIHRvIG5ldyBzdG9yYWdlIG1vZGVcbiAgICBpZiAodGhpcy5zdG9yYWdlID09PSBfLmxvY2FsU3RvcmFnZSkge1xuICAgICAgICBvbGRfY29va2llID0gXy5jb29raWUucGFyc2UodGhpcy5uYW1lKTtcblxuICAgICAgICBfLmNvb2tpZS5yZW1vdmUodGhpcy5uYW1lKTtcbiAgICAgICAgXy5jb29raWUucmVtb3ZlKHRoaXMubmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKG9sZF9jb29raWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZShvbGRfY29va2llKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zdG9yYWdlID09PSBfLmNvb2tpZSkge1xuICAgICAgICBvbGRfbG9jYWxzdG9yYWdlID0gXy5sb2NhbFN0b3JhZ2UucGFyc2UodGhpcy5uYW1lKTtcblxuICAgICAgICBfLmxvY2FsU3RvcmFnZS5yZW1vdmUodGhpcy5uYW1lKTtcblxuICAgICAgICBpZiAob2xkX2xvY2Fsc3RvcmFnZSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKG9sZF9sb2NhbHN0b3JhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5zdG9yYWdlLnNldChcbiAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICBfLkpTT05FbmNvZGUodGhpc1sncHJvcHMnXSksXG4gICAgICAgIHRoaXMuZXhwaXJlX2RheXMsXG4gICAgICAgIHRoaXMuY3Jvc3Nfc3ViZG9tYWluLFxuICAgICAgICB0aGlzLnNlY3VyZSxcbiAgICAgICAgdGhpcy5jcm9zc19zaXRlLFxuICAgICAgICB0aGlzLmNvb2tpZV9kb21haW5cbiAgICApO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZF9wcm9wID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdGhpcy5sb2FkKCk7XG4gICAgcmV0dXJuIHRoaXNbJ3Byb3BzJ11ba2V5XTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHJlbW92ZSBib3RoIGRvbWFpbiBhbmQgc3ViZG9tYWluIGNvb2tpZXNcbiAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSwgZmFsc2UsIHRoaXMuY29va2llX2RvbWFpbik7XG4gICAgdGhpcy5zdG9yYWdlLnJlbW92ZSh0aGlzLm5hbWUsIHRydWUsIHRoaXMuY29va2llX2RvbWFpbik7XG59O1xuXG4vLyByZW1vdmVzIHRoZSBzdG9yYWdlIGVudHJ5IGFuZCBkZWxldGVzIGFsbCBsb2FkZWQgZGF0YVxuLy8gZm9yY2VkIG5hbWUgZm9yIHRlc3RzXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgdGhpc1sncHJvcHMnXSA9IHt9O1xufTtcblxuLyoqXG4qIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuKiBAcGFyYW0geyo9fSBkZWZhdWx0X3ZhbHVlXG4qIEBwYXJhbSB7bnVtYmVyPX0gZGF5c1xuKi9cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnJlZ2lzdGVyX29uY2UgPSBmdW5jdGlvbihwcm9wcywgZGVmYXVsdF92YWx1ZSwgZGF5cykge1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3BzKSkge1xuICAgICAgICBpZiAodHlwZW9mKGRlZmF1bHRfdmFsdWUpID09PSAndW5kZWZpbmVkJykgeyBkZWZhdWx0X3ZhbHVlID0gJ05vbmUnOyB9XG4gICAgICAgIHRoaXMuZXhwaXJlX2RheXMgPSAodHlwZW9mKGRheXMpID09PSAndW5kZWZpbmVkJykgPyB0aGlzLmRlZmF1bHRfZXhwaXJ5IDogZGF5cztcblxuICAgICAgICB0aGlzLmxvYWQoKTtcblxuICAgICAgICBfLmVhY2gocHJvcHMsIGZ1bmN0aW9uKHZhbCwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzWydwcm9wcyddLmhhc093blByb3BlcnR5KHByb3ApIHx8IHRoaXNbJ3Byb3BzJ11bcHJvcF0gPT09IGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzWydwcm9wcyddW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLnNhdmUoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4qIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuKiBAcGFyYW0ge251bWJlcj19IGRheXNcbiovXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3BzLCBkYXlzKSB7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgIHRoaXMuZXhwaXJlX2RheXMgPSAodHlwZW9mKGRheXMpID09PSAndW5kZWZpbmVkJykgPyB0aGlzLmRlZmF1bHRfZXhwaXJ5IDogZGF5cztcblxuICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgXy5leHRlbmQodGhpc1sncHJvcHMnXSwgcHJvcHMpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICB0aGlzLmxvYWQoKTtcbiAgICBpZiAocHJvcCBpbiB0aGlzWydwcm9wcyddKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydwcm9wcyddW3Byb3BdO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfc2VhcmNoX2tleXdvcmQgPSBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgIHRoaXMucmVnaXN0ZXIoXy5pbmZvLnNlYXJjaEluZm8ocmVmZXJyZXIpKTtcbn07XG5cbi8vIEVYUE9SVEVEIE1FVEhPRCwgd2UgdGVzdCB0aGlzIGRpcmVjdGx5LlxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3JlZmVycmVyX2luZm8gPSBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgIC8vIElmIHJlZmVycmVyIGRvZXNuJ3QgZXhpc3QsIHdlIHdhbnQgdG8gbm90ZSB0aGUgZmFjdCB0aGF0IGl0IHdhcyB0eXBlLWluIHRyYWZmaWMuXG4gICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmVyJzogcmVmZXJyZXIgfHwgJyRkaXJlY3QnLFxuICAgICAgICAnJGluaXRpYWxfcmVmZXJyaW5nX2RvbWFpbic6IF8uaW5mby5yZWZlcnJpbmdEb21haW4ocmVmZXJyZXIpIHx8ICckZGlyZWN0J1xuICAgIH0sICcnKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmdldF9yZWZlcnJlcl9pbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJlcic6IHRoaXNbJ3Byb3BzJ11bJyRpbml0aWFsX3JlZmVycmVyJ10sXG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluJzogdGhpc1sncHJvcHMnXVsnJGluaXRpYWxfcmVmZXJyaW5nX2RvbWFpbiddXG4gICAgfSk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfY29uZmlnID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5kZWZhdWx0X2V4cGlyeSA9IHRoaXMuZXhwaXJlX2RheXMgPSBjb25maWdbJ2Nvb2tpZV9leHBpcmF0aW9uJ107XG4gICAgdGhpcy5zZXRfZGlzYWJsZWQoY29uZmlnWydkaXNhYmxlX3BlcnNpc3RlbmNlJ10pO1xuICAgIHRoaXMuc2V0X2Nvb2tpZV9kb21haW4oY29uZmlnWydjb29raWVfZG9tYWluJ10pO1xuICAgIHRoaXMuc2V0X2Nyb3NzX3NpdGUoY29uZmlnWydjcm9zc19zaXRlX2Nvb2tpZSddKTtcbiAgICB0aGlzLnNldF9jcm9zc19zdWJkb21haW4oY29uZmlnWydjcm9zc19zdWJkb21haW5fY29va2llJ10pO1xuICAgIHRoaXMuc2V0X3NlY3VyZShjb25maWdbJ3NlY3VyZV9jb29raWUnXSk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfZGlzYWJsZWQgPSBmdW5jdGlvbihkaXNhYmxlZCkge1xuICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9jb29raWVfZG9tYWluID0gZnVuY3Rpb24oY29va2llX2RvbWFpbikge1xuICAgIGlmIChjb29raWVfZG9tYWluICE9PSB0aGlzLmNvb2tpZV9kb21haW4pIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jb29raWVfZG9tYWluID0gY29va2llX2RvbWFpbjtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Nyb3NzX3NpdGUgPSBmdW5jdGlvbihjcm9zc19zaXRlKSB7XG4gICAgaWYgKGNyb3NzX3NpdGUgIT09IHRoaXMuY3Jvc3Nfc2l0ZSkge1xuICAgICAgICB0aGlzLmNyb3NzX3NpdGUgPSBjcm9zc19zaXRlO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfY3Jvc3Nfc3ViZG9tYWluID0gZnVuY3Rpb24oY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgaWYgKGNyb3NzX3N1YmRvbWFpbiAhPT0gdGhpcy5jcm9zc19zdWJkb21haW4pIHtcbiAgICAgICAgdGhpcy5jcm9zc19zdWJkb21haW4gPSBjcm9zc19zdWJkb21haW47XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmdldF9jcm9zc19zdWJkb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jcm9zc19zdWJkb21haW47XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfc2VjdXJlID0gZnVuY3Rpb24oc2VjdXJlKSB7XG4gICAgaWYgKHNlY3VyZSAhPT0gdGhpcy5zZWN1cmUpIHtcbiAgICAgICAgdGhpcy5zZWN1cmUgPSBzZWN1cmUgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9hZGRfdG9fcGVvcGxlX3F1ZXVlID0gZnVuY3Rpb24ocXVldWUsIGRhdGEpIHtcbiAgICB2YXIgcV9rZXkgPSB0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKSxcbiAgICAgICAgcV9kYXRhID0gZGF0YVtxdWV1ZV0sXG4gICAgICAgIHNldF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShTRVRfQUNUSU9OKSxcbiAgICAgICAgc2V0X29uY2VfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoU0VUX09OQ0VfQUNUSU9OKSxcbiAgICAgICAgdW5zZXRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoVU5TRVRfQUNUSU9OKSxcbiAgICAgICAgYWRkX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKEFERF9BQ1RJT04pLFxuICAgICAgICB1bmlvbl9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShVTklPTl9BQ1RJT04pLFxuICAgICAgICByZW1vdmVfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoUkVNT1ZFX0FDVElPTiwgW10pLFxuICAgICAgICBhcHBlbmRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoQVBQRU5EX0FDVElPTiwgW10pO1xuXG4gICAgaWYgKHFfa2V5ID09PSBTRVRfUVVFVUVfS0VZKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc2V0IHF1ZXVlIC0gd2UgY2FuIG92ZXJyaWRlIGFueSBleGlzdGluZyB2YWx1ZXNcbiAgICAgICAgXy5leHRlbmQoc2V0X3EsIHFfZGF0YSk7XG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIHBlbmRpbmcgaW5jcmVtZW50LCBvdmVycmlkZSBpdFxuICAgICAgICAvLyB3aXRoIHRoZSBzZXQuXG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShBRERfQUNUSU9OLCBxX2RhdGEpO1xuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBwZW5kaW5nIHVuaW9uLCBvdmVycmlkZSBpdFxuICAgICAgICAvLyB3aXRoIHRoZSBzZXQuXG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTklPTl9BQ1RJT04sIHFfZGF0YSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gU0VUX09OQ0VfUVVFVUVfS0VZKSB7XG4gICAgICAgIC8vIG9ubHkgcXVldWUgdGhlIGRhdGEgaWYgdGhlcmUgaXMgbm90IGFscmVhZHkgYSBzZXRfb25jZSBjYWxsIGZvciBpdC5cbiAgICAgICAgXy5lYWNoKHFfZGF0YSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgaWYgKCEoayBpbiBzZXRfb25jZV9xKSkge1xuICAgICAgICAgICAgICAgIHNldF9vbmNlX3Fba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBVTlNFVF9RVUVVRV9LRVkpIHtcbiAgICAgICAgXy5lYWNoKHFfZGF0YSwgZnVuY3Rpb24ocHJvcCkge1xuXG4gICAgICAgICAgICAvLyB1bmRvIHByZXZpb3VzbHktcXVldWVkIGFjdGlvbnMgb24gdGhpcyBrZXlcbiAgICAgICAgICAgIF8uZWFjaChbc2V0X3EsIHNldF9vbmNlX3EsIGFkZF9xLCB1bmlvbl9xXSwgZnVuY3Rpb24oZW5xdWV1ZWRfb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gZW5xdWV1ZWRfb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnF1ZXVlZF9vYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfLmVhY2goYXBwZW5kX3EsIGZ1bmN0aW9uKGFwcGVuZF9vYmopIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBhcHBlbmRfb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcHBlbmRfb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB1bnNldF9xW3Byb3BdID0gdHJ1ZTtcblxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBBRERfUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGV4aXN0cyBpbiB0aGUgc2V0IHF1ZXVlLCBpbmNyZW1lbnRcbiAgICAgICAgICAgIC8vIHRoZSB2YWx1ZVxuICAgICAgICAgICAgaWYgKGsgaW4gc2V0X3EpIHtcbiAgICAgICAgICAgICAgICBzZXRfcVtrXSArPSB2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBkb2Vzbid0IGV4aXN0LCB1cGRhdGUgdGhlIGFkZFxuICAgICAgICAgICAgICAgIC8vIHF1ZXVlXG4gICAgICAgICAgICAgICAgaWYgKCEoayBpbiBhZGRfcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkX3Fba10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRfcVtrXSArPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBVTklPTl9RVUVVRV9LRVkpIHtcbiAgICAgICAgXy5lYWNoKHFfZGF0YSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICAgIGlmICghKGsgaW4gdW5pb25fcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pb25fcVtrXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBtYXkgc2VuZCBkdXBsaWNhdGVzLCB0aGUgc2VydmVyIHdpbGwgZGVkdXAgdGhlbS5cbiAgICAgICAgICAgICAgICB1bmlvbl9xW2tdID0gdW5pb25fcVtrXS5jb25jYXQodik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFJFTU9WRV9RVUVVRV9LRVkpIHtcbiAgICAgICAgcmVtb3ZlX3EucHVzaChxX2RhdGEpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoQVBQRU5EX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBBUFBFTkRfUVVFVUVfS0VZKSB7XG4gICAgICAgIGFwcGVuZF9xLnB1c2gocV9kYXRhKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9XG5cbiAgICBjb25zb2xlJDEubG9nKCdNSVhQQU5FTCBQRU9QTEUgUkVRVUVTVCAoUVVFVUVELCBQRU5ESU5HIElERU5USUZZKTonKTtcbiAgICBjb25zb2xlJDEubG9nKGRhdGEpO1xuXG4gICAgdGhpcy5zYXZlKCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlID0gZnVuY3Rpb24ocXVldWUsIGRhdGEpIHtcbiAgICB2YXIgcSA9IHRoaXNbJ3Byb3BzJ11bdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSldO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChxKSkge1xuICAgICAgICBfLmVhY2goZGF0YSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgaWYgKHF1ZXVlID09PSBBUFBFTkRfQUNUSU9OIHx8IHF1ZXVlID09PSBSRU1PVkVfQUNUSU9OKSB7XG4gICAgICAgICAgICAgICAgLy8gbGlzdCBhY3Rpb25zOiBvbmx5IHJlbW92ZSBpZiBib3RoIGsrdiBtYXRjaFxuICAgICAgICAgICAgICAgIC8vIGUuZy4gcmVtb3ZlIHNob3VsZCBub3Qgb3ZlcnJpZGUgYXBwZW5kIGluIGEgY2FzZSBsaWtlXG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kKHtmb286ICdiYXInfSk7IHJlbW92ZSh7Zm9vOiAncXV4J30pXG4gICAgICAgICAgICAgICAgXy5lYWNoKHEsIGZ1bmN0aW9uKHF1ZXVlZF9hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlZF9hY3Rpb25ba10gPT09IHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZWRfYWN0aW9uW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBxW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5sb2FkX3F1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkX3Byb3AodGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSkpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX2dldF9xdWV1ZV9rZXkgPSBmdW5jdGlvbihxdWV1ZSkge1xuICAgIGlmIChxdWV1ZSA9PT0gU0VUX0FDVElPTikge1xuICAgICAgICByZXR1cm4gU0VUX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBTRVRfT05DRV9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFNFVF9PTkNFX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBVTlNFVF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFVOU0VUX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBBRERfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBBRERfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IEFQUEVORF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIEFQUEVORF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gUkVNT1ZFX0FDVElPTikge1xuICAgICAgICByZXR1cm4gUkVNT1ZFX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBVTklPTl9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFVOSU9OX1FVRVVFX0tFWTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ0ludmFsaWQgcXVldWU6JywgcXVldWUpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9nZXRfb3JfY3JlYXRlX3F1ZXVlID0gZnVuY3Rpb24ocXVldWUsIGRlZmF1bHRfdmFsKSB7XG4gICAgdmFyIGtleSA9IHRoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpO1xuICAgIGRlZmF1bHRfdmFsID0gXy5pc1VuZGVmaW5lZChkZWZhdWx0X3ZhbCkgPyB7fSA6IGRlZmF1bHRfdmFsO1xuICAgIHJldHVybiB0aGlzWydwcm9wcyddW2tleV0gfHwgKHRoaXNbJ3Byb3BzJ11ba2V5XSA9IGRlZmF1bHRfdmFsKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9ldmVudF90aW1lciA9IGZ1bmN0aW9uKGV2ZW50X25hbWUsIHRpbWVzdGFtcCkge1xuICAgIHZhciB0aW1lcnMgPSB0aGlzLmxvYWRfcHJvcChFVkVOVF9USU1FUlNfS0VZKSB8fCB7fTtcbiAgICB0aW1lcnNbZXZlbnRfbmFtZV0gPSB0aW1lc3RhbXA7XG4gICAgdGhpc1sncHJvcHMnXVtFVkVOVF9USU1FUlNfS0VZXSA9IHRpbWVycztcbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnJlbW92ZV9ldmVudF90aW1lciA9IGZ1bmN0aW9uKGV2ZW50X25hbWUpIHtcbiAgICB2YXIgdGltZXJzID0gdGhpcy5sb2FkX3Byb3AoRVZFTlRfVElNRVJTX0tFWSkgfHwge307XG4gICAgdmFyIHRpbWVzdGFtcCA9IHRpbWVyc1tldmVudF9uYW1lXTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodGltZXN0YW1wKSkge1xuICAgICAgICBkZWxldGUgdGhpc1sncHJvcHMnXVtFVkVOVF9USU1FUlNfS0VZXVtldmVudF9uYW1lXTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lc3RhbXA7XG59O1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qXG4gKiBNaXhwYW5lbCBKUyBMaWJyYXJ5XG4gKlxuICogQ29weXJpZ2h0IDIwMTIsIE1peHBhbmVsLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWRcbiAqIGh0dHA6Ly9taXhwYW5lbC5jb20vXG4gKlxuICogSW5jbHVkZXMgcG9ydGlvbnMgb2YgVW5kZXJzY29yZS5qc1xuICogaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlL1xuICogKGMpIDIwMTEgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIEluYy5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4vLyA9PUNsb3N1cmVDb21waWxlcj09XG4vLyBAY29tcGlsYXRpb25fbGV2ZWwgQURWQU5DRURfT1BUSU1JWkFUSU9OU1xuLy8gQG91dHB1dF9maWxlX25hbWUgbWl4cGFuZWwtMi44Lm1pbi5qc1xuLy8gPT0vQ2xvc3VyZUNvbXBpbGVyPT1cblxuLypcblNJTVBMRSBTVFlMRSBHVUlERTpcblxudGhpcy54ID09PSBwdWJsaWMgZnVuY3Rpb25cbnRoaXMuX3ggPT09IGludGVybmFsIC0gb25seSB1c2Ugd2l0aGluIHRoaXMgZmlsZVxudGhpcy5fX3ggPT09IHByaXZhdGUgLSBvbmx5IHVzZSB3aXRoaW4gdGhlIGNsYXNzXG5cbkdsb2JhbHMgc2hvdWxkIGJlIGFsbCBjYXBzXG4qL1xuXG52YXIgaW5pdF90eXBlOyAgICAgICAvLyBNT0RVTEUgb3IgU05JUFBFVCBsb2FkZXJcbi8vIGFsbG93IGJ1bmRsZXJzIHRvIHNwZWNpZnkgaG93IGV4dHJhIGNvZGUgKHJlY29yZGVyIGJ1bmRsZSkgc2hvdWxkIGJlIGxvYWRlZFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG52YXIgbG9hZF9leHRyYV9idW5kbGUgPSBmdW5jdGlvbihzcmMsIF9vbmxvYWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3Ioc3JjICsgJyBub3QgYXZhaWxhYmxlIGluIHRoaXMgYnVpbGQuJyk7XG59O1xuXG52YXIgbWl4cGFuZWxfbWFzdGVyOyAvLyBtYWluIG1peHBhbmVsIGluc3RhbmNlIC8gb2JqZWN0XG52YXIgSU5JVF9NT0RVTEUgID0gMDtcbnZhciBJTklUX1NOSVBQRVQgPSAxO1xuXG52YXIgSURFTlRJVFlfRlVOQyA9IGZ1bmN0aW9uKHgpIHtyZXR1cm4geDt9O1xudmFyIE5PT1BfRlVOQyA9IGZ1bmN0aW9uKCkge307XG5cbi8qKiBAY29uc3QgKi8gdmFyIFBSSU1BUllfSU5TVEFOQ0VfTkFNRSA9ICdtaXhwYW5lbCc7XG4vKiogQGNvbnN0ICovIHZhciBQQVlMT0FEX1RZUEVfQkFTRTY0ICAgPSAnYmFzZTY0Jztcbi8qKiBAY29uc3QgKi8gdmFyIFBBWUxPQURfVFlQRV9KU09OICAgICA9ICdqc29uJztcbi8qKiBAY29uc3QgKi8gdmFyIERFVklDRV9JRF9QUkVGSVggICAgICA9ICckZGV2aWNlOic7XG5cblxuLypcbiAqIER5bmFtaWMuLi4gY29uc3RhbnRzPyBJcyB0aGF0IGFuIG94eW1vcm9uP1xuICovXG4vLyBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0I3dpdGhDcmVkZW50aWFsc1xudmFyIFVTRV9YSFIgPSAod2luLlhNTEh0dHBSZXF1ZXN0ICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpKTtcblxuLy8gSUU8MTAgZG9lcyBub3Qgc3VwcG9ydCBjcm9zcy1vcmlnaW4gWEhSJ3MgYnV0IHNjcmlwdCB0YWdzXG4vLyB3aXRoIGRlZmVyIHdvbid0IGJsb2NrIHdpbmRvdy5vbmxvYWQ7IEVOUVVFVUVfUkVRVUVTVFNcbi8vIHNob3VsZCBvbmx5IGJlIHRydWUgZm9yIE9wZXJhPDEyXG52YXIgRU5RVUVVRV9SRVFVRVNUUyA9ICFVU0VfWEhSICYmICh1c2VyQWdlbnQuaW5kZXhPZignTVNJRScpID09PSAtMSkgJiYgKHVzZXJBZ2VudC5pbmRleE9mKCdNb3ppbGxhJykgPT09IC0xKTtcblxuLy8gc2F2ZSByZWZlcmVuY2UgdG8gbmF2aWdhdG9yLnNlbmRCZWFjb24gc28gaXQgY2FuIGJlIG1pbmlmaWVkXG52YXIgc2VuZEJlYWNvbiA9IG51bGw7XG5pZiAobmF2aWdhdG9yWydzZW5kQmVhY29uJ10pIHtcbiAgICBzZW5kQmVhY29uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGxhdGUgcmVmZXJlbmNlIHRvIG5hdmlnYXRvci5zZW5kQmVhY29uIHRvIGFsbG93IHBhdGNoaW5nL3NweWluZ1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yWydzZW5kQmVhY29uJ10uYXBwbHkobmF2aWdhdG9yLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbnZhciBERUZBVUxUX0FQSV9ST1VURVMgPSB7XG4gICAgJ3RyYWNrJzogJ3RyYWNrLycsXG4gICAgJ2VuZ2FnZSc6ICdlbmdhZ2UvJyxcbiAgICAnZ3JvdXBzJzogJ2dyb3Vwcy8nLFxuICAgICdyZWNvcmQnOiAncmVjb3JkLydcbn07XG5cbi8qXG4gKiBNb2R1bGUtbGV2ZWwgZ2xvYmFsc1xuICovXG52YXIgREVGQVVMVF9DT05GSUcgPSB7XG4gICAgJ2FwaV9ob3N0JzogICAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2FwaS1qcy5taXhwYW5lbC5jb20nLFxuICAgICdhcGlfcm91dGVzJzogICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0FQSV9ST1VURVMsXG4gICAgJ2FwaV9tZXRob2QnOiAgICAgICAgICAgICAgICAgICAgICAgICdQT1NUJyxcbiAgICAnYXBpX3RyYW5zcG9ydCc6ICAgICAgICAgICAgICAgICAgICAgJ1hIUicsXG4gICAgJ2FwaV9wYXlsb2FkX2Zvcm1hdCc6ICAgICAgICAgICAgICAgIFBBWUxPQURfVFlQRV9CQVNFNjQsXG4gICAgJ2FwcF9ob3N0JzogICAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL21peHBhbmVsLmNvbScsXG4gICAgJ2Nkbic6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2Nkbi5teHBubC5jb20nLFxuICAgICdjcm9zc19zaXRlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSc6ICAgICAgICAgICAgdHJ1ZSxcbiAgICAnZXJyb3JfcmVwb3J0ZXInOiAgICAgICAgICAgICAgICAgICAgTk9PUF9GVU5DLFxuICAgICdwZXJzaXN0ZW5jZSc6ICAgICAgICAgICAgICAgICAgICAgICAnY29va2llJyxcbiAgICAncGVyc2lzdGVuY2VfbmFtZSc6ICAgICAgICAgICAgICAgICAgJycsXG4gICAgJ2Nvb2tpZV9kb21haW4nOiAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICdjb29raWVfbmFtZSc6ICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAnbG9hZGVkJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgTk9PUF9GVU5DLFxuICAgICdtcF9sb2FkZXInOiAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICd0cmFja19tYXJrZXRpbmcnOiAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICd0cmFja19wYWdldmlldyc6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnc2tpcF9maXJzdF90b3VjaF9tYXJrZXRpbmcnOiAgICAgICAgZmFsc2UsXG4gICAgJ3N0b3JlX2dvb2dsZSc6ICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3N0b3BfdXRtX3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgIGZhbHNlLFxuICAgICdzYXZlX3JlZmVycmVyJzogICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICd0ZXN0JzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAndmVyYm9zZSc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2ltZyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkZWJ1Zyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAndHJhY2tfbGlua3NfdGltZW91dCc6ICAgICAgICAgICAgICAgMzAwLFxuICAgICdjb29raWVfZXhwaXJhdGlvbic6ICAgICAgICAgICAgICAgICAzNjUsXG4gICAgJ3VwZ3JhZGUnOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkaXNhYmxlX3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnZGlzYWJsZV9jb29raWUnOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3NlY3VyZV9jb29raWUnOiAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdpcCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdvcHRfb3V0X3RyYWNraW5nX2J5X2RlZmF1bHQnOiAgICAgICBmYWxzZSxcbiAgICAnb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0JzogICAgZmFsc2UsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZSc6ICdsb2NhbFN0b3JhZ2UnLFxuICAgICdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnOiAgICBudWxsLFxuICAgICdwcm9wZXJ0eV9ibGFja2xpc3QnOiAgICAgICAgICAgICAgICBbXSxcbiAgICAneGhyX2hlYWRlcnMnOiAgICAgICAgICAgICAgICAgICAgICAge30sIC8vIHsgaGVhZGVyOiB2YWx1ZSwgaGVhZGVyMjogdmFsdWUgfVxuICAgICdpZ25vcmVfZG50JzogICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnYmF0Y2hfcmVxdWVzdHMnOiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnYmF0Y2hfc2l6ZSc6ICAgICAgICAgICAgICAgICAgICAgICAgNTAsXG4gICAgJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJzogICAgICAgICAgIDUwMDAsXG4gICAgJ2JhdGNoX3JlcXVlc3RfdGltZW91dF9tcyc6ICAgICAgICAgIDkwMDAwLFxuICAgICdiYXRjaF9hdXRvc3RhcnQnOiAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdob29rcyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAncmVjb3JkX2Jsb2NrX2NsYXNzJzogICAgICAgICAgICAgICAgbmV3IFJlZ0V4cCgnXihtcC1ibG9ja3xmcy1leGNsdWRlfGFtcC1ibG9ja3xyci1ibG9ja3xwaC1uby1jYXB0dXJlKSQnKSxcbiAgICAncmVjb3JkX2Jsb2NrX3NlbGVjdG9yJzogICAgICAgICAgICAgJ2ltZywgdmlkZW8nLFxuICAgICdyZWNvcmRfY2FudmFzJzogICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAncmVjb3JkX2NvbGxlY3RfZm9udHMnOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3JlY29yZF9pZGxlX3RpbWVvdXRfbXMnOiAgICAgICAgICAgIDMwICogNjAgKiAxMDAwLCAvLyAzMCBtaW51dGVzXG4gICAgJ3JlY29yZF9tYXNrX3RleHRfY2xhc3MnOiAgICAgICAgICAgIG5ldyBSZWdFeHAoJ14obXAtbWFza3xmcy1tYXNrfGFtcC1tYXNrfHJyLW1hc2t8cGgtbWFzaykkJyksXG4gICAgJ3JlY29yZF9tYXNrX3RleHRfc2VsZWN0b3InOiAgICAgICAgICcqJyxcbiAgICAncmVjb3JkX21heF9tcyc6ICAgICAgICAgICAgICAgICAgICAgTUFYX1JFQ09SRElOR19NUyxcbiAgICAncmVjb3JkX21pbl9tcyc6ICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAncmVjb3JkX3Nlc3Npb25zX3BlcmNlbnQnOiAgICAgICAgICAgMCxcbiAgICAncmVjb3JkZXJfc3JjJzogICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY2RuLm14cG5sLmNvbS9saWJzL21peHBhbmVsLXJlY29yZGVyLm1pbi5qcydcbn07XG5cbnZhciBET01fTE9BREVEID0gZmFsc2U7XG5cbi8qKlxuICogTWl4cGFuZWwgTGlicmFyeSBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxMaWIgPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8qKlxuICogY3JlYXRlX21wbGliKHRva2VuOnN0cmluZywgY29uZmlnOm9iamVjdCwgbmFtZTpzdHJpbmcpXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IHRoZSBpbml0IG1ldGhvZCBvZiBNaXhwYW5lbExpYiBvYmplY3RzXG4gKiBhcyB3ZWxsIGFzIHRoZSBtYWluIGluaXRpYWxpemVyIGF0IHRoZSBlbmQgb2YgdGhlIEpTTGliICh0aGF0XG4gKiBpbml0aWFsaXplcyBkb2N1bWVudC5taXhwYW5lbCBhcyB3ZWxsIGFzIGFueSBhZGRpdGlvbmFsIGluc3RhbmNlc1xuICogZGVjbGFyZWQgYmVmb3JlIHRoaXMgZmlsZSBoYXMgbG9hZGVkKS5cbiAqL1xudmFyIGNyZWF0ZV9tcGxpYiA9IGZ1bmN0aW9uKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICB2YXIgaW5zdGFuY2UsXG4gICAgICAgIHRhcmdldCA9IChuYW1lID09PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpID8gbWl4cGFuZWxfbWFzdGVyIDogbWl4cGFuZWxfbWFzdGVyW25hbWVdO1xuXG4gICAgaWYgKHRhcmdldCAmJiBpbml0X3R5cGUgPT09IElOSVRfTU9EVUxFKSB7XG4gICAgICAgIGluc3RhbmNlID0gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgIV8uaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ1lvdSBoYXZlIGFscmVhZHkgaW5pdGlhbGl6ZWQgJyArIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlID0gbmV3IE1peHBhbmVsTGliKCk7XG4gICAgfVxuXG4gICAgaW5zdGFuY2UuX2NhY2hlZF9ncm91cHMgPSB7fTsgLy8gY2FjaGUgZ3JvdXBzIGluIGEgcG9vbFxuXG4gICAgaW5zdGFuY2UuX2luaXQodG9rZW4sIGNvbmZpZywgbmFtZSk7XG5cbiAgICBpbnN0YW5jZVsncGVvcGxlJ10gPSBuZXcgTWl4cGFuZWxQZW9wbGUoKTtcbiAgICBpbnN0YW5jZVsncGVvcGxlJ10uX2luaXQoaW5zdGFuY2UpO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5nZXRfY29uZmlnKCdza2lwX2ZpcnN0X3RvdWNoX21hcmtldGluZycpKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgbnVsbCBVVE0gcGFyYW1zIGluIHRoZSBvYmplY3QgYmVjYXVzZVxuICAgICAgICAvLyBVVE0gcGFyYW1ldGVycyBhY3QgYXMgYSB0dXBsZS4gSWYgYW55IFVUTSBwYXJhbVxuICAgICAgICAvLyBpcyBwcmVzZW50LCB0aGVuIHdlIHNldCBhbGwgVVRNIHBhcmFtcyBpbmNsdWRpbmdcbiAgICAgICAgLy8gZW1wdHkgb25lcyB0b2dldGhlclxuICAgICAgICB2YXIgdXRtX3BhcmFtcyA9IF8uaW5mby5jYW1wYWlnblBhcmFtcyhudWxsKTtcbiAgICAgICAgdmFyIGluaXRpYWxfdXRtX3BhcmFtcyA9IHt9O1xuICAgICAgICB2YXIgaGFzX3V0bSA9IGZhbHNlO1xuICAgICAgICBfLmVhY2godXRtX3BhcmFtcywgZnVuY3Rpb24odXRtX3ZhbHVlLCB1dG1fa2V5KSB7XG4gICAgICAgICAgICBpbml0aWFsX3V0bV9wYXJhbXNbJ2luaXRpYWxfJyArIHV0bV9rZXldID0gdXRtX3ZhbHVlO1xuICAgICAgICAgICAgaWYgKHV0bV92YWx1ZSkge1xuICAgICAgICAgICAgICAgIGhhc191dG0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc191dG0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlWydwZW9wbGUnXS5zZXRfb25jZShpbml0aWFsX3V0bV9wYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgYW55IGluc3RhbmNlIG9uIHRoZSBwYWdlIGhhcyBkZWJ1ZyA9IHRydWUsIHdlIHNldCB0aGVcbiAgICAvLyBnbG9iYWwgZGVidWcgdG8gYmUgdHJ1ZVxuICAgIENvbmZpZy5ERUJVRyA9IENvbmZpZy5ERUJVRyB8fCBpbnN0YW5jZS5nZXRfY29uZmlnKCdkZWJ1ZycpO1xuXG4gICAgLy8gaWYgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkLCB3ZSBjYWxsZWQgaW5pdCBhZnRlciB0aGUgbGliIGFscmVhZHlcbiAgICAvLyBsb2FkZWQsIHNvIHRoZXJlIHdvbid0IGJlIGFuIGFycmF5IG9mIHRoaW5ncyB0byBleGVjdXRlXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRhcmdldCkgJiYgXy5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgLy8gQ3J1bmNoIHRocm91Z2ggdGhlIHBlb3BsZSBxdWV1ZSBmaXJzdCAtIHdlIHF1ZXVlIHRoaXMgZGF0YSB1cCAmXG4gICAgICAgIC8vIGZsdXNoIG9uIGlkZW50aWZ5LCBzbyBpdCdzIGJldHRlciB0byBkbyBhbGwgdGhlc2Ugb3BlcmF0aW9ucyBmaXJzdFxuICAgICAgICBpbnN0YW5jZS5fZXhlY3V0ZV9hcnJheS5jYWxsKGluc3RhbmNlWydwZW9wbGUnXSwgdGFyZ2V0WydwZW9wbGUnXSk7XG4gICAgICAgIGluc3RhbmNlLl9leGVjdXRlX2FycmF5KHRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuLy8gSW5pdGlhbGl6YXRpb24gbWV0aG9kc1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIE1peHBhbmVsIHRyYWNraW5nIG9iamVjdC5cbiAqIEFsbCBuZXcgaW5zdGFuY2VzIGFyZSBhZGRlZCB0byB0aGUgbWFpbiBtaXhwYW5lbCBvYmplY3QgYXMgc3ViIHByb3BlcnRpZXMgKHN1Y2ggYXNcbiAqIG1peHBhbmVsLmxpYnJhcnlfbmFtZSkgYW5kIGFsc28gcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbi4gVG8gZGVmaW5lIGFcbiAqIHNlY29uZCBpbnN0YW5jZSBvbiB0aGUgcGFnZSwgeW91IHdvdWxkIGNhbGw6XG4gKlxuICogICAgIG1peHBhbmVsLmluaXQoJ25ldyB0b2tlbicsIHsgeW91cjogJ2NvbmZpZycgfSwgJ2xpYnJhcnlfbmFtZScpO1xuICpcbiAqIGFuZCB1c2UgaXQgbGlrZSBzbzpcbiAqXG4gKiAgICAgbWl4cGFuZWwubGlicmFyeV9uYW1lLnRyYWNrKC4uLik7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuICAgWW91ciBNaXhwYW5lbCBBUEkgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSAgQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlLiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL21peHBhbmVsL21peHBhbmVsLWpzL2Jsb2IvdjIuNDYuMC9zcmMvbWl4cGFuZWwtY29yZS5qcyNMODgtTDEyN1wiPlNlZSBhIGxpc3Qgb2YgZGVmYXVsdCBjb25maWcgb3B0aW9uczwvYT4uXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdICAgIFRoZSBuYW1lIGZvciB0aGUgbmV3IG1peHBhbmVsIGluc3RhbmNlIHRoYXQgeW91IHdhbnQgY3JlYXRlZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ1lvdSBtdXN0IG5hbWUgeW91ciBuZXcgbGlicmFyeTogaW5pdCh0b2tlbiwgY29uZmlnLCBuYW1lKScpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ1lvdSBtdXN0IGluaXRpYWxpemUgdGhlIG1haW4gbWl4cGFuZWwgb2JqZWN0IHJpZ2h0IGFmdGVyIHlvdSBpbmNsdWRlIHRoZSBNaXhwYW5lbCBqcyBzbmlwcGV0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVfbXBsaWIodG9rZW4sIGNvbmZpZywgbmFtZSk7XG4gICAgbWl4cGFuZWxfbWFzdGVyW25hbWVdID0gaW5zdGFuY2U7XG4gICAgaW5zdGFuY2UuX2xvYWRlZCgpO1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuLy8gbWl4cGFuZWwuX2luaXQodG9rZW46c3RyaW5nLCBjb25maWc6b2JqZWN0LCBuYW1lOnN0cmluZylcbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIHNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIG1peHBhbmVsXG4vLyBsaWJyYXJ5LiAgVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIG1ldGhvZCBhbmQgdGhlIGluaXQoLi4uKVxuLy8gbWV0aG9kIGlzIHRoaXMgb25lIGluaXRpYWxpemVzIHRoZSBhY3R1YWwgaW5zdGFuY2UsIHdoZXJlYXMgdGhlXG4vLyBpbml0KC4uLikgbWV0aG9kIHNldHMgdXAgYSBuZXcgbGlicmFyeSBhbmQgY2FsbHMgX2luaXQgb24gaXQuXG4vL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24odG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgIHRoaXNbJ19fbG9hZGVkJ10gPSB0cnVlO1xuICAgIHRoaXNbJ2NvbmZpZyddID0ge307XG5cbiAgICB2YXIgdmFyaWFibGVfZmVhdHVyZXMgPSB7fTtcblxuICAgIC8vIGRlZmF1bHQgdG8gSlNPTiBwYXlsb2FkIGZvciBzdGFuZGFyZCBtaXhwYW5lbC5jb20gQVBJIGhvc3RzXG4gICAgaWYgKCEoJ2FwaV9wYXlsb2FkX2Zvcm1hdCcgaW4gY29uZmlnKSkge1xuICAgICAgICB2YXIgYXBpX2hvc3QgPSBjb25maWdbJ2FwaV9ob3N0J10gfHwgREVGQVVMVF9DT05GSUdbJ2FwaV9ob3N0J107XG4gICAgICAgIGlmIChhcGlfaG9zdC5tYXRjaCgvXFwubWl4cGFuZWxcXC5jb20vKSkge1xuICAgICAgICAgICAgdmFyaWFibGVfZmVhdHVyZXNbJ2FwaV9wYXlsb2FkX2Zvcm1hdCddID0gUEFZTE9BRF9UWVBFX0pTT047XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldF9jb25maWcoXy5leHRlbmQoe30sIERFRkFVTFRfQ09ORklHLCB2YXJpYWJsZV9mZWF0dXJlcywgY29uZmlnLCB7XG4gICAgICAgICduYW1lJzogbmFtZSxcbiAgICAgICAgJ3Rva2VuJzogdG9rZW4sXG4gICAgICAgICdjYWxsYmFja19mbic6ICgobmFtZSA9PT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSA/IG5hbWUgOiBQUklNQVJZX0lOU1RBTkNFX05BTUUgKyAnLicgKyBuYW1lKSArICcuX2pzYydcbiAgICB9KSk7XG5cbiAgICB0aGlzWydfanNjJ10gPSBOT09QX0ZVTkM7XG5cbiAgICB0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX19yZXF1ZXN0X3F1ZXVlID0gW107XG4gICAgdGhpcy5fX2Rpc2FibGVkX2V2ZW50cyA9IFtdO1xuICAgIHRoaXMuX2ZsYWdzID0ge1xuICAgICAgICAnZGlzYWJsZV9hbGxfZXZlbnRzJzogZmFsc2UsXG4gICAgICAgICdpZGVudGlmeV9jYWxsZWQnOiBmYWxzZVxuICAgIH07XG5cbiAgICAvLyBzZXQgdXAgcmVxdWVzdCBxdWV1ZWluZy9iYXRjaGluZ1xuICAgIHRoaXMucmVxdWVzdF9iYXRjaGVycyA9IHt9O1xuICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gdGhpcy5nZXRfY29uZmlnKCdiYXRjaF9yZXF1ZXN0cycpO1xuICAgIGlmICh0aGlzLl9iYXRjaF9yZXF1ZXN0cykge1xuICAgICAgICBpZiAoIV8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCh0cnVlKSB8fCAhVVNFX1hIUikge1xuICAgICAgICAgICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5sb2coJ1R1cm5pbmcgb2ZmIE1peHBhbmVsIHJlcXVlc3QtcXVldWVpbmc7IG5lZWRzIFhIUiBhbmQgbG9jYWxTdG9yYWdlIHN1cHBvcnQnKTtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmdldF9iYXRjaGVyX2NvbmZpZ3MoKSwgZnVuY3Rpb24oYmF0Y2hlcl9jb25maWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlJDEubG9nKCdDbGVhcmluZyBiYXRjaCBxdWV1ZSAnICsgYmF0Y2hlcl9jb25maWcucXVldWVfa2V5KTtcbiAgICAgICAgICAgICAgICBfLmxvY2FsU3RvcmFnZS5yZW1vdmUoYmF0Y2hlcl9jb25maWcucXVldWVfa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0X2JhdGNoZXJzKCk7XG4gICAgICAgICAgICBpZiAoc2VuZEJlYWNvbiAmJiB3aW4uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIC8vIEJlZm9yZSBwYWdlIGNsb3NlcyBvciBoaWRlcyAodXNlciB0YWJzIGF3YXkgZXRjKSwgYXR0ZW1wdCB0byBmbHVzaCBhbnkgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8gcXVldWVkIHVwIHZpYSBuYXZpZ2F0b3Iuc2VuZEJlYWNvbi4gU2luY2Ugc2VuZEJlYWNvbiBkb2Vzbid0IHJlcG9ydCBzdWNjZXNzL2ZhaWx1cmUsXG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzIHdpbGwgbm90IGJlIHJlbW92ZWQgZnJvbSB0aGUgcGVyc2lzdGVudCBzdG9yZTsgaWYgdGhlIHNpdGUgaXMgbG9hZGVkIGFnYWluLFxuICAgICAgICAgICAgICAgIC8vIHRoZSBldmVudHMgd2lsbCBiZSBmbHVzaGVkIGFnYWluIG9uIHN0YXJ0dXAgYW5kIGRlZHVwbGljYXRlZCBvbiB0aGUgTWl4cGFuZWwgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gc2lkZS5cbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyByZWxpYWJsZSB3YXkgdG8gY2FwdHVyZSBvbmx5IHBhZ2UgY2xvc2UgZXZlbnRzLCBzbyB3ZSBsZWFuIG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIHZpc2liaWxpdHljaGFuZ2UgYW5kIHBhZ2VoaWRlIGV2ZW50cyBhcyByZWNvbW1lbmRlZCBhdFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvdW5sb2FkX2V2ZW50I3VzYWdlX25vdGVzLlxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGV2ZW50cyBmaXJlIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGF3YXkgZnJvbSB0aGUgY3VycmVudCBwYWdlL3RhYiwgc28gd2lsbCBvY2N1clxuICAgICAgICAgICAgICAgIC8vIG1vcmUgZnJlcXVlbnRseSB0aGFuIHBhZ2UgdW5sb2FkLCBidXQgYXJlIHRoZSBvbmx5IG1lY2hhbmlzbSBjdXJyZW50bHkgZm9yIGNhcHR1cmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2NlbmFyaW8gc29tZXdoYXQgcmVsaWFibHkuXG4gICAgICAgICAgICAgICAgdmFyIGZsdXNoX29uX3VubG9hZCA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHMuZmx1c2goe3VubG9hZGluZzogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2WydwZXJzaXN0ZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hfb25fdW5sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQkMVsndmlzaWJpbGl0eVN0YXRlJ10gPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaF9vbl91bmxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXSA9IHRoaXNbJ2Nvb2tpZSddID0gbmV3IE1peHBhbmVsUGVyc2lzdGVuY2UodGhpc1snY29uZmlnJ10pO1xuICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcyA9IHt9O1xuICAgIHRoaXMuX2dkcHJfaW5pdCgpO1xuXG4gICAgdmFyIHV1aWQgPSBfLlVVSUQoKTtcbiAgICBpZiAoIXRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCkpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBzZXQgdGhlIGRpc3RpbmN0IGlkXG4gICAgICAgIC8vIG9yIHRoZSBkZXZpY2UgaWQgaWYgc29tZXRoaW5nIHdhcyBhbHJlYWR5IHN0b3JlZFxuICAgICAgICAvLyBpbiB0aGUgcGVyc2l0ZW5jZVxuICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogREVWSUNFX0lEX1BSRUZJWCArIHV1aWQsXG4gICAgICAgICAgICAnJGRldmljZV9pZCc6IHV1aWRcbiAgICAgICAgfSwgJycpO1xuICAgIH1cblxuICAgIHZhciB0cmFja19wYWdldmlld19vcHRpb24gPSB0aGlzLmdldF9jb25maWcoJ3RyYWNrX3BhZ2V2aWV3Jyk7XG4gICAgaWYgKHRyYWNrX3BhZ2V2aWV3X29wdGlvbikge1xuICAgICAgICB0aGlzLl9pbml0X3VybF9jaGFuZ2VfdHJhY2tpbmcodHJhY2tfcGFnZXZpZXdfb3B0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCcpID4gMCAmJiBNYXRoLnJhbmRvbSgpICogMTAwIDw9IHRoaXMuZ2V0X2NvbmZpZygncmVjb3JkX3Nlc3Npb25zX3BlcmNlbnQnKSkge1xuICAgICAgICB0aGlzLnN0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF3aW5bJ011dGF0aW9uT2JzZXJ2ZXInXSkge1xuICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNdXRhdGlvbk9ic2VydmVyOyBza2lwcGluZyBzZXNzaW9uIHJlY29yZGluZycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZUxvYWRlZFJlY29yZGVyID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yZWNvcmRlciA9IHRoaXMuX3JlY29yZGVyIHx8IG5ldyB3aW5bJ19fbXBfcmVjb3JkZXInXSh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVjb3JkZXJbJ3N0YXJ0UmVjb3JkaW5nJ10oKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHdpblsnX19tcF9yZWNvcmRlciddKSkge1xuICAgICAgICBsb2FkX2V4dHJhX2J1bmRsZSh0aGlzLmdldF9jb25maWcoJ3JlY29yZGVyX3NyYycpLCBoYW5kbGVMb2FkZWRSZWNvcmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTG9hZGVkUmVjb3JkZXIoKTtcbiAgICB9XG59KTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlY29yZGVyKSB7XG4gICAgICAgIHRoaXMuX3JlY29yZGVyWydzdG9wUmVjb3JkaW5nJ10oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoJ1Nlc3Npb24gcmVjb3JkZXIgbW9kdWxlIG5vdCBsb2FkZWQnKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIHJlcGxheV9pZCA9IHRoaXMuX2dldF9zZXNzaW9uX3JlcGxheV9pZCgpO1xuICAgIGlmIChyZXBsYXlfaWQpIHtcbiAgICAgICAgcHJvcHNbJyRtcF9yZXBsYXlfaWQnXSA9IHJlcGxheV9pZDtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlcGxheV91cmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcGxheV91cmwgPSBudWxsO1xuICAgIHZhciByZXBsYXlfaWQgPSB0aGlzLl9nZXRfc2Vzc2lvbl9yZXBsYXlfaWQoKTtcbiAgICBpZiAocmVwbGF5X2lkKSB7XG4gICAgICAgIHZhciBxdWVyeV9wYXJhbXMgPSBfLkhUVFBCdWlsZFF1ZXJ5KHtcbiAgICAgICAgICAgICdyZXBsYXlfaWQnOiByZXBsYXlfaWQsXG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiB0aGlzLmdldF9kaXN0aW5jdF9pZCgpLFxuICAgICAgICAgICAgJ3Rva2VuJzogdGhpcy5nZXRfY29uZmlnKCd0b2tlbicpXG4gICAgICAgIH0pO1xuICAgICAgICByZXBsYXlfdXJsID0gJ2h0dHBzOi8vbWl4cGFuZWwuY29tL3Byb2plY3RzL3JlcGxheS1yZWRpcmVjdD8nICsgcXVlcnlfcGFyYW1zO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGF5X3VybDtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZ2V0X3Nlc3Npb25fcmVwbGF5X2lkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXBsYXlfaWQgPSBudWxsO1xuICAgIGlmICh0aGlzLl9yZWNvcmRlcikge1xuICAgICAgICByZXBsYXlfaWQgPSB0aGlzLl9yZWNvcmRlclsncmVwbGF5SWQnXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxheV9pZCB8fCBudWxsO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2RzXG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fbG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nZXRfY29uZmlnKCdsb2FkZWQnKSh0aGlzKTtcbiAgICB0aGlzLl9zZXRfZGVmYXVsdF9zdXBlcnByb3BzKCk7XG4gICAgdGhpc1sncGVvcGxlJ10uc2V0X29uY2UodGhpc1sncGVyc2lzdGVuY2UnXS5nZXRfcmVmZXJyZXJfaW5mbygpKTtcblxuICAgIC8vIGBzdG9yZV9nb29nbGVgIGlzIG5vdyBkZXByZWNhdGVkIGFuZCBwcmV2aW91c2x5IHN0b3JlZCBVVE0gcGFyYW1ldGVycyBhcmUgY2xlYXJlZFxuICAgIC8vIGZyb20gcGVyc2lzdGVuY2UgYnkgZGVmYXVsdC5cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdzdG9yZV9nb29nbGUnKSAmJiB0aGlzLmdldF9jb25maWcoJ3N0b3BfdXRtX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgdmFyIHV0bV9wYXJhbXMgPSBfLmluZm8uY2FtcGFpZ25QYXJhbXMobnVsbCk7XG4gICAgICAgIF8uZWFjaCh1dG1fcGFyYW1zLCBmdW5jdGlvbihfdXRtX3ZhbHVlLCB1dG1fa2V5KSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHVucmVnaXN0ZXIgcGVyc2lzdGVkIFVUTSBwYXJhbWV0ZXJzIHNvIG9sZCB2YWx1ZXNcbiAgICAgICAgICAgIC8vIGFyZSBub3QgbWl4ZWQgd2l0aCB0aGUgbmV3IFVUTSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXIodXRtX2tleSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxufTtcblxuLy8gdXBkYXRlIHBlcnNpc3RlbmNlIHdpdGggaW5mbyBvbiByZWZlcnJlciwgVVRNIHBhcmFtcywgZXRjXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3NldF9kZWZhdWx0X3N1cGVycHJvcHMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9zZWFyY2hfa2V5d29yZChkb2N1bWVudCQxLnJlZmVycmVyKTtcbiAgICAvLyBSZWdpc3RlcmluZyBzdXBlciBwcm9wZXJ0aWVzIGZvciBVVE0gcGVyc2lzdGVuY2UgYnkgJ3N0b3JlX2dvb2dsZScgaXMgZGVwcmVjYXRlZC5cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdzdG9yZV9nb29nbGUnKSAmJiAhdGhpcy5nZXRfY29uZmlnKCdzdG9wX3V0bV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoXy5pbmZvLmNhbXBhaWduUGFyYW1zKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdzYXZlX3JlZmVycmVyJykpIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS51cGRhdGVfcmVmZXJyZXJfaW5mbyhkb2N1bWVudCQxLnJlZmVycmVyKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2RvbV9sb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICBfLmVhY2godGhpcy5fX2RvbV9sb2FkZWRfcXVldWUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fdHJhY2tfZG9tLmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKCF0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSkge1xuICAgICAgICBfLmVhY2godGhpcy5fX3JlcXVlc3RfcXVldWUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRfcmVxdWVzdC5hcHBseSh0aGlzLCBpdGVtKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlO1xuICAgIGRlbGV0ZSB0aGlzLl9fcmVxdWVzdF9xdWV1ZTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fdHJhY2tfZG9tID0gZnVuY3Rpb24oRG9tQ2xhc3MsIGFyZ3MpIHtcbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdpbWcnKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignWW91IGNhblxcJ3QgdXNlIERPTSB0cmFja2luZyBmdW5jdGlvbnMgd2l0aCBpbWcgPSB0cnVlLicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFET01fTE9BREVEKSB7XG4gICAgICAgIHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlLnB1c2goW0RvbUNsYXNzLCBhcmdzXSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZHQgPSBuZXcgRG9tQ2xhc3MoKS5pbml0KHRoaXMpO1xuICAgIHJldHVybiBkdC50cmFjay5hcHBseShkdCwgYXJncyk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2luaXRfdXJsX2NoYW5nZV90cmFja2luZyA9IGZ1bmN0aW9uKHRyYWNrX3BhZ2V2aWV3X29wdGlvbikge1xuICAgIHZhciBwcmV2aW91c190cmFja2VkX3VybCA9ICcnO1xuICAgIHZhciB0cmFja2VkID0gdGhpcy50cmFja19wYWdldmlldygpO1xuICAgIGlmICh0cmFja2VkKSB7XG4gICAgICAgIHByZXZpb3VzX3RyYWNrZWRfdXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pbmNsdWRlKFsnZnVsbC11cmwnLCAndXJsLXdpdGgtcGF0aC1hbmQtcXVlcnktc3RyaW5nJywgJ3VybC13aXRoLXBhdGgnXSwgdHJhY2tfcGFnZXZpZXdfb3B0aW9uKSkge1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbXBfbG9jYXRpb25jaGFuZ2UnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdtcF9sb2NhdGlvbmNoYW5nZScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuYXRpdmVQdXNoU3RhdGUgPSB3aW4uaGlzdG9yeS5wdXNoU3RhdGU7XG4gICAgICAgIGlmICh0eXBlb2YgbmF0aXZlUHVzaFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3aW4uaGlzdG9yeS5wdXNoU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgdW51c2VkLCB1cmwpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVQdXNoU3RhdGUuY2FsbCh3aW4uaGlzdG9yeSwgc3RhdGUsIHVudXNlZCwgdXJsKTtcbiAgICAgICAgICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ21wX2xvY2F0aW9uY2hhbmdlJykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF0aXZlUmVwbGFjZVN0YXRlID0gd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlO1xuICAgICAgICBpZiAodHlwZW9mIG5hdGl2ZVJlcGxhY2VTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHVudXNlZCwgdXJsKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlUmVwbGFjZVN0YXRlLmNhbGwod2luLmhpc3RvcnksIHN0YXRlLCB1bnVzZWQsIHVybCk7XG4gICAgICAgICAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdtcF9sb2NhdGlvbmNoYW5nZScpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ21wX2xvY2F0aW9uY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudF91cmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgICAgICAgICAgdmFyIHNob3VsZF90cmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRyYWNrX3BhZ2V2aWV3X29wdGlvbiA9PT0gJ2Z1bGwtdXJsJykge1xuICAgICAgICAgICAgICAgIHNob3VsZF90cmFjayA9IGN1cnJlbnRfdXJsICE9PSBwcmV2aW91c190cmFja2VkX3VybDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhY2tfcGFnZXZpZXdfb3B0aW9uID09PSAndXJsLXdpdGgtcGF0aC1hbmQtcXVlcnktc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNob3VsZF90cmFjayA9IGN1cnJlbnRfdXJsLnNwbGl0KCcjJylbMF0gIT09IHByZXZpb3VzX3RyYWNrZWRfdXJsLnNwbGl0KCcjJylbMF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrX3BhZ2V2aWV3X29wdGlvbiA9PT0gJ3VybC13aXRoLXBhdGgnKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkX3RyYWNrID0gY3VycmVudF91cmwuc3BsaXQoJyMnKVswXS5zcGxpdCgnPycpWzBdICE9PSBwcmV2aW91c190cmFja2VkX3VybC5zcGxpdCgnIycpWzBdLnNwbGl0KCc/JylbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRfdHJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tlZCA9IHRoaXMudHJhY2tfcGFnZXZpZXcoKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c190cmFja2VkX3VybCA9IGN1cnJlbnRfdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIF9wcmVwYXJlX2NhbGxiYWNrKCkgc2hvdWxkIGJlIGNhbGxlZCBieSBjYWxsZXJzIG9mIF9zZW5kX3JlcXVlc3QgZm9yIHVzZVxuICogYXMgdGhlIGNhbGxiYWNrIGFyZ3VtZW50LlxuICpcbiAqIElmIHRoZXJlIGlzIG5vIGNhbGxiYWNrLCB0aGlzIHJldHVybnMgbnVsbC5cbiAqIElmIHdlIGFyZSBnb2luZyB0byBtYWtlIFhIUi9YRFIgcmVxdWVzdHMsIHRoaXMgcmV0dXJucyBhIGZ1bmN0aW9uLlxuICogSWYgd2UgYXJlIGdvaW5nIHRvIHVzZSBzY3JpcHQgdGFncywgdGhpcyByZXR1cm5zIGEgc3RyaW5nIHRvIHVzZSBhcyB0aGVcbiAqIGNhbGxiYWNrIEdFVCBwYXJhbS5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9wcmVwYXJlX2NhbGxiYWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIGRhdGEpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChjYWxsYmFjaykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKFVTRV9YSFIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrX2Z1bmN0aW9uID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrX2Z1bmN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGdpdmVzIHVzIGEgY2FsbGJhY2ssIHdlIHN0b3JlIGFzIGEgcmFuZG9tXG4gICAgICAgIC8vIHByb3BlcnR5IG9uIHRoaXMgaW5zdGFuY2VzIGpzYyBmdW5jdGlvbiBhbmQgdXBkYXRlIG91clxuICAgICAgICAvLyBjYWxsYmFjayBzdHJpbmcgdG8gcmVmbGVjdCB0aGF0LlxuICAgICAgICB2YXIganNjID0gdGhpc1snX2pzYyddO1xuICAgICAgICB2YXIgcmFuZG9taXplZF9jYiA9ICcnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrX3N0cmluZyA9IHRoaXMuZ2V0X2NvbmZpZygnY2FsbGJhY2tfZm4nKSArICdbJyArIHJhbmRvbWl6ZWRfY2IgKyAnXSc7XG4gICAgICAgIGpzY1tyYW5kb21pemVkX2NiXSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBkZWxldGUganNjW3JhbmRvbWl6ZWRfY2JdO1xuICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tfc3RyaW5nO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fc2VuZF9yZXF1ZXN0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBzdWNjZWVkZWQgPSB0cnVlO1xuXG4gICAgaWYgKEVOUVVFVUVfUkVRVUVTVFMpIHtcbiAgICAgICAgdGhpcy5fX3JlcXVlc3RfcXVldWUucHVzaChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gc3VjY2VlZGVkO1xuICAgIH1cblxuICAgIHZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgICAgIG1ldGhvZDogdGhpcy5nZXRfY29uZmlnKCdhcGlfbWV0aG9kJyksXG4gICAgICAgIHRyYW5zcG9ydDogdGhpcy5nZXRfY29uZmlnKCdhcGlfdHJhbnNwb3J0JyksXG4gICAgICAgIHZlcmJvc2U6IHRoaXMuZ2V0X2NvbmZpZygndmVyYm9zZScpXG4gICAgfTtcbiAgICB2YXIgYm9keV9kYXRhID0gbnVsbDtcblxuICAgIGlmICghY2FsbGJhY2sgJiYgKF8uaXNGdW5jdGlvbihvcHRpb25zKSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfLmV4dGVuZChERUZBVUxUX09QVElPTlMsIG9wdGlvbnMgfHwge30pO1xuICAgIGlmICghVVNFX1hIUikge1xuICAgICAgICBvcHRpb25zLm1ldGhvZCA9ICdHRVQnO1xuICAgIH1cbiAgICB2YXIgdXNlX3Bvc3QgPSBvcHRpb25zLm1ldGhvZCA9PT0gJ1BPU1QnO1xuICAgIHZhciB1c2Vfc2VuZEJlYWNvbiA9IHNlbmRCZWFjb24gJiYgdXNlX3Bvc3QgJiYgb3B0aW9ucy50cmFuc3BvcnQudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbmRiZWFjb24nO1xuXG4gICAgLy8gbmVlZGVkIHRvIGNvcnJlY3RseSBmb3JtYXQgcmVzcG9uc2VzXG4gICAgdmFyIHZlcmJvc2VfbW9kZSA9IG9wdGlvbnMudmVyYm9zZTtcbiAgICBpZiAoZGF0YVsndmVyYm9zZSddKSB7IHZlcmJvc2VfbW9kZSA9IHRydWU7IH1cblxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3Rlc3QnKSkgeyBkYXRhWyd0ZXN0J10gPSAxOyB9XG4gICAgaWYgKHZlcmJvc2VfbW9kZSkgeyBkYXRhWyd2ZXJib3NlJ10gPSAxOyB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnaW1nJykpIHsgZGF0YVsnaW1nJ10gPSAxOyB9XG4gICAgaWYgKCFVU0VfWEhSKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGNhbGxiYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKHZlcmJvc2VfbW9kZSB8fCB0aGlzLmdldF9jb25maWcoJ3Rlc3QnKSkge1xuICAgICAgICAgICAgLy8gVmVyYm9zZSBvdXRwdXQgKGZyb20gdmVyYm9zZSBtb2RlLCBvciBhbiBlcnJvciBpbiB0ZXN0IG1vZGUpIGlzIGEganNvbiBibG9iLFxuICAgICAgICAgICAgLy8gd2hpY2ggYnkgaXRzZWxmIGlzIG5vdCB2YWxpZCBqYXZhc2NyaXB0LiBXaXRob3V0IGEgY2FsbGJhY2ssIHRoaXMgdmVyYm9zZSBvdXRwdXQgd2lsbFxuICAgICAgICAgICAgLy8gY2F1c2UgYW4gZXJyb3Igd2hlbiByZXR1cm5lZCB2aWEganNvbnAsIHNvIHdlIGZvcmNlIGEgbm8tb3AgY2FsbGJhY2sgcGFyYW0uXG4gICAgICAgICAgICAvLyBTZWUgdGhlIEVDTUEgc2NyaXB0IHNwZWM6IGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy0xMi40XG4gICAgICAgICAgICBkYXRhWydjYWxsYmFjayddID0gJyhmdW5jdGlvbigpe30pJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRhdGFbJ2lwJ10gPSB0aGlzLmdldF9jb25maWcoJ2lwJyk/MTowO1xuICAgIGRhdGFbJ18nXSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodXNlX3Bvc3QpIHtcbiAgICAgICAgYm9keV9kYXRhID0gJ2RhdGE9JyArIGVuY29kZVVSSUNvbXBvbmVudChkYXRhWydkYXRhJ10pO1xuICAgICAgICBkZWxldGUgZGF0YVsnZGF0YSddO1xuICAgIH1cblxuICAgIHVybCArPSAnPycgKyBfLkhUVFBCdWlsZFF1ZXJ5KGRhdGEpO1xuXG4gICAgdmFyIGxpYiA9IHRoaXM7XG4gICAgaWYgKCdpbWcnIGluIGRhdGEpIHtcbiAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgICAgIGRvY3VtZW50JDEuYm9keS5hcHBlbmRDaGlsZChpbWcpO1xuICAgIH0gZWxzZSBpZiAodXNlX3NlbmRCZWFjb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IHNlbmRCZWFjb24odXJsLCBib2R5X2RhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN1Y2NlZWRlZCA/IDEgOiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoVVNFX1hIUikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxLm9wZW4ob3B0aW9ucy5tZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5nZXRfY29uZmlnKCd4aHJfaGVhZGVycycpO1xuICAgICAgICAgICAgaWYgKHVzZV9wb3N0KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8uZWFjaChoZWFkZXJzLCBmdW5jdGlvbihoZWFkZXJWYWx1ZSwgaGVhZGVyTmFtZSkge1xuICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0X21zICYmIHR5cGVvZiByZXEudGltZW91dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXEudGltZW91dCA9IG9wdGlvbnMudGltZW91dF9tcztcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZW5kIHRoZSBtcF9vcHRvdXQgY29va2llXG4gICAgICAgICAgICAvLyB3aXRoQ3JlZGVudGlhbHMgY2Fubm90IGJlIG1vZGlmaWVkIHVudGlsIGFmdGVyIGNhbGxpbmcgLm9wZW4gb24gQW5kcm9pZCBhbmQgTW9iaWxlIFNhZmFyaVxuICAgICAgICAgICAgcmVxLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkgeyAvLyBYTUxIdHRwUmVxdWVzdC5ET05FID09IDQsIGV4Y2VwdCBpbiBzYWZhcmkgNFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gXy5KU09ORGVjb2RlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaWdub3JlX2pzb25fZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXEucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKE51bWJlcihyZXEucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS50aW1lb3V0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXJlcS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0X3RpbWUgPj0gcmVxLnRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ3RpbWVvdXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICdCYWQgSFRUUCBzdGF0dXM6ICcgKyByZXEuc3RhdHVzICsgJyAnICsgcmVxLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlX21vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlX2hlYWRlcnMgPSByZXFbJ3Jlc3BvbnNlSGVhZGVycyddIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7c3RhdHVzOiAwLCBodHRwU3RhdHVzQ29kZTogcmVxWydzdGF0dXMnXSwgZXJyb3I6IGVycm9yLCByZXRyeUFmdGVyOiByZXNwb25zZV9oZWFkZXJzWydSZXRyeS1BZnRlciddfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5zZW5kKGJvZHlfZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICBzY3JpcHQuZGVmZXIgPSB0cnVlO1xuICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgICB2YXIgcyA9IGRvY3VtZW50JDEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICAgICAgICBzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1Y2NlZWRlZDtcbn07XG5cbi8qKlxuICogX2V4ZWN1dGVfYXJyYXkoKSBkZWFscyB3aXRoIHByb2Nlc3NpbmcgYW55IG1peHBhbmVsIGZ1bmN0aW9uXG4gKiBjYWxscyB0aGF0IHdlcmUgY2FsbGVkIGJlZm9yZSB0aGUgTWl4cGFuZWwgbGlicmFyeSB3ZXJlIGxvYWRlZFxuICogKGFuZCBhcmUgdGh1cyBzdG9yZWQgaW4gYW4gYXJyYXkgc28gdGhleSBjYW4gYmUgY2FsbGVkIGxhdGVyKVxuICpcbiAqIE5vdGU6IHdlIGZpcmUgb2ZmIGFsbCB0aGUgbWl4cGFuZWwgZnVuY3Rpb24gY2FsbHMgJiYgdXNlciBkZWZpbmVkXG4gKiBmdW5jdGlvbnMgQkVGT1JFIHdlIGZpcmUgb2ZmIG1peHBhbmVsIHRyYWNraW5nIGNhbGxzLiBUaGlzIGlzIHNvXG4gKiBpZGVudGlmeS9yZWdpc3Rlci9zZXRfY29uZmlnIGNhbGxzIGNhbiBwcm9wZXJseSBtb2RpZnkgZWFybHlcbiAqIHRyYWNraW5nIGNhbGxzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZXhlY3V0ZV9hcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGZuX25hbWUsIGFsaWFzX2NhbGxzID0gW10sIG90aGVyX2NhbGxzID0gW10sIHRyYWNraW5nX2NhbGxzID0gW107XG4gICAgXy5lYWNoKGFycmF5LCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBmbl9uYW1lID0gaXRlbVswXTtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoZm5fbmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0cmFja2luZ19jYWxscy5wdXNoKGl0ZW0pOyAvLyBjaGFpbmVkIGNhbGwgZS5nLiBtaXhwYW5lbC5nZXRfZ3JvdXAoKS5zZXQoKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaXRlbSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShpdGVtKSAmJiBmbl9uYW1lID09PSAnYWxpYXMnKSB7XG4gICAgICAgICAgICAgICAgYWxpYXNfY2FsbHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KGl0ZW0pICYmIGZuX25hbWUuaW5kZXhPZigndHJhY2snKSAhPT0gLTEgJiYgdHlwZW9mKHRoaXNbZm5fbmFtZV0pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdfY2FsbHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3RoZXJfY2FsbHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgdmFyIGV4ZWN1dGUgPSBmdW5jdGlvbihjYWxscywgY29udGV4dCkge1xuICAgICAgICBfLmVhY2goY2FsbHMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoaXRlbVswXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGFpbmVkIGNhbGxcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGVyID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICBfLmVhY2goaXRlbSwgZnVuY3Rpb24oY2FsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsZXIgPSBjYWxsZXJbY2FsbFswXV0uYXBwbHkoY2FsbGVyLCBjYWxsLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpdGVtWzBdXS5hcHBseSh0aGlzLCBpdGVtLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgY29udGV4dCk7XG4gICAgfTtcblxuICAgIGV4ZWN1dGUoYWxpYXNfY2FsbHMsIHRoaXMpO1xuICAgIGV4ZWN1dGUob3RoZXJfY2FsbHMsIHRoaXMpO1xuICAgIGV4ZWN1dGUodHJhY2tpbmdfY2FsbHMsIHRoaXMpO1xufTtcblxuLy8gcmVxdWVzdCBxdWV1ZWluZyB1dGlsc1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuYXJlX2JhdGNoZXJzX2luaXRpYWxpemVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cztcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfYmF0Y2hlcl9jb25maWdzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHF1ZXVlX3ByZWZpeCA9ICdfX21wcV8nICsgdGhpcy5nZXRfY29uZmlnKCd0b2tlbicpO1xuICAgIHZhciBhcGlfcm91dGVzID0gdGhpcy5nZXRfY29uZmlnKCdhcGlfcm91dGVzJyk7XG4gICAgdGhpcy5fYmF0Y2hlcl9jb25maWdzID0gdGhpcy5fYmF0Y2hlcl9jb25maWdzIHx8IHtcbiAgICAgICAgZXZlbnRzOiB7dHlwZTogJ2V2ZW50cycsIGVuZHBvaW50OiAnLycgKyBhcGlfcm91dGVzWyd0cmFjayddLCBxdWV1ZV9rZXk6IHF1ZXVlX3ByZWZpeCArICdfZXYnfSxcbiAgICAgICAgcGVvcGxlOiB7dHlwZTogJ3Blb3BsZScsIGVuZHBvaW50OiAnLycgKyBhcGlfcm91dGVzWydlbmdhZ2UnXSwgcXVldWVfa2V5OiBxdWV1ZV9wcmVmaXggKyAnX3BwJ30sXG4gICAgICAgIGdyb3Vwczoge3R5cGU6ICdncm91cHMnLCBlbmRwb2ludDogJy8nICsgYXBpX3JvdXRlc1snZ3JvdXBzJ10sIHF1ZXVlX2tleTogcXVldWVfcHJlZml4ICsgJ19ncid9XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYmF0Y2hlcl9jb25maWdzO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmluaXRfYmF0Y2hlcnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuYXJlX2JhdGNoZXJzX2luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgdmFyIGJhdGNoZXJfZm9yID0gXy5iaW5kKGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3RCYXRjaGVyKFxuICAgICAgICAgICAgICAgIGF0dHJzLnF1ZXVlX2tleSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxpYkNvbmZpZzogdGhpc1snY29uZmlnJ10sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yUmVwb3J0ZXI6IHRoaXMuZ2V0X2NvbmZpZygnZXJyb3JfcmVwb3J0ZXInKSxcbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlcXVlc3RGdW5jOiBfLmJpbmQoZnVuY3Rpb24oZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRfcmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldF9jb25maWcoJ2FwaV9ob3N0JykgKyBhdHRycy5lbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVfZGF0YV9mb3JfcmVxdWVzdChkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVfY2FsbGJhY2soY2IsIGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlU2VuZEhvb2s6IF8uYmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnVuX2hvb2soJ2JlZm9yZV9zZW5kXycgKyBhdHRycy50eXBlLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBbGxCYXRjaGluZ0Z1bmM6IF8uYmluZCh0aGlzLnN0b3BfYmF0Y2hfc2VuZGVycywgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIHVzZVBlcnNpc3RlbmNlOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHZhciBiYXRjaGVyX2NvbmZpZ3MgPSB0aGlzLmdldF9iYXRjaGVyX2NvbmZpZ3MoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzID0ge1xuICAgICAgICAgICAgZXZlbnRzOiBiYXRjaGVyX2ZvcihiYXRjaGVyX2NvbmZpZ3MuZXZlbnRzKSxcbiAgICAgICAgICAgIHBlb3BsZTogYmF0Y2hlcl9mb3IoYmF0Y2hlcl9jb25maWdzLnBlb3BsZSksXG4gICAgICAgICAgICBncm91cHM6IGJhdGNoZXJfZm9yKGJhdGNoZXJfY29uZmlncy5ncm91cHMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2JhdGNoX2F1dG9zdGFydCcpKSB7XG4gICAgICAgIHRoaXMuc3RhcnRfYmF0Y2hfc2VuZGVycygpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9iYXRjaF9zZW5kZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYmF0Y2hlcnNfd2VyZV9zdGFydGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5hcmVfYmF0Y2hlcnNfaW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IHRydWU7XG4gICAgICAgIF8uZWFjaCh0aGlzLnJlcXVlc3RfYmF0Y2hlcnMsIGZ1bmN0aW9uKGJhdGNoZXIpIHtcbiAgICAgICAgICAgIGJhdGNoZXIuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3BfYmF0Y2hfc2VuZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gZmFsc2U7XG4gICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICBiYXRjaGVyLnN0b3AoKTtcbiAgICAgICAgYmF0Y2hlci5jbGVhcigpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBwdXNoKCkga2VlcHMgdGhlIHN0YW5kYXJkIGFzeW5jLWFycmF5LXB1c2hcbiAqIGJlaGF2aW9yIGFyb3VuZCBhZnRlciB0aGUgbGliIGlzIGxvYWRlZC5cbiAqIFRoaXMgaXMgb25seSB1c2VmdWwgZm9yIGV4dGVybmFsIGludGVncmF0aW9ucyB0aGF0XG4gKiBkbyBub3Qgd2lzaCB0byByZWx5IG9uIG91ciBjb252ZW5pZW5jZSBtZXRob2RzXG4gKiAoY3JlYXRlZCBpbiB0aGUgc25pcHBldCkuXG4gKlxuICogIyMjIFVzYWdlOlxuICogICAgIG1peHBhbmVsLnB1c2goWydyZWdpc3RlcicsIHsgYTogJ2InIH1dKTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtIEEgW2Z1bmN0aW9uX25hbWUsIGFyZ3MuLi5dIGFycmF5IHRvIGJlIGV4ZWN1dGVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHRoaXMuX2V4ZWN1dGVfYXJyYXkoW2l0ZW1dKTtcbn07XG5cbi8qKlxuICogRGlzYWJsZSBldmVudHMgb24gdGhlIE1peHBhbmVsIG9iamVjdC4gSWYgcGFzc2VkIG5vIGFyZ3VtZW50cyxcbiAqIHRoaXMgZnVuY3Rpb24gZGlzYWJsZXMgdHJhY2tpbmcgb2YgYW55IGV2ZW50LiBJZiBwYXNzZWQgYW5cbiAqIGFycmF5IG9mIGV2ZW50IG5hbWVzLCB0aG9zZSBldmVudHMgd2lsbCBiZSBkaXNhYmxlZCwgYnV0IG90aGVyXG4gKiBldmVudHMgd2lsbCBjb250aW51ZSB0byBiZSB0cmFja2VkLlxuICpcbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3RvcCBvdGhlciBtaXhwYW5lbCBmdW5jdGlvbnMgZnJvbVxuICogZmlyaW5nLCBzdWNoIGFzIHJlZ2lzdGVyKCkgb3IgcGVvcGxlLnNldCgpLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IFtldmVudHNdIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRvIGRpc2FibGVcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbihldmVudHMpIHtcbiAgICBpZiAodHlwZW9mKGV2ZW50cykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzLmRpc2FibGVfYWxsX2V2ZW50cyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2Rpc2FibGVkX2V2ZW50cyA9IHRoaXMuX19kaXNhYmxlZF9ldmVudHMuY29uY2F0KGV2ZW50cyk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9lbmNvZGVfZGF0YV9mb3JfcmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgZW5jb2RlZF9kYXRhID0gXy5KU09ORW5jb2RlKGRhdGEpO1xuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2FwaV9wYXlsb2FkX2Zvcm1hdCcpID09PSBQQVlMT0FEX1RZUEVfQkFTRTY0KSB7XG4gICAgICAgIGVuY29kZWRfZGF0YSA9IF8uYmFzZTY0RW5jb2RlKGVuY29kZWRfZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB7J2RhdGEnOiBlbmNvZGVkX2RhdGF9O1xufTtcblxuLy8gaW50ZXJuYWwgbWV0aG9kIGZvciBoYW5kbGluZyB0cmFjayB2cyBiYXRjaC1lbnF1ZXVlIGxvZ2ljXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3RyYWNrX29yX2JhdGNoID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJ1bmNhdGVkX2RhdGEgPSBfLnRydW5jYXRlKG9wdGlvbnMuZGF0YSwgMjU1KTtcbiAgICB2YXIgZW5kcG9pbnQgPSBvcHRpb25zLmVuZHBvaW50O1xuICAgIHZhciBiYXRjaGVyID0gb3B0aW9ucy5iYXRjaGVyO1xuICAgIHZhciBzaG91bGRfc2VuZF9pbW1lZGlhdGVseSA9IG9wdGlvbnMuc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHk7XG4gICAgdmFyIHNlbmRfcmVxdWVzdF9vcHRpb25zID0gb3B0aW9ucy5zZW5kX3JlcXVlc3Rfb3B0aW9ucyB8fCB7fTtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IE5PT1BfRlVOQztcblxuICAgIHZhciByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCA9IHRydWU7XG4gICAgdmFyIHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZW5kX3JlcXVlc3Rfb3B0aW9ucy5za2lwX2hvb2tzKSB7XG4gICAgICAgICAgICB0cnVuY2F0ZWRfZGF0YSA9IHRoaXMuX3J1bl9ob29rKCdiZWZvcmVfc2VuZF8nICsgb3B0aW9ucy50eXBlLCB0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRydW5jYXRlZF9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEubG9nKCdNSVhQQU5FTCBSRVFVRVNUOicpO1xuICAgICAgICAgICAgY29uc29sZSQxLmxvZyh0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KFxuICAgICAgICAgICAgICAgIGVuZHBvaW50LFxuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0KHRydW5jYXRlZF9kYXRhKSxcbiAgICAgICAgICAgICAgICBzZW5kX3JlcXVlc3Rfb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlX2NhbGxiYWNrKGNhbGxiYWNrLCB0cnVuY2F0ZWRfZGF0YSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX2JhdGNoX3JlcXVlc3RzICYmICFzaG91bGRfc2VuZF9pbW1lZGlhdGVseSkge1xuICAgICAgICBiYXRjaGVyLmVucXVldWUodHJ1bmNhdGVkX2RhdGEpLnRoZW4oZnVuY3Rpb24oc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soMSwgdHJ1bmNhdGVkX2RhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZW5kX3JlcXVlc3RfaW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdF9lbnF1ZXVlZF9vcl9pbml0aWF0ZWQgPSBzZW5kX3JlcXVlc3RfaW1tZWRpYXRlbHkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdF9lbnF1ZXVlZF9vcl9pbml0aWF0ZWQgJiYgdHJ1bmNhdGVkX2RhdGE7XG59O1xuXG4vKipcbiAqIFRyYWNrIGFuIGV2ZW50LiBUaGlzIGlzIHRoZSBtb3N0IGltcG9ydGFudCBhbmRcbiAqIGZyZXF1ZW50bHkgdXNlZCBNaXhwYW5lbCBmdW5jdGlvbi5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIGFuIGV2ZW50IG5hbWVkICdSZWdpc3RlcmVkJ1xuICogICAgIG1peHBhbmVsLnRyYWNrKCdSZWdpc3RlcmVkJywgeydHZW5kZXInOiAnTWFsZScsICdBZ2UnOiAyMX0pO1xuICpcbiAqICAgICAvLyB0cmFjayBhbiBldmVudCB1c2luZyBuYXZpZ2F0b3Iuc2VuZEJlYWNvblxuICogICAgIG1peHBhbmVsLnRyYWNrKCdMZWZ0IHBhZ2UnLCB7J2R1cmF0aW9uX3NlY29uZHMnOiAzNX0sIHt0cmFuc3BvcnQ6ICdzZW5kQmVhY29uJ30pO1xuICpcbiAqIFRvIHRyYWNrIGxpbmsgY2xpY2tzIG9yIGZvcm0gc3VibWlzc2lvbnMsIHNlZSB0cmFja19saW5rcygpIG9yIHRyYWNrX2Zvcm1zKCkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LiBUaGlzIGNhbiBiZSBhbnl0aGluZyB0aGUgdXNlciBkb2VzIC0gJ0J1dHRvbiBDbGljaycsICdTaWduIFVwJywgJ0l0ZW0gUHVyY2hhc2VkJywgZXRjLlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXZlbnQgeW91J3JlIHNlbmRpbmcuIFRoZXNlIGRlc2NyaWJlIHRoZSB1c2VyIHdobyBkaWQgdGhlIGV2ZW50IG9yIGRldGFpbHMgYWJvdXQgdGhlIGV2ZW50IGl0c2VsZi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhpcyB0cmFjayByZXF1ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRyYW5zcG9ydF0gVHJhbnNwb3J0IG1ldGhvZCBmb3IgbmV0d29yayByZXF1ZXN0ICgneGhyJyBvciAnc2VuZEJlYWNvbicpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZW5kX2ltbWVkaWF0ZWx5XSBXaGV0aGVyIHRvIGJ5cGFzcyBiYXRjaGluZy9xdWV1ZWluZyBhbmQgc2VuZCB0cmFjayByZXF1ZXN0IGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm5zIHtCb29sZWFufE9iamVjdH0gSWYgdGhlIHRyYWNraW5nIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWF0ZWQvcXVldWVkLCBhbiBvYmplY3RcbiAqIHdpdGggdGhlIHRyYWNraW5nIHBheWxvYWQgc2VudCB0byB0aGUgQVBJIHNlcnZlciBpcyByZXR1cm5lZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2sgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGV2ZW50X25hbWUsIHByb3BlcnRpZXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdHJhbnNwb3J0ID0gb3B0aW9uc1sndHJhbnNwb3J0J107IC8vIGV4dGVybmFsIEFQSSwgZG9uJ3QgbWluaWZ5ICd0cmFuc3BvcnQnIHByb3BcbiAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNwb3J0ID0gdHJhbnNwb3J0OyAvLyAndHJhbnNwb3J0JyBwcm9wIG5hbWUgY2FuIGJlIG1pbmlmaWVkIGludGVybmFsbHlcbiAgICB9XG4gICAgdmFyIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5ID0gb3B0aW9uc1snc2VuZF9pbW1lZGlhdGVseSddO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBOT09QX0ZVTkM7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ05vIGV2ZW50IG5hbWUgcHJvdmlkZWQgdG8gbWl4cGFuZWwudHJhY2snKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudF9pc19kaXNhYmxlZChldmVudF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0c1xuICAgIHByb3BlcnRpZXMgPSBfLmV4dGVuZCh7fSwgcHJvcGVydGllcyk7XG4gICAgcHJvcGVydGllc1sndG9rZW4nXSA9IHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKTtcblxuICAgIC8vIHNldCAkZHVyYXRpb24gaWYgdGltZV9ldmVudCB3YXMgcHJldmlvdXNseSBjYWxsZWQgZm9yIHRoaXMgZXZlbnRcbiAgICB2YXIgc3RhcnRfdGltZXN0YW1wID0gdGhpc1sncGVyc2lzdGVuY2UnXS5yZW1vdmVfZXZlbnRfdGltZXIoZXZlbnRfbmFtZSk7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHN0YXJ0X3RpbWVzdGFtcCkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uX2luX21zID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydF90aW1lc3RhbXA7XG4gICAgICAgIHByb3BlcnRpZXNbJyRkdXJhdGlvbiddID0gcGFyc2VGbG9hdCgoZHVyYXRpb25faW5fbXMgLyAxMDAwKS50b0ZpeGVkKDMpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRfZGVmYXVsdF9zdXBlcnByb3BzKCk7XG5cbiAgICB2YXIgbWFya2V0aW5nX3Byb3BlcnRpZXMgPSB0aGlzLmdldF9jb25maWcoJ3RyYWNrX21hcmtldGluZycpXG4gICAgICAgID8gXy5pbmZvLm1hcmtldGluZ1BhcmFtcygpXG4gICAgICAgIDoge307XG5cbiAgICAvLyBub3RlOiBleHRlbmQgd3JpdGVzIHRvIHRoZSBmaXJzdCBvYmplY3QsIHNvIGxldHMgbWFrZSBzdXJlIHdlXG4gICAgLy8gZG9uJ3Qgd3JpdGUgdG8gdGhlIHBlcnNpc3RlbmNlIHByb3BlcnRpZXMgb2JqZWN0IGFuZCBpbmZvXG4gICAgLy8gcHJvcGVydGllcyBvYmplY3QgYnkgcGFzc2luZyBpbiBhIG5ldyBvYmplY3RcblxuICAgIC8vIHVwZGF0ZSBwcm9wZXJ0aWVzIHdpdGggcGFnZXZpZXcgaW5mbyBhbmQgc3VwZXItcHJvcGVydGllc1xuICAgIHByb3BlcnRpZXMgPSBfLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIF8uaW5mby5wcm9wZXJ0aWVzKHsnbXBfbG9hZGVyJzogdGhpcy5nZXRfY29uZmlnKCdtcF9sb2FkZXInKX0pLFxuICAgICAgICBtYXJrZXRpbmdfcHJvcGVydGllcyxcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5wcm9wZXJ0aWVzKCksXG4gICAgICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcyxcbiAgICAgICAgdGhpcy5nZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcygpLFxuICAgICAgICBwcm9wZXJ0aWVzXG4gICAgKTtcblxuICAgIHZhciBwcm9wZXJ0eV9ibGFja2xpc3QgPSB0aGlzLmdldF9jb25maWcoJ3Byb3BlcnR5X2JsYWNrbGlzdCcpO1xuICAgIGlmIChfLmlzQXJyYXkocHJvcGVydHlfYmxhY2tsaXN0KSkge1xuICAgICAgICBfLmVhY2gocHJvcGVydHlfYmxhY2tsaXN0LCBmdW5jdGlvbihibGFja2xpc3RlZF9wcm9wKSB7XG4gICAgICAgICAgICBkZWxldGUgcHJvcGVydGllc1tibGFja2xpc3RlZF9wcm9wXTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3BlcnR5X2JsYWNrbGlzdCBjb25maWc6ICcgKyBwcm9wZXJ0eV9ibGFja2xpc3QpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgICAnZXZlbnQnOiBldmVudF9uYW1lLFxuICAgICAgICAncHJvcGVydGllcyc6IHByb3BlcnRpZXNcbiAgICB9O1xuICAgIHZhciByZXQgPSB0aGlzLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdldmVudHMnLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgJy8nICsgdGhpcy5nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ3RyYWNrJ10sXG4gICAgICAgIGJhdGNoZXI6IHRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHMsXG4gICAgICAgIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5OiBzaG91bGRfc2VuZF9pbW1lZGlhdGVseSxcbiAgICAgICAgc2VuZF9yZXF1ZXN0X29wdGlvbnM6IG9wdGlvbnNcbiAgICB9LCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gcmV0O1xufSk7XG5cbi8qKlxuICogUmVnaXN0ZXIgdGhlIGN1cnJlbnQgdXNlciBpbnRvIG9uZS9tYW55IGdyb3Vwcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCBbJ21peHBhbmVsJywgJ2dvb2dsZSddKSAvLyBhbiBhcnJheSBvZiBJRHNcbiAqICAgICAgbWl4cGFuZWwuc2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqICAgICAgbWl4cGFuZWwuc2V0X2dyb3VwKCdjb21wYW55JywgMTI4NzQ2MzEyKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xOdW1iZXJ9IGdyb3VwX2lkcyBBbiBhcnJheSBvZiBncm91cCBJRHMsIG9yIGEgc2luZ3VsYXIgZ3JvdXAgSURcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2dyb3VwID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihncm91cF9rZXksIGdyb3VwX2lkcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNBcnJheShncm91cF9pZHMpKSB7XG4gICAgICAgIGdyb3VwX2lkcyA9IFtncm91cF9pZHNdO1xuICAgIH1cbiAgICB2YXIgcHJvcCA9IHt9O1xuICAgIHByb3BbZ3JvdXBfa2V5XSA9IGdyb3VwX2lkcztcbiAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS5zZXQoZ3JvdXBfa2V5LCBncm91cF9pZHMsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIEFkZCBhIG5ldyBncm91cCBmb3IgdGhpcyB1c2VyLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLmFkZF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7Kn0gZ3JvdXBfaWQgQSB2YWxpZCBNaXhwYW5lbCBwcm9wZXJ0eSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuYWRkX2dyb3VwID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjaykge1xuICAgIHZhciBvbGRfdmFsdWVzID0gdGhpcy5nZXRfcHJvcGVydHkoZ3JvdXBfa2V5KTtcbiAgICB2YXIgcHJvcCA9IHt9O1xuICAgIGlmIChvbGRfdmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcFtncm91cF9rZXldID0gW2dyb3VwX2lkXTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcihwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2xkX3ZhbHVlcy5pbmRleE9mKGdyb3VwX2lkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9sZF92YWx1ZXMucHVzaChncm91cF9pZCk7XG4gICAgICAgICAgICBwcm9wW2dyb3VwX2tleV0gPSBvbGRfdmFsdWVzO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcihwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1sncGVvcGxlJ10udW5pb24oZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUmVtb3ZlIGEgZ3JvdXAgZnJvbSB0aGlzIHVzZXIuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwucmVtb3ZlX2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHsqfSBncm91cF9pZCBBIHZhbGlkIE1peHBhbmVsIHByb3BlcnR5IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZW1vdmVfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9sZF92YWx1ZSA9IHRoaXMuZ2V0X3Byb3BlcnR5KGdyb3VwX2tleSk7XG4gICAgLy8gaWYgdGhlIHZhbHVlIGRvZXNuJ3QgZXhpc3QsIHRoZSBwZXJzaXN0ZW50IHN0b3JlIGlzIHVuY2hhbmdlZFxuICAgIGlmIChvbGRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaWR4ID0gb2xkX3ZhbHVlLmluZGV4T2YoZ3JvdXBfaWQpO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIG9sZF92YWx1ZS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoe2dyb3VwX2tleTogb2xkX3ZhbHVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZF92YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3Rlcihncm91cF9rZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS5yZW1vdmUoZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogVHJhY2sgYW4gZXZlbnQgd2l0aCBzcGVjaWZpYyBncm91cHMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwudHJhY2tfd2l0aF9ncm91cHMoJ3B1cmNoYXNlJywgeydwcm9kdWN0JzogJ2lwaG9uZSd9LCB7J1VuaXZlcnNpdHknOiBbJ1VDQicsICdVQ0xBJ119KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoc2VlIGBtaXhwYW5lbC50cmFjaygpYClcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBBIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXZlbnQgeW91J3JlIHNlbmRpbmcgKHNlZSBgbWl4cGFuZWwudHJhY2soKWApXG4gKiBAcGFyYW0ge09iamVjdD19IGdyb3VwcyBBbiBvYmplY3QgbWFwcGluZyBncm91cCBuYW1lIGtleXMgdG8gb25lIG9yIG1vcmUgdmFsdWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfd2l0aF9ncm91cHMgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGV2ZW50X25hbWUsIHByb3BlcnRpZXMsIGdyb3VwcywgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJhY2tpbmdfcHJvcHMgPSBfLmV4dGVuZCh7fSwgcHJvcGVydGllcyB8fCB7fSk7XG4gICAgXy5lYWNoKGdyb3VwcywgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAodiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNraW5nX3Byb3BzW2tdID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKGV2ZW50X25hbWUsIHRyYWNraW5nX3Byb3BzLCBjYWxsYmFjayk7XG59KTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9jcmVhdGVfbWFwX2tleSA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgcmV0dXJuIGdyb3VwX2tleSArICdfJyArIEpTT04uc3RyaW5naWZ5KGdyb3VwX2lkKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcmVtb3ZlX2dyb3VwX2Zyb21fY2FjaGUgPSBmdW5jdGlvbiAoZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWNoZWRfZ3JvdXBzW3RoaXMuX2NyZWF0ZV9tYXBfa2V5KGdyb3VwX2tleSwgZ3JvdXBfaWQpXTtcbn07XG5cbi8qKlxuICogTG9vayB1cCByZWZlcmVuY2UgdG8gYSBNaXhwYW5lbCBncm91cFxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoZ3JvdXBfa2V5LCBncm91cF9pZClcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHtPYmplY3R9IGdyb3VwX2lkIEEgdmFsaWQgTWl4cGFuZWwgcHJvcGVydHkgdHlwZVxuICogQHJldHVybnMge09iamVjdH0gQSBNaXhwYW5lbEdyb3VwIGlkZW50aWZpZXJcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9ncm91cCA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgdmFyIG1hcF9rZXkgPSB0aGlzLl9jcmVhdGVfbWFwX2tleShncm91cF9rZXksIGdyb3VwX2lkKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLl9jYWNoZWRfZ3JvdXBzW21hcF9rZXldO1xuICAgIGlmIChncm91cCA9PT0gdW5kZWZpbmVkIHx8IGdyb3VwLl9ncm91cF9rZXkgIT09IGdyb3VwX2tleSB8fCBncm91cC5fZ3JvdXBfaWQgIT09IGdyb3VwX2lkKSB7XG4gICAgICAgIGdyb3VwID0gbmV3IE1peHBhbmVsR3JvdXAoKTtcbiAgICAgICAgZ3JvdXAuX2luaXQodGhpcywgZ3JvdXBfa2V5LCBncm91cF9pZCk7XG4gICAgICAgIHRoaXMuX2NhY2hlZF9ncm91cHNbbWFwX2tleV0gPSBncm91cDtcbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwO1xufTtcblxuLyoqXG4gKiBUcmFjayBhIGRlZmF1bHQgTWl4cGFuZWwgcGFnZSB2aWV3IGV2ZW50LCB3aGljaCBpbmNsdWRlcyBleHRyYSBkZWZhdWx0IGV2ZW50IHByb3BlcnRpZXMgdG9cbiAqIGltcHJvdmUgcGFnZSB2aWV3IGRhdGEuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBhIGRlZmF1bHQgJG1wX3dlYl9wYWdlX3ZpZXcgZXZlbnRcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldygpO1xuICpcbiAqICAgICAvLyB0cmFjayBhIHBhZ2UgdmlldyBldmVudCB3aXRoIGFkZGl0aW9uYWwgZXZlbnQgcHJvcGVydGllc1xuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KHsnYWJfdGVzdF92YXJpYW50JzogJ2NhcmQtbGF5b3V0LWInfSk7XG4gKlxuICogICAgIC8vIGV4YW1wbGUgYXBwcm9hY2ggdG8gdHJhY2sgcGFnZSB2aWV3cyBvbiBkaWZmZXJlbnQgcGFnZSB0eXBlcyBhcyBldmVudCBwcm9wZXJ0aWVzXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydwYWdlJzogJ3ByaWNpbmcnfSk7XG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydwYWdlJzogJ2hvbWVwYWdlJ30pO1xuICpcbiAqICAgICAvLyBVTkNPTU1PTjogVHJhY2tpbmcgYSBwYWdlIHZpZXcgZXZlbnQgd2l0aCBhIGN1c3RvbSBldmVudF9uYW1lIG9wdGlvbi4gTk9UIGV4cGVjdGVkIHRvIGJlIHVzZWQgZm9yXG4gKiAgICAgLy8gaW5kaXZpZHVhbCBwYWdlcyBvbiB0aGUgc2FtZSBzaXRlIG9yIHByb2R1Y3QuIFVzZSBjYXNlcyBmb3IgY3VzdG9tIGV2ZW50X25hbWUgbWF5IGJlIHBhZ2VcbiAqICAgICAvLyB2aWV3cyBvbiBkaWZmZXJlbnQgcHJvZHVjdHMgb3IgaW50ZXJuYWwgYXBwbGljYXRpb25zIHRoYXQgYXJlIGNvbnNpZGVyZWQgY29tcGxldGVseSBzZXBhcmF0ZVxuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KHsncGFnZSc6ICdjdXN0b21lci1zZWFyY2gnfSwgeydldmVudF9uYW1lJzogJ1tpbnRlcm5hbF0gQWRtaW4gUGFnZSBWaWV3J30pO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBUaGUgYGNvbmZpZy50cmFja19wYWdldmlld2Agb3B0aW9uIGZvciA8YSBocmVmPVwiI21peHBhbmVsaW5pdFwiPm1peHBhbmVsLmluaXQoKTwvYT5cbiAqIG1heSBiZSB0dXJuZWQgb24gZm9yIHRyYWNraW5nIHBhZ2UgbG9hZHMgYXV0b21hdGljYWxseS5cbiAqXG4gKiAgICAgLy8gdHJhY2sgb25seSBwYWdlIGxvYWRzXG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6IHRydWV9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgVVJMIGNoYW5nZXMgaW4gYW55IG1hbm5lclxuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiAnZnVsbC11cmwnfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIHdoZW4gdGhlIFVSTCBjaGFuZ2VzLCBpZ25vcmluZyBhbnkgY2hhbmdlcyBpbiB0aGUgaGFzaCBwYXJ0XG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6ICd1cmwtd2l0aC1wYXRoLWFuZC1xdWVyeS1zdHJpbmcnfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIHdoZW4gdGhlIHBhdGggY2hhbmdlcywgaWdub3JpbmcgYW55IHF1ZXJ5IHBhcmFtZXRlciBvciBoYXNoIGNoYW5nZXNcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogJ3VybC13aXRoLXBhdGgnfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBbiBvcHRpb25hbCBzZXQgb2YgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIHNlbmQgd2l0aCB0aGUgcGFnZSB2aWV3IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFBhZ2UgdmlldyB0cmFja2luZyBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZXZlbnRfbmFtZV0gLSBBbHRlcm5hdGUgbmFtZSBmb3IgdGhlIHRyYWNraW5nIGV2ZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbnxPYmplY3R9IElmIHRoZSB0cmFja2luZyByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhdGVkL3F1ZXVlZCwgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSB0cmFja2luZyBwYXlsb2FkIHNlbnQgdG8gdGhlIEFQSSBzZXJ2ZXIgaXMgcmV0dXJuZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3BhZ2V2aWV3ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBldmVudF9uYW1lID0gb3B0aW9uc1snZXZlbnRfbmFtZSddIHx8ICckbXBfd2ViX3BhZ2Vfdmlldyc7XG5cbiAgICB2YXIgZGVmYXVsdF9wYWdlX3Byb3BlcnRpZXMgPSBfLmV4dGVuZChcbiAgICAgICAgXy5pbmZvLm1wUGFnZVZpZXdQcm9wZXJ0aWVzKCksXG4gICAgICAgIF8uaW5mby5jYW1wYWlnblBhcmFtcygpLFxuICAgICAgICBfLmluZm8uY2xpY2tQYXJhbXMoKVxuICAgICk7XG5cbiAgICB2YXIgZXZlbnRfcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgZGVmYXVsdF9wYWdlX3Byb3BlcnRpZXMsXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMudHJhY2soZXZlbnRfbmFtZSwgZXZlbnRfcHJvcGVydGllcyk7XG59KTtcblxuLyoqXG4gKiBUcmFjayBjbGlja3Mgb24gYSBzZXQgb2YgZG9jdW1lbnQgZWxlbWVudHMuIFNlbGVjdG9yIG11c3QgYmUgYVxuICogdmFsaWQgcXVlcnkuIEVsZW1lbnRzIG11c3QgZXhpc3Qgb24gdGhlIHBhZ2UgYXQgdGhlIHRpbWUgdHJhY2tfbGlua3MgaXMgY2FsbGVkLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgY2xpY2sgZm9yIGxpbmsgaWQgI25hdlxuICogICAgIG1peHBhbmVsLnRyYWNrX2xpbmtzKCcjbmF2JywgJ0NsaWNrZWQgTmF2IExpbmsnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHdhaXQgdXAgdG8gMzAwIG1zIGZvciB0aGUgTWl4cGFuZWxcbiAqIHNlcnZlcnMgdG8gcmVzcG9uZC4gSWYgdGhleSBoYXZlIG5vdCByZXNwb25kZWQgYnkgdGhhdCB0aW1lXG4gKiBpdCB3aWxsIGhlYWQgdG8gdGhlIGxpbmsgd2l0aG91dCBlbnN1cmluZyB0aGF0IHlvdXIgZXZlbnRcbiAqIGhhcyBiZWVuIHRyYWNrZWQuICBUbyBjb25maWd1cmUgdGhpcyB0aW1lb3V0IHBsZWFzZSBzZWUgdGhlXG4gKiBzZXRfY29uZmlnKCkgZG9jdW1lbnRhdGlvbiBiZWxvdy5cbiAqXG4gKiBJZiB5b3UgcGFzcyBhIGZ1bmN0aW9uIGluIGFzIHRoZSBwcm9wZXJ0aWVzIGFyZ3VtZW50LCB0aGVcbiAqIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgRE9NRWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGVcbiAqIGV2ZW50IGFzIGFuIGFyZ3VtZW50LiAgWW91IGFyZSBleHBlY3RlZCB0byByZXR1cm4gYW4gb2JqZWN0XG4gKiBmcm9tIHRoZSBmdW5jdGlvbjsgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGlzIG9iamVjdFxuICogd2lsbCBiZSBzZW50IHRvIG1peHBhbmVsIGFzIGV2ZW50IHByb3BlcnRpZXMuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBxdWVyeSBBIHZhbGlkIERPTSBxdWVyeSwgZWxlbWVudCBvciBqUXVlcnktZXNxdWUgbGlzdFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyYWNrXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW3Byb3BlcnRpZXNdIEEgcHJvcGVydGllcyBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZGljdGlvbmFyeSBvZiBwcm9wZXJ0aWVzIHdoZW4gcGFzc2VkIGEgRE9NRWxlbWVudFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfbGlua3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tfZG9tLmNhbGwodGhpcywgTGlua1RyYWNrZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFRyYWNrIGZvcm0gc3VibWlzc2lvbnMuIFNlbGVjdG9yIG11c3QgYmUgYSB2YWxpZCBxdWVyeS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIHN1Ym1pc3Npb24gZm9yIGZvcm0gaWQgJ3JlZ2lzdGVyJ1xuICogICAgIG1peHBhbmVsLnRyYWNrX2Zvcm1zKCcjcmVnaXN0ZXInLCAnQ3JlYXRlZCBBY2NvdW50Jyk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCB3YWl0IHVwIHRvIDMwMCBtcyBmb3IgdGhlIG1peHBhbmVsXG4gKiBzZXJ2ZXJzIHRvIHJlc3BvbmQsIGlmIHRoZXkgaGF2ZSBub3QgcmVzcG9uZGVkIGJ5IHRoYXQgdGltZVxuICogaXQgd2lsbCBoZWFkIHRvIHRoZSBsaW5rIHdpdGhvdXQgZW5zdXJpbmcgdGhhdCB5b3VyIGV2ZW50XG4gKiBoYXMgYmVlbiB0cmFja2VkLiAgVG8gY29uZmlndXJlIHRoaXMgdGltZW91dCBwbGVhc2Ugc2VlIHRoZVxuICogc2V0X2NvbmZpZygpIGRvY3VtZW50YXRpb24gYmVsb3cuXG4gKlxuICogSWYgeW91IHBhc3MgYSBmdW5jdGlvbiBpbiBhcyB0aGUgcHJvcGVydGllcyBhcmd1bWVudCwgdGhlXG4gKiBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIERPTUVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gKiBldmVudCBhcyBhbiBhcmd1bWVudC4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIG9iamVjdFxuICogZnJvbSB0aGUgZnVuY3Rpb247IGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gdGhpcyBvYmplY3RcbiAqIHdpbGwgYmUgc2VudCB0byBtaXhwYW5lbCBhcyBldmVudCBwcm9wZXJ0aWVzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcXVlcnkgQSB2YWxpZCBET00gcXVlcnksIGVsZW1lbnQgb3IgalF1ZXJ5LWVzcXVlIGxpc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmFja1xuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtwcm9wZXJ0aWVzXSBUaGlzIGNhbiBiZSBhIHNldCBvZiBwcm9wZXJ0aWVzLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBwcm9wZXJ0aWVzIGFmdGVyIGJlaW5nIHBhc3NlZCBhIERPTUVsZW1lbnRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2Zvcm1zID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrX2RvbS5jYWxsKHRoaXMsIEZvcm1UcmFja2VyLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBUaW1lIGFuIGV2ZW50IGJ5IGluY2x1ZGluZyB0aGUgdGltZSBiZXR3ZWVuIHRoaXMgY2FsbCBhbmQgYVxuICogbGF0ZXIgJ3RyYWNrJyBjYWxsIGZvciB0aGUgc2FtZSBldmVudCBpbiB0aGUgcHJvcGVydGllcyBzZW50XG4gKiB3aXRoIHRoZSBldmVudC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRpbWUgYW4gZXZlbnQgbmFtZWQgJ1JlZ2lzdGVyZWQnXG4gKiAgICAgbWl4cGFuZWwudGltZV9ldmVudCgnUmVnaXN0ZXJlZCcpO1xuICogICAgIG1peHBhbmVsLnRyYWNrKCdSZWdpc3RlcmVkJywgeydHZW5kZXInOiAnTWFsZScsICdBZ2UnOiAyMX0pO1xuICpcbiAqIFdoZW4gY2FsbGVkIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQgbmFtZSwgdGhlIG5leHQgdHJhY2sgY2FsbCBmb3IgdGhhdCBldmVudFxuICogbmFtZSB3aWxsIGluY2x1ZGUgdGhlIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHRoZSAndGltZV9ldmVudCcgYW5kICd0cmFjaydcbiAqIGNhbGxzLiBUaGlzIHZhbHVlIGlzIHN0b3JlZCBhcyBzZWNvbmRzIGluIHRoZSAnJGR1cmF0aW9uJyBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50aW1lX2V2ZW50ID0gZnVuY3Rpb24oZXZlbnRfbmFtZSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdObyBldmVudCBuYW1lIHByb3ZpZGVkIHRvIG1peHBhbmVsLnRpbWVfZXZlbnQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudF9pc19kaXNhYmxlZChldmVudF9uYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS5zZXRfZXZlbnRfdGltZXIoZXZlbnRfbmFtZSwgIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbn07XG5cbnZhciBSRUdJU1RFUl9ERUZBVUxUUyA9IHtcbiAgICAncGVyc2lzdGVudCc6IHRydWVcbn07XG4vKipcbiAqIEhlbHBlciB0byBwYXJzZSBvcHRpb25zIHBhcmFtIGZvciByZWdpc3RlciBtZXRob2RzLCBtYWludGFpbmluZ1xuICogbGVnYWN5IHN1cHBvcnQgZm9yIHBsYWluIFwiZGF5c1wiIHBhcmFtIGluc3RlYWQgb2Ygb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gJ2RheXMnIG9wdGlvbiAoTnVtYmVyKSwgb3IgT3B0aW9ucyBvYmplY3QgZm9yIHJlZ2lzdGVyIG1ldGhvZHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9wdGlvbnMgb2JqZWN0XG4gKi9cbnZhciBvcHRpb25zX2Zvcl9yZWdpc3RlciA9IGZ1bmN0aW9uKGRheXNfb3Jfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmIChfLmlzT2JqZWN0KGRheXNfb3Jfb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRheXNfb3Jfb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKGRheXNfb3Jfb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsnZGF5cyc6IGRheXNfb3Jfb3B0aW9uc307XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gXy5leHRlbmQoe30sIFJFR0lTVEVSX0RFRkFVTFRTLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBzZXQgb2Ygc3VwZXIgcHJvcGVydGllcywgd2hpY2ggYXJlIGluY2x1ZGVkIHdpdGggYWxsXG4gKiBldmVudHMuIFRoaXMgd2lsbCBvdmVyd3JpdGUgcHJldmlvdXMgc3VwZXIgcHJvcGVydHkgdmFsdWVzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgJ0dlbmRlcicgYXMgYSBzdXBlciBwcm9wZXJ0eVxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyKHsnR2VuZGVyJzogJ0ZlbWFsZSd9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgc2V2ZXJhbCBzdXBlciBwcm9wZXJ0aWVzIHdoZW4gYSB1c2VyIHNpZ25zIHVwXG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXIoe1xuICogICAgICAgICAnRW1haWwnOiAnamRvZUBleGFtcGxlLmNvbScsXG4gKiAgICAgICAgICdBY2NvdW50IFR5cGUnOiAnRnJlZSdcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgb25seSBmb3IgdGhlIGN1cnJlbnQgcGFnZWxvYWRcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcih7J05hbWUnOiAnUGF0J30sIHtwZXJzaXN0ZW50OiBmYWxzZX0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gc3RvcmUgYWJvdXQgdGhlIHVzZXJcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgb3IgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMuZGF5c10gLSBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBwdXQgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wcywgZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihkYXlzX29yX29wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5yZWdpc3Rlcihwcm9wcywgb3B0aW9uc1snZGF5cyddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfLmV4dGVuZCh0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMsIHByb3BzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgc2V0IG9mIHN1cGVyIHByb3BlcnRpZXMgb25seSBvbmNlLiBUaGlzIHdpbGwgbm90XG4gKiBvdmVyd3JpdGUgcHJldmlvdXMgc3VwZXIgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2UgcmVnaXN0ZXIoKS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyIGEgc3VwZXIgcHJvcGVydHkgZm9yIHRoZSBmaXJzdCB0aW1lIG9ubHlcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcl9vbmNlKHtcbiAqICAgICAgICAgJ0ZpcnN0IExvZ2luIERhdGUnOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgb25jZSwgb25seSBmb3IgdGhlIGN1cnJlbnQgcGFnZWxvYWRcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcl9vbmNlKHtcbiAqICAgICAgICAgJ0ZpcnN0IGludGVyYWN0aW9uIHRpbWUnOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAqICAgICB9LCAnTm9uZScsIHtwZXJzaXN0ZW50OiBmYWxzZX0pO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBJZiBkZWZhdWx0X3ZhbHVlIGlzIHNwZWNpZmllZCwgY3VycmVudCBzdXBlciBwcm9wZXJ0aWVzXG4gKiB3aXRoIHRoYXQgdmFsdWUgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBBbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIHN0b3JlIGFib3V0IHRoZSB1c2VyXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0X3ZhbHVlXSBWYWx1ZSB0byBvdmVycmlkZSBpZiBhbHJlYWR5IHNldCBpbiBzdXBlciBwcm9wZXJ0aWVzIChleDogJ0ZhbHNlJykgRGVmYXVsdDogJ05vbmUnXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IFtkYXlzX29yX29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IG9yIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLmRheXNdIC0gbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMucGVyc2lzdGVudD10cnVlXSAtIHdoZXRoZXIgdG8gcHV0IGluIHBlcnNpc3RlbnQgc3RvcmFnZSAoY29va2llL2xvY2FsU3RvcmFnZSlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyX29uY2UgPSBmdW5jdGlvbihwcm9wcywgZGVmYXVsdF92YWx1ZSwgZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihkYXlzX29yX29wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5yZWdpc3Rlcl9vbmNlKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBvcHRpb25zWydkYXlzJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YoZGVmYXVsdF92YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkZWZhdWx0X3ZhbHVlID0gJ05vbmUnO1xuICAgICAgICB9XG4gICAgICAgIF8uZWFjaChwcm9wcywgZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHNbcHJvcF0gPT09IGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVsZXRlIGEgc3VwZXIgcHJvcGVydHkgc3RvcmVkIHdpdGggdGhlIGN1cnJlbnQgdXNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IHRvIHJlbW92ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBsb29rIGluIHBlcnNpc3RlbnQgc3RvcmFnZSAoY29va2llL2xvY2FsU3RvcmFnZSlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wZXJ0eSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihvcHRpb25zKTtcbiAgICBpZiAob3B0aW9uc1sncGVyc2lzdGVudCddKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udW5yZWdpc3Rlcihwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wZXJ0eV07XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9yZWdpc3Rlcl9zaW5nbGUgPSBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHByb3BzW3Byb3BdID0gdmFsdWU7XG4gICAgdGhpcy5yZWdpc3Rlcihwcm9wcyk7XG59O1xuXG4vKipcbiAqIElkZW50aWZ5IGEgdXNlciB3aXRoIGEgdW5pcXVlIElEIHRvIHRyYWNrIHVzZXIgYWN0aXZpdHkgYWNyb3NzXG4gKiBkZXZpY2VzLCB0aWUgYSB1c2VyIHRvIHRoZWlyIGV2ZW50cywgYW5kIGNyZWF0ZSBhIHVzZXIgcHJvZmlsZS5cbiAqIElmIHlvdSBuZXZlciBjYWxsIHRoaXMgbWV0aG9kLCB1bmlxdWUgdmlzaXRvcnMgYXJlIHRyYWNrZWQgdXNpbmdcbiAqIGEgVVVJRCBnZW5lcmF0ZWQgdGhlIGZpcnN0IHRpbWUgdGhleSB2aXNpdCB0aGUgc2l0ZS5cbiAqXG4gKiBDYWxsIGlkZW50aWZ5IHdoZW4geW91IGtub3cgdGhlIGlkZW50aXR5IG9mIHRoZSBjdXJyZW50IHVzZXIsXG4gKiB0eXBpY2FsbHkgYWZ0ZXIgbG9naW4gb3Igc2lnbnVwLiBXZSByZWNvbW1lbmQgYWdhaW5zdCB1c2luZ1xuICogaWRlbnRpZnkgZm9yIGFub255bW91cyB2aXNpdG9ycyB0byB5b3VyIHNpdGUuXG4gKlxuICogIyMjIE5vdGVzOlxuICogSWYgeW91ciBwcm9qZWN0IGhhc1xuICogPGEgaHJlZj1cImh0dHBzOi8vaGVscC5taXhwYW5lbC5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDM5MTMzODUxXCI+SUQgTWVyZ2U8L2E+XG4gKiBlbmFibGVkLCB0aGUgaWRlbnRpZnkgbWV0aG9kIHdpbGwgY29ubmVjdCBwcmUtIGFuZFxuICogcG9zdC1hdXRoZW50aWNhdGlvbiBldmVudHMgd2hlbiBhcHByb3ByaWF0ZS5cbiAqXG4gKiBJZiB5b3VyIHByb2plY3QgZG9lcyBub3QgaGF2ZSBJRCBNZXJnZSBlbmFibGVkLCBpZGVudGlmeSB3aWxsXG4gKiBjaGFuZ2UgdGhlIHVzZXIncyBsb2NhbCBkaXN0aW5jdF9pZCB0byB0aGUgdW5pcXVlIElEIHlvdSBwYXNzLlxuICogRXZlbnRzIHRyYWNrZWQgcHJpb3IgdG8gYXV0aGVudGljYXRpb24gd2lsbCBub3QgYmUgY29ubmVjdGVkXG4gKiB0byB0aGUgc2FtZSB1c2VyIGlkZW50aXR5LiBJZiBJRCBNZXJnZSBpcyBkaXNhYmxlZCwgYWxpYXMgY2FuXG4gKiBiZSB1c2VkIHRvIGNvbm5lY3QgcHJlLSBhbmQgcG9zdC1yZWdpc3RyYXRpb24gZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdW5pcXVlX2lkXSBBIHN0cmluZyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgYSB1c2VyLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBkaXN0aW5jdF9pZCBjdXJyZW50bHkgaW4gdGhlIHBlcnNpc3RlbnQgc3RvcmUgKGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UpIHdpbGwgYmUgdXNlZC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24oXG4gICAgbmV3X2Rpc3RpbmN0X2lkLCBfc2V0X2NhbGxiYWNrLCBfYWRkX2NhbGxiYWNrLCBfYXBwZW5kX2NhbGxiYWNrLCBfc2V0X29uY2VfY2FsbGJhY2ssIF91bmlvbl9jYWxsYmFjaywgX3Vuc2V0X2NhbGxiYWNrLCBfcmVtb3ZlX2NhbGxiYWNrXG4pIHtcbiAgICAvLyBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gICAgLy8gIF9zZXRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgc2V0IHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX2FkZF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBhZGQgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfYXBwZW5kX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIGFwcGVuZCBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF9zZXRfb25jZV9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBzZXRfb25jZSBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF91bmlvbl9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSB1bmlvbiBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF91bnNldF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSB1bnNldCBxdWV1ZSBpcyBmbHVzaGVkXG5cbiAgICB2YXIgcHJldmlvdXNfZGlzdGluY3RfaWQgPSB0aGlzLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIGlmIChuZXdfZGlzdGluY3RfaWQgJiYgcHJldmlvdXNfZGlzdGluY3RfaWQgIT09IG5ld19kaXN0aW5jdF9pZCkge1xuICAgICAgICAvLyB3ZSBhbGxvdyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbiBpZiBwcmV2aW91cyBkaXN0aW5jdF9pZCBpcyBzYW1lIGFzIG5ld19kaXN0aW5jdF9pZFxuICAgICAgICAvLyBzbyB0aGF0IHlvdSBjYW4gZm9yY2UgZmx1c2ggcGVvcGxlIHVwZGF0ZXMgZm9yIGFub255bW91cyBwcm9maWxlcy5cbiAgICAgICAgaWYgKHR5cGVvZiBuZXdfZGlzdGluY3RfaWQgPT09ICdzdHJpbmcnICYmIG5ld19kaXN0aW5jdF9pZC5pbmRleE9mKERFVklDRV9JRF9QUkVGSVgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignZGlzdGluY3RfaWQgY2Fubm90IGhhdmUgJGRldmljZTogcHJlZml4Jyk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3Rlcih7JyR1c2VyX2lkJzogbmV3X2Rpc3RpbmN0X2lkfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldF9wcm9wZXJ0eSgnJGRldmljZV9pZCcpKSB7XG4gICAgICAgIC8vIFRoZSBwZXJzaXN0ZWQgZGlzdGluY3QgaWQgbWlnaHQgbm90IGFjdHVhbGx5IGJlIGEgZGV2aWNlIGlkIGF0IGFsbFxuICAgICAgICAvLyBpdCBtaWdodCBiZSBhIGRpc3RpbmN0IGlkIG9mIHRoZSB1c2VyIGZyb20gYmVmb3JlXG4gICAgICAgIHZhciBkZXZpY2VfaWQgPSBwcmV2aW91c19kaXN0aW5jdF9pZDtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgICAgICckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCc6IHRydWUsXG4gICAgICAgICAgICAnJGRldmljZV9pZCc6IGRldmljZV9pZFxuICAgICAgICB9LCAnJyk7XG4gICAgfVxuXG4gICAgLy8gaWRlbnRpZnkgb25seSBjaGFuZ2VzIHRoZSBkaXN0aW5jdCBpZCBpZiBpdCBkb2Vzbid0IG1hdGNoIGVpdGhlciB0aGUgZXhpc3Rpbmcgb3IgdGhlIGFsaWFzO1xuICAgIC8vIGlmIGl0J3MgbmV3LCBibG93IGF3YXkgdGhlIGFsaWFzIGFzIHdlbGwuXG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAhPT0gcHJldmlvdXNfZGlzdGluY3RfaWQgJiYgbmV3X2Rpc3RpbmN0X2lkICE9PSB0aGlzLmdldF9wcm9wZXJ0eShBTElBU19JRF9LRVkpKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlcihBTElBU19JRF9LRVkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHsnZGlzdGluY3RfaWQnOiBuZXdfZGlzdGluY3RfaWR9KTtcbiAgICB9XG4gICAgdGhpcy5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID0gdHJ1ZTtcbiAgICAvLyBGbHVzaCBhbnkgcXVldWVkIHVwIHBlb3BsZSByZXF1ZXN0c1xuICAgIHRoaXNbJ3Blb3BsZSddLl9mbHVzaChfc2V0X2NhbGxiYWNrLCBfYWRkX2NhbGxiYWNrLCBfYXBwZW5kX2NhbGxiYWNrLCBfc2V0X29uY2VfY2FsbGJhY2ssIF91bmlvbl9jYWxsYmFjaywgX3Vuc2V0X2NhbGxiYWNrLCBfcmVtb3ZlX2NhbGxiYWNrKTtcblxuICAgIC8vIHNlbmQgYW4gJGlkZW50aWZ5IGV2ZW50IGFueSB0aW1lIHRoZSBkaXN0aW5jdF9pZCBpcyBjaGFuZ2luZyAtIGxvZ2ljIG9uIHRoZSBzZXJ2ZXJcbiAgICAvLyB3aWxsIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBkbyBhbnl0aGluZyB3aXRoIGl0LlxuICAgIGlmIChuZXdfZGlzdGluY3RfaWQgIT09IHByZXZpb3VzX2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIHRoaXMudHJhY2soJyRpZGVudGlmeScsIHtcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IG5ld19kaXN0aW5jdF9pZCxcbiAgICAgICAgICAgICckYW5vbl9kaXN0aW5jdF9pZCc6IHByZXZpb3VzX2Rpc3RpbmN0X2lkXG4gICAgICAgIH0sIHtza2lwX2hvb2tzOiB0cnVlfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgc3VwZXIgcHJvcGVydGllcyBhbmQgZ2VuZXJhdGVzIGEgbmV3IHJhbmRvbSBkaXN0aW5jdF9pZCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAqIFVzZWZ1bCBmb3IgY2xlYXJpbmcgZGF0YSB3aGVuIGEgdXNlciBsb2dzIG91dC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS5jbGVhcigpO1xuICAgIHRoaXMuX2ZsYWdzLmlkZW50aWZ5X2NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciB1dWlkID0gXy5VVUlEKCk7XG4gICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgJ2Rpc3RpbmN0X2lkJzogREVWSUNFX0lEX1BSRUZJWCArIHV1aWQsXG4gICAgICAgICckZGV2aWNlX2lkJzogdXVpZFxuICAgIH0sICcnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBkaXN0aW5jdCBpZCBvZiB0aGUgdXNlci4gVGhpcyBpcyBlaXRoZXIgdGhlIGlkIGF1dG9tYXRpY2FsbHlcbiAqIGdlbmVyYXRlZCBieSB0aGUgbGlicmFyeSBvciB0aGUgaWQgdGhhdCBoYXMgYmVlbiBwYXNzZWQgYnkgYSBjYWxsIHRvIGlkZW50aWZ5KCkuXG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIGdldF9kaXN0aW5jdF9pZCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciB0aGUgTWl4cGFuZWwgbGlicmFyeSBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAqIGluaXQoKSBoYXMgYSBsb2FkZWQgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGhhbmRsZSB0aGlzIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAvLyBzZXQgZGlzdGluY3RfaWQgYWZ0ZXIgdGhlIG1peHBhbmVsIGxpYnJhcnkgaGFzIGxvYWRlZFxuICogICAgIG1peHBhbmVsLmluaXQoJ1lPVVIgUFJPSkVDVCBUT0tFTicsIHtcbiAqICAgICAgICAgbG9hZGVkOiBmdW5jdGlvbihtaXhwYW5lbCkge1xuICogICAgICAgICAgICAgZGlzdGluY3RfaWQgPSBtaXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2Rpc3RpbmN0X2lkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0X3Byb3BlcnR5KCdkaXN0aW5jdF9pZCcpO1xufTtcblxuLyoqXG4gKiBUaGUgYWxpYXMgbWV0aG9kIGNyZWF0ZXMgYW4gYWxpYXMgd2hpY2ggTWl4cGFuZWwgd2lsbCB1c2UgdG9cbiAqIHJlbWFwIG9uZSBpZCB0byBhbm90aGVyLiBNdWx0aXBsZSBhbGlhc2VzIGNhbiBwb2ludCB0byB0aGVcbiAqIHNhbWUgaWRlbnRpZmllci5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGlzIGEgdmFsaWQgdXNlIG9mIGFsaWFzOlxuICpcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKiAgICAgLy8gWW91IGNhbiBhZGQgbXVsdGlwbGUgaWQgYWxpYXNlcyB0byB0aGUgZXhpc3RpbmcgSURcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3ZXJfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqXG4gKiBBbGlhc2VzIGNhbiBhbHNvIGJlIGNoYWluZWQgLSB0aGUgZm9sbG93aW5nIGlzIGEgdmFsaWQgZXhhbXBsZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICdleGlzdGluZ19pZCcpO1xuICogICAgIC8vIGNoYWluIG5ld2VyX2lkIC0gbmV3X2lkIC0gZXhpc3RpbmdfaWRcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3ZXJfaWQnLCAnbmV3X2lkJyk7XG4gKlxuICogQWxpYXNlcyBjYW5ub3QgcG9pbnQgdG8gbXVsdGlwbGUgaWRlbnRpZmllcnMgLSB0aGUgZm9sbG93aW5nXG4gKiBleGFtcGxlIHdpbGwgbm90IHdvcms6XG4gKlxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqICAgICAvLyB0aGlzIGlzIGludmFsaWQgYXMgJ25ld19pZCcgYWxyZWFkeSBwb2ludHMgdG8gJ2V4aXN0aW5nX2lkJ1xuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnbmV3ZXJfaWQnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogSWYgeW91ciBwcm9qZWN0IGRvZXMgbm90IGhhdmVcbiAqIDxhIGhyZWY9XCJodHRwczovL2hlbHAubWl4cGFuZWwuY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAzOTEzMzg1MVwiPklEIE1lcmdlPC9hPlxuICogZW5hYmxlZCwgdGhlIGJlc3QgcHJhY3RpY2UgaXMgdG8gY2FsbCBhbGlhcyBvbmNlIHdoZW4gYSB1bmlxdWVcbiAqIElEIGlzIGZpcnN0IGNyZWF0ZWQgZm9yIGEgdXNlciAoZS5nLiwgd2hlbiBhIHVzZXIgZmlyc3QgcmVnaXN0ZXJzXG4gKiBmb3IgYW4gYWNjb3VudCkuIERvIG5vdCB1c2UgYWxpYXMgbXVsdGlwbGUgdGltZXMgZm9yIGEgc2luZ2xlXG4gKiB1c2VyIHdpdGhvdXQgSUQgTWVyZ2UgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWxpYXMgQSB1bmlxdWUgaWRlbnRpZmllciB0aGF0IHlvdSB3YW50IHRvIHVzZSBmb3IgdGhpcyB1c2VyIGluIHRoZSBmdXR1cmUuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29yaWdpbmFsXSBUaGUgY3VycmVudCBpZGVudGlmaWVyIGJlaW5nIHVzZWQgZm9yIHRoaXMgdXNlci5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24oYWxpYXMsIG9yaWdpbmFsKSB7XG4gICAgLy8gSWYgdGhlICRwZW9wbGVfZGlzdGluY3RfaWQga2V5IGV4aXN0cyBpbiBwZXJzaXN0ZW5jZSwgdGhlcmUgaGFzIGJlZW4gYSBwcmV2aW91c1xuICAgIC8vIG1peHBhbmVsLnBlb3BsZS5pZGVudGlmeSgpIGNhbGwgbWFkZSBmb3IgdGhpcyB1c2VyLiBJdCBpcyBWRVJZIEJBRCB0byBtYWtlIGFuIGFsaWFzIHdpdGhcbiAgICAvLyB0aGlzIElELCBhcyBpdCB3aWxsIGR1cGxpY2F0ZSB1c2Vycy5cbiAgICBpZiAoYWxpYXMgPT09IHRoaXMuZ2V0X3Byb3BlcnR5KFBFT1BMRV9ESVNUSU5DVF9JRF9LRVkpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdBdHRlbXB0aW5nIHRvIGNyZWF0ZSBhbGlhcyBmb3IgZXhpc3RpbmcgUGVvcGxlIHVzZXIgLSBhYm9ydGluZy4nKTtcbiAgICAgICAgcmV0dXJuIC0yO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQob3JpZ2luYWwpKSB7XG4gICAgICAgIG9yaWdpbmFsID0gdGhpcy5nZXRfZGlzdGluY3RfaWQoKTtcbiAgICB9XG4gICAgaWYgKGFsaWFzICE9PSBvcmlnaW5hbCkge1xuICAgICAgICB0aGlzLl9yZWdpc3Rlcl9zaW5nbGUoQUxJQVNfSURfS0VZLCBhbGlhcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrKCckY3JlYXRlX2FsaWFzJywge1xuICAgICAgICAgICAgJ2FsaWFzJzogYWxpYXMsXG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBvcmlnaW5hbFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBza2lwX2hvb2tzOiB0cnVlXG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gRmx1c2ggdGhlIHBlb3BsZSBxdWV1ZVxuICAgICAgICAgICAgX3RoaXMuaWRlbnRpZnkoYWxpYXMpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignYWxpYXMgbWF0Y2hlcyBjdXJyZW50IGRpc3RpbmN0X2lkIC0gc2tpcHBpbmcgYXBpIGNhbGwuJyk7XG4gICAgICAgIHRoaXMuaWRlbnRpZnkoYWxpYXMpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlIGEgc3RyaW5nIHRvIHJlY29nbml6ZSB0aGUgdXNlciBieS4gVGhlIHN0cmluZyBwYXNzZWQgdG9cbiAqIHRoaXMgbWV0aG9kIHdpbGwgYXBwZWFyIGluIHRoZSBNaXhwYW5lbCBTdHJlYW1zIHByb2R1Y3QgcmF0aGVyXG4gKiB0aGFuIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIG5hbWUuIE5hbWUgdGFncyBkbyBub3QgaGF2ZSB0b1xuICogYmUgdW5pcXVlLlxuICpcbiAqIFRoaXMgdmFsdWUgd2lsbCBvbmx5IGJlIGluY2x1ZGVkIGluIFN0cmVhbXMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZV90YWcgQSBodW1hbiByZWFkYWJsZSBuYW1lIGZvciB0aGUgdXNlclxuICogQGRlcHJlY2F0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLm5hbWVfdGFnID0gZnVuY3Rpb24obmFtZV90YWcpIHtcbiAgICB0aGlzLl9yZWdpc3Rlcl9zaW5nbGUoJ21wX25hbWVfdGFnJywgbmFtZV90YWcpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBtaXhwYW5lbCBsaWJyYXJ5IGluc3RhbmNlLlxuICpcbiAqIFRoZSBkZWZhdWx0IGNvbmZpZyBpczpcbiAqXG4gKiAgICAge1xuICogICAgICAgLy8gaG9zdCBmb3IgcmVxdWVzdHMgKGN1c3RvbWl6YWJsZSBmb3IgZS5nLiBhIGxvY2FsIHByb3h5KVxuICogICAgICAgYXBpX2hvc3Q6ICdodHRwczovL2FwaS1qcy5taXhwYW5lbC5jb20nLFxuICpcbiAqICAgICAgIC8vIGVuZHBvaW50cyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHJlcXVlc3RzXG4gKiAgICAgICBhcGlfcm91dGVzOiB7XG4gKiAgICAgICAgIHRyYWNrOiAndHJhY2svJyxcbiAqICAgICAgICAgZW5nYWdlOiAnZW5nYWdlLycsXG4gKiAgICAgICAgIGdyb3VwczogJ2dyb3Vwcy8nLFxuICogICAgICAgfVxuICpcbiAqICAgICAgIC8vIEhUVFAgbWV0aG9kIGZvciB0cmFja2luZyByZXF1ZXN0c1xuICogICAgICAgYXBpX21ldGhvZDogJ1BPU1QnXG4gKlxuICogICAgICAgLy8gdHJhbnNwb3J0IGZvciBzZW5kaW5nIHJlcXVlc3RzICgnWEhSJyBvciAnc2VuZEJlYWNvbicpXG4gKiAgICAgICAvLyBOQjogc2VuZEJlYWNvbiBzaG91bGQgb25seSBiZSB1c2VkIGZvciBzY2VuYXJpb3Mgc3VjaCBhc1xuICogICAgICAgLy8gcGFnZSB1bmxvYWQgd2hlcmUgYSBcImJlc3QtZWZmb3J0XCIgYXR0ZW1wdCB0byBzZW5kIGlzXG4gKiAgICAgICAvLyBhY2NlcHRhYmxlOyB0aGUgc2VuZEJlYWNvbiBBUEkgZG9lcyBub3Qgc3VwcG9ydCBjYWxsYmFja3NcbiAqICAgICAgIC8vIG9yIGFueSB3YXkgdG8ga25vdyB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LiBNaXhwYW5lbFxuICogICAgICAgLy8gdHJhY2tpbmcgdmlhIHNlbmRCZWFjb24gd2lsbCBub3Qgc3VwcG9ydCBhbnkgZXZlbnQtXG4gKiAgICAgICAvLyBiYXRjaGluZyBvciByZXRyeSBtZWNoYW5pc21zLlxuICogICAgICAgYXBpX3RyYW5zcG9ydDogJ1hIUidcbiAqXG4gKiAgICAgICAvLyByZXF1ZXN0LWJhdGNoaW5nL3F1ZXVlaW5nL3JldHJ5XG4gKiAgICAgICBiYXRjaF9yZXF1ZXN0czogdHJ1ZSxcbiAqXG4gKiAgICAgICAvLyBtYXhpbXVtIG51bWJlciBvZiBldmVudHMvdXBkYXRlcyB0byBzZW5kIGluIGEgc2luZ2xlXG4gKiAgICAgICAvLyBuZXR3b3JrIHJlcXVlc3RcbiAqICAgICAgIGJhdGNoX3NpemU6IDUwLFxuICpcbiAqICAgICAgIC8vIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW4gc2VuZGluZyBiYXRjaCByZXF1ZXN0c1xuICogICAgICAgYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXM6IDUwMDAsXG4gKlxuICogICAgICAgLy8gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIG5ldHdvcmsgcmVzcG9uc2VzIHRvIGJhdGNoIHJlcXVlc3RzXG4gKiAgICAgICAvLyBiZWZvcmUgdGhleSBhcmUgY29uc2lkZXJlZCB0aW1lZC1vdXQgYW5kIHJldHJpZWRcbiAqICAgICAgIGJhdGNoX3JlcXVlc3RfdGltZW91dF9tczogOTAwMDAsXG4gKlxuICogICAgICAgLy8gb3ZlcnJpZGUgdmFsdWUgZm9yIGNvb2tpZSBkb21haW4sIG9ubHkgdXNlZnVsIGZvciBlbnN1cmluZ1xuICogICAgICAgLy8gY29ycmVjdCBjcm9zcy1zdWJkb21haW4gY29va2llcyBvbiB1bnVzdWFsIGRvbWFpbnMgbGlrZVxuICogICAgICAgLy8gc3ViZG9tYWluLm1haW5zaXRlLmF2b2NhdC5mcjsgTkIgdGhpcyBjYW5ub3QgYmUgdXNlZCB0b1xuICogICAgICAgLy8gc2V0IGNvb2tpZXMgb24gYSBkaWZmZXJlbnQgZG9tYWluIHRoYW4gdGhlIGN1cnJlbnQgb3JpZ2luXG4gKiAgICAgICBjb29raWVfZG9tYWluOiAnJ1xuICpcbiAqICAgICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgY29va2llIGV4cGlyYXRpb24gKGluIGRheXMpXG4gKiAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzY1XG4gKlxuICogICAgICAgLy8gaWYgdHJ1ZSwgY29va2llIHdpbGwgYmUgc2V0IHdpdGggU2FtZVNpdGU9Tm9uZTsgU2VjdXJlXG4gKiAgICAgICAvLyB0aGlzIGlzIG9ubHkgdXNlZnVsIGluIHNwZWNpYWwgc2l0dWF0aW9ucywgbGlrZSBlbWJlZGRlZFxuICogICAgICAgLy8gM3JkLXBhcnR5IGlmcmFtZXMgdGhhdCBzZXQgdXAgYSBNaXhwYW5lbCBpbnN0YW5jZVxuICogICAgICAgY3Jvc3Nfc2l0ZV9jb29raWU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gc3VwZXIgcHJvcGVydGllcyBzcGFuIHN1YmRvbWFpbnNcbiAqICAgICAgIGNyb3NzX3N1YmRvbWFpbl9jb29raWU6IHRydWVcbiAqXG4gKiAgICAgICAvLyBkZWJ1ZyBtb2RlXG4gKiAgICAgICBkZWJ1ZzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBpZiB0aGlzIGlzIHRydWUsIHRoZSBtaXhwYW5lbCBjb29raWUgb3IgbG9jYWxTdG9yYWdlIGVudHJ5XG4gKiAgICAgICAvLyB3aWxsIGJlIGRlbGV0ZWQsIGFuZCBubyB1c2VyIHBlcnNpc3RlbmNlIHdpbGwgdGFrZSBwbGFjZVxuICogICAgICAgZGlzYWJsZV9wZXJzaXN0ZW5jZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBpZiB0aGlzIGlzIHRydWUsIE1peHBhbmVsIHdpbGwgYXV0b21hdGljYWxseSBkZXRlcm1pbmVcbiAqICAgICAgIC8vIENpdHksIFJlZ2lvbiBhbmQgQ291bnRyeSBkYXRhIHVzaW5nIHRoZSBJUCBhZGRyZXNzIG9mXG4gKiAgICAgICAvL3RoZSBjbGllbnRcbiAqICAgICAgIGlwOiB0cnVlXG4gKlxuICogICAgICAgLy8gb3B0IHVzZXJzIG91dCBvZiB0cmFja2luZyBieSB0aGlzIE1peHBhbmVsIGluc3RhbmNlIGJ5IGRlZmF1bHRcbiAqICAgICAgIG9wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdDogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBvcHQgdXNlcnMgb3V0IG9mIGJyb3dzZXIgZGF0YSBzdG9yYWdlIGJ5IHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UgYnkgZGVmYXVsdFxuICogICAgICAgb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIHBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIGJ5IG9wdC1pbi9vcHQtb3V0IG1ldGhvZHMgLSBjb29raWVcbiAqICAgICAgIC8vIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogICAgICAgb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlOiAnbG9jYWxTdG9yYWdlJ1xuICpcbiAqICAgICAgIC8vIGN1c3RvbWl6ZSB0aGUgbmFtZSBvZiBjb29raWUvbG9jYWxTdG9yYWdlIHNldCBieSBvcHQtaW4vb3B0LW91dCBtZXRob2RzXG4gKiAgICAgICBvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXg6IG51bGxcbiAqXG4gKiAgICAgICAvLyB0eXBlIG9mIHBlcnNpc3RlbnQgc3RvcmUgZm9yIHN1cGVyIHByb3BlcnRpZXMgKGNvb2tpZS9cbiAqICAgICAgIC8vIGxvY2FsU3RvcmFnZSkgaWYgc2V0IHRvICdsb2NhbFN0b3JhZ2UnLCBhbnkgZXhpc3RpbmdcbiAqICAgICAgIC8vIG1peHBhbmVsIGNvb2tpZSB2YWx1ZSB3aXRoIHRoZSBzYW1lIHBlcnNpc3RlbmNlX25hbWVcbiAqICAgICAgIC8vIHdpbGwgYmUgdHJhbnNmZXJyZWQgdG8gbG9jYWxTdG9yYWdlIGFuZCBkZWxldGVkXG4gKiAgICAgICBwZXJzaXN0ZW5jZTogJ2Nvb2tpZSdcbiAqXG4gKiAgICAgICAvLyBuYW1lIGZvciBzdXBlciBwcm9wZXJ0aWVzIHBlcnNpc3RlbnQgc3RvcmVcbiAqICAgICAgIHBlcnNpc3RlbmNlX25hbWU6ICcnXG4gKlxuICogICAgICAgLy8gbmFtZXMgb2YgcHJvcGVydGllcy9zdXBlcnByb3BlcnRpZXMgd2hpY2ggc2hvdWxkIG5ldmVyXG4gKiAgICAgICAvLyBiZSBzZW50IHdpdGggdHJhY2soKSBjYWxsc1xuICogICAgICAgcHJvcGVydHlfYmxhY2tsaXN0OiBbXVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgbWl4cGFuZWwgY29va2llcyB3aWxsIGJlIG1hcmtlZCBhc1xuICogICAgICAgLy8gc2VjdXJlLCBtZWFuaW5nIHRoZXkgd2lsbCBvbmx5IGJlIHRyYW5zbWl0dGVkIG92ZXIgaHR0cHNcbiAqICAgICAgIHNlY3VyZV9jb29raWU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gZGlzYWJsZXMgZW5yaWNoaW5nIHVzZXIgcHJvZmlsZXMgd2l0aCBmaXJzdCB0b3VjaCBtYXJrZXRpbmcgZGF0YVxuICogICAgICAgc2tpcF9maXJzdF90b3VjaF9tYXJrZXRpbmc6IGZhbHNlXG4gKlxuICogICAgICAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIHRyYWNrX2xpbmtzIHdpbGxcbiAqICAgICAgIC8vIHdhaXQgZm9yIE1peHBhbmVsJ3Mgc2VydmVycyB0byByZXNwb25kXG4gKiAgICAgICB0cmFja19saW5rc190aW1lb3V0OiAzMDBcbiAqXG4gKiAgICAgICAvLyBhZGRzIGFueSBVVE0gcGFyYW1ldGVycyBhbmQgY2xpY2sgSURzIHByZXNlbnQgb24gdGhlIHBhZ2UgdG8gYW55IGV2ZW50cyBmaXJlZFxuICogICAgICAgdHJhY2tfbWFya2V0aW5nOiB0cnVlXG4gKlxuICogICAgICAgLy8gZW5hYmxlcyBhdXRvbWF0aWMgcGFnZSB2aWV3IHRyYWNraW5nIHVzaW5nIGRlZmF1bHQgcGFnZSB2aWV3IGV2ZW50cyB0aHJvdWdoXG4gKiAgICAgICAvLyB0aGUgdHJhY2tfcGFnZXZpZXcoKSBtZXRob2RcbiAqICAgICAgIHRyYWNrX3BhZ2V2aWV3OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHlvdSBzZXQgdXBncmFkZSB0byBiZSB0cnVlLCB0aGUgbGlicmFyeSB3aWxsIGNoZWNrIGZvclxuICogICAgICAgLy8gYSBjb29raWUgZnJvbSBvdXIgb2xkIGpzIGxpYnJhcnkgYW5kIGltcG9ydCBzdXBlclxuICogICAgICAgLy8gcHJvcGVydGllcyBmcm9tIGl0LCB0aGVuIHRoZSBvbGQgY29va2llIGlzIGRlbGV0ZWRcbiAqICAgICAgIC8vIFRoZSB1cGdyYWRlIGNvbmZpZyBvcHRpb24gb25seSB3b3JrcyBpbiB0aGUgaW5pdGlhbGl6YXRpb24sXG4gKiAgICAgICAvLyBzbyBtYWtlIHN1cmUgeW91IHNldCBpdCB3aGVuIHlvdSBjcmVhdGUgdGhlIGxpYnJhcnkuXG4gKiAgICAgICB1cGdyYWRlOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGV4dHJhIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHRvIHNldCBmb3IgZWFjaCBBUEkgcmVxdWVzdCwgaW5cbiAqICAgICAgIC8vIHRoZSBmb3JtYXQgeydIZWFkZXItTmFtZSc6IHZhbHVlfVxuICogICAgICAgeGhyX2hlYWRlcnM6IHt9XG4gKlxuICogICAgICAgLy8gd2hldGhlciB0byBpZ25vcmUgb3IgcmVzcGVjdCB0aGUgd2ViIGJyb3dzZXIncyBEbyBOb3QgVHJhY2sgc2V0dGluZ1xuICogICAgICAgaWdub3JlX2RudDogZmFsc2VcbiAqICAgICB9XG4gKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQSBkaWN0aW9uYXJ5IG9mIG5ldyBjb25maWd1cmF0aW9uIHZhbHVlcyB0byB1cGRhdGVcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9jb25maWcgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICBpZiAoXy5pc09iamVjdChjb25maWcpKSB7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXNbJ2NvbmZpZyddLCBjb25maWcpO1xuXG4gICAgICAgIHZhciBuZXdfYmF0Y2hfc2l6ZSA9IGNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xuICAgICAgICBpZiAobmV3X2JhdGNoX3NpemUpIHtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLnJlcXVlc3RfYmF0Y2hlcnMsIGZ1bmN0aW9uKGJhdGNoZXIpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVyLnJlc2V0QmF0Y2hTaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdwZXJzaXN0ZW5jZV9uYW1lJykpIHtcbiAgICAgICAgICAgIHRoaXNbJ2NvbmZpZyddWydwZXJzaXN0ZW5jZV9uYW1lJ10gPSB0aGlzWydjb25maWcnXVsnY29va2llX25hbWUnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0X2NvbmZpZygnZGlzYWJsZV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgICAgICB0aGlzWydjb25maWcnXVsnZGlzYWJsZV9wZXJzaXN0ZW5jZSddID0gdGhpc1snY29uZmlnJ11bJ2Rpc2FibGVfY29va2llJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpc1sncGVyc2lzdGVuY2UnXSkge1xuICAgICAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS51cGRhdGVfY29uZmlnKHRoaXNbJ2NvbmZpZyddKTtcbiAgICAgICAgfVxuICAgICAgICBDb25maWcuREVCVUcgPSBDb25maWcuREVCVUcgfHwgdGhpcy5nZXRfY29uZmlnKCdkZWJ1ZycpO1xuICAgIH1cbn07XG5cbi8qKlxuICogcmV0dXJucyB0aGUgY3VycmVudCBjb25maWcgb2JqZWN0IGZvciB0aGUgbGlicmFyeS5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9jb25maWcgPSBmdW5jdGlvbihwcm9wX25hbWUpIHtcbiAgICByZXR1cm4gdGhpc1snY29uZmlnJ11bcHJvcF9uYW1lXTtcbn07XG5cbi8qKlxuICogRmV0Y2ggYSBob29rIGZ1bmN0aW9uIGZyb20gY29uZmlnLCB3aXRoIHNhZmUgZGVmYXVsdCwgYW5kIHJ1biBpdFxuICogYWdhaW5zdCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9va19uYW1lIHdoaWNoIGhvb2sgdG8gcmV0cmlldmVcbiAqIEByZXR1cm5zIHthbnl8bnVsbH0gcmV0dXJuIHZhbHVlIG9mIHVzZXItcHJvdmlkZWQgaG9vaywgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyByZXR1cm5lZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3J1bl9ob29rID0gZnVuY3Rpb24oaG9va19uYW1lKSB7XG4gICAgdmFyIHJldCA9ICh0aGlzWydjb25maWcnXVsnaG9va3MnXVtob29rX25hbWVdIHx8IElERU5USVRZX0ZVTkMpLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKGhvb2tfbmFtZSArICcgaG9vayBkaWQgbm90IHJldHVybiBhIHZhbHVlJyk7XG4gICAgICAgIHJldCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzdXBlciBwcm9wZXJ0eSBuYW1lZCBwcm9wZXJ0eV9uYW1lLiBJZiBubyBzdWNoXG4gKiBwcm9wZXJ0eSBpcyBzZXQsIGdldF9wcm9wZXJ0eSgpIHdpbGwgcmV0dXJuIHRoZSB1bmRlZmluZWQgdmFsdWUuXG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIGdldF9wcm9wZXJ0eSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciB0aGUgTWl4cGFuZWwgbGlicmFyeSBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAqIGluaXQoKSBoYXMgYSBsb2FkZWQgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGhhbmRsZSB0aGlzIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAvLyBncmFiIHZhbHVlIGZvciAndXNlcl9pZCcgYWZ0ZXIgdGhlIG1peHBhbmVsIGxpYnJhcnkgaGFzIGxvYWRlZFxuICogICAgIG1peHBhbmVsLmluaXQoJ1lPVVIgUFJPSkVDVCBUT0tFTicsIHtcbiAqICAgICAgICAgbG9hZGVkOiBmdW5jdGlvbihtaXhwYW5lbCkge1xuICogICAgICAgICAgICAgdXNlcl9pZCA9IG1peHBhbmVsLmdldF9wcm9wZXJ0eSgndXNlcl9pZCcpO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5X25hbWUgVGhlIG5hbWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IHlvdSB3YW50IHRvIHJldHJpZXZlXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfcHJvcGVydHkgPSBmdW5jdGlvbihwcm9wZXJ0eV9uYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbJ3BlcnNpc3RlbmNlJ10ubG9hZF9wcm9wKFtwcm9wZXJ0eV9uYW1lXSk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0X2NvbmZpZygnbmFtZScpO1xuICAgIGlmIChuYW1lICE9PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpIHtcbiAgICAgICAgbmFtZSA9IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSArICcuJyArIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9ldmVudF9pc19kaXNhYmxlZCA9IGZ1bmN0aW9uKGV2ZW50X25hbWUpIHtcbiAgICByZXR1cm4gXy5pc0Jsb2NrZWRVQSh1c2VyQWdlbnQpIHx8XG4gICAgICAgIHRoaXMuX2ZsYWdzLmRpc2FibGVfYWxsX2V2ZW50cyB8fFxuICAgICAgICBfLmluY2x1ZGUodGhpcy5fX2Rpc2FibGVkX2V2ZW50cywgZXZlbnRfbmFtZSk7XG59O1xuXG4vLyBwZXJmb3JtIHNvbWUgaG91c2VrZWVwaW5nIGFyb3VuZCBHRFBSIG9wdC1pbi9vdXQgc3RhdGVcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZ2Rwcl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlzX2xvY2FsU3RvcmFnZV9yZXF1ZXN0ZWQgPSB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZScpID09PSAnbG9jYWxTdG9yYWdlJztcblxuICAgIC8vIHRyeSB0byBjb252ZXJ0IG9wdC1pbi9vdXQgY29va2llcyB0byBsb2NhbFN0b3JhZ2UgaWYgcG9zc2libGVcbiAgICBpZiAoaXNfbG9jYWxTdG9yYWdlX3JlcXVlc3RlZCAmJiBfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzX29wdGVkX2luX3RyYWNraW5nKCkgJiYgdGhpcy5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoeydwZXJzaXN0ZW5jZV90eXBlJzogJ2Nvb2tpZSd9KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRfaW5fdHJhY2tpbmcoeydlbmFibGVfcGVyc2lzdGVuY2UnOiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCkgJiYgdGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKHsncGVyc2lzdGVuY2VfdHlwZSc6ICdjb29raWUnfSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0X291dF90cmFja2luZyh7J2NsZWFyX3BlcnNpc3RlbmNlJzogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoe1xuICAgICAgICAgICAgJ3BlcnNpc3RlbmNlX3R5cGUnOiAnY29va2llJyxcbiAgICAgICAgICAgICdlbmFibGVfcGVyc2lzdGVuY2UnOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBhbHJlYWR5IG9wdGVkIG91dCAtIGlmIHNvLCBjbGVhciAmIGRpc2FibGUgcGVyc2lzdGVuY2VcbiAgICBpZiAodGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCkpIHtcbiAgICAgICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2UoeydjbGVhcl9wZXJzaXN0ZW5jZSc6IHRydWV9KTtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgd2Ugc2hvdWxkIG9wdCBvdXQgYnkgZGVmYXVsdFxuICAgIC8vIG5vdGU6IHdlIGRvbid0IGNsZWFyIHBlcnNpc3RlbmNlIGhlcmUgYnkgZGVmYXVsdCBzaW5jZSBvcHQtb3V0IGRlZmF1bHQgc3RhdGUgaXMgb2Z0ZW5cbiAgICAvLyAgICAgICB1c2VkIGFzIGFuIGluaXRpYWwgc3RhdGUgd2hpbGUgR0RQUiBpbmZvcm1hdGlvbiBpcyBiZWluZyBjb2xsZWN0ZWRcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmhhc19vcHRlZF9pbl90cmFja2luZygpICYmIChcbiAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX2J5X2RlZmF1bHQnKSB8fCBfLmNvb2tpZS5nZXQoJ21wX29wdG91dCcpXG4gICAgKSkge1xuICAgICAgICBfLmNvb2tpZS5yZW1vdmUoJ21wX29wdG91dCcpO1xuICAgICAgICB0aGlzLm9wdF9vdXRfdHJhY2tpbmcoe1xuICAgICAgICAgICAgJ2NsZWFyX3BlcnNpc3RlbmNlJzogdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQnKVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSBvciBkaXNhYmxlIHBlcnNpc3RlbmNlIGJhc2VkIG9uIG9wdGlvbnNcbiAqIG9ubHkgZW5hYmxlL2Rpc2FibGUgaWYgcGVyc2lzdGVuY2UgaXMgbm90IGFscmVhZHkgaW4gdGhpcyBzdGF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhcl9wZXJzaXN0ZW5jZV0gSWYgdHJ1ZSwgd2lsbCBkZWxldGUgYWxsIGRhdGEgc3RvcmVkIGJ5IHRoZSBzZGsgaW4gcGVyc2lzdGVuY2UgYW5kIGRpc2FibGUgaXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlX3BlcnNpc3RlbmNlXSBJZiB0cnVlLCB3aWxsIHJlLWVuYWJsZSBzZGsgcGVyc2lzdGVuY2VcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZGlzYWJsZWQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1snY2xlYXJfcGVyc2lzdGVuY2UnXSkge1xuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnNbJ2VuYWJsZV9wZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgIGRpc2FibGVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdkaXNhYmxlX3BlcnNpc3RlbmNlJykgJiYgdGhpc1sncGVyc2lzdGVuY2UnXS5kaXNhYmxlZCAhPT0gZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5zZXRfZGlzYWJsZWQoZGlzYWJsZWQpO1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnN0b3BfYmF0Y2hfc2VuZGVycygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9ubHkgc3RhcnQgYmF0Y2hlcnMgYWZ0ZXIgb3B0LWluIGlmIHRoZXkgaGF2ZSBwcmV2aW91c2x5IGJlZW4gc3RhcnRlZFxuICAgICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCB1bmludGVudGlvbmFsbHkgc3RhcnRpbmcgdXAgYmF0Y2hpbmcgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgIGlmICh0aGlzLl9iYXRjaGVyc193ZXJlX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRfYmF0Y2hfc2VuZGVycygpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gY2FsbCBhIGJhc2UgZ2RwciBmdW5jdGlvbiBhZnRlciBjb25zdHJ1Y3RpbmcgdGhlIGFwcHJvcHJpYXRlIHRva2VuIGFuZCBvcHRpb25zIGFyZ3Ncbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZ2Rwcl9jYWxsX2Z1bmMgPSBmdW5jdGlvbihmdW5jLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ3RyYWNrJzogXy5iaW5kKHRoaXMudHJhY2ssIHRoaXMpLFxuICAgICAgICAncGVyc2lzdGVuY2VfdHlwZSc6IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJyksXG4gICAgICAgICdjb29raWVfcHJlZml4JzogdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnKSxcbiAgICAgICAgJ2Nvb2tpZV9leHBpcmF0aW9uJzogdGhpcy5nZXRfY29uZmlnKCdjb29raWVfZXhwaXJhdGlvbicpLFxuICAgICAgICAnY3Jvc3Nfc2l0ZV9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ2Nyb3NzX3NpdGVfY29va2llJyksXG4gICAgICAgICdjcm9zc19zdWJkb21haW5fY29va2llJzogdGhpcy5nZXRfY29uZmlnKCdjcm9zc19zdWJkb21haW5fY29va2llJyksXG4gICAgICAgICdjb29raWVfZG9tYWluJzogdGhpcy5nZXRfY29uZmlnKCdjb29raWVfZG9tYWluJyksXG4gICAgICAgICdzZWN1cmVfY29va2llJzogdGhpcy5nZXRfY29uZmlnKCdzZWN1cmVfY29va2llJyksXG4gICAgICAgICdpZ25vcmVfZG50JzogdGhpcy5nZXRfY29uZmlnKCdpZ25vcmVfZG50JylcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGlmIGxvY2FsU3RvcmFnZSBjYW4gYmUgdXNlZCBmb3IgcmVjb3JkaW5nIG9wdCBvdXQgc3RhdHVzLCBmYWxsIGJhY2sgdG8gY29va2llIGlmIG5vdFxuICAgIGlmICghXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgb3B0aW9uc1sncGVyc2lzdGVuY2VfdHlwZSddID0gJ2Nvb2tpZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmModGhpcy5nZXRfY29uZmlnKCd0b2tlbicpLCB7XG4gICAgICAgIHRyYWNrOiBvcHRpb25zWyd0cmFjayddLFxuICAgICAgICB0cmFja0V2ZW50TmFtZTogb3B0aW9uc1sndHJhY2tfZXZlbnRfbmFtZSddLFxuICAgICAgICB0cmFja1Byb3BlcnRpZXM6IG9wdGlvbnNbJ3RyYWNrX3Byb3BlcnRpZXMnXSxcbiAgICAgICAgcGVyc2lzdGVuY2VUeXBlOiBvcHRpb25zWydwZXJzaXN0ZW5jZV90eXBlJ10sXG4gICAgICAgIHBlcnNpc3RlbmNlUHJlZml4OiBvcHRpb25zWydjb29raWVfcHJlZml4J10sXG4gICAgICAgIGNvb2tpZURvbWFpbjogb3B0aW9uc1snY29va2llX2RvbWFpbiddLFxuICAgICAgICBjb29raWVFeHBpcmF0aW9uOiBvcHRpb25zWydjb29raWVfZXhwaXJhdGlvbiddLFxuICAgICAgICBjcm9zc1NpdGVDb29raWU6IG9wdGlvbnNbJ2Nyb3NzX3NpdGVfY29va2llJ10sXG4gICAgICAgIGNyb3NzU3ViZG9tYWluQ29va2llOiBvcHRpb25zWydjcm9zc19zdWJkb21haW5fY29va2llJ10sXG4gICAgICAgIHNlY3VyZUNvb2tpZTogb3B0aW9uc1snc2VjdXJlX2Nvb2tpZSddLFxuICAgICAgICBpZ25vcmVEbnQ6IG9wdGlvbnNbJ2lnbm9yZV9kbnQnXVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIG9wdCB1c2VyIGluXG4gKiAgICAgbWl4cGFuZWwub3B0X2luX3RyYWNraW5nKCk7XG4gKlxuICogICAgIC8vIG9wdCB1c2VyIGluIHdpdGggc3BlY2lmaWMgZXZlbnQgbmFtZSwgcHJvcGVydGllcywgY29va2llIGNvbmZpZ3VyYXRpb25cbiAqICAgICBtaXhwYW5lbC5vcHRfaW5fdHJhY2tpbmcoe1xuICogICAgICAgICB0cmFja19ldmVudF9uYW1lOiAnVXNlciBvcHRlZCBpbicsXG4gKiAgICAgICAgIHRyYWNrX2V2ZW50X3Byb3BlcnRpZXM6IHtcbiAqICAgICAgICAgICAgICdFbWFpbCc6ICdqZG9lQGV4YW1wbGUuY29tJ1xuICogICAgICAgICB9LFxuICogICAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzAsXG4gKiAgICAgICAgIHNlY3VyZV9jb29raWU6IHRydWVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMudHJhY2tdIEZ1bmN0aW9uIHVzZWQgZm9yIHRyYWNraW5nIGEgTWl4cGFuZWwgZXZlbnQgdG8gcmVjb3JkIHRoZSBvcHQtaW4gYWN0aW9uIChkZWZhdWx0IGlzIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyB0cmFjayBtZXRob2QpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhY2tfZXZlbnRfbmFtZT0kb3B0X2luXSBFdmVudCBuYW1lIHRvIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHJhY2tfcHJvcGVydGllc10gU2V0IG9mIHByb3BlcnRpZXMgdG8gYmUgdHJhY2tlZCBhbG9uZyB3aXRoIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZV9wZXJzaXN0ZW5jZT10cnVlXSBJZiB0cnVlLCB3aWxsIHJlLWVuYWJsZSBzZGsgcGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llX2V4cGlyYXRpb25dIE51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXMgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfZG9tYWluXSBDdXN0b20gY29va2llIGRvbWFpbiAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zaXRlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3N1YmRvbWFpbl9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X2luX3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICdlbmFibGVfcGVyc2lzdGVuY2UnOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9nZHByX2NhbGxfZnVuYyhvcHRJbiwgb3B0aW9ucyk7XG4gICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2Uob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIG9wdCB1c2VyIG91dFxuICogICAgIG1peHBhbmVsLm9wdF9vdXRfdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgb3V0IHdpdGggZGlmZmVyZW50IGNvb2tpZSBjb25maWd1cmF0aW9uIGZyb20gTWl4cGFuZWwgaW5zdGFuY2VcbiAqICAgICBtaXhwYW5lbC5vcHRfb3V0X3RyYWNraW5nKHtcbiAqICAgICAgICAgY29va2llX2V4cGlyYXRpb246IDMwLFxuICogICAgICAgICBzZWN1cmVfY29va2llOiB0cnVlXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVsZXRlX3VzZXI9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCBkZWxldGUgdGhlIGN1cnJlbnRseSBpZGVudGlmaWVkIHVzZXIncyBwcm9maWxlIGFuZCBjbGVhciBhbGwgY2hhcmdlcyBhZnRlciBvcHRpbmcgdGhlIHVzZXIgb3V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyX3BlcnNpc3RlbmNlPXRydWVdIElmIHRydWUsIHdpbGwgZGVsZXRlIGFsbCBkYXRhIHN0b3JlZCBieSB0aGUgc2RrIGluIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2NsZWFyX3BlcnNpc3RlbmNlJzogdHJ1ZSxcbiAgICAgICAgJ2RlbGV0ZV91c2VyJzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gZGVsZXRlIHVzZXIgYW5kIGNsZWFyIGNoYXJnZXMgc2luY2UgdGhlc2UgbWV0aG9kcyBtYXkgYmUgZGlzYWJsZWQgYnkgb3B0LW91dFxuICAgIGlmIChvcHRpb25zWydkZWxldGVfdXNlciddICYmIHRoaXNbJ3Blb3BsZSddICYmIHRoaXNbJ3Blb3BsZSddLl9pZGVudGlmeV9jYWxsZWQoKSkge1xuICAgICAgICB0aGlzWydwZW9wbGUnXS5kZWxldGVfdXNlcigpO1xuICAgICAgICB0aGlzWydwZW9wbGUnXS5jbGVhcl9jaGFyZ2VzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMob3B0T3V0LCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIHZhciBoYXNfb3B0ZWRfaW4gPSBtaXhwYW5lbC5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoKTtcbiAqICAgICAvLyB1c2UgaGFzX29wdGVkX2luIHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gY3VycmVudCBvcHQtaW4gc3RhdHVzXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dkcHJfY2FsbF9mdW5jKGhhc09wdGVkSW4sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIHZhciBoYXNfb3B0ZWRfb3V0ID0gbWl4cGFuZWwuaGFzX29wdGVkX291dF90cmFja2luZygpO1xuICogICAgIC8vIHVzZSBoYXNfb3B0ZWRfb3V0IHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gY3VycmVudCBvcHQtb3V0IHN0YXR1c1xuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX291dF90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMoaGFzT3B0ZWRPdXQsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgdXNlcidzIG9wdCBpbi9vdXQgc3RhdHVzIG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBjbGVhciB1c2VyJ3Mgb3B0LWluL291dCBzdGF0dXNcbiAqICAgICBtaXhwYW5lbC5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nKCk7XG4gKlxuICogICAgIC8vIGNsZWFyIHVzZXIncyBvcHQtaW4vb3V0IHN0YXR1cyB3aXRoIHNwZWNpZmljIGNvb2tpZSBjb25maWd1cmF0aW9uIC0gc2hvdWxkIG1hdGNoXG4gKiAgICAgLy8gY29uZmlndXJhdGlvbiB1c2VkIHdoZW4gb3B0X2luX3RyYWNraW5nL29wdF9vdXRfdHJhY2tpbmcgbWV0aG9kcyB3ZXJlIGNhbGxlZC5cbiAqICAgICBtaXhwYW5lbC5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nKHtcbiAqICAgICAgICAgY29va2llX2V4cGlyYXRpb246IDMwLFxuICogICAgICAgICBzZWN1cmVfY29va2llOiB0cnVlXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlX3BlcnNpc3RlbmNlPXRydWVdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVfZXhwaXJhdGlvbl0gTnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlcyAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9kb21haW5dIEN1c3RvbSBjb29raWUgZG9tYWluIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3NpdGVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWQgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICdlbmFibGVfcGVyc2lzdGVuY2UnOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9nZHByX2NhbGxfZnVuYyhjbGVhck9wdEluT3V0LCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZShvcHRpb25zKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZXBvcnRfZXJyb3IgPSBmdW5jdGlvbihtc2csIGVycikge1xuICAgIGNvbnNvbGUkMS5lcnJvci5hcHBseShjb25zb2xlJDEuZXJyb3IsIGFyZ3VtZW50cyk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFlcnIgJiYgIShtc2cgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgIG1zZyA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0X2NvbmZpZygnZXJyb3JfcmVwb3J0ZXInKShtc2csIGVycik7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKGVycik7XG4gICAgfVxufTtcblxuLy8gRVhQT1JUUyAoZm9yIGNsb3N1cmUgY29tcGlsZXIpXG5cbi8vIE1peHBhbmVsTGliIEV4cG9ydHNcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaW5pdCddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmluaXQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3Jlc2V0J10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZXNldDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZGlzYWJsZSddICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmRpc2FibGU7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RpbWVfZXZlbnQnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50aW1lX2V2ZW50O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFjayddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2s7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX2xpbmtzJ10gICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19saW5rcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfZm9ybXMnXSAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2Zvcm1zO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja19wYWdldmlldyddICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfcGFnZXZpZXc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3JlZ2lzdGVyJ10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3Rlcjtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVnaXN0ZXJfb25jZSddICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyX29uY2U7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3VucmVnaXN0ZXInXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS51bnJlZ2lzdGVyO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydpZGVudGlmeSddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaWRlbnRpZnk7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2FsaWFzJ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5hbGlhcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnbmFtZV90YWcnXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLm5hbWVfdGFnO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzZXRfY29uZmlnJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2NvbmZpZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X2NvbmZpZyddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9jb25maWc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9wcm9wZXJ0eSddICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfcHJvcGVydHk7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9kaXN0aW5jdF9pZCddICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZGlzdGluY3RfaWQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RvU3RyaW5nJ10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50b1N0cmluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnb3B0X291dF90cmFja2luZyddICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9vdXRfdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ29wdF9pbl90cmFja2luZyddICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfaW5fdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2hhc19vcHRlZF9vdXRfdHJhY2tpbmcnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydoYXNfb3B0ZWRfaW5fdHJhY2tpbmcnXSAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX2luX3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydjbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nJ10gICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuY2xlYXJfb3B0X2luX291dF90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc2V0X2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnYWRkX2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmFkZF9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVtb3ZlX2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlbW92ZV9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfd2l0aF9ncm91cHMnXSAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3dpdGhfZ3JvdXBzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdGFydF9iYXRjaF9zZW5kZXJzJ10gICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfYmF0Y2hfc2VuZGVycztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RvcF9iYXRjaF9zZW5kZXJzJ10gICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3BfYmF0Y2hfc2VuZGVycztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcnXSAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdG9wX3Nlc3Npb25fcmVjb3JkaW5nJ10gICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9zZXNzaW9uX3JlY29yZGluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXMnXSAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfc2Vzc2lvbl9yZXBsYXlfdXJsJ10gICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVwbGF5X3VybDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnREVGQVVMVF9BUElfUk9VVEVTJ10gICAgICAgICAgICAgICAgID0gREVGQVVMVF9BUElfUk9VVEVTO1xuXG4vLyBNaXhwYW5lbFBlcnNpc3RlbmNlIEV4cG9ydHNcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWydwcm9wZXJ0aWVzJ10gICAgICAgICAgICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnByb3BlcnRpZXM7XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsndXBkYXRlX3NlYXJjaF9rZXl3b3JkJ10gPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfc2VhcmNoX2tleXdvcmQ7XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsndXBkYXRlX3JlZmVycmVyX2luZm8nXSAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfcmVmZXJyZXJfaW5mbztcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWydnZXRfY3Jvc3Nfc3ViZG9tYWluJ10gICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmdldF9jcm9zc19zdWJkb21haW47XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsnY2xlYXInXSAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5jbGVhcjtcblxuXG52YXIgaW5zdGFuY2VzID0ge307XG52YXIgZXh0ZW5kX21wID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gYWRkIGFsbCB0aGUgc3ViIG1peHBhbmVsIGluc3RhbmNlc1xuICAgIF8uZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uKGluc3RhbmNlLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpIHsgbWl4cGFuZWxfbWFzdGVyW25hbWVdID0gaW5zdGFuY2U7IH1cbiAgICB9KTtcblxuICAgIC8vIGFkZCBwcml2YXRlIGZ1bmN0aW9ucyBhcyBfXG4gICAgbWl4cGFuZWxfbWFzdGVyWydfJ10gPSBfO1xufTtcblxudmFyIG92ZXJyaWRlX21wX2luaXRfZnVuYyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHdlIG92ZXJyaWRlIHRoZSBzbmlwcGV0cyBpbml0IGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhXG4gICAgLy8gdXNlciBpbml0aWFsaXplcyB0aGUgbWl4cGFuZWwgbGlicmFyeSBhZnRlciB0aGUgc2NyaXB0IGxvYWRzICYgcnVuc1xuICAgIG1peHBhbmVsX21hc3RlclsnaW5pdCddID0gZnVuY3Rpb24odG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBhIHN1YiBsaWJyYXJ5XG4gICAgICAgICAgICBpZiAoIW1peHBhbmVsX21hc3RlcltuYW1lXSkge1xuICAgICAgICAgICAgICAgIG1peHBhbmVsX21hc3RlcltuYW1lXSA9IGluc3RhbmNlc1tuYW1lXSA9IGNyZWF0ZV9tcGxpYih0b2tlbiwgY29uZmlnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0uX2xvYWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1peHBhbmVsX21hc3RlcltuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG1peHBhbmVsX21hc3RlcjtcblxuICAgICAgICAgICAgaWYgKGluc3RhbmNlc1tQUklNQVJZX0lOU1RBTkNFX05BTUVdKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFpbiBtaXhwYW5lbCBsaWIgYWxyZWFkeSBpbml0aWFsaXplZFxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gaW50aWFsaXplIHRoZSBtYWluIG1peHBhbmVsIGxpYlxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gY3JlYXRlX21wbGliKHRva2VuLCBjb25maWcsIFBSSU1BUllfSU5TVEFOQ0VfTkFNRSk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuX2xvYWRlZCgpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlc1tQUklNQVJZX0lOU1RBTkNFX05BTUVdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1peHBhbmVsX21hc3RlciA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaWYgKGluaXRfdHlwZSA9PT0gSU5JVF9TTklQUEVUKSB7XG4gICAgICAgICAgICAgICAgd2luW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0gPSBtaXhwYW5lbF9tYXN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbmRfbXAoKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgYWRkX2RvbV9sb2FkZWRfaGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIENyb3NzIGJyb3dzZXIgRE9NIExvYWRlZCBzdXBwb3J0XG4gICAgZnVuY3Rpb24gZG9tX2xvYWRlZF9oYW5kbGVyKCkge1xuICAgICAgICAvLyBmdW5jdGlvbiBmbGFnIHNpbmNlIHdlIG9ubHkgd2FudCB0byBleGVjdXRlIHRoaXMgb25jZVxuICAgICAgICBpZiAoZG9tX2xvYWRlZF9oYW5kbGVyLmRvbmUpIHsgcmV0dXJuOyB9XG4gICAgICAgIGRvbV9sb2FkZWRfaGFuZGxlci5kb25lID0gdHJ1ZTtcblxuICAgICAgICBET01fTE9BREVEID0gdHJ1ZTtcbiAgICAgICAgRU5RVUVVRV9SRVFVRVNUUyA9IGZhbHNlO1xuXG4gICAgICAgIF8uZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uKGluc3QpIHtcbiAgICAgICAgICAgIGluc3QuX2RvbV9sb2FkZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9fc2Nyb2xsX2NoZWNrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jdW1lbnQkMS5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwoJ2xlZnQnKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGRvX3Njcm9sbF9jaGVjaywgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkb21fbG9hZGVkX2hhbmRsZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoZG9jdW1lbnQkMS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGlmIChkb2N1bWVudCQxLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgIC8vIHNhZmFyaSA0IGNhbiBmaXJlIHRoZSBET01Db250ZW50TG9hZGVkIGV2ZW50IGJlZm9yZSBsb2FkaW5nIGFsbFxuICAgICAgICAgICAgLy8gZXh0ZXJuYWwgSlMgKGluY2x1ZGluZyB0aGlzIGZpbGUpLiB5b3Ugd2lsbCBzZWUgc29tZSBjb3B5cGFzdGFcbiAgICAgICAgICAgIC8vIG9uIHRoZSBpbnRlcm5ldCB0aGF0IGNoZWNrcyBmb3IgJ2NvbXBsZXRlJyBhbmQgJ2xvYWRlZCcsIGJ1dFxuICAgICAgICAgICAgLy8gJ2xvYWRlZCcgaXMgYW4gSUUgdGhpbmdcbiAgICAgICAgICAgIGRvbV9sb2FkZWRfaGFuZGxlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQkMS5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZG9tX2xvYWRlZF9oYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50JDEuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgLy8gSUVcbiAgICAgICAgZG9jdW1lbnQkMS5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgZG9tX2xvYWRlZF9oYW5kbGVyKTtcblxuICAgICAgICAvLyBjaGVjayB0byBtYWtlIHN1cmUgd2UgYXJuJ3QgaW4gYSBmcmFtZVxuICAgICAgICB2YXIgdG9wbGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRvcGxldmVsID0gd2luLmZyYW1lRWxlbWVudCA9PT0gbnVsbDtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnQkMS5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgJiYgdG9wbGV2ZWwpIHtcbiAgICAgICAgICAgIGRvX3Njcm9sbF9jaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmFsbGJhY2sgaGFuZGxlciwgYWx3YXlzIHdpbGwgd29ya1xuICAgIF8ucmVnaXN0ZXJfZXZlbnQod2luLCAnbG9hZCcsIGRvbV9sb2FkZWRfaGFuZGxlciwgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiBpbml0X2FzX21vZHVsZShidW5kbGVfbG9hZGVyKSB7XG4gICAgbG9hZF9leHRyYV9idW5kbGUgPSBidW5kbGVfbG9hZGVyO1xuICAgIGluaXRfdHlwZSA9IElOSVRfTU9EVUxFO1xuICAgIG1peHBhbmVsX21hc3RlciA9IG5ldyBNaXhwYW5lbExpYigpO1xuXG4gICAgb3ZlcnJpZGVfbXBfaW5pdF9mdW5jKCk7XG4gICAgbWl4cGFuZWxfbWFzdGVyWydpbml0J10oKTtcbiAgICBhZGRfZG9tX2xvYWRlZF9oYW5kbGVyKCk7XG5cbiAgICByZXR1cm4gbWl4cGFuZWxfbWFzdGVyO1xufVxuXG4vLyBGb3IgbG9hZGluZyBzZXBhcmF0ZSBidW5kbGVzIGFzeW5jaHJvbm91c2x5IHZpYSBzY3JpcHQgdGFnXG5cbi8vIEZvciBidWlsZHMgdGhhdCBoYXZlIGV2ZXJ5dGhpbmcgaW4gb25lIGJ1bmRsZSwgbm8gZXh0cmEgd29yay5cbmZ1bmN0aW9uIGxvYWROb29wIChfc3JjLCBvbmxvYWQpIHtcbiAgICBvbmxvYWQoKTtcbn1cblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG52YXIgbWl4cGFuZWwgPSBpbml0X2FzX21vZHVsZShsb2FkTm9vcCk7XG5cbmV4cG9ydCB7IG1peHBhbmVsIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mixpanel-browser/dist/mixpanel.module.js\n");

/***/ })

};
;