"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mixpanel-browser";
exports.ids = ["vendor-chunks/mixpanel-browser"];
exports.modules = {

/***/ "(ssr)/./node_modules/mixpanel-browser/dist/mixpanel.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/mixpanel-browser/dist/mixpanel.module.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mixpanel)\n/* harmony export */ });\nvar NodeType;\r\n(function (NodeType) {\r\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\r\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\r\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\r\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\r\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\r\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\r\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\r\n    return n.nodeType === n.ELEMENT_NODE;\r\n}\r\nfunction isShadowRoot(n) {\r\n    const host = n === null || n === void 0 ? void 0 : n.host;\r\n    return Boolean((host === null || host === void 0 ? void 0 : host.shadowRoot) === n);\r\n}\r\nfunction isNativeShadowDom(shadowRoot) {\r\n    return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\r\n}\r\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\r\n    if (cssText.includes(' background-clip: text;') &&\r\n        !cssText.includes(' -webkit-background-clip: text;')) {\r\n        cssText = cssText.replace(' background-clip: text;', ' -webkit-background-clip: text; background-clip: text;');\r\n    }\r\n    return cssText;\r\n}\r\nfunction escapeImportStatement(rule) {\r\n    const { cssText } = rule;\r\n    if (cssText.split('\"').length < 3)\r\n        return cssText;\r\n    const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\r\n    if (rule.layerName === '') {\r\n        statement.push(`layer`);\r\n    }\r\n    else if (rule.layerName) {\r\n        statement.push(`layer(${rule.layerName})`);\r\n    }\r\n    if (rule.supportsText) {\r\n        statement.push(`supports(${rule.supportsText})`);\r\n    }\r\n    if (rule.media.length) {\r\n        statement.push(rule.media.mediaText);\r\n    }\r\n    return statement.join(' ') + ';';\r\n}\r\nfunction stringifyStylesheet(s) {\r\n    try {\r\n        const rules = s.rules || s.cssRules;\r\n        return rules\r\n            ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(''))\r\n            : null;\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\r\nfunction stringifyRule(rule) {\r\n    let importStringified;\r\n    if (isCSSImportRule(rule)) {\r\n        try {\r\n            importStringified =\r\n                stringifyStylesheet(rule.styleSheet) ||\r\n                    escapeImportStatement(rule);\r\n        }\r\n        catch (error) {\r\n        }\r\n    }\r\n    else if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\r\n        return fixSafariColons(rule.cssText);\r\n    }\r\n    return importStringified || rule.cssText;\r\n}\r\nfunction fixSafariColons(cssStringified) {\r\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\r\n    return cssStringified.replace(regex, '$1\\\\$2');\r\n}\r\nfunction isCSSImportRule(rule) {\r\n    return 'styleSheet' in rule;\r\n}\r\nfunction isCSSStyleRule(rule) {\r\n    return 'selectorText' in rule;\r\n}\r\nclass Mirror {\r\n    constructor() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n    getId(n) {\r\n        var _a;\r\n        if (!n)\r\n            return -1;\r\n        const id = (_a = this.getMeta(n)) === null || _a === void 0 ? void 0 : _a.id;\r\n        return id !== null && id !== void 0 ? id : -1;\r\n    }\r\n    getNode(id) {\r\n        return this.idNodeMap.get(id) || null;\r\n    }\r\n    getIds() {\r\n        return Array.from(this.idNodeMap.keys());\r\n    }\r\n    getMeta(n) {\r\n        return this.nodeMetaMap.get(n) || null;\r\n    }\r\n    removeNodeFromMap(n) {\r\n        const id = this.getId(n);\r\n        this.idNodeMap.delete(id);\r\n        if (n.childNodes) {\r\n            n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\r\n        }\r\n    }\r\n    has(id) {\r\n        return this.idNodeMap.has(id);\r\n    }\r\n    hasNode(node) {\r\n        return this.nodeMetaMap.has(node);\r\n    }\r\n    add(n, meta) {\r\n        const id = meta.id;\r\n        this.idNodeMap.set(id, n);\r\n        this.nodeMetaMap.set(n, meta);\r\n    }\r\n    replace(id, n) {\r\n        const oldNode = this.getNode(id);\r\n        if (oldNode) {\r\n            const meta = this.nodeMetaMap.get(oldNode);\r\n            if (meta)\r\n                this.nodeMetaMap.set(n, meta);\r\n        }\r\n        this.idNodeMap.set(id, n);\r\n    }\r\n    reset() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n}\r\nfunction createMirror() {\r\n    return new Mirror();\r\n}\r\nfunction maskInputValue({ element, maskInputOptions, tagName, type, value, maskInputFn, }) {\r\n    let text = value || '';\r\n    const actualType = type && toLowerCase(type);\r\n    if (maskInputOptions[tagName.toLowerCase()] ||\r\n        (actualType && maskInputOptions[actualType])) {\r\n        if (maskInputFn) {\r\n            text = maskInputFn(text, element);\r\n        }\r\n        else {\r\n            text = '*'.repeat(text.length);\r\n        }\r\n    }\r\n    return text;\r\n}\r\nfunction toLowerCase(str) {\r\n    return str.toLowerCase();\r\n}\r\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\r\nfunction is2DCanvasBlank(canvas) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx)\r\n        return true;\r\n    const chunkSize = 50;\r\n    for (let x = 0; x < canvas.width; x += chunkSize) {\r\n        for (let y = 0; y < canvas.height; y += chunkSize) {\r\n            const getImageData = ctx.getImageData;\r\n            const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData\r\n                ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\r\n                : getImageData;\r\n            const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\r\n            if (pixelBuffer.some((pixel) => pixel !== 0))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getInputType(element) {\r\n    const type = element.type;\r\n    return element.hasAttribute('data-rr-is-password')\r\n        ? 'password'\r\n        : type\r\n            ?\r\n                toLowerCase(type)\r\n            : null;\r\n}\r\nfunction extractFileExtension(path, baseURL) {\r\n    var _a;\r\n    let url;\r\n    try {\r\n        url = new URL(path, baseURL !== null && baseURL !== void 0 ? baseURL : window.location.href);\r\n    }\r\n    catch (err) {\r\n        return null;\r\n    }\r\n    const regex = /\\.([0-9a-z]+)(?:$)/i;\r\n    const match = url.pathname.match(regex);\r\n    return (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : null;\r\n}\n\nlet _id = 1;\r\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\r\nconst IGNORED_NODE = -2;\r\nfunction genId() {\r\n    return _id++;\r\n}\r\nfunction getValidTagName(element) {\r\n    if (element instanceof HTMLFormElement) {\r\n        return 'form';\r\n    }\r\n    const processedTagName = toLowerCase(element.tagName);\r\n    if (tagNameRegex.test(processedTagName)) {\r\n        return 'div';\r\n    }\r\n    return processedTagName;\r\n}\r\nfunction extractOrigin(url) {\r\n    let origin = '';\r\n    if (url.indexOf('//') > -1) {\r\n        origin = url.split('/').slice(0, 3).join('/');\r\n    }\r\n    else {\r\n        origin = url.split('/')[0];\r\n    }\r\n    origin = origin.split('?')[0];\r\n    return origin;\r\n}\r\nlet canvasService;\r\nlet canvasCtx;\r\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\r\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\r\nconst URL_WWW_MATCH = /^www\\..*/i;\r\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\r\nfunction absoluteToStylesheet(cssText, href) {\r\n    return (cssText || '').replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\r\n        const filePath = path1 || path2 || path3;\r\n        const maybeQuote = quote1 || quote2 || '';\r\n        if (!filePath) {\r\n            return origin;\r\n        }\r\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (DATA_URI.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (filePath[0] === '/') {\r\n            return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\r\n        }\r\n        const stack = href.split('/');\r\n        const parts = filePath.split('/');\r\n        stack.pop();\r\n        for (const part of parts) {\r\n            if (part === '.') {\r\n                continue;\r\n            }\r\n            else if (part === '..') {\r\n                stack.pop();\r\n            }\r\n            else {\r\n                stack.push(part);\r\n            }\r\n        }\r\n        return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\r\n    });\r\n}\r\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\r\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\r\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\r\n    if (attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    let pos = 0;\r\n    function collectCharacters(regEx) {\r\n        let chars;\r\n        const match = regEx.exec(attributeValue.substring(pos));\r\n        if (match) {\r\n            chars = match[0];\r\n            pos += chars.length;\r\n            return chars;\r\n        }\r\n        return '';\r\n    }\r\n    const output = [];\r\n    while (true) {\r\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\r\n        if (pos >= attributeValue.length) {\r\n            break;\r\n        }\r\n        let url = collectCharacters(SRCSET_NOT_SPACES);\r\n        if (url.slice(-1) === ',') {\r\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\r\n            output.push(url);\r\n        }\r\n        else {\r\n            let descriptorsStr = '';\r\n            url = absoluteToDoc(doc, url);\r\n            let inParens = false;\r\n            while (true) {\r\n                const c = attributeValue.charAt(pos);\r\n                if (c === '') {\r\n                    output.push((url + descriptorsStr).trim());\r\n                    break;\r\n                }\r\n                else if (!inParens) {\r\n                    if (c === ',') {\r\n                        pos += 1;\r\n                        output.push((url + descriptorsStr).trim());\r\n                        break;\r\n                    }\r\n                    else if (c === '(') {\r\n                        inParens = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (c === ')') {\r\n                        inParens = false;\r\n                    }\r\n                }\r\n                descriptorsStr += c;\r\n                pos += 1;\r\n            }\r\n        }\r\n    }\r\n    return output.join(', ');\r\n}\r\nfunction absoluteToDoc(doc, attributeValue) {\r\n    if (!attributeValue || attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    const a = doc.createElement('a');\r\n    a.href = attributeValue;\r\n    return a.href;\r\n}\r\nfunction isSVGElement(el) {\r\n    return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\r\n}\r\nfunction getHref() {\r\n    const a = document.createElement('a');\r\n    a.href = '';\r\n    return a.href;\r\n}\r\nfunction transformAttribute(doc, tagName, name, value) {\r\n    if (!value) {\r\n        return value;\r\n    }\r\n    if (name === 'src' ||\r\n        (name === 'href' && !(tagName === 'use' && value[0] === '#'))) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'xlink:href' && value[0] !== '#') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'background' &&\r\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'srcset') {\r\n        return getAbsoluteSrcsetString(doc, value);\r\n    }\r\n    else if (name === 'style') {\r\n        return absoluteToStylesheet(value, getHref());\r\n    }\r\n    else if (tagName === 'object' && name === 'data') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    return value;\r\n}\r\nfunction ignoreAttribute(tagName, name, _value) {\r\n    return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\r\n}\r\nfunction _isBlockedElement(element, blockClass, blockSelector) {\r\n    try {\r\n        if (typeof blockClass === 'string') {\r\n            if (element.classList.contains(blockClass)) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (let eIndex = element.classList.length; eIndex--;) {\r\n                const className = element.classList[eIndex];\r\n                if (blockClass.test(className)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        if (blockSelector) {\r\n            return element.matches(blockSelector);\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction classMatchesRegex(node, regex, checkAncestors) {\r\n    if (!node)\r\n        return false;\r\n    if (node.nodeType !== node.ELEMENT_NODE) {\r\n        if (!checkAncestors)\r\n            return false;\r\n        return classMatchesRegex(node.parentNode, regex, checkAncestors);\r\n    }\r\n    for (let eIndex = node.classList.length; eIndex--;) {\r\n        const className = node.classList[eIndex];\r\n        if (regex.test(className)) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!checkAncestors)\r\n        return false;\r\n    return classMatchesRegex(node.parentNode, regex, checkAncestors);\r\n}\r\nfunction needMaskingText(node, maskTextClass, maskTextSelector, checkAncestors) {\r\n    try {\r\n        const el = node.nodeType === node.ELEMENT_NODE\r\n            ? node\r\n            : node.parentElement;\r\n        if (el === null)\r\n            return false;\r\n        if (typeof maskTextClass === 'string') {\r\n            if (checkAncestors) {\r\n                if (el.closest(`.${maskTextClass}`))\r\n                    return true;\r\n            }\r\n            else {\r\n                if (el.classList.contains(maskTextClass))\r\n                    return true;\r\n            }\r\n        }\r\n        else {\r\n            if (classMatchesRegex(el, maskTextClass, checkAncestors))\r\n                return true;\r\n        }\r\n        if (maskTextSelector) {\r\n            if (checkAncestors) {\r\n                if (el.closest(maskTextSelector))\r\n                    return true;\r\n            }\r\n            else {\r\n                if (el.matches(maskTextSelector))\r\n                    return true;\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\r\n    const win = iframeEl.contentWindow;\r\n    if (!win) {\r\n        return;\r\n    }\r\n    let fired = false;\r\n    let readyState;\r\n    try {\r\n        readyState = win.document.readyState;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (readyState !== 'complete') {\r\n        const timer = setTimeout(() => {\r\n            if (!fired) {\r\n                listener();\r\n                fired = true;\r\n            }\r\n        }, iframeLoadTimeout);\r\n        iframeEl.addEventListener('load', () => {\r\n            clearTimeout(timer);\r\n            fired = true;\r\n            listener();\r\n        });\r\n        return;\r\n    }\r\n    const blankUrl = 'about:blank';\r\n    if (win.location.href !== blankUrl ||\r\n        iframeEl.src === blankUrl ||\r\n        iframeEl.src === '') {\r\n        setTimeout(listener, 0);\r\n        return iframeEl.addEventListener('load', listener);\r\n    }\r\n    iframeEl.addEventListener('load', listener);\r\n}\r\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\r\n    let fired = false;\r\n    let styleSheetLoaded;\r\n    try {\r\n        styleSheetLoaded = link.sheet;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (styleSheetLoaded)\r\n        return;\r\n    const timer = setTimeout(() => {\r\n        if (!fired) {\r\n            listener();\r\n            fired = true;\r\n        }\r\n    }, styleSheetLoadTimeout);\r\n    link.addEventListener('load', () => {\r\n        clearTimeout(timer);\r\n        fired = true;\r\n        listener();\r\n    });\r\n}\r\nfunction serializeNode(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, needsMask, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, } = options;\r\n    const rootId = getRootId(doc, mirror);\r\n    switch (n.nodeType) {\r\n        case n.DOCUMENT_NODE:\r\n            if (n.compatMode !== 'CSS1Compat') {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                    compatMode: n.compatMode,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                };\r\n            }\r\n        case n.DOCUMENT_TYPE_NODE:\r\n            return {\r\n                type: NodeType.DocumentType,\r\n                name: n.name,\r\n                publicId: n.publicId,\r\n                systemId: n.systemId,\r\n                rootId,\r\n            };\r\n        case n.ELEMENT_NODE:\r\n            return serializeElementNode(n, {\r\n                doc,\r\n                blockClass,\r\n                blockSelector,\r\n                inlineStylesheet,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                dataURLOptions,\r\n                inlineImages,\r\n                recordCanvas,\r\n                keepIframeSrcFn,\r\n                newlyAddedElement,\r\n                rootId,\r\n            });\r\n        case n.TEXT_NODE:\r\n            return serializeTextNode(n, {\r\n                needsMask,\r\n                maskTextFn,\r\n                rootId,\r\n            });\r\n        case n.CDATA_SECTION_NODE:\r\n            return {\r\n                type: NodeType.CDATA,\r\n                textContent: '',\r\n                rootId,\r\n            };\r\n        case n.COMMENT_NODE:\r\n            return {\r\n                type: NodeType.Comment,\r\n                textContent: n.textContent || '',\r\n                rootId,\r\n            };\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getRootId(doc, mirror) {\r\n    if (!mirror.hasNode(doc))\r\n        return undefined;\r\n    const docId = mirror.getId(doc);\r\n    return docId === 1 ? undefined : docId;\r\n}\r\nfunction serializeTextNode(n, options) {\r\n    var _a;\r\n    const { needsMask, maskTextFn, rootId } = options;\r\n    const parentTagName = n.parentNode && n.parentNode.tagName;\r\n    let textContent = n.textContent;\r\n    const isStyle = parentTagName === 'STYLE' ? true : undefined;\r\n    const isScript = parentTagName === 'SCRIPT' ? true : undefined;\r\n    if (isStyle && textContent) {\r\n        try {\r\n            if (n.nextSibling || n.previousSibling) {\r\n            }\r\n            else if ((_a = n.parentNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) {\r\n                textContent = stringifyStylesheet(n.parentNode.sheet);\r\n            }\r\n        }\r\n        catch (err) {\r\n            console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\r\n        }\r\n        textContent = absoluteToStylesheet(textContent, getHref());\r\n    }\r\n    if (isScript) {\r\n        textContent = 'SCRIPT_PLACEHOLDER';\r\n    }\r\n    if (!isStyle && !isScript && textContent && needsMask) {\r\n        textContent = maskTextFn\r\n            ? maskTextFn(textContent, n.parentElement)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    return {\r\n        type: NodeType.Text,\r\n        textContent: textContent || '',\r\n        isStyle,\r\n        rootId,\r\n    };\r\n}\r\nfunction serializeElementNode(n, options) {\r\n    const { doc, blockClass, blockSelector, inlineStylesheet, maskInputOptions = {}, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId, } = options;\r\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector);\r\n    const tagName = getValidTagName(n);\r\n    let attributes = {};\r\n    const len = n.attributes.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const attr = n.attributes[i];\r\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\r\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\r\n        }\r\n    }\r\n    if (tagName === 'link' && inlineStylesheet) {\r\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\r\n            return s.href === n.href;\r\n        });\r\n        let cssText = null;\r\n        if (stylesheet) {\r\n            cssText = stringifyStylesheet(stylesheet);\r\n        }\r\n        if (cssText) {\r\n            delete attributes.rel;\r\n            delete attributes.href;\r\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\r\n        }\r\n    }\r\n    if (tagName === 'style' &&\r\n        n.sheet &&\r\n        !(n.innerText || n.textContent || '').trim().length) {\r\n        const cssText = stringifyStylesheet(n.sheet);\r\n        if (cssText) {\r\n            attributes._cssText = absoluteToStylesheet(cssText, getHref());\r\n        }\r\n    }\r\n    if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {\r\n        const value = n.value;\r\n        const checked = n.checked;\r\n        if (attributes.type !== 'radio' &&\r\n            attributes.type !== 'checkbox' &&\r\n            attributes.type !== 'submit' &&\r\n            attributes.type !== 'button' &&\r\n            value) {\r\n            attributes.value = maskInputValue({\r\n                element: n,\r\n                type: getInputType(n),\r\n                tagName,\r\n                value,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        else if (checked) {\r\n            attributes.checked = checked;\r\n        }\r\n    }\r\n    if (tagName === 'option') {\r\n        if (n.selected && !maskInputOptions['select']) {\r\n            attributes.selected = true;\r\n        }\r\n        else {\r\n            delete attributes.selected;\r\n        }\r\n    }\r\n    if (tagName === 'canvas' && recordCanvas) {\r\n        if (n.__context === '2d') {\r\n            if (!is2DCanvasBlank(n)) {\r\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n        }\r\n        else if (!('__context' in n)) {\r\n            const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            const blankCanvas = document.createElement('canvas');\r\n            blankCanvas.width = n.width;\r\n            blankCanvas.height = n.height;\r\n            const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            if (canvasDataURL !== blankCanvasDataURL) {\r\n                attributes.rr_dataURL = canvasDataURL;\r\n            }\r\n        }\r\n    }\r\n    if (tagName === 'img' && inlineImages) {\r\n        if (!canvasService) {\r\n            canvasService = doc.createElement('canvas');\r\n            canvasCtx = canvasService.getContext('2d');\r\n        }\r\n        const image = n;\r\n        const oldValue = image.crossOrigin;\r\n        image.crossOrigin = 'anonymous';\r\n        const recordInlineImage = () => {\r\n            image.removeEventListener('load', recordInlineImage);\r\n            try {\r\n                canvasService.width = image.naturalWidth;\r\n                canvasService.height = image.naturalHeight;\r\n                canvasCtx.drawImage(image, 0, 0);\r\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n            catch (err) {\r\n                console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);\r\n            }\r\n            oldValue\r\n                ? (attributes.crossOrigin = oldValue)\r\n                : image.removeAttribute('crossorigin');\r\n        };\r\n        if (image.complete && image.naturalWidth !== 0)\r\n            recordInlineImage();\r\n        else\r\n            image.addEventListener('load', recordInlineImage);\r\n    }\r\n    if (tagName === 'audio' || tagName === 'video') {\r\n        const mediaAttributes = attributes;\r\n        mediaAttributes.rr_mediaState = n.paused\r\n            ? 'paused'\r\n            : 'played';\r\n        mediaAttributes.rr_mediaCurrentTime = n.currentTime;\r\n        mediaAttributes.rr_mediaPlaybackRate = n.playbackRate;\r\n        mediaAttributes.rr_mediaMuted = n.muted;\r\n        mediaAttributes.rr_mediaLoop = n.loop;\r\n        mediaAttributes.rr_mediaVolume = n.volume;\r\n    }\r\n    if (!newlyAddedElement) {\r\n        if (n.scrollLeft) {\r\n            attributes.rr_scrollLeft = n.scrollLeft;\r\n        }\r\n        if (n.scrollTop) {\r\n            attributes.rr_scrollTop = n.scrollTop;\r\n        }\r\n    }\r\n    if (needBlock) {\r\n        const { width, height } = n.getBoundingClientRect();\r\n        attributes = {\r\n            class: attributes.class,\r\n            rr_width: `${width}px`,\r\n            rr_height: `${height}px`,\r\n        };\r\n    }\r\n    if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src)) {\r\n        if (!n.contentDocument) {\r\n            attributes.rr_src = attributes.src;\r\n        }\r\n        delete attributes.src;\r\n    }\r\n    let isCustomElement;\r\n    try {\r\n        if (customElements.get(tagName))\r\n            isCustomElement = true;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return {\r\n        type: NodeType.Element,\r\n        tagName,\r\n        attributes,\r\n        childNodes: [],\r\n        isSVG: isSVGElement(n) || undefined,\r\n        needBlock,\r\n        rootId,\r\n        isCustom: isCustomElement,\r\n    };\r\n}\r\nfunction lowerIfExists(maybeAttr) {\r\n    if (maybeAttr === undefined || maybeAttr === null) {\r\n        return '';\r\n    }\r\n    else {\r\n        return maybeAttr.toLowerCase();\r\n    }\r\n}\r\nfunction slimDOMExcluded(sn, slimDOMOptions) {\r\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\r\n        return true;\r\n    }\r\n    else if (sn.type === NodeType.Element) {\r\n        if (slimDOMOptions.script &&\r\n            (sn.tagName === 'script' ||\r\n                (sn.tagName === 'link' &&\r\n                    (sn.attributes.rel === 'preload' ||\r\n                        sn.attributes.rel === 'modulepreload') &&\r\n                    sn.attributes.as === 'script') ||\r\n                (sn.tagName === 'link' &&\r\n                    sn.attributes.rel === 'prefetch' &&\r\n                    typeof sn.attributes.href === 'string' &&\r\n                    extractFileExtension(sn.attributes.href) === 'js'))) {\r\n            return true;\r\n        }\r\n        else if (slimDOMOptions.headFavicon &&\r\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\r\n                (sn.tagName === 'meta' &&\r\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\r\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\r\n            return true;\r\n        }\r\n        else if (sn.tagName === 'meta') {\r\n            if (slimDOMOptions.headMetaDescKeywords &&\r\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaSocial &&\r\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\r\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\r\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaRobots &&\r\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\r\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\r\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaHttpEquiv &&\r\n                sn.attributes['http-equiv'] !== undefined) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaAuthorship &&\r\n                (lowerIfExists(sn.attributes.name) === 'author' ||\r\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\r\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\r\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\r\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\r\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\r\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaVerification &&\r\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\r\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction serializeNodeWithId(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, maskTextClass, maskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5000, onStylesheetLoad, stylesheetLoadTimeout = 5000, keepIframeSrcFn = () => false, newlyAddedElement = false, } = options;\r\n    let { needsMask } = options;\r\n    let { preserveWhiteSpace = true } = options;\r\n    if (!needsMask &&\r\n        n.childNodes) {\r\n        const checkAncestors = needsMask === undefined;\r\n        needsMask = needMaskingText(n, maskTextClass, maskTextSelector, checkAncestors);\r\n    }\r\n    const _serializedNode = serializeNode(n, {\r\n        doc,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        needsMask,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement,\r\n    });\r\n    if (!_serializedNode) {\r\n        console.warn(n, 'not serialized');\r\n        return null;\r\n    }\r\n    let id;\r\n    if (mirror.hasNode(n)) {\r\n        id = mirror.getId(n);\r\n    }\r\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\r\n        (!preserveWhiteSpace &&\r\n            _serializedNode.type === NodeType.Text &&\r\n            !_serializedNode.isStyle &&\r\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\r\n        id = IGNORED_NODE;\r\n    }\r\n    else {\r\n        id = genId();\r\n    }\r\n    const serializedNode = Object.assign(_serializedNode, { id });\r\n    mirror.add(n, serializedNode);\r\n    if (id === IGNORED_NODE) {\r\n        return null;\r\n    }\r\n    if (onSerialize) {\r\n        onSerialize(n);\r\n    }\r\n    let recordChild = !skipChild;\r\n    if (serializedNode.type === NodeType.Element) {\r\n        recordChild = recordChild && !serializedNode.needBlock;\r\n        delete serializedNode.needBlock;\r\n        const shadowRoot = n.shadowRoot;\r\n        if (shadowRoot && isNativeShadowDom(shadowRoot))\r\n            serializedNode.isShadowHost = true;\r\n    }\r\n    if ((serializedNode.type === NodeType.Document ||\r\n        serializedNode.type === NodeType.Element) &&\r\n        recordChild) {\r\n        if (slimDOMOptions.headWhitespace &&\r\n            serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'head') {\r\n            preserveWhiteSpace = false;\r\n        }\r\n        const bypassOptions = {\r\n            doc,\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            needsMask,\r\n            maskTextClass,\r\n            maskTextSelector,\r\n            skipChild,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            slimDOMOptions,\r\n            dataURLOptions,\r\n            inlineImages,\r\n            recordCanvas,\r\n            preserveWhiteSpace,\r\n            onSerialize,\r\n            onIframeLoad,\r\n            iframeLoadTimeout,\r\n            onStylesheetLoad,\r\n            stylesheetLoadTimeout,\r\n            keepIframeSrcFn,\r\n        };\r\n        if (serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'textarea' &&\r\n            serializedNode.attributes.value !== undefined) ;\r\n        else {\r\n            for (const childN of Array.from(n.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n        if (isElement(n) && n.shadowRoot) {\r\n            for (const childN of Array.from(n.shadowRoot.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    isNativeShadowDom(n.shadowRoot) &&\r\n                        (serializedChildNode.isShadow = true);\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (n.parentNode &&\r\n        isShadowRoot(n.parentNode) &&\r\n        isNativeShadowDom(n.parentNode)) {\r\n        serializedNode.isShadow = true;\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'iframe') {\r\n        onceIframeLoaded(n, () => {\r\n            const iframeDoc = n.contentDocument;\r\n            if (iframeDoc && onIframeLoad) {\r\n                const serializedIframeNode = serializeNodeWithId(iframeDoc, {\r\n                    doc: iframeDoc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    needsMask,\r\n                    maskTextClass,\r\n                    maskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedIframeNode) {\r\n                    onIframeLoad(n, serializedIframeNode);\r\n                }\r\n            }\r\n        }, iframeLoadTimeout);\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'link' &&\r\n        typeof serializedNode.attributes.rel === 'string' &&\r\n        (serializedNode.attributes.rel === 'stylesheet' ||\r\n            (serializedNode.attributes.rel === 'preload' &&\r\n                typeof serializedNode.attributes.href === 'string' &&\r\n                extractFileExtension(serializedNode.attributes.href) === 'css'))) {\r\n        onceStylesheetLoaded(n, () => {\r\n            if (onStylesheetLoad) {\r\n                const serializedLinkNode = serializeNodeWithId(n, {\r\n                    doc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    needsMask,\r\n                    maskTextClass,\r\n                    maskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedLinkNode) {\r\n                    onStylesheetLoad(n, serializedLinkNode);\r\n                }\r\n            }\r\n        }, stylesheetLoadTimeout);\r\n    }\r\n    return serializedNode;\r\n}\r\nfunction snapshot(n, options) {\r\n    const { mirror = new Mirror(), blockClass = 'rr-block', blockSelector = null, maskTextClass = 'rr-mask', maskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false, } = options || {};\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n            password: true,\r\n        }\r\n        : maskAllInputs === false\r\n            ? {\r\n                password: true,\r\n            }\r\n            : maskAllInputs;\r\n    const slimDOMOptions = slimDOM === true || slimDOM === 'all'\r\n        ?\r\n            {\r\n                script: true,\r\n                comment: true,\r\n                headFavicon: true,\r\n                headWhitespace: true,\r\n                headMetaDescKeywords: slimDOM === 'all',\r\n                headMetaSocial: true,\r\n                headMetaRobots: true,\r\n                headMetaHttpEquiv: true,\r\n                headMetaAuthorship: true,\r\n                headMetaVerification: true,\r\n            }\r\n        : slimDOM === false\r\n            ? {}\r\n            : slimDOM;\r\n    return serializeNodeWithId(n, {\r\n        doc: n,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        maskTextClass,\r\n        maskTextSelector,\r\n        skipChild: false,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        slimDOMOptions,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        preserveWhiteSpace,\r\n        onSerialize,\r\n        onIframeLoad,\r\n        iframeLoadTimeout,\r\n        onStylesheetLoad,\r\n        stylesheetLoadTimeout,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement: false,\r\n    });\r\n}\n\nfunction on(type, fn, target = document) {\r\n    const options = { capture: true, passive: true };\r\n    target.addEventListener(type, fn, options);\r\n    return () => target.removeEventListener(type, fn, options);\r\n}\r\nconst DEPARTED_MIRROR_ACCESS_WARNING = 'Please stop import mirror directly. Instead of that,' +\r\n    '\\r\\n' +\r\n    'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\r\n    '\\r\\n' +\r\n    'or you can use record.mirror to access the mirror instance during recording.';\r\nlet _mirror = {\r\n    map: {},\r\n    getId() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return -1;\r\n    },\r\n    getNode() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return null;\r\n    },\r\n    removeNodeFromMap() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n    has() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return false;\r\n    },\r\n    reset() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n};\r\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\r\n    _mirror = new Proxy(_mirror, {\r\n        get(target, prop, receiver) {\r\n            if (prop === 'map') {\r\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n            }\r\n            return Reflect.get(target, prop, receiver);\r\n        },\r\n    });\r\n}\r\nfunction throttle(func, wait, options = {}) {\r\n    let timeout = null;\r\n    let previous = 0;\r\n    return function (...args) {\r\n        const now = Date.now();\r\n        if (!previous && options.leading === false) {\r\n            previous = now;\r\n        }\r\n        const remaining = wait - (now - previous);\r\n        const context = this;\r\n        if (remaining <= 0 || remaining > wait) {\r\n            if (timeout) {\r\n                clearTimeout(timeout);\r\n                timeout = null;\r\n            }\r\n            previous = now;\r\n            func.apply(context, args);\r\n        }\r\n        else if (!timeout && options.trailing !== false) {\r\n            timeout = setTimeout(() => {\r\n                previous = options.leading === false ? 0 : Date.now();\r\n                timeout = null;\r\n                func.apply(context, args);\r\n            }, remaining);\r\n        }\r\n    };\r\n}\r\nfunction hookSetter(target, key, d, isRevoked, win = window) {\r\n    const original = win.Object.getOwnPropertyDescriptor(target, key);\r\n    win.Object.defineProperty(target, key, isRevoked\r\n        ? d\r\n        : {\r\n            set(value) {\r\n                setTimeout(() => {\r\n                    d.set.call(this, value);\r\n                }, 0);\r\n                if (original && original.set) {\r\n                    original.set.call(this, value);\r\n                }\r\n            },\r\n        });\r\n    return () => hookSetter(target, key, original || {}, true);\r\n}\r\nfunction patch(source, name, replacement) {\r\n    try {\r\n        if (!(name in source)) {\r\n            return () => {\r\n            };\r\n        }\r\n        const original = source[name];\r\n        const wrapped = replacement(original);\r\n        if (typeof wrapped === 'function') {\r\n            wrapped.prototype = wrapped.prototype || {};\r\n            Object.defineProperties(wrapped, {\r\n                __rrweb_original__: {\r\n                    enumerable: false,\r\n                    value: original,\r\n                },\r\n            });\r\n        }\r\n        source[name] = wrapped;\r\n        return () => {\r\n            source[name] = original;\r\n        };\r\n    }\r\n    catch (_a) {\r\n        return () => {\r\n        };\r\n    }\r\n}\r\nlet nowTimestamp = Date.now;\r\nif (!(/[1-9][0-9]{12}/.test(Date.now().toString()))) {\r\n    nowTimestamp = () => new Date().getTime();\r\n}\r\nfunction getWindowScroll(win) {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    const doc = win.document;\r\n    return {\r\n        left: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollLeft\r\n            : win.pageXOffset !== undefined\r\n                ? win.pageXOffset\r\n                : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollLeft) ||\r\n                    ((_b = (_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.scrollLeft) ||\r\n                    ((_c = doc === null || doc === void 0 ? void 0 : doc.body) === null || _c === void 0 ? void 0 : _c.scrollLeft) ||\r\n                    0,\r\n        top: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollTop\r\n            : win.pageYOffset !== undefined\r\n                ? win.pageYOffset\r\n                : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollTop) ||\r\n                    ((_e = (_d = doc === null || doc === void 0 ? void 0 : doc.body) === null || _d === void 0 ? void 0 : _d.parentElement) === null || _e === void 0 ? void 0 : _e.scrollTop) ||\r\n                    ((_f = doc === null || doc === void 0 ? void 0 : doc.body) === null || _f === void 0 ? void 0 : _f.scrollTop) ||\r\n                    0,\r\n    };\r\n}\r\nfunction getWindowHeight() {\r\n    return (window.innerHeight ||\r\n        (document.documentElement && document.documentElement.clientHeight) ||\r\n        (document.body && document.body.clientHeight));\r\n}\r\nfunction getWindowWidth() {\r\n    return (window.innerWidth ||\r\n        (document.documentElement && document.documentElement.clientWidth) ||\r\n        (document.body && document.body.clientWidth));\r\n}\r\nfunction closestElementOfNode(node) {\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    const el = node.nodeType === node.ELEMENT_NODE\r\n        ? node\r\n        : node.parentElement;\r\n    return el;\r\n}\r\nfunction isBlocked(node, blockClass, blockSelector, checkAncestors) {\r\n    if (!node) {\r\n        return false;\r\n    }\r\n    const el = closestElementOfNode(node);\r\n    if (!el) {\r\n        return false;\r\n    }\r\n    try {\r\n        if (typeof blockClass === 'string') {\r\n            if (el.classList.contains(blockClass))\r\n                return true;\r\n            if (checkAncestors && el.closest('.' + blockClass) !== null)\r\n                return true;\r\n        }\r\n        else {\r\n            if (classMatchesRegex(el, blockClass, checkAncestors))\r\n                return true;\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    if (blockSelector) {\r\n        if (el.matches(blockSelector))\r\n            return true;\r\n        if (checkAncestors && el.closest(blockSelector) !== null)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction isSerialized(n, mirror) {\r\n    return mirror.getId(n) !== -1;\r\n}\r\nfunction isIgnored(n, mirror) {\r\n    return mirror.getId(n) === IGNORED_NODE;\r\n}\r\nfunction isAncestorRemoved(target, mirror) {\r\n    if (isShadowRoot(target)) {\r\n        return false;\r\n    }\r\n    const id = mirror.getId(target);\r\n    if (!mirror.has(id)) {\r\n        return true;\r\n    }\r\n    if (target.parentNode &&\r\n        target.parentNode.nodeType === target.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    if (!target.parentNode) {\r\n        return true;\r\n    }\r\n    return isAncestorRemoved(target.parentNode, mirror);\r\n}\r\nfunction legacy_isTouchEvent(event) {\r\n    return Boolean(event.changedTouches);\r\n}\r\nfunction polyfill(win = window) {\r\n    if ('NodeList' in win && !win.NodeList.prototype.forEach) {\r\n        win.NodeList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\r\n        win.DOMTokenList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if (!Node.prototype.contains) {\r\n        Node.prototype.contains = (...args) => {\r\n            let node = args[0];\r\n            if (!(0 in args)) {\r\n                throw new TypeError('1 argument is required');\r\n            }\r\n            do {\r\n                if (this === node) {\r\n                    return true;\r\n                }\r\n            } while ((node = node && node.parentNode));\r\n            return false;\r\n        };\r\n    }\r\n}\r\nfunction isSerializedIframe(n, mirror) {\r\n    return Boolean(n.nodeName === 'IFRAME' && mirror.getMeta(n));\r\n}\r\nfunction isSerializedStylesheet(n, mirror) {\r\n    return Boolean(n.nodeName === 'LINK' &&\r\n        n.nodeType === n.ELEMENT_NODE &&\r\n        n.getAttribute &&\r\n        n.getAttribute('rel') === 'stylesheet' &&\r\n        mirror.getMeta(n));\r\n}\r\nfunction hasShadowRoot(n) {\r\n    return Boolean(n === null || n === void 0 ? void 0 : n.shadowRoot);\r\n}\r\nclass StyleSheetMirror {\r\n    constructor() {\r\n        this.id = 1;\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n    }\r\n    getId(stylesheet) {\r\n        var _a;\r\n        return (_a = this.styleIDMap.get(stylesheet)) !== null && _a !== void 0 ? _a : -1;\r\n    }\r\n    has(stylesheet) {\r\n        return this.styleIDMap.has(stylesheet);\r\n    }\r\n    add(stylesheet, id) {\r\n        if (this.has(stylesheet))\r\n            return this.getId(stylesheet);\r\n        let newId;\r\n        if (id === undefined) {\r\n            newId = this.id++;\r\n        }\r\n        else\r\n            newId = id;\r\n        this.styleIDMap.set(stylesheet, newId);\r\n        this.idStyleMap.set(newId, stylesheet);\r\n        return newId;\r\n    }\r\n    getStyle(id) {\r\n        return this.idStyleMap.get(id) || null;\r\n    }\r\n    reset() {\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n        this.id = 1;\r\n    }\r\n    generateId() {\r\n        return this.id++;\r\n    }\r\n}\r\nfunction getShadowHost(n) {\r\n    var _a, _b;\r\n    let shadowHost = null;\r\n    if (((_b = (_a = n.getRootNode) === null || _a === void 0 ? void 0 : _a.call(n)) === null || _b === void 0 ? void 0 : _b.nodeType) === Node.DOCUMENT_FRAGMENT_NODE &&\r\n        n.getRootNode().host)\r\n        shadowHost = n.getRootNode().host;\r\n    return shadowHost;\r\n}\r\nfunction getRootShadowHost(n) {\r\n    let rootShadowHost = n;\r\n    let shadowHost;\r\n    while ((shadowHost = getShadowHost(rootShadowHost)))\r\n        rootShadowHost = shadowHost;\r\n    return rootShadowHost;\r\n}\r\nfunction shadowHostInDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    const shadowHost = getRootShadowHost(n);\r\n    return doc.contains(shadowHost);\r\n}\r\nfunction inDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    return doc.contains(n) || shadowHostInDom(n);\r\n}\n\nvar EventType$1 = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType$1 || {});\nvar IncrementalSource$1 = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource$1 || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\n\nfunction isNodeInLinkedList(n) {\r\n    return '__ln' in n;\r\n}\r\nclass DoubleLinkedList {\r\n    constructor() {\r\n        this.length = 0;\r\n        this.head = null;\r\n        this.tail = null;\r\n    }\r\n    get(position) {\r\n        if (position >= this.length) {\r\n            throw new Error('Position outside of list range');\r\n        }\r\n        let current = this.head;\r\n        for (let index = 0; index < position; index++) {\r\n            current = (current === null || current === void 0 ? void 0 : current.next) || null;\r\n        }\r\n        return current;\r\n    }\r\n    addNode(n) {\r\n        const node = {\r\n            value: n,\r\n            previous: null,\r\n            next: null,\r\n        };\r\n        n.__ln = node;\r\n        if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\r\n            const current = n.previousSibling.__ln.next;\r\n            node.next = current;\r\n            node.previous = n.previousSibling.__ln;\r\n            n.previousSibling.__ln.next = node;\r\n            if (current) {\r\n                current.previous = node;\r\n            }\r\n        }\r\n        else if (n.nextSibling &&\r\n            isNodeInLinkedList(n.nextSibling) &&\r\n            n.nextSibling.__ln.previous) {\r\n            const current = n.nextSibling.__ln.previous;\r\n            node.previous = current;\r\n            node.next = n.nextSibling.__ln;\r\n            n.nextSibling.__ln.previous = node;\r\n            if (current) {\r\n                current.next = node;\r\n            }\r\n        }\r\n        else {\r\n            if (this.head) {\r\n                this.head.previous = node;\r\n            }\r\n            node.next = this.head;\r\n            this.head = node;\r\n        }\r\n        if (node.next === null) {\r\n            this.tail = node;\r\n        }\r\n        this.length++;\r\n    }\r\n    removeNode(n) {\r\n        const current = n.__ln;\r\n        if (!this.head) {\r\n            return;\r\n        }\r\n        if (!current.previous) {\r\n            this.head = current.next;\r\n            if (this.head) {\r\n                this.head.previous = null;\r\n            }\r\n            else {\r\n                this.tail = null;\r\n            }\r\n        }\r\n        else {\r\n            current.previous.next = current.next;\r\n            if (current.next) {\r\n                current.next.previous = current.previous;\r\n            }\r\n            else {\r\n                this.tail = current.previous;\r\n            }\r\n        }\r\n        if (n.__ln) {\r\n            delete n.__ln;\r\n        }\r\n        this.length--;\r\n    }\r\n}\r\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\r\nclass MutationBuffer {\r\n    constructor() {\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.texts = [];\r\n        this.attributes = [];\r\n        this.attributeMap = new WeakMap();\r\n        this.removes = [];\r\n        this.mapRemoves = [];\r\n        this.movedMap = {};\r\n        this.addedSet = new Set();\r\n        this.movedSet = new Set();\r\n        this.droppedSet = new Set();\r\n        this.processMutations = (mutations) => {\r\n            mutations.forEach(this.processMutation);\r\n            this.emit();\r\n        };\r\n        this.emit = () => {\r\n            if (this.frozen || this.locked) {\r\n                return;\r\n            }\r\n            const adds = [];\r\n            const addedIds = new Set();\r\n            const addList = new DoubleLinkedList();\r\n            const getNextId = (n) => {\r\n                let ns = n;\r\n                let nextId = IGNORED_NODE;\r\n                while (nextId === IGNORED_NODE) {\r\n                    ns = ns && ns.nextSibling;\r\n                    nextId = ns && this.mirror.getId(ns);\r\n                }\r\n                return nextId;\r\n            };\r\n            const pushAdd = (n) => {\r\n                if (!n.parentNode ||\r\n                    !inDom(n) ||\r\n                    n.parentNode.tagName === 'TEXTAREA') {\r\n                    return;\r\n                }\r\n                const parentId = isShadowRoot(n.parentNode)\r\n                    ? this.mirror.getId(getShadowHost(n))\r\n                    : this.mirror.getId(n.parentNode);\r\n                const nextId = getNextId(n);\r\n                if (parentId === -1 || nextId === -1) {\r\n                    return addList.addNode(n);\r\n                }\r\n                const sn = serializeNodeWithId(n, {\r\n                    doc: this.doc,\r\n                    mirror: this.mirror,\r\n                    blockClass: this.blockClass,\r\n                    blockSelector: this.blockSelector,\r\n                    maskTextClass: this.maskTextClass,\r\n                    maskTextSelector: this.maskTextSelector,\r\n                    skipChild: true,\r\n                    newlyAddedElement: true,\r\n                    inlineStylesheet: this.inlineStylesheet,\r\n                    maskInputOptions: this.maskInputOptions,\r\n                    maskTextFn: this.maskTextFn,\r\n                    maskInputFn: this.maskInputFn,\r\n                    slimDOMOptions: this.slimDOMOptions,\r\n                    dataURLOptions: this.dataURLOptions,\r\n                    recordCanvas: this.recordCanvas,\r\n                    inlineImages: this.inlineImages,\r\n                    onSerialize: (currentN) => {\r\n                        if (isSerializedIframe(currentN, this.mirror)) {\r\n                            this.iframeManager.addIframe(currentN);\r\n                        }\r\n                        if (isSerializedStylesheet(currentN, this.mirror)) {\r\n                            this.stylesheetManager.trackLinkElement(currentN);\r\n                        }\r\n                        if (hasShadowRoot(n)) {\r\n                            this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);\r\n                        }\r\n                    },\r\n                    onIframeLoad: (iframe, childSn) => {\r\n                        this.iframeManager.attachIframe(iframe, childSn);\r\n                        this.shadowDomManager.observeAttachShadow(iframe);\r\n                    },\r\n                    onStylesheetLoad: (link, childSn) => {\r\n                        this.stylesheetManager.attachLinkElement(link, childSn);\r\n                    },\r\n                });\r\n                if (sn) {\r\n                    adds.push({\r\n                        parentId,\r\n                        nextId,\r\n                        node: sn,\r\n                    });\r\n                    addedIds.add(sn.id);\r\n                }\r\n            };\r\n            while (this.mapRemoves.length) {\r\n                this.mirror.removeNodeFromMap(this.mapRemoves.shift());\r\n            }\r\n            for (const n of this.movedSet) {\r\n                if (isParentRemoved(this.removes, n, this.mirror) &&\r\n                    !this.movedSet.has(n.parentNode)) {\r\n                    continue;\r\n                }\r\n                pushAdd(n);\r\n            }\r\n            for (const n of this.addedSet) {\r\n                if (!isAncestorInSet(this.droppedSet, n) &&\r\n                    !isParentRemoved(this.removes, n, this.mirror)) {\r\n                    pushAdd(n);\r\n                }\r\n                else if (isAncestorInSet(this.movedSet, n)) {\r\n                    pushAdd(n);\r\n                }\r\n                else {\r\n                    this.droppedSet.add(n);\r\n                }\r\n            }\r\n            let candidate = null;\r\n            while (addList.length) {\r\n                let node = null;\r\n                if (candidate) {\r\n                    const parentId = this.mirror.getId(candidate.value.parentNode);\r\n                    const nextId = getNextId(candidate.value);\r\n                    if (parentId !== -1 && nextId !== -1) {\r\n                        node = candidate;\r\n                    }\r\n                }\r\n                if (!node) {\r\n                    let tailNode = addList.tail;\r\n                    while (tailNode) {\r\n                        const _node = tailNode;\r\n                        tailNode = tailNode.previous;\r\n                        if (_node) {\r\n                            const parentId = this.mirror.getId(_node.value.parentNode);\r\n                            const nextId = getNextId(_node.value);\r\n                            if (nextId === -1)\r\n                                continue;\r\n                            else if (parentId !== -1) {\r\n                                node = _node;\r\n                                break;\r\n                            }\r\n                            else {\r\n                                const unhandledNode = _node.value;\r\n                                if (unhandledNode.parentNode &&\r\n                                    unhandledNode.parentNode.nodeType ===\r\n                                        Node.DOCUMENT_FRAGMENT_NODE) {\r\n                                    const shadowHost = unhandledNode.parentNode\r\n                                        .host;\r\n                                    const parentId = this.mirror.getId(shadowHost);\r\n                                    if (parentId !== -1) {\r\n                                        node = _node;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!node) {\r\n                    while (addList.head) {\r\n                        addList.removeNode(addList.head.value);\r\n                    }\r\n                    break;\r\n                }\r\n                candidate = node.previous;\r\n                addList.removeNode(node.value);\r\n                pushAdd(node.value);\r\n            }\r\n            const payload = {\r\n                texts: this.texts\r\n                    .map((text) => {\r\n                    const n = text.node;\r\n                    if (n.parentNode &&\r\n                        n.parentNode.tagName === 'TEXTAREA') {\r\n                        this.genTextAreaValueMutation(n.parentNode);\r\n                    }\r\n                    return {\r\n                        id: this.mirror.getId(n),\r\n                        value: text.value,\r\n                    };\r\n                })\r\n                    .filter((text) => !addedIds.has(text.id))\r\n                    .filter((text) => this.mirror.has(text.id)),\r\n                attributes: this.attributes\r\n                    .map((attribute) => {\r\n                    const { attributes } = attribute;\r\n                    if (typeof attributes.style === 'string') {\r\n                        const diffAsStr = JSON.stringify(attribute.styleDiff);\r\n                        const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\r\n                        if (diffAsStr.length < attributes.style.length) {\r\n                            if ((diffAsStr + unchangedAsStr).split('var(').length ===\r\n                                attributes.style.split('var(').length) {\r\n                                attributes.style = attribute.styleDiff;\r\n                            }\r\n                        }\r\n                    }\r\n                    return {\r\n                        id: this.mirror.getId(attribute.node),\r\n                        attributes: attributes,\r\n                    };\r\n                })\r\n                    .filter((attribute) => !addedIds.has(attribute.id))\r\n                    .filter((attribute) => this.mirror.has(attribute.id)),\r\n                removes: this.removes,\r\n                adds,\r\n            };\r\n            if (!payload.texts.length &&\r\n                !payload.attributes.length &&\r\n                !payload.removes.length &&\r\n                !payload.adds.length) {\r\n                return;\r\n            }\r\n            this.texts = [];\r\n            this.attributes = [];\r\n            this.attributeMap = new WeakMap();\r\n            this.removes = [];\r\n            this.addedSet = new Set();\r\n            this.movedSet = new Set();\r\n            this.droppedSet = new Set();\r\n            this.movedMap = {};\r\n            this.mutationCb(payload);\r\n        };\r\n        this.genTextAreaValueMutation = (textarea) => {\r\n            let item = this.attributeMap.get(textarea);\r\n            if (!item) {\r\n                item = {\r\n                    node: textarea,\r\n                    attributes: {},\r\n                    styleDiff: {},\r\n                    _unchangedStyles: {},\r\n                };\r\n                this.attributes.push(item);\r\n                this.attributeMap.set(textarea, item);\r\n            }\r\n            item.attributes.value = Array.from(textarea.childNodes, (cn) => cn.textContent || '').join('');\r\n        };\r\n        this.processMutation = (m) => {\r\n            if (isIgnored(m.target, this.mirror)) {\r\n                return;\r\n            }\r\n            switch (m.type) {\r\n                case 'characterData': {\r\n                    const value = m.target.textContent;\r\n                    if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) &&\r\n                        value !== m.oldValue) {\r\n                        this.texts.push({\r\n                            value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, true) && value\r\n                                ? this.maskTextFn\r\n                                    ? this.maskTextFn(value, closestElementOfNode(m.target))\r\n                                    : value.replace(/[\\S]/g, '*')\r\n                                : value,\r\n                            node: m.target,\r\n                        });\r\n                    }\r\n                    break;\r\n                }\r\n                case 'attributes': {\r\n                    const target = m.target;\r\n                    let attributeName = m.attributeName;\r\n                    let value = m.target.getAttribute(attributeName);\r\n                    if (attributeName === 'value') {\r\n                        const type = getInputType(target);\r\n                        value = maskInputValue({\r\n                            element: target,\r\n                            maskInputOptions: this.maskInputOptions,\r\n                            tagName: target.tagName,\r\n                            type,\r\n                            value,\r\n                            maskInputFn: this.maskInputFn,\r\n                        });\r\n                    }\r\n                    if (isBlocked(m.target, this.blockClass, this.blockSelector, false) ||\r\n                        value === m.oldValue) {\r\n                        return;\r\n                    }\r\n                    let item = this.attributeMap.get(m.target);\r\n                    if (target.tagName === 'IFRAME' &&\r\n                        attributeName === 'src' &&\r\n                        !this.keepIframeSrcFn(value)) {\r\n                        if (!target.contentDocument) {\r\n                            attributeName = 'rr_src';\r\n                        }\r\n                        else {\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (!item) {\r\n                        item = {\r\n                            node: m.target,\r\n                            attributes: {},\r\n                            styleDiff: {},\r\n                            _unchangedStyles: {},\r\n                        };\r\n                        this.attributes.push(item);\r\n                        this.attributeMap.set(m.target, item);\r\n                    }\r\n                    if (attributeName === 'type' &&\r\n                        target.tagName === 'INPUT' &&\r\n                        (m.oldValue || '').toLowerCase() === 'password') {\r\n                        target.setAttribute('data-rr-is-password', 'true');\r\n                    }\r\n                    if (!ignoreAttribute(target.tagName, attributeName)) {\r\n                        item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value);\r\n                        if (attributeName === 'style') {\r\n                            if (!this.unattachedDoc) {\r\n                                try {\r\n                                    this.unattachedDoc =\r\n                                        document.implementation.createHTMLDocument();\r\n                                }\r\n                                catch (e) {\r\n                                    this.unattachedDoc = this.doc;\r\n                                }\r\n                            }\r\n                            const old = this.unattachedDoc.createElement('span');\r\n                            if (m.oldValue) {\r\n                                old.setAttribute('style', m.oldValue);\r\n                            }\r\n                            for (const pname of Array.from(target.style)) {\r\n                                const newValue = target.style.getPropertyValue(pname);\r\n                                const newPriority = target.style.getPropertyPriority(pname);\r\n                                if (newValue !== old.style.getPropertyValue(pname) ||\r\n                                    newPriority !== old.style.getPropertyPriority(pname)) {\r\n                                    if (newPriority === '') {\r\n                                        item.styleDiff[pname] = newValue;\r\n                                    }\r\n                                    else {\r\n                                        item.styleDiff[pname] = [newValue, newPriority];\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    item._unchangedStyles[pname] = [newValue, newPriority];\r\n                                }\r\n                            }\r\n                            for (const pname of Array.from(old.style)) {\r\n                                if (target.style.getPropertyValue(pname) === '') {\r\n                                    item.styleDiff[pname] = false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case 'childList': {\r\n                    if (isBlocked(m.target, this.blockClass, this.blockSelector, true))\r\n                        return;\r\n                    if (m.target.tagName === 'TEXTAREA') {\r\n                        this.genTextAreaValueMutation(m.target);\r\n                        return;\r\n                    }\r\n                    m.addedNodes.forEach((n) => this.genAdds(n, m.target));\r\n                    m.removedNodes.forEach((n) => {\r\n                        const nodeId = this.mirror.getId(n);\r\n                        const parentId = isShadowRoot(m.target)\r\n                            ? this.mirror.getId(m.target.host)\r\n                            : this.mirror.getId(m.target);\r\n                        if (isBlocked(m.target, this.blockClass, this.blockSelector, false) ||\r\n                            isIgnored(n, this.mirror) ||\r\n                            !isSerialized(n, this.mirror)) {\r\n                            return;\r\n                        }\r\n                        if (this.addedSet.has(n)) {\r\n                            deepDelete(this.addedSet, n);\r\n                            this.droppedSet.add(n);\r\n                        }\r\n                        else if (this.addedSet.has(m.target) && nodeId === -1) ;\r\n                        else if (isAncestorRemoved(m.target, this.mirror)) ;\r\n                        else if (this.movedSet.has(n) &&\r\n                            this.movedMap[moveKey(nodeId, parentId)]) {\r\n                            deepDelete(this.movedSet, n);\r\n                        }\r\n                        else {\r\n                            this.removes.push({\r\n                                parentId,\r\n                                id: nodeId,\r\n                                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target)\r\n                                    ? true\r\n                                    : undefined,\r\n                            });\r\n                        }\r\n                        this.mapRemoves.push(n);\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n        this.genAdds = (n, target) => {\r\n            if (this.processedNodeManager.inOtherBuffer(n, this))\r\n                return;\r\n            if (this.addedSet.has(n) || this.movedSet.has(n))\r\n                return;\r\n            if (this.mirror.hasNode(n)) {\r\n                if (isIgnored(n, this.mirror)) {\r\n                    return;\r\n                }\r\n                this.movedSet.add(n);\r\n                let targetId = null;\r\n                if (target && this.mirror.hasNode(target)) {\r\n                    targetId = this.mirror.getId(target);\r\n                }\r\n                if (targetId && targetId !== -1) {\r\n                    this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;\r\n                }\r\n            }\r\n            else {\r\n                this.addedSet.add(n);\r\n                this.droppedSet.delete(n);\r\n            }\r\n            if (!isBlocked(n, this.blockClass, this.blockSelector, false)) {\r\n                n.childNodes.forEach((childN) => this.genAdds(childN));\r\n                if (hasShadowRoot(n)) {\r\n                    n.shadowRoot.childNodes.forEach((childN) => {\r\n                        this.processedNodeManager.add(childN, this);\r\n                        this.genAdds(childN, n);\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n    init(options) {\r\n        [\r\n            'mutationCb',\r\n            'blockClass',\r\n            'blockSelector',\r\n            'maskTextClass',\r\n            'maskTextSelector',\r\n            'inlineStylesheet',\r\n            'maskInputOptions',\r\n            'maskTextFn',\r\n            'maskInputFn',\r\n            'keepIframeSrcFn',\r\n            'recordCanvas',\r\n            'inlineImages',\r\n            'slimDOMOptions',\r\n            'dataURLOptions',\r\n            'doc',\r\n            'mirror',\r\n            'iframeManager',\r\n            'stylesheetManager',\r\n            'shadowDomManager',\r\n            'canvasManager',\r\n            'processedNodeManager',\r\n        ].forEach((key) => {\r\n            this[key] = options[key];\r\n        });\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n        this.canvasManager.freeze();\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n        this.canvasManager.unfreeze();\r\n        this.emit();\r\n    }\r\n    isFrozen() {\r\n        return this.frozen;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n        this.canvasManager.lock();\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n        this.canvasManager.unlock();\r\n        this.emit();\r\n    }\r\n    reset() {\r\n        this.shadowDomManager.reset();\r\n        this.canvasManager.reset();\r\n    }\r\n}\r\nfunction deepDelete(addsSet, n) {\r\n    addsSet.delete(n);\r\n    n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\r\n}\r\nfunction isParentRemoved(removes, n, mirror) {\r\n    if (removes.length === 0)\r\n        return false;\r\n    return _isParentRemoved(removes, n, mirror);\r\n}\r\nfunction _isParentRemoved(removes, n, mirror) {\r\n    const { parentNode } = n;\r\n    if (!parentNode) {\r\n        return false;\r\n    }\r\n    const parentId = mirror.getId(parentNode);\r\n    if (removes.some((r) => r.id === parentId)) {\r\n        return true;\r\n    }\r\n    return _isParentRemoved(removes, parentNode, mirror);\r\n}\r\nfunction isAncestorInSet(set, n) {\r\n    if (set.size === 0)\r\n        return false;\r\n    return _isAncestorInSet(set, n);\r\n}\r\nfunction _isAncestorInSet(set, n) {\r\n    const { parentNode } = n;\r\n    if (!parentNode) {\r\n        return false;\r\n    }\r\n    if (set.has(parentNode)) {\r\n        return true;\r\n    }\r\n    return _isAncestorInSet(set, parentNode);\r\n}\n\nlet errorHandler;\r\nfunction registerErrorHandler(handler) {\r\n    errorHandler = handler;\r\n}\r\nfunction unregisterErrorHandler() {\r\n    errorHandler = undefined;\r\n}\r\nconst callbackWrapper = (cb) => {\r\n    if (!errorHandler) {\r\n        return cb;\r\n    }\r\n    const rrwebWrapped = ((...rest) => {\r\n        try {\r\n            return cb(...rest);\r\n        }\r\n        catch (error) {\r\n            if (errorHandler && errorHandler(error) === true) {\r\n                return;\r\n            }\r\n            throw error;\r\n        }\r\n    });\r\n    return rrwebWrapped;\r\n};\n\nconst mutationBuffers = [];\r\nfunction getEventTarget(event) {\r\n    try {\r\n        if ('composedPath' in event) {\r\n            const path = event.composedPath();\r\n            if (path.length) {\r\n                return path[0];\r\n            }\r\n        }\r\n        else if ('path' in event && event.path.length) {\r\n            return event.path[0];\r\n        }\r\n    }\r\n    catch (_a) {\r\n    }\r\n    return event && event.target;\r\n}\r\nfunction initMutationObserver(options, rootEl) {\r\n    var _a, _b;\r\n    const mutationBuffer = new MutationBuffer();\r\n    mutationBuffers.push(mutationBuffer);\r\n    mutationBuffer.init(options);\r\n    let mutationObserverCtor = window.MutationObserver ||\r\n        window.__rrMutationObserver;\r\n    const angularZoneSymbol = (_b = (_a = window === null || window === void 0 ? void 0 : window.Zone) === null || _a === void 0 ? void 0 : _a.__symbol__) === null || _b === void 0 ? void 0 : _b.call(_a, 'MutationObserver');\r\n    if (angularZoneSymbol &&\r\n        window[angularZoneSymbol]) {\r\n        mutationObserverCtor = window[angularZoneSymbol];\r\n    }\r\n    const observer = new mutationObserverCtor(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));\r\n    observer.observe(rootEl, {\r\n        attributes: true,\r\n        attributeOldValue: true,\r\n        characterData: true,\r\n        characterDataOldValue: true,\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\r\nfunction initMoveObserver({ mousemoveCb, sampling, doc, mirror, }) {\r\n    if (sampling.mousemove === false) {\r\n        return () => {\r\n        };\r\n    }\r\n    const threshold = typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\r\n    const callbackThreshold = typeof sampling.mousemoveCallback === 'number'\r\n        ? sampling.mousemoveCallback\r\n        : 500;\r\n    let positions = [];\r\n    let timeBaseline;\r\n    const wrappedCb = throttle(callbackWrapper((source) => {\r\n        const totalOffset = Date.now() - timeBaseline;\r\n        mousemoveCb(positions.map((p) => {\r\n            p.timeOffset -= totalOffset;\r\n            return p;\r\n        }), source);\r\n        positions = [];\r\n        timeBaseline = null;\r\n    }), callbackThreshold);\r\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {\r\n        const target = getEventTarget(evt);\r\n        const { clientX, clientY } = legacy_isTouchEvent(evt)\r\n            ? evt.changedTouches[0]\r\n            : evt;\r\n        if (!timeBaseline) {\r\n            timeBaseline = nowTimestamp();\r\n        }\r\n        positions.push({\r\n            x: clientX,\r\n            y: clientY,\r\n            id: mirror.getId(target),\r\n            timeOffset: nowTimestamp() - timeBaseline,\r\n        });\r\n        wrappedCb(typeof DragEvent !== 'undefined' && evt instanceof DragEvent\r\n            ? IncrementalSource$1.Drag\r\n            : evt instanceof MouseEvent\r\n                ? IncrementalSource$1.MouseMove\r\n                : IncrementalSource$1.TouchMove);\r\n    }), threshold, {\r\n        trailing: false,\r\n    }));\r\n    const handlers = [\r\n        on('mousemove', updatePosition, doc),\r\n        on('touchmove', updatePosition, doc),\r\n        on('drag', updatePosition, doc),\r\n    ];\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initMouseInteractionObserver({ mouseInteractionCb, doc, mirror, blockClass, blockSelector, sampling, }) {\r\n    if (sampling.mouseInteraction === false) {\r\n        return () => {\r\n        };\r\n    }\r\n    const disableMap = sampling.mouseInteraction === true ||\r\n        sampling.mouseInteraction === undefined\r\n        ? {}\r\n        : sampling.mouseInteraction;\r\n    const handlers = [];\r\n    let currentPointerType = null;\r\n    const getHandler = (eventKey) => {\r\n        return (event) => {\r\n            const target = getEventTarget(event);\r\n            if (isBlocked(target, blockClass, blockSelector, true)) {\r\n                return;\r\n            }\r\n            let pointerType = null;\r\n            let thisEventKey = eventKey;\r\n            if ('pointerType' in event) {\r\n                switch (event.pointerType) {\r\n                    case 'mouse':\r\n                        pointerType = PointerTypes.Mouse;\r\n                        break;\r\n                    case 'touch':\r\n                        pointerType = PointerTypes.Touch;\r\n                        break;\r\n                    case 'pen':\r\n                        pointerType = PointerTypes.Pen;\r\n                        break;\r\n                }\r\n                if (pointerType === PointerTypes.Touch) {\r\n                    if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\r\n                        thisEventKey = 'TouchStart';\r\n                    }\r\n                    else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\r\n                        thisEventKey = 'TouchEnd';\r\n                    }\r\n                }\r\n                else if (pointerType === PointerTypes.Pen) ;\r\n            }\r\n            else if (legacy_isTouchEvent(event)) {\r\n                pointerType = PointerTypes.Touch;\r\n            }\r\n            if (pointerType !== null) {\r\n                currentPointerType = pointerType;\r\n                if ((thisEventKey.startsWith('Touch') &&\r\n                    pointerType === PointerTypes.Touch) ||\r\n                    (thisEventKey.startsWith('Mouse') &&\r\n                        pointerType === PointerTypes.Mouse)) {\r\n                    pointerType = null;\r\n                }\r\n            }\r\n            else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\r\n                pointerType = currentPointerType;\r\n                currentPointerType = null;\r\n            }\r\n            const e = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\r\n            if (!e) {\r\n                return;\r\n            }\r\n            const id = mirror.getId(target);\r\n            const { clientX, clientY } = e;\r\n            callbackWrapper(mouseInteractionCb)(Object.assign({ type: MouseInteractions[thisEventKey], id, x: clientX, y: clientY }, (pointerType !== null && { pointerType })));\r\n        };\r\n    };\r\n    Object.keys(MouseInteractions)\r\n        .filter((key) => Number.isNaN(Number(key)) &&\r\n        !key.endsWith('_Departed') &&\r\n        disableMap[key] !== false)\r\n        .forEach((eventKey) => {\r\n        let eventName = toLowerCase(eventKey);\r\n        const handler = getHandler(eventKey);\r\n        if (window.PointerEvent) {\r\n            switch (MouseInteractions[eventKey]) {\r\n                case MouseInteractions.MouseDown:\r\n                case MouseInteractions.MouseUp:\r\n                    eventName = eventName.replace('mouse', 'pointer');\r\n                    break;\r\n                case MouseInteractions.TouchStart:\r\n                case MouseInteractions.TouchEnd:\r\n                    return;\r\n            }\r\n        }\r\n        handlers.push(on(eventName, handler, doc));\r\n    });\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initScrollObserver({ scrollCb, doc, mirror, blockClass, blockSelector, sampling, }) {\r\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {\r\n        const target = getEventTarget(evt);\r\n        if (!target ||\r\n            isBlocked(target, blockClass, blockSelector, true)) {\r\n            return;\r\n        }\r\n        const id = mirror.getId(target);\r\n        if (target === doc && doc.defaultView) {\r\n            const scrollLeftTop = getWindowScroll(doc.defaultView);\r\n            scrollCb({\r\n                id,\r\n                x: scrollLeftTop.left,\r\n                y: scrollLeftTop.top,\r\n            });\r\n        }\r\n        else {\r\n            scrollCb({\r\n                id,\r\n                x: target.scrollLeft,\r\n                y: target.scrollTop,\r\n            });\r\n        }\r\n    }), sampling.scroll || 100));\r\n    return on('scroll', updatePosition, doc);\r\n}\r\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\r\n    let lastH = -1;\r\n    let lastW = -1;\r\n    const updateDimension = callbackWrapper(throttle(callbackWrapper(() => {\r\n        const height = getWindowHeight();\r\n        const width = getWindowWidth();\r\n        if (lastH !== height || lastW !== width) {\r\n            viewportResizeCb({\r\n                width: Number(width),\r\n                height: Number(height),\r\n            });\r\n            lastH = height;\r\n            lastW = width;\r\n        }\r\n    }), 200));\r\n    return on('resize', updateDimension, win);\r\n}\r\nconst INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\r\nconst lastInputValueMap = new WeakMap();\r\nfunction initInputObserver({ inputCb, doc, mirror, blockClass, blockSelector, ignoreClass, ignoreSelector, maskInputOptions, maskInputFn, sampling, userTriggeredOnInput, }) {\r\n    function eventHandler(event) {\r\n        let target = getEventTarget(event);\r\n        const userTriggered = event.isTrusted;\r\n        const tagName = target && target.tagName;\r\n        if (target && tagName === 'OPTION') {\r\n            target = target.parentElement;\r\n        }\r\n        if (!target ||\r\n            !tagName ||\r\n            INPUT_TAGS.indexOf(tagName) < 0 ||\r\n            isBlocked(target, blockClass, blockSelector, true)) {\r\n            return;\r\n        }\r\n        if (target.classList.contains(ignoreClass) ||\r\n            (ignoreSelector && target.matches(ignoreSelector))) {\r\n            return;\r\n        }\r\n        let text = target.value;\r\n        let isChecked = false;\r\n        const type = getInputType(target) || '';\r\n        if (type === 'radio' || type === 'checkbox') {\r\n            isChecked = target.checked;\r\n        }\r\n        else if (maskInputOptions[tagName.toLowerCase()] ||\r\n            maskInputOptions[type]) {\r\n            text = maskInputValue({\r\n                element: target,\r\n                maskInputOptions,\r\n                tagName,\r\n                type,\r\n                value: text,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        cbWithDedup(target, userTriggeredOnInput\r\n            ? { text, isChecked, userTriggered }\r\n            : { text, isChecked });\r\n        const name = target.name;\r\n        if (type === 'radio' && name && isChecked) {\r\n            doc\r\n                .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\r\n                .forEach((el) => {\r\n                if (el !== target) {\r\n                    const text = el.value;\r\n                    cbWithDedup(el, userTriggeredOnInput\r\n                        ? { text, isChecked: !isChecked, userTriggered: false }\r\n                        : { text, isChecked: !isChecked });\r\n                }\r\n            });\r\n        }\r\n    }\r\n    function cbWithDedup(target, v) {\r\n        const lastInputValue = lastInputValueMap.get(target);\r\n        if (!lastInputValue ||\r\n            lastInputValue.text !== v.text ||\r\n            lastInputValue.isChecked !== v.isChecked) {\r\n            lastInputValueMap.set(target, v);\r\n            const id = mirror.getId(target);\r\n            callbackWrapper(inputCb)(Object.assign(Object.assign({}, v), { id }));\r\n        }\r\n    }\r\n    const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\r\n    const handlers = events.map((eventName) => on(eventName, callbackWrapper(eventHandler), doc));\r\n    const currentWindow = doc.defaultView;\r\n    if (!currentWindow) {\r\n        return () => {\r\n            handlers.forEach((h) => h());\r\n        };\r\n    }\r\n    const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, 'value');\r\n    const hookProperties = [\r\n        [currentWindow.HTMLInputElement.prototype, 'value'],\r\n        [currentWindow.HTMLInputElement.prototype, 'checked'],\r\n        [currentWindow.HTMLSelectElement.prototype, 'value'],\r\n        [currentWindow.HTMLTextAreaElement.prototype, 'value'],\r\n        [currentWindow.HTMLSelectElement.prototype, 'selectedIndex'],\r\n        [currentWindow.HTMLOptionElement.prototype, 'selected'],\r\n    ];\r\n    if (propertyDescriptor && propertyDescriptor.set) {\r\n        handlers.push(...hookProperties.map((p) => hookSetter(p[0], p[1], {\r\n            set() {\r\n                callbackWrapper(eventHandler)({\r\n                    target: this,\r\n                    isTrusted: false,\r\n                });\r\n            },\r\n        }, false, currentWindow)));\r\n    }\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction getNestedCSSRulePositions(rule) {\r\n    const positions = [];\r\n    function recurse(childRule, pos) {\r\n        if ((hasNestedCSSRule('CSSGroupingRule') &&\r\n            childRule.parentRule instanceof CSSGroupingRule) ||\r\n            (hasNestedCSSRule('CSSMediaRule') &&\r\n                childRule.parentRule instanceof CSSMediaRule) ||\r\n            (hasNestedCSSRule('CSSSupportsRule') &&\r\n                childRule.parentRule instanceof CSSSupportsRule) ||\r\n            (hasNestedCSSRule('CSSConditionRule') &&\r\n                childRule.parentRule instanceof CSSConditionRule)) {\r\n            const rules = Array.from(childRule.parentRule.cssRules);\r\n            const index = rules.indexOf(childRule);\r\n            pos.unshift(index);\r\n        }\r\n        else if (childRule.parentStyleSheet) {\r\n            const rules = Array.from(childRule.parentStyleSheet.cssRules);\r\n            const index = rules.indexOf(childRule);\r\n            pos.unshift(index);\r\n        }\r\n        return pos;\r\n    }\r\n    return recurse(rule, positions);\r\n}\r\nfunction getIdAndStyleId(sheet, mirror, styleMirror) {\r\n    let id, styleId;\r\n    if (!sheet)\r\n        return {};\r\n    if (sheet.ownerNode)\r\n        id = mirror.getId(sheet.ownerNode);\r\n    else\r\n        styleId = styleMirror.getId(sheet);\r\n    return {\r\n        styleId,\r\n        id,\r\n    };\r\n}\r\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror, stylesheetManager }, { win }) {\r\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\r\n        return () => {\r\n        };\r\n    }\r\n    const insertRule = win.CSSStyleSheet.prototype.insertRule;\r\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            const [rule, index] = argumentsList;\r\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleSheetRuleCb({\r\n                    id,\r\n                    styleId,\r\n                    adds: [{ rule, index }],\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\r\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            const [index] = argumentsList;\r\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleSheetRuleCb({\r\n                    id,\r\n                    styleId,\r\n                    removes: [{ index }],\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    let replace;\r\n    if (win.CSSStyleSheet.prototype.replace) {\r\n        replace = win.CSSStyleSheet.prototype.replace;\r\n        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [text] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        replace: text,\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    }\r\n    let replaceSync;\r\n    if (win.CSSStyleSheet.prototype.replaceSync) {\r\n        replaceSync = win.CSSStyleSheet.prototype.replaceSync;\r\n        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [text] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        replaceSync: text,\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    }\r\n    const supportedNestedCSSRuleTypes = {};\r\n    if (canMonkeyPatchNestedCSSRule('CSSGroupingRule')) {\r\n        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\r\n    }\r\n    else {\r\n        if (canMonkeyPatchNestedCSSRule('CSSMediaRule')) {\r\n            supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\r\n        }\r\n        if (canMonkeyPatchNestedCSSRule('CSSConditionRule')) {\r\n            supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\r\n        }\r\n        if (canMonkeyPatchNestedCSSRule('CSSSupportsRule')) {\r\n            supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\r\n        }\r\n    }\r\n    const unmodifiedFunctions = {};\r\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\r\n        unmodifiedFunctions[typeKey] = {\r\n            insertRule: type.prototype.insertRule,\r\n            deleteRule: type.prototype.deleteRule,\r\n        };\r\n        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [rule, index] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        adds: [\r\n                            {\r\n                                rule,\r\n                                index: [\r\n                                    ...getNestedCSSRulePositions(thisArg),\r\n                                    index || 0,\r\n                                ],\r\n                            },\r\n                        ],\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [index] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        removes: [\r\n                            { index: [...getNestedCSSRulePositions(thisArg), index] },\r\n                        ],\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    });\r\n    return callbackWrapper(() => {\r\n        win.CSSStyleSheet.prototype.insertRule = insertRule;\r\n        win.CSSStyleSheet.prototype.deleteRule = deleteRule;\r\n        replace && (win.CSSStyleSheet.prototype.replace = replace);\r\n        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\r\n        Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\r\n            type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\r\n            type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\r\n        });\r\n    });\r\n}\r\nfunction initAdoptedStyleSheetObserver({ mirror, stylesheetManager, }, host) {\r\n    var _a, _b, _c;\r\n    let hostId = null;\r\n    if (host.nodeName === '#document')\r\n        hostId = mirror.getId(host);\r\n    else\r\n        hostId = mirror.getId(host.host);\r\n    const patchTarget = host.nodeName === '#document'\r\n        ? (_a = host.defaultView) === null || _a === void 0 ? void 0 : _a.Document\r\n        : (_c = (_b = host.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView) === null || _c === void 0 ? void 0 : _c.ShadowRoot;\r\n    const originalPropertyDescriptor = (patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype)\r\n        ? Object.getOwnPropertyDescriptor(patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype, 'adoptedStyleSheets')\r\n        : undefined;\r\n    if (hostId === null ||\r\n        hostId === -1 ||\r\n        !patchTarget ||\r\n        !originalPropertyDescriptor)\r\n        return () => {\r\n        };\r\n    Object.defineProperty(host, 'adoptedStyleSheets', {\r\n        configurable: originalPropertyDescriptor.configurable,\r\n        enumerable: originalPropertyDescriptor.enumerable,\r\n        get() {\r\n            var _a;\r\n            return (_a = originalPropertyDescriptor.get) === null || _a === void 0 ? void 0 : _a.call(this);\r\n        },\r\n        set(sheets) {\r\n            var _a;\r\n            const result = (_a = originalPropertyDescriptor.set) === null || _a === void 0 ? void 0 : _a.call(this, sheets);\r\n            if (hostId !== null && hostId !== -1) {\r\n                try {\r\n                    stylesheetManager.adoptStyleSheets(sheets, hostId);\r\n                }\r\n                catch (e) {\r\n                }\r\n            }\r\n            return result;\r\n        },\r\n    });\r\n    return callbackWrapper(() => {\r\n        Object.defineProperty(host, 'adoptedStyleSheets', {\r\n            configurable: originalPropertyDescriptor.configurable,\r\n            enumerable: originalPropertyDescriptor.enumerable,\r\n            get: originalPropertyDescriptor.get,\r\n            set: originalPropertyDescriptor.set,\r\n        });\r\n    });\r\n}\r\nfunction initStyleDeclarationObserver({ styleDeclarationCb, mirror, ignoreCSSAttributes, stylesheetManager, }, { win }) {\r\n    const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\r\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            var _a;\r\n            const [property, value, priority] = argumentsList;\r\n            if (ignoreCSSAttributes.has(property)) {\r\n                return setProperty.apply(thisArg, [property, value, priority]);\r\n            }\r\n            const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleDeclarationCb({\r\n                    id,\r\n                    styleId,\r\n                    set: {\r\n                        property,\r\n                        value,\r\n                        priority,\r\n                    },\r\n                    index: getNestedCSSRulePositions(thisArg.parentRule),\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\r\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            var _a;\r\n            const [property] = argumentsList;\r\n            if (ignoreCSSAttributes.has(property)) {\r\n                return removeProperty.apply(thisArg, [property]);\r\n            }\r\n            const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleDeclarationCb({\r\n                    id,\r\n                    styleId,\r\n                    remove: {\r\n                        property,\r\n                    },\r\n                    index: getNestedCSSRulePositions(thisArg.parentRule),\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    return callbackWrapper(() => {\r\n        win.CSSStyleDeclaration.prototype.setProperty = setProperty;\r\n        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\r\n    });\r\n}\r\nfunction initMediaInteractionObserver({ mediaInteractionCb, blockClass, blockSelector, mirror, sampling, doc, }) {\r\n    const handler = callbackWrapper((type) => throttle(callbackWrapper((event) => {\r\n        const target = getEventTarget(event);\r\n        if (!target ||\r\n            isBlocked(target, blockClass, blockSelector, true)) {\r\n            return;\r\n        }\r\n        const { currentTime, volume, muted, playbackRate, loop } = target;\r\n        mediaInteractionCb({\r\n            type,\r\n            id: mirror.getId(target),\r\n            currentTime,\r\n            volume,\r\n            muted,\r\n            playbackRate,\r\n            loop,\r\n        });\r\n    }), sampling.media || 500));\r\n    const handlers = [\r\n        on('play', handler(0), doc),\r\n        on('pause', handler(1), doc),\r\n        on('seeked', handler(2), doc),\r\n        on('volumechange', handler(3), doc),\r\n        on('ratechange', handler(4), doc),\r\n    ];\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initFontObserver({ fontCb, doc }) {\r\n    const win = doc.defaultView;\r\n    if (!win) {\r\n        return () => {\r\n        };\r\n    }\r\n    const handlers = [];\r\n    const fontMap = new WeakMap();\r\n    const originalFontFace = win.FontFace;\r\n    win.FontFace = function FontFace(family, source, descriptors) {\r\n        const fontFace = new originalFontFace(family, source, descriptors);\r\n        fontMap.set(fontFace, {\r\n            family,\r\n            buffer: typeof source !== 'string',\r\n            descriptors,\r\n            fontSource: typeof source === 'string'\r\n                ? source\r\n                : JSON.stringify(Array.from(new Uint8Array(source))),\r\n        });\r\n        return fontFace;\r\n    };\r\n    const restoreHandler = patch(doc.fonts, 'add', function (original) {\r\n        return function (fontFace) {\r\n            setTimeout(callbackWrapper(() => {\r\n                const p = fontMap.get(fontFace);\r\n                if (p) {\r\n                    fontCb(p);\r\n                    fontMap.delete(fontFace);\r\n                }\r\n            }), 0);\r\n            return original.apply(this, [fontFace]);\r\n        };\r\n    });\r\n    handlers.push(() => {\r\n        win.FontFace = originalFontFace;\r\n    });\r\n    handlers.push(restoreHandler);\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initSelectionObserver(param) {\r\n    const { doc, mirror, blockClass, blockSelector, selectionCb } = param;\r\n    let collapsed = true;\r\n    const updateSelection = callbackWrapper(() => {\r\n        const selection = doc.getSelection();\r\n        if (!selection || (collapsed && (selection === null || selection === void 0 ? void 0 : selection.isCollapsed)))\r\n            return;\r\n        collapsed = selection.isCollapsed || false;\r\n        const ranges = [];\r\n        const count = selection.rangeCount || 0;\r\n        for (let i = 0; i < count; i++) {\r\n            const range = selection.getRangeAt(i);\r\n            const { startContainer, startOffset, endContainer, endOffset } = range;\r\n            const blocked = isBlocked(startContainer, blockClass, blockSelector, true) ||\r\n                isBlocked(endContainer, blockClass, blockSelector, true);\r\n            if (blocked)\r\n                continue;\r\n            ranges.push({\r\n                start: mirror.getId(startContainer),\r\n                startOffset,\r\n                end: mirror.getId(endContainer),\r\n                endOffset,\r\n            });\r\n        }\r\n        selectionCb({ ranges });\r\n    });\r\n    updateSelection();\r\n    return on('selectionchange', updateSelection);\r\n}\r\nfunction initCustomElementObserver({ doc, customElementCb, }) {\r\n    const win = doc.defaultView;\r\n    if (!win || !win.customElements)\r\n        return () => { };\r\n    const restoreHandler = patch(win.customElements, 'define', function (original) {\r\n        return function (name, constructor, options) {\r\n            try {\r\n                customElementCb({\r\n                    define: {\r\n                        name,\r\n                    },\r\n                });\r\n            }\r\n            catch (e) {\r\n                console.warn(`Custom element callback failed for ${name}`);\r\n            }\r\n            return original.apply(this, [name, constructor, options]);\r\n        };\r\n    });\r\n    return restoreHandler;\r\n}\r\nfunction mergeHooks(o, hooks) {\r\n    const { mutationCb, mousemoveCb, mouseInteractionCb, scrollCb, viewportResizeCb, inputCb, mediaInteractionCb, styleSheetRuleCb, styleDeclarationCb, canvasMutationCb, fontCb, selectionCb, customElementCb, } = o;\r\n    o.mutationCb = (...p) => {\r\n        if (hooks.mutation) {\r\n            hooks.mutation(...p);\r\n        }\r\n        mutationCb(...p);\r\n    };\r\n    o.mousemoveCb = (...p) => {\r\n        if (hooks.mousemove) {\r\n            hooks.mousemove(...p);\r\n        }\r\n        mousemoveCb(...p);\r\n    };\r\n    o.mouseInteractionCb = (...p) => {\r\n        if (hooks.mouseInteraction) {\r\n            hooks.mouseInteraction(...p);\r\n        }\r\n        mouseInteractionCb(...p);\r\n    };\r\n    o.scrollCb = (...p) => {\r\n        if (hooks.scroll) {\r\n            hooks.scroll(...p);\r\n        }\r\n        scrollCb(...p);\r\n    };\r\n    o.viewportResizeCb = (...p) => {\r\n        if (hooks.viewportResize) {\r\n            hooks.viewportResize(...p);\r\n        }\r\n        viewportResizeCb(...p);\r\n    };\r\n    o.inputCb = (...p) => {\r\n        if (hooks.input) {\r\n            hooks.input(...p);\r\n        }\r\n        inputCb(...p);\r\n    };\r\n    o.mediaInteractionCb = (...p) => {\r\n        if (hooks.mediaInteaction) {\r\n            hooks.mediaInteaction(...p);\r\n        }\r\n        mediaInteractionCb(...p);\r\n    };\r\n    o.styleSheetRuleCb = (...p) => {\r\n        if (hooks.styleSheetRule) {\r\n            hooks.styleSheetRule(...p);\r\n        }\r\n        styleSheetRuleCb(...p);\r\n    };\r\n    o.styleDeclarationCb = (...p) => {\r\n        if (hooks.styleDeclaration) {\r\n            hooks.styleDeclaration(...p);\r\n        }\r\n        styleDeclarationCb(...p);\r\n    };\r\n    o.canvasMutationCb = (...p) => {\r\n        if (hooks.canvasMutation) {\r\n            hooks.canvasMutation(...p);\r\n        }\r\n        canvasMutationCb(...p);\r\n    };\r\n    o.fontCb = (...p) => {\r\n        if (hooks.font) {\r\n            hooks.font(...p);\r\n        }\r\n        fontCb(...p);\r\n    };\r\n    o.selectionCb = (...p) => {\r\n        if (hooks.selection) {\r\n            hooks.selection(...p);\r\n        }\r\n        selectionCb(...p);\r\n    };\r\n    o.customElementCb = (...c) => {\r\n        if (hooks.customElement) {\r\n            hooks.customElement(...c);\r\n        }\r\n        customElementCb(...c);\r\n    };\r\n}\r\nfunction initObservers(o, hooks = {}) {\r\n    const currentWindow = o.doc.defaultView;\r\n    if (!currentWindow) {\r\n        return () => {\r\n        };\r\n    }\r\n    mergeHooks(o, hooks);\r\n    let mutationObserver;\r\n    if (o.recordDOM) {\r\n        mutationObserver = initMutationObserver(o, o.doc);\r\n    }\r\n    const mousemoveHandler = initMoveObserver(o);\r\n    const mouseInteractionHandler = initMouseInteractionObserver(o);\r\n    const scrollHandler = initScrollObserver(o);\r\n    const viewportResizeHandler = initViewportResizeObserver(o, {\r\n        win: currentWindow,\r\n    });\r\n    const inputHandler = initInputObserver(o);\r\n    const mediaInteractionHandler = initMediaInteractionObserver(o);\r\n    let styleSheetObserver = () => { };\r\n    let adoptedStyleSheetObserver = () => { };\r\n    let styleDeclarationObserver = () => { };\r\n    let fontObserver = () => { };\r\n    if (o.recordDOM) {\r\n        styleSheetObserver = initStyleSheetObserver(o, { win: currentWindow });\r\n        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);\r\n        styleDeclarationObserver = initStyleDeclarationObserver(o, {\r\n            win: currentWindow,\r\n        });\r\n        if (o.collectFonts) {\r\n            fontObserver = initFontObserver(o);\r\n        }\r\n    }\r\n    const selectionObserver = initSelectionObserver(o);\r\n    const customElementObserver = initCustomElementObserver(o);\r\n    const pluginHandlers = [];\r\n    for (const plugin of o.plugins) {\r\n        pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\r\n    }\r\n    return callbackWrapper(() => {\r\n        mutationBuffers.forEach((b) => b.reset());\r\n        mutationObserver === null || mutationObserver === void 0 ? void 0 : mutationObserver.disconnect();\r\n        mousemoveHandler();\r\n        mouseInteractionHandler();\r\n        scrollHandler();\r\n        viewportResizeHandler();\r\n        inputHandler();\r\n        mediaInteractionHandler();\r\n        styleSheetObserver();\r\n        adoptedStyleSheetObserver();\r\n        styleDeclarationObserver();\r\n        fontObserver();\r\n        selectionObserver();\r\n        customElementObserver();\r\n        pluginHandlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction hasNestedCSSRule(prop) {\r\n    return typeof window[prop] !== 'undefined';\r\n}\r\nfunction canMonkeyPatchNestedCSSRule(prop) {\r\n    return Boolean(typeof window[prop] !== 'undefined' &&\r\n        window[prop].prototype &&\r\n        'insertRule' in window[prop].prototype &&\r\n        'deleteRule' in window[prop].prototype);\r\n}\n\nclass CrossOriginIframeMirror {\r\n    constructor(generateIdFn) {\r\n        this.generateIdFn = generateIdFn;\r\n        this.iframeIdToRemoteIdMap = new WeakMap();\r\n        this.iframeRemoteIdToIdMap = new WeakMap();\r\n    }\r\n    getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\r\n        const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\r\n        const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\r\n        let id = idToRemoteIdMap.get(remoteId);\r\n        if (!id) {\r\n            id = this.generateIdFn();\r\n            idToRemoteIdMap.set(remoteId, id);\r\n            remoteIdToIdMap.set(id, remoteId);\r\n        }\r\n        return id;\r\n    }\r\n    getIds(iframe, remoteId) {\r\n        const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\r\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\r\n        return remoteId.map((id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap));\r\n    }\r\n    getRemoteId(iframe, id, map) {\r\n        const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\r\n        if (typeof id !== 'number')\r\n            return id;\r\n        const remoteId = remoteIdToIdMap.get(id);\r\n        if (!remoteId)\r\n            return -1;\r\n        return remoteId;\r\n    }\r\n    getRemoteIds(iframe, ids) {\r\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\r\n        return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\r\n    }\r\n    reset(iframe) {\r\n        if (!iframe) {\r\n            this.iframeIdToRemoteIdMap = new WeakMap();\r\n            this.iframeRemoteIdToIdMap = new WeakMap();\r\n            return;\r\n        }\r\n        this.iframeIdToRemoteIdMap.delete(iframe);\r\n        this.iframeRemoteIdToIdMap.delete(iframe);\r\n    }\r\n    getIdToRemoteIdMap(iframe) {\r\n        let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\r\n        if (!idToRemoteIdMap) {\r\n            idToRemoteIdMap = new Map();\r\n            this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\r\n        }\r\n        return idToRemoteIdMap;\r\n    }\r\n    getRemoteIdToIdMap(iframe) {\r\n        let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\r\n        if (!remoteIdToIdMap) {\r\n            remoteIdToIdMap = new Map();\r\n            this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\r\n        }\r\n        return remoteIdToIdMap;\r\n    }\r\n}\n\nclass IframeManager {\r\n    constructor(options) {\r\n        this.iframes = new WeakMap();\r\n        this.crossOriginIframeMap = new WeakMap();\r\n        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\r\n        this.crossOriginIframeRootIdMap = new WeakMap();\r\n        this.mutationCb = options.mutationCb;\r\n        this.wrappedEmit = options.wrappedEmit;\r\n        this.stylesheetManager = options.stylesheetManager;\r\n        this.recordCrossOriginIframes = options.recordCrossOriginIframes;\r\n        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\r\n        this.mirror = options.mirror;\r\n        if (this.recordCrossOriginIframes) {\r\n            window.addEventListener('message', this.handleMessage.bind(this));\r\n        }\r\n    }\r\n    addIframe(iframeEl) {\r\n        this.iframes.set(iframeEl, true);\r\n        if (iframeEl.contentWindow)\r\n            this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\r\n    }\r\n    addLoadListener(cb) {\r\n        this.loadListener = cb;\r\n    }\r\n    attachIframe(iframeEl, childSn) {\r\n        var _a;\r\n        this.mutationCb({\r\n            adds: [\r\n                {\r\n                    parentId: this.mirror.getId(iframeEl),\r\n                    nextId: null,\r\n                    node: childSn,\r\n                },\r\n            ],\r\n            removes: [],\r\n            texts: [],\r\n            attributes: [],\r\n            isAttachIframe: true,\r\n        });\r\n        (_a = this.loadListener) === null || _a === void 0 ? void 0 : _a.call(this, iframeEl);\r\n        if (iframeEl.contentDocument &&\r\n            iframeEl.contentDocument.adoptedStyleSheets &&\r\n            iframeEl.contentDocument.adoptedStyleSheets.length > 0)\r\n            this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\r\n    }\r\n    handleMessage(message) {\r\n        const crossOriginMessageEvent = message;\r\n        if (crossOriginMessageEvent.data.type !== 'rrweb' ||\r\n            crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\r\n            return;\r\n        const iframeSourceWindow = message.source;\r\n        if (!iframeSourceWindow)\r\n            return;\r\n        const iframeEl = this.crossOriginIframeMap.get(message.source);\r\n        if (!iframeEl)\r\n            return;\r\n        const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\r\n        if (transformedEvent)\r\n            this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\r\n    }\r\n    transformCrossOriginEvent(iframeEl, e) {\r\n        var _a;\r\n        switch (e.type) {\r\n            case EventType$1.FullSnapshot: {\r\n                this.crossOriginIframeMirror.reset(iframeEl);\r\n                this.crossOriginIframeStyleMirror.reset(iframeEl);\r\n                this.replaceIdOnNode(e.data.node, iframeEl);\r\n                const rootId = e.data.node.id;\r\n                this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\r\n                this.patchRootIdOnNode(e.data.node, rootId);\r\n                return {\r\n                    timestamp: e.timestamp,\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource$1.Mutation,\r\n                        adds: [\r\n                            {\r\n                                parentId: this.mirror.getId(iframeEl),\r\n                                nextId: null,\r\n                                node: e.data.node,\r\n                            },\r\n                        ],\r\n                        removes: [],\r\n                        texts: [],\r\n                        attributes: [],\r\n                        isAttachIframe: true,\r\n                    },\r\n                };\r\n            }\r\n            case EventType$1.Meta:\r\n            case EventType$1.Load:\r\n            case EventType$1.DomContentLoaded: {\r\n                return false;\r\n            }\r\n            case EventType$1.Plugin: {\r\n                return e;\r\n            }\r\n            case EventType$1.Custom: {\r\n                this.replaceIds(e.data.payload, iframeEl, ['id', 'parentId', 'previousId', 'nextId']);\r\n                return e;\r\n            }\r\n            case EventType$1.IncrementalSnapshot: {\r\n                switch (e.data.source) {\r\n                    case IncrementalSource$1.Mutation: {\r\n                        e.data.adds.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, [\r\n                                'parentId',\r\n                                'nextId',\r\n                                'previousId',\r\n                            ]);\r\n                            this.replaceIdOnNode(n.node, iframeEl);\r\n                            const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\r\n                            rootId && this.patchRootIdOnNode(n.node, rootId);\r\n                        });\r\n                        e.data.removes.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['parentId', 'id']);\r\n                        });\r\n                        e.data.attributes.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['id']);\r\n                        });\r\n                        e.data.texts.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['id']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.Drag:\r\n                    case IncrementalSource$1.TouchMove:\r\n                    case IncrementalSource$1.MouseMove: {\r\n                        e.data.positions.forEach((p) => {\r\n                            this.replaceIds(p, iframeEl, ['id']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.ViewportResize: {\r\n                        return false;\r\n                    }\r\n                    case IncrementalSource$1.MediaInteraction:\r\n                    case IncrementalSource$1.MouseInteraction:\r\n                    case IncrementalSource$1.Scroll:\r\n                    case IncrementalSource$1.CanvasMutation:\r\n                    case IncrementalSource$1.Input: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.StyleSheetRule:\r\n                    case IncrementalSource$1.StyleDeclaration: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        this.replaceStyleIds(e.data, iframeEl, ['styleId']);\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.Font: {\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.Selection: {\r\n                        e.data.ranges.forEach((range) => {\r\n                            this.replaceIds(range, iframeEl, ['start', 'end']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.AdoptedStyleSheet: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        this.replaceStyleIds(e.data, iframeEl, ['styleIds']);\r\n                        (_a = e.data.styles) === null || _a === void 0 ? void 0 : _a.forEach((style) => {\r\n                            this.replaceStyleIds(style, iframeEl, ['styleId']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    replace(iframeMirror, obj, iframeEl, keys) {\r\n        for (const key of keys) {\r\n            if (!Array.isArray(obj[key]) && typeof obj[key] !== 'number')\r\n                continue;\r\n            if (Array.isArray(obj[key])) {\r\n                obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\r\n            }\r\n            else {\r\n                obj[key] = iframeMirror.getId(iframeEl, obj[key]);\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n    replaceIds(obj, iframeEl, keys) {\r\n        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\r\n    }\r\n    replaceStyleIds(obj, iframeEl, keys) {\r\n        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\r\n    }\r\n    replaceIdOnNode(node, iframeEl) {\r\n        this.replaceIds(node, iframeEl, ['id', 'rootId']);\r\n        if ('childNodes' in node) {\r\n            node.childNodes.forEach((child) => {\r\n                this.replaceIdOnNode(child, iframeEl);\r\n            });\r\n        }\r\n    }\r\n    patchRootIdOnNode(node, rootId) {\r\n        if (node.type !== NodeType.Document && !node.rootId)\r\n            node.rootId = rootId;\r\n        if ('childNodes' in node) {\r\n            node.childNodes.forEach((child) => {\r\n                this.patchRootIdOnNode(child, rootId);\r\n            });\r\n        }\r\n    }\r\n}\n\nclass ShadowDomManager {\r\n    constructor(options) {\r\n        this.shadowDoms = new WeakSet();\r\n        this.restoreHandlers = [];\r\n        this.mutationCb = options.mutationCb;\r\n        this.scrollCb = options.scrollCb;\r\n        this.bypassOptions = options.bypassOptions;\r\n        this.mirror = options.mirror;\r\n        this.init();\r\n    }\r\n    init() {\r\n        this.reset();\r\n        this.patchAttachShadow(Element, document);\r\n    }\r\n    addShadowRoot(shadowRoot, doc) {\r\n        if (!isNativeShadowDom(shadowRoot))\r\n            return;\r\n        if (this.shadowDoms.has(shadowRoot))\r\n            return;\r\n        this.shadowDoms.add(shadowRoot);\r\n        const observer = initMutationObserver(Object.assign(Object.assign({}, this.bypassOptions), { doc, mutationCb: this.mutationCb, mirror: this.mirror, shadowDomManager: this }), shadowRoot);\r\n        this.restoreHandlers.push(() => observer.disconnect());\r\n        this.restoreHandlers.push(initScrollObserver(Object.assign(Object.assign({}, this.bypassOptions), { scrollCb: this.scrollCb, doc: shadowRoot, mirror: this.mirror })));\r\n        setTimeout(() => {\r\n            if (shadowRoot.adoptedStyleSheets &&\r\n                shadowRoot.adoptedStyleSheets.length > 0)\r\n                this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));\r\n            this.restoreHandlers.push(initAdoptedStyleSheetObserver({\r\n                mirror: this.mirror,\r\n                stylesheetManager: this.bypassOptions.stylesheetManager,\r\n            }, shadowRoot));\r\n        }, 0);\r\n    }\r\n    observeAttachShadow(iframeElement) {\r\n        if (!iframeElement.contentWindow || !iframeElement.contentDocument)\r\n            return;\r\n        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\r\n    }\r\n    patchAttachShadow(element, doc) {\r\n        const manager = this;\r\n        this.restoreHandlers.push(patch(element.prototype, 'attachShadow', function (original) {\r\n            return function (option) {\r\n                const shadowRoot = original.call(this, option);\r\n                if (this.shadowRoot && inDom(this))\r\n                    manager.addShadowRoot(this.shadowRoot, doc);\r\n                return shadowRoot;\r\n            };\r\n        }));\r\n    }\r\n    reset() {\r\n        this.restoreHandlers.forEach((handler) => {\r\n            try {\r\n                handler();\r\n            }\r\n            catch (e) {\r\n            }\r\n        });\r\n        this.restoreHandlers = [];\r\n        this.shadowDoms = new WeakSet();\r\n    }\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\n\nconst canvasVarMap = new Map();\r\nfunction variableListFor(ctx, ctor) {\r\n    let contextMap = canvasVarMap.get(ctx);\r\n    if (!contextMap) {\r\n        contextMap = new Map();\r\n        canvasVarMap.set(ctx, contextMap);\r\n    }\r\n    if (!contextMap.has(ctor)) {\r\n        contextMap.set(ctor, []);\r\n    }\r\n    return contextMap.get(ctor);\r\n}\r\nconst saveWebGLVar = (value, win, ctx) => {\r\n    if (!value ||\r\n        !(isInstanceOfWebGLObject(value, win) || typeof value === 'object'))\r\n        return;\r\n    const name = value.constructor.name;\r\n    const list = variableListFor(ctx, name);\r\n    let index = list.indexOf(value);\r\n    if (index === -1) {\r\n        index = list.length;\r\n        list.push(value);\r\n    }\r\n    return index;\r\n};\r\nfunction serializeArg(value, win, ctx) {\r\n    if (value instanceof Array) {\r\n        return value.map((arg) => serializeArg(arg, win, ctx));\r\n    }\r\n    else if (value === null) {\r\n        return value;\r\n    }\r\n    else if (value instanceof Float32Array ||\r\n        value instanceof Float64Array ||\r\n        value instanceof Int32Array ||\r\n        value instanceof Uint32Array ||\r\n        value instanceof Uint8Array ||\r\n        value instanceof Uint16Array ||\r\n        value instanceof Int16Array ||\r\n        value instanceof Int8Array ||\r\n        value instanceof Uint8ClampedArray) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [Object.values(value)],\r\n        };\r\n    }\r\n    else if (value instanceof ArrayBuffer) {\r\n        const name = value.constructor.name;\r\n        const base64 = encode(value);\r\n        return {\r\n            rr_type: name,\r\n            base64,\r\n        };\r\n    }\r\n    else if (value instanceof DataView) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [\r\n                serializeArg(value.buffer, win, ctx),\r\n                value.byteOffset,\r\n                value.byteLength,\r\n            ],\r\n        };\r\n    }\r\n    else if (value instanceof HTMLImageElement) {\r\n        const name = value.constructor.name;\r\n        const { src } = value;\r\n        return {\r\n            rr_type: name,\r\n            src,\r\n        };\r\n    }\r\n    else if (value instanceof HTMLCanvasElement) {\r\n        const name = 'HTMLImageElement';\r\n        const src = value.toDataURL();\r\n        return {\r\n            rr_type: name,\r\n            src,\r\n        };\r\n    }\r\n    else if (value instanceof ImageData) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [serializeArg(value.data, win, ctx), value.width, value.height],\r\n        };\r\n    }\r\n    else if (isInstanceOfWebGLObject(value, win) || typeof value === 'object') {\r\n        const name = value.constructor.name;\r\n        const index = saveWebGLVar(value, win, ctx);\r\n        return {\r\n            rr_type: name,\r\n            index: index,\r\n        };\r\n    }\r\n    return value;\r\n}\r\nconst serializeArgs = (args, win, ctx) => {\r\n    return args.map((arg) => serializeArg(arg, win, ctx));\r\n};\r\nconst isInstanceOfWebGLObject = (value, win) => {\r\n    const webGLConstructorNames = [\r\n        'WebGLActiveInfo',\r\n        'WebGLBuffer',\r\n        'WebGLFramebuffer',\r\n        'WebGLProgram',\r\n        'WebGLRenderbuffer',\r\n        'WebGLShader',\r\n        'WebGLShaderPrecisionFormat',\r\n        'WebGLTexture',\r\n        'WebGLUniformLocation',\r\n        'WebGLVertexArrayObject',\r\n        'WebGLVertexArrayObjectOES',\r\n    ];\r\n    const supportedWebGLConstructorNames = webGLConstructorNames.filter((name) => typeof win[name] === 'function');\r\n    return Boolean(supportedWebGLConstructorNames.find((name) => value instanceof win[name]));\r\n};\n\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {\r\n    const handlers = [];\r\n    const props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\r\n    for (const prop of props2D) {\r\n        try {\r\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\r\n                        setTimeout(() => {\r\n                            const recordArgs = serializeArgs(args, win, this);\r\n                            cb(this.canvas, {\r\n                                type: CanvasContext['2D'],\r\n                                property: prop,\r\n                                args: recordArgs,\r\n                            });\r\n                        }, 0);\r\n                    }\r\n                    return original.apply(this, args);\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch (_a) {\r\n            const hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type: CanvasContext['2D'],\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nfunction getNormalizedContextName(contextType) {\r\n    return contextType === 'experimental-webgl' ? 'webgl' : contextType;\r\n}\r\nfunction initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {\r\n    const handlers = [];\r\n    try {\r\n        const restoreHandler = patch(win.HTMLCanvasElement.prototype, 'getContext', function (original) {\r\n            return function (contextType, ...args) {\r\n                if (!isBlocked(this, blockClass, blockSelector, true)) {\r\n                    const ctxName = getNormalizedContextName(contextType);\r\n                    if (!('__context' in this))\r\n                        this.__context = ctxName;\r\n                    if (setPreserveDrawingBufferToTrue &&\r\n                        ['webgl', 'webgl2'].includes(ctxName)) {\r\n                        if (args[0] && typeof args[0] === 'object') {\r\n                            const contextAttributes = args[0];\r\n                            if (!contextAttributes.preserveDrawingBuffer) {\r\n                                contextAttributes.preserveDrawingBuffer = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            args.splice(0, 1, {\r\n                                preserveDrawingBuffer: true,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                return original.apply(this, [contextType, ...args]);\r\n            };\r\n        });\r\n        handlers.push(restoreHandler);\r\n    }\r\n    catch (_a) {\r\n        console.error('failed to patch HTMLCanvasElement.prototype.getContext');\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, mirror, win) {\r\n    const handlers = [];\r\n    const props = Object.getOwnPropertyNames(prototype);\r\n    for (const prop of props) {\r\n        if ([\r\n            'isContextLost',\r\n            'canvas',\r\n            'drawingBufferWidth',\r\n            'drawingBufferHeight',\r\n        ].includes(prop)) {\r\n            continue;\r\n        }\r\n        try {\r\n            if (typeof prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    const result = original.apply(this, args);\r\n                    saveWebGLVar(result, win, this);\r\n                    if ('tagName' in this.canvas &&\r\n                        !isBlocked(this.canvas, blockClass, blockSelector, true)) {\r\n                        const recordArgs = serializeArgs(args, win, this);\r\n                        const mutation = {\r\n                            type,\r\n                            property: prop,\r\n                            args: recordArgs,\r\n                        };\r\n                        cb(this.canvas, mutation);\r\n                    }\r\n                    return result;\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch (_a) {\r\n            const hookHandler = hookSetter(prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type,\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return handlers;\r\n}\r\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector, mirror) {\r\n    const handlers = [];\r\n    handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, mirror, win));\r\n    if (typeof win.WebGL2RenderingContext !== 'undefined') {\r\n        handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, mirror, win));\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nfunction funcToSource(fn, sourcemapArg) {\n    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n    var source = fn.toString();\n    var lines = source.split('\\n');\n    lines.pop();\n    lines.shift();\n    var blankPrefixLength = lines[0].search(/\\S/);\n    var regex = /(['\"])__worker_loader_strict__(['\"])/g;\n    for (var i = 0, n = lines.length; i < n; ++i) {\n        lines[i] = lines[i].substring(blankPrefixLength).replace(regex, '$1use strict$2') + '\\n';\n    }\n    if (sourcemap) {\n        lines.push('\\/\\/# sourceMappingURL=' + sourcemap + '\\n');\n    }\n    return lines;\n}\n\nfunction createURL(fn, sourcemapArg) {\n    var lines = funcToSource(fn, sourcemapArg);\n    var blob = new Blob(lines, { type: 'application/javascript' });\n    return URL.createObjectURL(blob);\n}\n\nfunction createInlineWorkerFactory(fn, sourcemapArg) {\n    var url;\n    return function WorkerFactory(options) {\n        url = url || createURL(fn, sourcemapArg);\n        return new Worker(url, options);\n    };\n}\n\nvar WorkerFactory = createInlineWorkerFactory(/* rollup-plugin-web-worker-loader */function () {\n(function () {\n    '__worker_loader_strict__';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\n\n    /*\n     * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i = 0; i < chars.length; i++) {\n        lookup[chars.charCodeAt(i)] = i;\n    }\n    var encode = function (arraybuffer) {\n        var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n        for (i = 0; i < len; i += 3) {\n            base64 += chars[bytes[i] >> 2];\n            base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n            base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n            base64 += chars[bytes[i + 2] & 63];\n        }\n        if (len % 3 === 2) {\n            base64 = base64.substring(0, base64.length - 1) + '=';\n        }\n        else if (len % 3 === 1) {\n            base64 = base64.substring(0, base64.length - 2) + '==';\n        }\n        return base64;\n    };\n\n    const lastBlobMap = new Map();\r\n    const transparentBlobMap = new Map();\r\n    function getTransparentBlobFor(width, height, dataURLOptions) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const id = `${width}-${height}`;\r\n            if ('OffscreenCanvas' in globalThis) {\r\n                if (transparentBlobMap.has(id))\r\n                    return transparentBlobMap.get(id);\r\n                const offscreen = new OffscreenCanvas(width, height);\r\n                offscreen.getContext('2d');\r\n                const blob = yield offscreen.convertToBlob(dataURLOptions);\r\n                const arrayBuffer = yield blob.arrayBuffer();\r\n                const base64 = encode(arrayBuffer);\r\n                transparentBlobMap.set(id, base64);\r\n                return base64;\r\n            }\r\n            else {\r\n                return '';\r\n            }\r\n        });\r\n    }\r\n    const worker = self;\r\n    worker.onmessage = function (e) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if ('OffscreenCanvas' in globalThis) {\r\n                const { id, bitmap, width, height, dataURLOptions } = e.data;\r\n                const transparentBase64 = getTransparentBlobFor(width, height, dataURLOptions);\r\n                const offscreen = new OffscreenCanvas(width, height);\r\n                const ctx = offscreen.getContext('2d');\r\n                ctx.drawImage(bitmap, 0, 0);\r\n                bitmap.close();\r\n                const blob = yield offscreen.convertToBlob(dataURLOptions);\r\n                const type = blob.type;\r\n                const arrayBuffer = yield blob.arrayBuffer();\r\n                const base64 = encode(arrayBuffer);\r\n                if (!lastBlobMap.has(id) && (yield transparentBase64) === base64) {\r\n                    lastBlobMap.set(id, base64);\r\n                    return worker.postMessage({ id });\r\n                }\r\n                if (lastBlobMap.get(id) === base64)\r\n                    return worker.postMessage({ id });\r\n                worker.postMessage({\r\n                    id,\r\n                    type,\r\n                    base64,\r\n                    width,\r\n                    height,\r\n                });\r\n                lastBlobMap.set(id, base64);\r\n            }\r\n            else {\r\n                return worker.postMessage({ id: e.data.id });\r\n            }\r\n        });\r\n    };\n\n})();\n}, null);\n\nclass CanvasManager {\r\n    reset() {\r\n        this.pendingCanvasMutations.clear();\r\n        this.resetObservers && this.resetObservers();\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n    }\r\n    constructor(options) {\r\n        this.pendingCanvasMutations = new Map();\r\n        this.rafStamps = { latestId: 0, invokeId: null };\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.processMutation = (target, mutation) => {\r\n            const newFrame = this.rafStamps.invokeId &&\r\n                this.rafStamps.latestId !== this.rafStamps.invokeId;\r\n            if (newFrame || !this.rafStamps.invokeId)\r\n                this.rafStamps.invokeId = this.rafStamps.latestId;\r\n            if (!this.pendingCanvasMutations.has(target)) {\r\n                this.pendingCanvasMutations.set(target, []);\r\n            }\r\n            this.pendingCanvasMutations.get(target).push(mutation);\r\n        };\r\n        const { sampling = 'all', win, blockClass, blockSelector, recordCanvas, dataURLOptions, } = options;\r\n        this.mutationCb = options.mutationCb;\r\n        this.mirror = options.mirror;\r\n        if (recordCanvas && sampling === 'all')\r\n            this.initCanvasMutationObserver(win, blockClass, blockSelector);\r\n        if (recordCanvas && typeof sampling === 'number')\r\n            this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\r\n                dataURLOptions,\r\n            });\r\n    }\r\n    initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, true);\r\n        const snapshotInProgressMap = new Map();\r\n        const worker = new WorkerFactory();\r\n        worker.onmessage = (e) => {\r\n            const { id } = e.data;\r\n            snapshotInProgressMap.set(id, false);\r\n            if (!('base64' in e.data))\r\n                return;\r\n            const { base64, type, width, height } = e.data;\r\n            this.mutationCb({\r\n                id,\r\n                type: CanvasContext['2D'],\r\n                commands: [\r\n                    {\r\n                        property: 'clearRect',\r\n                        args: [0, 0, width, height],\r\n                    },\r\n                    {\r\n                        property: 'drawImage',\r\n                        args: [\r\n                            {\r\n                                rr_type: 'ImageBitmap',\r\n                                args: [\r\n                                    {\r\n                                        rr_type: 'Blob',\r\n                                        data: [{ rr_type: 'ArrayBuffer', base64 }],\r\n                                        type,\r\n                                    },\r\n                                ],\r\n                            },\r\n                            0,\r\n                            0,\r\n                        ],\r\n                    },\r\n                ],\r\n            });\r\n        };\r\n        const timeBetweenSnapshots = 1000 / fps;\r\n        let lastSnapshotTime = 0;\r\n        let rafId;\r\n        const getCanvas = () => {\r\n            const matchedCanvas = [];\r\n            win.document.querySelectorAll('canvas').forEach((canvas) => {\r\n                if (!isBlocked(canvas, blockClass, blockSelector, true)) {\r\n                    matchedCanvas.push(canvas);\r\n                }\r\n            });\r\n            return matchedCanvas;\r\n        };\r\n        const takeCanvasSnapshots = (timestamp) => {\r\n            if (lastSnapshotTime &&\r\n                timestamp - lastSnapshotTime < timeBetweenSnapshots) {\r\n                rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n                return;\r\n            }\r\n            lastSnapshotTime = timestamp;\r\n            getCanvas()\r\n                .forEach((canvas) => __awaiter(this, void 0, void 0, function* () {\r\n                var _a;\r\n                const id = this.mirror.getId(canvas);\r\n                if (snapshotInProgressMap.get(id))\r\n                    return;\r\n                if (canvas.width === 0 || canvas.height === 0)\r\n                    return;\r\n                snapshotInProgressMap.set(id, true);\r\n                if (['webgl', 'webgl2'].includes(canvas.__context)) {\r\n                    const context = canvas.getContext(canvas.__context);\r\n                    if (((_a = context === null || context === void 0 ? void 0 : context.getContextAttributes()) === null || _a === void 0 ? void 0 : _a.preserveDrawingBuffer) === false) {\r\n                        context.clear(context.COLOR_BUFFER_BIT);\r\n                    }\r\n                }\r\n                const bitmap = yield createImageBitmap(canvas);\r\n                worker.postMessage({\r\n                    id,\r\n                    bitmap,\r\n                    width: canvas.width,\r\n                    height: canvas.height,\r\n                    dataURLOptions: options.dataURLOptions,\r\n                }, [bitmap]);\r\n            }));\r\n            rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n        };\r\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            cancelAnimationFrame(rafId);\r\n        };\r\n    }\r\n    initCanvasMutationObserver(win, blockClass, blockSelector) {\r\n        this.startRAFTimestamping();\r\n        this.startPendingCanvasMutationFlusher();\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, false);\r\n        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\r\n        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, this.mirror);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            canvas2DReset();\r\n            canvasWebGL1and2Reset();\r\n        };\r\n    }\r\n    startPendingCanvasMutationFlusher() {\r\n        requestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    startRAFTimestamping() {\r\n        const setLatestRAFTimestamp = (timestamp) => {\r\n            this.rafStamps.latestId = timestamp;\r\n            requestAnimationFrame(setLatestRAFTimestamp);\r\n        };\r\n        requestAnimationFrame(setLatestRAFTimestamp);\r\n    }\r\n    flushPendingCanvasMutations() {\r\n        this.pendingCanvasMutations.forEach((values, canvas) => {\r\n            const id = this.mirror.getId(canvas);\r\n            this.flushPendingCanvasMutationFor(canvas, id);\r\n        });\r\n        requestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    flushPendingCanvasMutationFor(canvas, id) {\r\n        if (this.frozen || this.locked) {\r\n            return;\r\n        }\r\n        const valuesWithType = this.pendingCanvasMutations.get(canvas);\r\n        if (!valuesWithType || id === -1)\r\n            return;\r\n        const values = valuesWithType.map((value) => {\r\n            const rest = __rest(value, [\"type\"]);\r\n            return rest;\r\n        });\r\n        const { type } = valuesWithType[0];\r\n        this.mutationCb({ id, type, commands: values });\r\n        this.pendingCanvasMutations.delete(canvas);\r\n    }\r\n}\n\nclass StylesheetManager {\r\n    constructor(options) {\r\n        this.trackedLinkElements = new WeakSet();\r\n        this.styleMirror = new StyleSheetMirror();\r\n        this.mutationCb = options.mutationCb;\r\n        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\r\n    }\r\n    attachLinkElement(linkEl, childSn) {\r\n        if ('_cssText' in childSn.attributes)\r\n            this.mutationCb({\r\n                adds: [],\r\n                removes: [],\r\n                texts: [],\r\n                attributes: [\r\n                    {\r\n                        id: childSn.id,\r\n                        attributes: childSn\r\n                            .attributes,\r\n                    },\r\n                ],\r\n            });\r\n        this.trackLinkElement(linkEl);\r\n    }\r\n    trackLinkElement(linkEl) {\r\n        if (this.trackedLinkElements.has(linkEl))\r\n            return;\r\n        this.trackedLinkElements.add(linkEl);\r\n        this.trackStylesheetInLinkElement(linkEl);\r\n    }\r\n    adoptStyleSheets(sheets, hostId) {\r\n        if (sheets.length === 0)\r\n            return;\r\n        const adoptedStyleSheetData = {\r\n            id: hostId,\r\n            styleIds: [],\r\n        };\r\n        const styles = [];\r\n        for (const sheet of sheets) {\r\n            let styleId;\r\n            if (!this.styleMirror.has(sheet)) {\r\n                styleId = this.styleMirror.add(sheet);\r\n                styles.push({\r\n                    styleId,\r\n                    rules: Array.from(sheet.rules || CSSRule, (r, index) => ({\r\n                        rule: stringifyRule(r),\r\n                        index,\r\n                    })),\r\n                });\r\n            }\r\n            else\r\n                styleId = this.styleMirror.getId(sheet);\r\n            adoptedStyleSheetData.styleIds.push(styleId);\r\n        }\r\n        if (styles.length > 0)\r\n            adoptedStyleSheetData.styles = styles;\r\n        this.adoptedStyleSheetCb(adoptedStyleSheetData);\r\n    }\r\n    reset() {\r\n        this.styleMirror.reset();\r\n        this.trackedLinkElements = new WeakSet();\r\n    }\r\n    trackStylesheetInLinkElement(linkEl) {\r\n    }\r\n}\n\nclass ProcessedNodeManager {\r\n    constructor() {\r\n        this.nodeMap = new WeakMap();\r\n        this.loop = true;\r\n        this.periodicallyClear();\r\n    }\r\n    periodicallyClear() {\r\n        requestAnimationFrame(() => {\r\n            this.clear();\r\n            if (this.loop)\r\n                this.periodicallyClear();\r\n        });\r\n    }\r\n    inOtherBuffer(node, thisBuffer) {\r\n        const buffers = this.nodeMap.get(node);\r\n        return (buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer));\r\n    }\r\n    add(node, buffer) {\r\n        this.nodeMap.set(node, (this.nodeMap.get(node) || new Set()).add(buffer));\r\n    }\r\n    clear() {\r\n        this.nodeMap = new WeakMap();\r\n    }\r\n    destroy() {\r\n        this.loop = false;\r\n    }\r\n}\n\nfunction wrapEvent(e) {\r\n    return Object.assign(Object.assign({}, e), { timestamp: nowTimestamp() });\r\n}\r\nlet wrappedEmit;\r\nlet takeFullSnapshot;\r\nlet canvasManager;\r\nlet recording = false;\r\nconst mirror = createMirror();\r\nfunction record(options = {}) {\r\n    const { emit, checkoutEveryNms, checkoutEveryNth, blockClass = 'rr-block', blockSelector = null, ignoreClass = 'rr-ignore', ignoreSelector = null, maskTextClass = 'rr-mask', maskTextSelector = null, inlineStylesheet = true, maskAllInputs, maskInputOptions: _maskInputOptions, slimDOMOptions: _slimDOMOptions, maskInputFn, maskTextFn, hooks, packFn, sampling = {}, dataURLOptions = {}, mousemoveWait, recordDOM = true, recordCanvas = false, recordCrossOriginIframes = false, recordAfter = options.recordAfter === 'DOMContentLoaded'\r\n        ? options.recordAfter\r\n        : 'load', userTriggeredOnInput = false, collectFonts = false, inlineImages = false, plugins, keepIframeSrcFn = () => false, ignoreCSSAttributes = new Set([]), errorHandler, } = options;\r\n    registerErrorHandler(errorHandler);\r\n    const inEmittingFrame = recordCrossOriginIframes\r\n        ? window.parent === window\r\n        : true;\r\n    let passEmitsToParent = false;\r\n    if (!inEmittingFrame) {\r\n        try {\r\n            if (window.parent.document) {\r\n                passEmitsToParent = false;\r\n            }\r\n        }\r\n        catch (e) {\r\n            passEmitsToParent = true;\r\n        }\r\n    }\r\n    if (inEmittingFrame && !emit) {\r\n        throw new Error('emit function is required');\r\n    }\r\n    if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\r\n        sampling.mousemove = mousemoveWait;\r\n    }\r\n    mirror.reset();\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n            password: true,\r\n        }\r\n        : _maskInputOptions !== undefined\r\n            ? _maskInputOptions\r\n            : { password: true };\r\n    const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === 'all'\r\n        ? {\r\n            script: true,\r\n            comment: true,\r\n            headFavicon: true,\r\n            headWhitespace: true,\r\n            headMetaSocial: true,\r\n            headMetaRobots: true,\r\n            headMetaHttpEquiv: true,\r\n            headMetaVerification: true,\r\n            headMetaAuthorship: _slimDOMOptions === 'all',\r\n            headMetaDescKeywords: _slimDOMOptions === 'all',\r\n        }\r\n        : _slimDOMOptions\r\n            ? _slimDOMOptions\r\n            : {};\r\n    polyfill();\r\n    let lastFullSnapshotEvent;\r\n    let incrementalSnapshotCount = 0;\r\n    const eventProcessor = (e) => {\r\n        for (const plugin of plugins || []) {\r\n            if (plugin.eventProcessor) {\r\n                e = plugin.eventProcessor(e);\r\n            }\r\n        }\r\n        if (packFn &&\r\n            !passEmitsToParent) {\r\n            e = packFn(e);\r\n        }\r\n        return e;\r\n    };\r\n    wrappedEmit = (e, isCheckout) => {\r\n        var _a;\r\n        if (((_a = mutationBuffers[0]) === null || _a === void 0 ? void 0 : _a.isFrozen()) &&\r\n            e.type !== EventType$1.FullSnapshot &&\r\n            !(e.type === EventType$1.IncrementalSnapshot &&\r\n                e.data.source === IncrementalSource$1.Mutation)) {\r\n            mutationBuffers.forEach((buf) => buf.unfreeze());\r\n        }\r\n        if (inEmittingFrame) {\r\n            emit === null || emit === void 0 ? void 0 : emit(eventProcessor(e), isCheckout);\r\n        }\r\n        else if (passEmitsToParent) {\r\n            const message = {\r\n                type: 'rrweb',\r\n                event: eventProcessor(e),\r\n                origin: window.location.origin,\r\n                isCheckout,\r\n            };\r\n            window.parent.postMessage(message, '*');\r\n        }\r\n        if (e.type === EventType$1.FullSnapshot) {\r\n            lastFullSnapshotEvent = e;\r\n            incrementalSnapshotCount = 0;\r\n        }\r\n        else if (e.type === EventType$1.IncrementalSnapshot) {\r\n            if (e.data.source === IncrementalSource$1.Mutation &&\r\n                e.data.isAttachIframe) {\r\n                return;\r\n            }\r\n            incrementalSnapshotCount++;\r\n            const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\r\n            const exceedTime = checkoutEveryNms &&\r\n                e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\r\n            if (exceedCount || exceedTime) {\r\n                takeFullSnapshot(true);\r\n            }\r\n        }\r\n    };\r\n    const wrappedMutationEmit = (m) => {\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType$1.IncrementalSnapshot,\r\n            data: Object.assign({ source: IncrementalSource$1.Mutation }, m),\r\n        }));\r\n    };\r\n    const wrappedScrollEmit = (p) => wrappedEmit(wrapEvent({\r\n        type: EventType$1.IncrementalSnapshot,\r\n        data: Object.assign({ source: IncrementalSource$1.Scroll }, p),\r\n    }));\r\n    const wrappedCanvasMutationEmit = (p) => wrappedEmit(wrapEvent({\r\n        type: EventType$1.IncrementalSnapshot,\r\n        data: Object.assign({ source: IncrementalSource$1.CanvasMutation }, p),\r\n    }));\r\n    const wrappedAdoptedStyleSheetEmit = (a) => wrappedEmit(wrapEvent({\r\n        type: EventType$1.IncrementalSnapshot,\r\n        data: Object.assign({ source: IncrementalSource$1.AdoptedStyleSheet }, a),\r\n    }));\r\n    const stylesheetManager = new StylesheetManager({\r\n        mutationCb: wrappedMutationEmit,\r\n        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit,\r\n    });\r\n    const iframeManager = new IframeManager({\r\n        mirror,\r\n        mutationCb: wrappedMutationEmit,\r\n        stylesheetManager: stylesheetManager,\r\n        recordCrossOriginIframes,\r\n        wrappedEmit,\r\n    });\r\n    for (const plugin of plugins || []) {\r\n        if (plugin.getMirror)\r\n            plugin.getMirror({\r\n                nodeMirror: mirror,\r\n                crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\r\n                crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror,\r\n            });\r\n    }\r\n    const processedNodeManager = new ProcessedNodeManager();\r\n    canvasManager = new CanvasManager({\r\n        recordCanvas,\r\n        mutationCb: wrappedCanvasMutationEmit,\r\n        win: window,\r\n        blockClass,\r\n        blockSelector,\r\n        mirror,\r\n        sampling: sampling.canvas,\r\n        dataURLOptions,\r\n    });\r\n    const shadowDomManager = new ShadowDomManager({\r\n        mutationCb: wrappedMutationEmit,\r\n        scrollCb: wrappedScrollEmit,\r\n        bypassOptions: {\r\n            blockClass,\r\n            blockSelector,\r\n            maskTextClass,\r\n            maskTextSelector,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            dataURLOptions,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            recordCanvas,\r\n            inlineImages,\r\n            sampling,\r\n            slimDOMOptions,\r\n            iframeManager,\r\n            stylesheetManager,\r\n            canvasManager,\r\n            keepIframeSrcFn,\r\n            processedNodeManager,\r\n        },\r\n        mirror,\r\n    });\r\n    takeFullSnapshot = (isCheckout = false) => {\r\n        if (!recordDOM) {\r\n            return;\r\n        }\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType$1.Meta,\r\n            data: {\r\n                href: window.location.href,\r\n                width: getWindowWidth(),\r\n                height: getWindowHeight(),\r\n            },\r\n        }), isCheckout);\r\n        stylesheetManager.reset();\r\n        shadowDomManager.init();\r\n        mutationBuffers.forEach((buf) => buf.lock());\r\n        const node = snapshot(document, {\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            maskTextClass,\r\n            maskTextSelector,\r\n            inlineStylesheet,\r\n            maskAllInputs: maskInputOptions,\r\n            maskTextFn,\r\n            slimDOM: slimDOMOptions,\r\n            dataURLOptions,\r\n            recordCanvas,\r\n            inlineImages,\r\n            onSerialize: (n) => {\r\n                if (isSerializedIframe(n, mirror)) {\r\n                    iframeManager.addIframe(n);\r\n                }\r\n                if (isSerializedStylesheet(n, mirror)) {\r\n                    stylesheetManager.trackLinkElement(n);\r\n                }\r\n                if (hasShadowRoot(n)) {\r\n                    shadowDomManager.addShadowRoot(n.shadowRoot, document);\r\n                }\r\n            },\r\n            onIframeLoad: (iframe, childSn) => {\r\n                iframeManager.attachIframe(iframe, childSn);\r\n                shadowDomManager.observeAttachShadow(iframe);\r\n            },\r\n            onStylesheetLoad: (linkEl, childSn) => {\r\n                stylesheetManager.attachLinkElement(linkEl, childSn);\r\n            },\r\n            keepIframeSrcFn,\r\n        });\r\n        if (!node) {\r\n            return console.warn('Failed to snapshot the document');\r\n        }\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType$1.FullSnapshot,\r\n            data: {\r\n                node,\r\n                initialOffset: getWindowScroll(window),\r\n            },\r\n        }), isCheckout);\r\n        mutationBuffers.forEach((buf) => buf.unlock());\r\n        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\r\n            stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\r\n    };\r\n    try {\r\n        const handlers = [];\r\n        const observe = (doc) => {\r\n            var _a;\r\n            return callbackWrapper(initObservers)({\r\n                mutationCb: wrappedMutationEmit,\r\n                mousemoveCb: (positions, source) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: {\r\n                        source,\r\n                        positions,\r\n                    },\r\n                })),\r\n                mouseInteractionCb: (d) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.MouseInteraction }, d),\r\n                })),\r\n                scrollCb: wrappedScrollEmit,\r\n                viewportResizeCb: (d) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.ViewportResize }, d),\r\n                })),\r\n                inputCb: (v) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.Input }, v),\r\n                })),\r\n                mediaInteractionCb: (p) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.MediaInteraction }, p),\r\n                })),\r\n                styleSheetRuleCb: (r) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.StyleSheetRule }, r),\r\n                })),\r\n                styleDeclarationCb: (r) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.StyleDeclaration }, r),\r\n                })),\r\n                canvasMutationCb: wrappedCanvasMutationEmit,\r\n                fontCb: (p) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.Font }, p),\r\n                })),\r\n                selectionCb: (p) => {\r\n                    wrappedEmit(wrapEvent({\r\n                        type: EventType$1.IncrementalSnapshot,\r\n                        data: Object.assign({ source: IncrementalSource$1.Selection }, p),\r\n                    }));\r\n                },\r\n                customElementCb: (c) => {\r\n                    wrappedEmit(wrapEvent({\r\n                        type: EventType$1.IncrementalSnapshot,\r\n                        data: Object.assign({ source: IncrementalSource$1.CustomElement }, c),\r\n                    }));\r\n                },\r\n                blockClass,\r\n                ignoreClass,\r\n                ignoreSelector,\r\n                maskTextClass,\r\n                maskTextSelector,\r\n                maskInputOptions,\r\n                inlineStylesheet,\r\n                sampling,\r\n                recordDOM,\r\n                recordCanvas,\r\n                inlineImages,\r\n                userTriggeredOnInput,\r\n                collectFonts,\r\n                doc,\r\n                maskInputFn,\r\n                maskTextFn,\r\n                keepIframeSrcFn,\r\n                blockSelector,\r\n                slimDOMOptions,\r\n                dataURLOptions,\r\n                mirror,\r\n                iframeManager,\r\n                stylesheetManager,\r\n                shadowDomManager,\r\n                processedNodeManager,\r\n                canvasManager,\r\n                ignoreCSSAttributes,\r\n                plugins: ((_a = plugins === null || plugins === void 0 ? void 0 : plugins.filter((p) => p.observer)) === null || _a === void 0 ? void 0 : _a.map((p) => ({\r\n                    observer: p.observer,\r\n                    options: p.options,\r\n                    callback: (payload) => wrappedEmit(wrapEvent({\r\n                        type: EventType$1.Plugin,\r\n                        data: {\r\n                            plugin: p.name,\r\n                            payload,\r\n                        },\r\n                    })),\r\n                }))) || [],\r\n            }, hooks);\r\n        };\r\n        iframeManager.addLoadListener((iframeEl) => {\r\n            try {\r\n                handlers.push(observe(iframeEl.contentDocument));\r\n            }\r\n            catch (error) {\r\n                console.warn(error);\r\n            }\r\n        });\r\n        const init = () => {\r\n            takeFullSnapshot();\r\n            handlers.push(observe(document));\r\n            recording = true;\r\n        };\r\n        if (document.readyState === 'interactive' ||\r\n            document.readyState === 'complete') {\r\n            init();\r\n        }\r\n        else {\r\n            handlers.push(on('DOMContentLoaded', () => {\r\n                wrappedEmit(wrapEvent({\r\n                    type: EventType$1.DomContentLoaded,\r\n                    data: {},\r\n                }));\r\n                if (recordAfter === 'DOMContentLoaded')\r\n                    init();\r\n            }));\r\n            handlers.push(on('load', () => {\r\n                wrappedEmit(wrapEvent({\r\n                    type: EventType$1.Load,\r\n                    data: {},\r\n                }));\r\n                if (recordAfter === 'load')\r\n                    init();\r\n            }, window));\r\n        }\r\n        return () => {\r\n            handlers.forEach((h) => h());\r\n            processedNodeManager.destroy();\r\n            recording = false;\r\n            unregisterErrorHandler();\r\n        };\r\n    }\r\n    catch (error) {\r\n        console.warn(error);\r\n    }\r\n}\r\nrecord.addCustomEvent = (tag, payload) => {\r\n    if (!recording) {\r\n        throw new Error('please add custom event after start recording');\r\n    }\r\n    wrappedEmit(wrapEvent({\r\n        type: EventType$1.Custom,\r\n        data: {\r\n            tag,\r\n            payload,\r\n        },\r\n    }));\r\n};\r\nrecord.freezePage = () => {\r\n    mutationBuffers.forEach((buf) => buf.freeze());\r\n};\r\nrecord.takeFullSnapshot = (isCheckout) => {\r\n    if (!recording) {\r\n        throw new Error('please take full snapshot after start recording');\r\n    }\r\n    takeFullSnapshot(isCheckout);\r\n};\r\nrecord.mirror = mirror;\n\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\n\nvar Config = {\n    DEBUG: false,\n    LIB_VERSION: '2.58.0'\n};\n\n// since es6 imports are static and we run unit tests from the console, window won't be defined when importing this file\nvar win;\nif (typeof(window) === 'undefined') {\n    var loc = {\n        hostname: ''\n    };\n    win = {\n        navigator: { userAgent: '', onLine: true },\n        document: {\n            location: loc,\n            referrer: ''\n        },\n        screen: { width: 0, height: 0 },\n        location: loc\n    };\n} else {\n    win = window;\n}\n\nvar setImmediate = win['setImmediate'];\nvar builtInProp, cycle, schedulingQueue,\n    ToString = Object.prototype.toString,\n    timer = (typeof setImmediate !== 'undefined') ?\n        function timer(fn) { return setImmediate(fn); } :\n        setTimeout;\n\n// dammit, IE8.\ntry {\n    Object.defineProperty({},'x',{});\n    builtInProp = function builtInProp(obj,name,val,config) {\n        return Object.defineProperty(obj,name,{\n            value: val,\n            writable: true,\n            configurable: config !== false\n        });\n    };\n}\ncatch (err) {\n    builtInProp = function builtInProp(obj,name,val) {\n        obj[name] = val;\n        return obj;\n    };\n}\n\n// Note: using a queue instead of array for efficiency\nschedulingQueue = (function Queue() {\n    var first, last, item;\n\n    function Item(fn,self) {\n        this.fn = fn;\n        this.self = self;\n        this.next = void 0;\n    }\n\n    return {\n        add: function add(fn,self) {\n            item = new Item(fn,self);\n            if (last) {\n                last.next = item;\n            }\n            else {\n                first = item;\n            }\n            last = item;\n            item = void 0;\n        },\n        drain: function drain() {\n            var f = first;\n            first = last = cycle = void 0;\n\n            while (f) {\n                f.fn.call(f.self);\n                f = f.next;\n            }\n        }\n    };\n})();\n\nfunction schedule(fn,self) {\n    schedulingQueue.add(fn,self);\n    if (!cycle) {\n        cycle = timer(schedulingQueue.drain);\n    }\n}\n\n// promise duck typing\nfunction isThenable(o) {\n    var _then, oType = typeof o;\n\n    if (o !== null && (oType === 'object' || oType === 'function')) {\n        _then = o.then;\n    }\n    return typeof _then === 'function' ? _then : false;\n}\n\nfunction notify() {\n    for (var i=0; i<this.chain.length; i++) {\n        notifyIsolated(\n            this,\n            (this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n            this.chain[i]\n        );\n    }\n    this.chain.length = 0;\n}\n\n// NOTE: This is a separate function to isolate\n// the `try..catch` so that other code can be\n// optimized better\nfunction notifyIsolated(self,cb,chain) {\n    var ret, _then;\n    try {\n        if (cb === false) {\n            chain.reject(self.msg);\n        }\n        else {\n            if (cb === true) {\n                ret = self.msg;\n            }\n            else {\n                ret = cb.call(void 0,self.msg);\n            }\n\n            if (ret === chain.promise) {\n                chain.reject(TypeError('Promise-chain cycle'));\n            }\n            // eslint-disable-next-line no-cond-assign\n            else if (_then = isThenable(ret)) {\n                _then.call(ret,chain.resolve,chain.reject);\n            }\n            else {\n                chain.resolve(ret);\n            }\n        }\n    }\n    catch (err) {\n        chain.reject(err);\n    }\n}\n\nfunction resolve(msg) {\n    var _then, self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    try {\n        // eslint-disable-next-line no-cond-assign\n        if (_then = isThenable(msg)) {\n            schedule(function(){\n                var defWrapper = new MakeDefWrapper(self);\n                try {\n                    _then.call(msg,\n                        function $resolve$(){ resolve.apply(defWrapper,arguments); },\n                        function $reject$(){ reject.apply(defWrapper,arguments); }\n                    );\n                }\n                catch (err) {\n                    reject.call(defWrapper,err);\n                }\n            });\n        }\n        else {\n            self.msg = msg;\n            self.state = 1;\n            if (self.chain.length > 0) {\n                schedule(notify,self);\n            }\n        }\n    }\n    catch (err) {\n        reject.call(new MakeDefWrapper(self),err);\n    }\n}\n\nfunction reject(msg) {\n    var self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    self.msg = msg;\n    self.state = 2;\n    if (self.chain.length > 0) {\n        schedule(notify,self);\n    }\n}\n\nfunction iteratePromises(Constructor,arr,resolver,rejecter) {\n    for (var idx=0; idx<arr.length; idx++) {\n        (function IIFE(idx){\n            Constructor.resolve(arr[idx])\n                .then(\n                    function $resolver$(msg){\n                        resolver(idx,msg);\n                    },\n                    rejecter\n                );\n        })(idx);\n    }\n}\n\nfunction MakeDefWrapper(self) {\n    this.def = self;\n    this.triggered = false;\n}\n\nfunction MakeDef(self) {\n    this.promise = self;\n    this.state = 0;\n    this.triggered = false;\n    this.chain = [];\n    this.msg = void 0;\n}\n\nfunction NpoPromise(executor) {\n    if (typeof executor !== 'function') {\n        throw TypeError('Not a function');\n    }\n\n    if (this['__NPO__'] !== 0) {\n        throw TypeError('Not a promise');\n    }\n\n    // instance shadowing the inherited \"brand\"\n    // to signal an already \"initialized\" promise\n    this['__NPO__'] = 1;\n\n    var def = new MakeDef(this);\n\n    this['then'] = function then(success,failure) {\n        var o = {\n            success: typeof success === 'function' ? success : true,\n            failure: typeof failure === 'function' ? failure : false\n        };\n            // Note: `then(..)` itself can be borrowed to be used against\n            // a different promise constructor for making the chained promise,\n            // by substituting a different `this` binding.\n        o.promise = new this.constructor(function extractChain(resolve,reject) {\n            if (typeof resolve !== 'function' || typeof reject !== 'function') {\n                throw TypeError('Not a function');\n            }\n\n            o.resolve = resolve;\n            o.reject = reject;\n        });\n        def.chain.push(o);\n\n        if (def.state !== 0) {\n            schedule(notify,def);\n        }\n\n        return o.promise;\n    };\n    this['catch'] = function $catch$(failure) {\n        return this.then(void 0,failure);\n    };\n\n    try {\n        executor.call(\n            void 0,\n            function publicResolve(msg){\n                resolve.call(def,msg);\n            },\n            function publicReject(msg) {\n                reject.call(def,msg);\n            }\n        );\n    }\n    catch (err) {\n        reject.call(def,err);\n    }\n}\n\nvar PromisePrototype = builtInProp({},'constructor',NpoPromise,\n    /*configurable=*/false\n);\n\n    // Note: Android 4 cannot use `Object.defineProperty(..)` here\nNpoPromise.prototype = PromisePrototype;\n\n// built-in \"brand\" to signal an \"uninitialized\" promise\nbuiltInProp(PromisePrototype,'__NPO__',0,\n    /*configurable=*/false\n);\n\nbuiltInProp(NpoPromise,'resolve',function Promise$resolve(msg) {\n    var Constructor = this;\n\n    // spec mandated checks\n    // note: best \"isPromise\" check that's practical for now\n    if (msg && typeof msg === 'object' && msg['__NPO__'] === 1) {\n        return msg;\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        resolve(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'reject',function Promise$reject(msg) {\n    return new this(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        reject(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'all',function Promise$all(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n    if (arr.length === 0) {\n        return Constructor.resolve([]);\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        var len = arr.length, msgs = Array(len), count = 0;\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg) {\n            msgs[idx] = msg;\n            if (++count === len) {\n                resolve(msgs);\n            }\n        },reject);\n    });\n});\n\nbuiltInProp(NpoPromise,'race',function Promise$race(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg){\n            resolve(msg);\n        },reject);\n    });\n});\n\nvar PromisePolyfill;\nif (typeof Promise !== 'undefined' && Promise.toString().indexOf('[native code]') !== -1) {\n    PromisePolyfill = Promise;\n} else {\n    PromisePolyfill = NpoPromise;\n}\n\n/* eslint camelcase: \"off\", eqeqeq: \"off\" */\n\n// Maximum allowed session recording length\nvar MAX_RECORDING_MS = 24 * 60 * 60 * 1000; // 24 hours\n// Maximum allowed value for minimum session recording length\nvar MAX_VALUE_FOR_MIN_RECORDING_MS = 8 * 1000; // 8 seconds\n\n/*\n * Saved references to long variable names, so that closure compiler can\n * minimize file size.\n */\n\nvar ArrayProto = Array.prototype,\n    FuncProto = Function.prototype,\n    ObjProto = Object.prototype,\n    slice = ArrayProto.slice,\n    toString = ObjProto.toString,\n    hasOwnProperty = ObjProto.hasOwnProperty,\n    windowConsole = win.console,\n    navigator = win.navigator,\n    document$1 = win.document,\n    windowOpera = win.opera,\n    screen = win.screen,\n    userAgent = navigator.userAgent;\n\nvar nativeBind = FuncProto.bind,\n    nativeForEach = ArrayProto.forEach,\n    nativeIndexOf = ArrayProto.indexOf,\n    nativeMap = ArrayProto.map,\n    nativeIsArray = Array.isArray,\n    breaker = {};\n\nvar _ = {\n    trim: function(str) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n};\n\n// Console override\nvar console$1 = {\n    /** @type {function(...*)} */\n    log: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            try {\n                windowConsole.log.apply(windowConsole, arguments);\n            } catch (err) {\n                _.each(arguments, function(arg) {\n                    windowConsole.log(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    warn: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel warning:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.warn.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.warn(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    error: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    critical: function() {\n        if (!_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    }\n};\n\nvar log_func_with_prefix = function(func, prefix) {\n    return function() {\n        arguments[0] = '[' + prefix + '] ' + arguments[0];\n        return func.apply(console$1, arguments);\n    };\n};\nvar console_with_prefix = function(prefix) {\n    return {\n        log: log_func_with_prefix(console$1.log, prefix),\n        error: log_func_with_prefix(console$1.error, prefix),\n        critical: log_func_with_prefix(console$1.critical, prefix)\n    };\n};\n\n\n// UNDERSCORE\n// Embed part of the Underscore Library\n_.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n    }\n    if (!_.isFunction(func)) {\n        throw new TypeError();\n    }\n    args = slice.call(arguments, 2);\n    bound = function() {\n        if (!(this instanceof bound)) {\n            return func.apply(context, args.concat(slice.call(arguments)));\n        }\n        var ctor = {};\n        ctor.prototype = func.prototype;\n        var self = new ctor();\n        ctor.prototype = null;\n        var result = func.apply(self, args.concat(slice.call(arguments)));\n        if (Object(result) === result) {\n            return result;\n        }\n        return self;\n    };\n    return bound;\n};\n\n/**\n * @param {*=} obj\n * @param {function(...*)=} iterator\n * @param {Object=} context\n */\n_.each = function(obj, iterator, context) {\n    if (obj === null || obj === undefined) {\n        return;\n    }\n    if (nativeForEach && obj.forEach === nativeForEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n                return;\n            }\n        }\n    } else {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                if (iterator.call(context, obj[key], key, obj) === breaker) {\n                    return;\n                }\n            }\n        }\n    }\n};\n\n_.extend = function(obj) {\n    _.each(slice.call(arguments, 1), function(source) {\n        for (var prop in source) {\n            if (source[prop] !== void 0) {\n                obj[prop] = source[prop];\n            }\n        }\n    });\n    return obj;\n};\n\n_.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n\n// from a comment on http://dbj.org/dbj/?p=286\n// fails on only one very rare and deliberate custom object:\n// var bomb = { toString : undefined, valueOf: function(o) { return \"function BOMBA!\"; }};\n_.isFunction = function(f) {\n    try {\n        return /^\\s*\\bfunction\\b/.test(f);\n    } catch (x) {\n        return false;\n    }\n};\n\n_.isArguments = function(obj) {\n    return !!(obj && hasOwnProperty.call(obj, 'callee'));\n};\n\n_.toArray = function(iterable) {\n    if (!iterable) {\n        return [];\n    }\n    if (iterable.toArray) {\n        return iterable.toArray();\n    }\n    if (_.isArray(iterable)) {\n        return slice.call(iterable);\n    }\n    if (_.isArguments(iterable)) {\n        return slice.call(iterable);\n    }\n    return _.values(iterable);\n};\n\n_.map = function(arr, callback, context) {\n    if (nativeMap && arr.map === nativeMap) {\n        return arr.map(callback, context);\n    } else {\n        var results = [];\n        _.each(arr, function(item) {\n            results.push(callback.call(context, item));\n        });\n        return results;\n    }\n};\n\n_.keys = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value, key) {\n        results[results.length] = key;\n    });\n    return results;\n};\n\n_.values = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value) {\n        results[results.length] = value;\n    });\n    return results;\n};\n\n_.include = function(obj, target) {\n    var found = false;\n    if (obj === null) {\n        return found;\n    }\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n        return obj.indexOf(target) != -1;\n    }\n    _.each(obj, function(value) {\n        if (found || (found = (value === target))) {\n            return breaker;\n        }\n    });\n    return found;\n};\n\n_.includes = function(str, needle) {\n    return str.indexOf(needle) !== -1;\n};\n\n// Underscore Addons\n_.inherit = function(subclass, superclass) {\n    subclass.prototype = new superclass();\n    subclass.prototype.constructor = subclass;\n    subclass.superclass = superclass.prototype;\n    return subclass;\n};\n\n_.isObject = function(obj) {\n    return (obj === Object(obj) && !_.isArray(obj));\n};\n\n_.isEmptyObject = function(obj) {\n    if (_.isObject(obj)) {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n_.isUndefined = function(obj) {\n    return obj === void 0;\n};\n\n_.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n};\n\n_.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n};\n\n_.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n};\n\n_.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n};\n\n_.encodeDates = function(obj) {\n    _.each(obj, function(v, k) {\n        if (_.isDate(v)) {\n            obj[k] = _.formatDate(v);\n        } else if (_.isObject(v)) {\n            obj[k] = _.encodeDates(v); // recurse\n        }\n    });\n    return obj;\n};\n\n_.timestamp = function() {\n    Date.now = Date.now || function() {\n        return +new Date;\n    };\n    return Date.now();\n};\n\n_.formatDate = function(d) {\n    // YYYY-MM-DDTHH:MM:SS in UTC\n    function pad(n) {\n        return n < 10 ? '0' + n : n;\n    }\n    return d.getUTCFullYear() + '-' +\n        pad(d.getUTCMonth() + 1) + '-' +\n        pad(d.getUTCDate()) + 'T' +\n        pad(d.getUTCHours()) + ':' +\n        pad(d.getUTCMinutes()) + ':' +\n        pad(d.getUTCSeconds());\n};\n\n_.strip_empty_properties = function(p) {\n    var ret = {};\n    _.each(p, function(v, k) {\n        if (_.isString(v) && v.length > 0) {\n            ret[k] = v;\n        }\n    });\n    return ret;\n};\n\n/*\n * this function returns a copy of object after truncating it.  If\n * passed an Array or Object it will iterate through obj and\n * truncate all the values recursively.\n */\n_.truncate = function(obj, length) {\n    var ret;\n\n    if (typeof(obj) === 'string') {\n        ret = obj.slice(0, length);\n    } else if (_.isArray(obj)) {\n        ret = [];\n        _.each(obj, function(val) {\n            ret.push(_.truncate(val, length));\n        });\n    } else if (_.isObject(obj)) {\n        ret = {};\n        _.each(obj, function(val, key) {\n            ret[key] = _.truncate(val, length);\n        });\n    } else {\n        ret = obj;\n    }\n\n    return ret;\n};\n\n_.JSONEncode = (function() {\n    return function(mixed_val) {\n        var value = mixed_val;\n        var quote = function(string) {\n            var escapable = /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // eslint-disable-line no-control-regex\n            var meta = { // table of character substitutions\n                '\\b': '\\\\b',\n                '\\t': '\\\\t',\n                '\\n': '\\\\n',\n                '\\f': '\\\\f',\n                '\\r': '\\\\r',\n                '\"': '\\\\\"',\n                '\\\\': '\\\\\\\\'\n            };\n\n            escapable.lastIndex = 0;\n            return escapable.test(string) ?\n                '\"' + string.replace(escapable, function(a) {\n                    var c = meta[a];\n                    return typeof c === 'string' ? c :\n                        '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"' :\n                '\"' + string + '\"';\n        };\n\n        var str = function(key, holder) {\n            var gap = '';\n            var indent = '    ';\n            var i = 0; // The loop counter.\n            var k = ''; // The member key.\n            var v = ''; // The member value.\n            var length = 0;\n            var mind = gap;\n            var partial = [];\n            var value = holder[key];\n\n            // If the value has a toJSON method, call it to obtain a replacement value.\n            if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n                value = value.toJSON(key);\n            }\n\n            // What happens next depends on the value's type.\n            switch (typeof value) {\n                case 'string':\n                    return quote(value);\n\n                case 'number':\n                    // JSON numbers must be finite. Encode non-finite numbers as null.\n                    return isFinite(value) ? String(value) : 'null';\n\n                case 'boolean':\n                case 'null':\n                    // If the value is a boolean or null, convert it to a string. Note:\n                    // typeof null does not produce 'null'. The case is included here in\n                    // the remote chance that this gets fixed someday.\n\n                    return String(value);\n\n                case 'object':\n                    // If the type is 'object', we might be dealing with an object or an array or\n                    // null.\n                    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n                    // so watch out for that case.\n                    if (!value) {\n                        return 'null';\n                    }\n\n                    // Make an array to hold the partial results of stringifying this object value.\n                    gap += indent;\n                    partial = [];\n\n                    // Is the value an array?\n                    if (toString.apply(value) === '[object Array]') {\n                        // The value is an array. Stringify every element. Use null as a placeholder\n                        // for non-JSON values.\n\n                        length = value.length;\n                        for (i = 0; i < length; i += 1) {\n                            partial[i] = str(i, value) || 'null';\n                        }\n\n                        // Join all of the elements together, separated with commas, and wrap them in\n                        // brackets.\n                        v = partial.length === 0 ? '[]' :\n                            gap ? '[\\n' + gap +\n                            partial.join(',\\n' + gap) + '\\n' +\n                            mind + ']' :\n                                '[' + partial.join(',') + ']';\n                        gap = mind;\n                        return v;\n                    }\n\n                    // Iterate through all of the keys in the object.\n                    for (k in value) {\n                        if (hasOwnProperty.call(value, k)) {\n                            v = str(k, value);\n                            if (v) {\n                                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                            }\n                        }\n                    }\n\n                    // Join all of the member texts together, separated with commas,\n                    // and wrap them in braces.\n                    v = partial.length === 0 ? '{}' :\n                        gap ? '{' + partial.join(',') + '' +\n                        mind + '}' : '{' + partial.join(',') + '}';\n                    gap = mind;\n                    return v;\n            }\n        };\n\n        // Make a fake root object containing our value under the key of ''.\n        // Return the result of stringifying the value.\n        return str('', {\n            '': value\n        });\n    };\n})();\n\n/**\n * From https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n * Slightly modified to throw a real Error rather than a POJO\n */\n_.JSONDecode = (function() {\n    var at, // The index of the current character\n        ch, // The current character\n        escapee = {\n            '\"': '\"',\n            '\\\\': '\\\\',\n            '/': '/',\n            'b': '\\b',\n            'f': '\\f',\n            'n': '\\n',\n            'r': '\\r',\n            't': '\\t'\n        },\n        text,\n        error = function(m) {\n            var e = new SyntaxError(m);\n            e.at = at;\n            e.text = text;\n            throw e;\n        },\n        next = function(c) {\n            // If a c parameter is provided, verify that it matches the current character.\n            if (c && c !== ch) {\n                error('Expected \\'' + c + '\\' instead of \\'' + ch + '\\'');\n            }\n            // Get the next character. When there are no more characters,\n            // return the empty string.\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n        number = function() {\n            // Parse a number value.\n            var number,\n                string = '';\n\n            if (ch === '-') {\n                string = '-';\n                next('-');\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n            if (ch === '.') {\n                string += '.';\n                while (next() && ch >= '0' && ch <= '9') {\n                    string += ch;\n                }\n            }\n            if (ch === 'e' || ch === 'E') {\n                string += ch;\n                next();\n                if (ch === '-' || ch === '+') {\n                    string += ch;\n                    next();\n                }\n                while (ch >= '0' && ch <= '9') {\n                    string += ch;\n                    next();\n                }\n            }\n            number = +string;\n            if (!isFinite(number)) {\n                error('Bad number');\n            } else {\n                return number;\n            }\n        },\n\n        string = function() {\n            // Parse a string value.\n            var hex,\n                i,\n                string = '',\n                uffff;\n            // When parsing for string values, we must look for \" and \\ characters.\n            if (ch === '\"') {\n                while (next()) {\n                    if (ch === '\"') {\n                        next();\n                        return string;\n                    }\n                    if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error('Bad string');\n        },\n        white = function() {\n            // Skip whitespace.\n            while (ch && ch <= ' ') {\n                next();\n            }\n        },\n        word = function() {\n            // true, false, or null.\n            switch (ch) {\n                case 't':\n                    next('t');\n                    next('r');\n                    next('u');\n                    next('e');\n                    return true;\n                case 'f':\n                    next('f');\n                    next('a');\n                    next('l');\n                    next('s');\n                    next('e');\n                    return false;\n                case 'n':\n                    next('n');\n                    next('u');\n                    next('l');\n                    next('l');\n                    return null;\n            }\n            error('Unexpected \"' + ch + '\"');\n        },\n        value, // Placeholder for the value function.\n        array = function() {\n            // Parse an array value.\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array; // empty array\n                }\n                while (ch) {\n                    array.push(value());\n                    white();\n                    if (ch === ']') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad array');\n        },\n        object = function() {\n            // Parse an object value.\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object; // empty object\n                }\n                while (ch) {\n                    key = string();\n                    white();\n                    next(':');\n                    if (Object.hasOwnProperty.call(object, key)) {\n                        error('Duplicate key \"' + key + '\"');\n                    }\n                    object[key] = value();\n                    white();\n                    if (ch === '}') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad object');\n        };\n\n    value = function() {\n        // Parse a JSON value. It could be an object, an array, a string,\n        // a number, or a word.\n        white();\n        switch (ch) {\n            case '{':\n                return object();\n            case '[':\n                return array();\n            case '\"':\n                return string();\n            case '-':\n                return number();\n            default:\n                return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n    // Return the json_parse function. It will have access to all of the\n    // above functions and variables.\n    return function(source) {\n        var result;\n\n        text = source;\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error('Syntax error');\n        }\n\n        return result;\n    };\n})();\n\n_.base64Encode = function(data) {\n    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = '',\n        tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    data = _.utf8Encode(data);\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n            break;\n    }\n\n    return enc;\n};\n\n_.utf8Encode = function(string) {\n    string = (string + '').replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n    var utftext = '',\n        start,\n        end;\n    var stringl = 0,\n        n;\n\n    start = end = 0;\n    stringl = string.length;\n\n    for (n = 0; n < stringl; n++) {\n        var c1 = string.charCodeAt(n);\n        var enc = null;\n\n        if (c1 < 128) {\n            end++;\n        } else if ((c1 > 127) && (c1 < 2048)) {\n            enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128);\n        } else {\n            enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);\n        }\n        if (enc !== null) {\n            if (end > start) {\n                utftext += string.substring(start, end);\n            }\n            utftext += enc;\n            start = end = n + 1;\n        }\n    }\n\n    if (end > start) {\n        utftext += string.substring(start, string.length);\n    }\n\n    return utftext;\n};\n\n_.UUID = (function() {\n\n    // Time-based entropy\n    var T = function() {\n        var time = 1 * new Date(); // cross-browser version of Date.now()\n        var ticks;\n        if (win.performance && win.performance.now) {\n            ticks = win.performance.now();\n        } else {\n            // fall back to busy loop\n            ticks = 0;\n\n            // this while loop figures how many browser ticks go by\n            // before 1*new Date() returns a new number, ie the amount\n            // of ticks that go by per millisecond\n            while (time == 1 * new Date()) {\n                ticks++;\n            }\n        }\n        return time.toString(16) + Math.floor(ticks).toString(16);\n    };\n\n    // Math.Random entropy\n    var R = function() {\n        return Math.random().toString(16).replace('.', '');\n    };\n\n    // User agent entropy\n    // This function takes the user agent string, and then xors\n    // together each sequence of 8 bytes.  This produces a final\n    // sequence of 8 bytes which it returns as hex.\n    var UA = function() {\n        var ua = userAgent,\n            i, ch, buffer = [],\n            ret = 0;\n\n        function xor(result, byte_array) {\n            var j, tmp = 0;\n            for (j = 0; j < byte_array.length; j++) {\n                tmp |= (buffer[j] << j * 8);\n            }\n            return result ^ tmp;\n        }\n\n        for (i = 0; i < ua.length; i++) {\n            ch = ua.charCodeAt(i);\n            buffer.unshift(ch & 0xFF);\n            if (buffer.length >= 4) {\n                ret = xor(ret, buffer);\n                buffer = [];\n            }\n        }\n\n        if (buffer.length > 0) {\n            ret = xor(ret, buffer);\n        }\n\n        return ret.toString(16);\n    };\n\n    return function() {\n        var se = (screen.height * screen.width).toString(16);\n        return (T() + '-' + R() + '-' + UA() + '-' + se + '-' + T());\n    };\n})();\n\n// _.isBlockedUA()\n// This is to block various web spiders from executing our JS and\n// sending false tracking data\nvar BLOCKED_UA_STRS = [\n    'ahrefsbot',\n    'ahrefssiteaudit',\n    'baiduspider',\n    'bingbot',\n    'bingpreview',\n    'chrome-lighthouse',\n    'facebookexternal',\n    'petalbot',\n    'pinterest',\n    'screaming frog',\n    'yahoo! slurp',\n    'yandexbot',\n\n    // a whole bunch of goog-specific crawlers\n    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers\n    'adsbot-google',\n    'apis-google',\n    'duplexweb-google',\n    'feedfetcher-google',\n    'google favicon',\n    'google web preview',\n    'google-read-aloud',\n    'googlebot',\n    'googleweblight',\n    'mediapartners-google',\n    'storebot-google'\n];\n_.isBlockedUA = function(ua) {\n    var i;\n    ua = ua.toLowerCase();\n    for (i = 0; i < BLOCKED_UA_STRS.length; i++) {\n        if (ua.indexOf(BLOCKED_UA_STRS[i]) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * @param {Object=} formdata\n * @param {string=} arg_separator\n */\n_.HTTPBuildQuery = function(formdata, arg_separator) {\n    var use_val, use_key, tmp_arr = [];\n\n    if (_.isUndefined(arg_separator)) {\n        arg_separator = '&';\n    }\n\n    _.each(formdata, function(val, key) {\n        use_val = encodeURIComponent(val.toString());\n        use_key = encodeURIComponent(key);\n        tmp_arr[tmp_arr.length] = use_key + '=' + use_val;\n    });\n\n    return tmp_arr.join(arg_separator);\n};\n\n_.getQueryParam = function(url, param) {\n    // Expects a raw URL\n\n    param = param.replace(/[[]/g, '\\\\[').replace(/[\\]]/g, '\\\\]');\n    var regexS = '[\\\\?&]' + param + '=([^&#]*)',\n        regex = new RegExp(regexS),\n        results = regex.exec(url);\n    if (results === null || (results && typeof(results[1]) !== 'string' && results[1].length)) {\n        return '';\n    } else {\n        var result = results[1];\n        try {\n            result = decodeURIComponent(result);\n        } catch(err) {\n            console$1.error('Skipping decoding for malformed query param: ' + result);\n        }\n        return result.replace(/\\+/g, ' ');\n    }\n};\n\n\n// _.cookie\n// Methods partially borrowed from quirksmode.org/js/cookies.html\n_.cookie = {\n    get: function(name) {\n        var nameEQ = name + '=';\n        var ca = document$1.cookie.split(';');\n        for (var i = 0; i < ca.length; i++) {\n            var c = ca[i];\n            while (c.charAt(0) == ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return decodeURIComponent(c.substring(nameEQ.length, c.length));\n            }\n        }\n        return null;\n    },\n\n    parse: function(name) {\n        var cookie;\n        try {\n            cookie = _.JSONDecode(_.cookie.get(name)) || {};\n        } catch (err) {\n            // noop\n        }\n        return cookie;\n    },\n\n    set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '',\n            expires = '',\n            secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (seconds) {\n            var date = new Date();\n            date.setTime(date.getTime() + (seconds * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        document$1.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n    },\n\n    set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '', expires = '', secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (days) {\n            var date = new Date();\n            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        var new_cookie_val = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n        document$1.cookie = new_cookie_val;\n        return new_cookie_val;\n    },\n\n    remove: function(name, is_cross_subdomain, domain_override) {\n        _.cookie.set(name, '', -1, is_cross_subdomain, false, false, domain_override);\n    }\n};\n\nvar _localStorageSupported = null;\nvar localStorageSupported = function(storage, forceCheck) {\n    if (_localStorageSupported !== null && !forceCheck) {\n        return _localStorageSupported;\n    }\n\n    var supported = true;\n    try {\n        storage = storage || win.localStorage;\n        var key = '__mplss_' + cheap_guid(8),\n            val = 'xyz';\n        storage.setItem(key, val);\n        if (storage.getItem(key) !== val) {\n            supported = false;\n        }\n        storage.removeItem(key);\n    } catch (err) {\n        supported = false;\n    }\n\n    _localStorageSupported = supported;\n    return supported;\n};\n\n// _.localStorage\n_.localStorage = {\n    is_supported: function(force_check) {\n        var supported = localStorageSupported(null, force_check);\n        if (!supported) {\n            console$1.error('localStorage unsupported; falling back to cookie store');\n        }\n        return supported;\n    },\n\n    error: function(msg) {\n        console$1.error('localStorage error: ' + msg);\n    },\n\n    get: function(name) {\n        try {\n            return win.localStorage.getItem(name);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n        return null;\n    },\n\n    parse: function(name) {\n        try {\n            return _.JSONDecode(_.localStorage.get(name)) || {};\n        } catch (err) {\n            // noop\n        }\n        return null;\n    },\n\n    set: function(name, value) {\n        try {\n            win.localStorage.setItem(name, value);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n    },\n\n    remove: function(name) {\n        try {\n            win.localStorage.removeItem(name);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n    }\n};\n\n_.register_event = (function() {\n    // written by Dean Edwards, 2005\n    // with input from Tino Zijdel - crisp@xs4all.nl\n    // with input from Carl Sverre - mail@carlsverre.com\n    // with input from Mixpanel\n    // http://dean.edwards.name/weblog/2005/10/add-event/\n    // https://gist.github.com/1930440\n\n    /**\n     * @param {Object} element\n     * @param {string} type\n     * @param {function(...*)} handler\n     * @param {boolean=} oldSchool\n     * @param {boolean=} useCapture\n     */\n    var register_event = function(element, type, handler, oldSchool, useCapture) {\n        if (!element) {\n            console$1.error('No valid element provided to register_event');\n            return;\n        }\n\n        if (element.addEventListener && !oldSchool) {\n            element.addEventListener(type, handler, !!useCapture);\n        } else {\n            var ontype = 'on' + type;\n            var old_handler = element[ontype]; // can be undefined\n            element[ontype] = makeHandler(element, handler, old_handler);\n        }\n    };\n\n    function makeHandler(element, new_handler, old_handlers) {\n        var handler = function(event) {\n            event = event || fixEvent(win.event);\n\n            // this basically happens in firefox whenever another script\n            // overwrites the onload callback and doesn't pass the event\n            // object to previously defined callbacks.  All the browsers\n            // that don't define window.event implement addEventListener\n            // so the dom_loaded handler will still be fired as usual.\n            if (!event) {\n                return undefined;\n            }\n\n            var ret = true;\n            var old_result, new_result;\n\n            if (_.isFunction(old_handlers)) {\n                old_result = old_handlers(event);\n            }\n            new_result = new_handler.call(element, event);\n\n            if ((false === old_result) || (false === new_result)) {\n                ret = false;\n            }\n\n            return ret;\n        };\n\n        return handler;\n    }\n\n    function fixEvent(event) {\n        if (event) {\n            event.preventDefault = fixEvent.preventDefault;\n            event.stopPropagation = fixEvent.stopPropagation;\n        }\n        return event;\n    }\n    fixEvent.preventDefault = function() {\n        this.returnValue = false;\n    };\n    fixEvent.stopPropagation = function() {\n        this.cancelBubble = true;\n    };\n\n    return register_event;\n})();\n\n\nvar TOKEN_MATCH_REGEX = new RegExp('^(\\\\w*)\\\\[(\\\\w+)([=~\\\\|\\\\^\\\\$\\\\*]?)=?\"?([^\\\\]\"]*)\"?\\\\]$');\n\n_.dom_query = (function() {\n    /* document.getElementsBySelector(selector)\n    - returns an array of element objects from the current document\n    matching the CSS selector. Selectors can contain element names,\n    class names and ids and can be nested. For example:\n\n    elements = document.getElementsBySelector('div#main p a.external')\n\n    Will return an array of all 'a' elements with 'external' in their\n    class attribute that are contained inside 'p' elements that are\n    contained inside the 'div' element which has id=\"main\"\n\n    New in version 0.4: Support for CSS2 and CSS3 attribute selectors:\n    See http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\n    Version 0.4 - Simon Willison, March 25th 2003\n    -- Works in Phoenix 0.5, Mozilla 1.3, Opera 7, Internet Explorer 6, Internet Explorer 5 on Windows\n    -- Opera 7 fails\n\n    Version 0.5 - Carl Sverre, Jan 7th 2013\n    -- Now uses jQuery-esque `hasClass` for testing class name\n    equality.  This fixes a bug related to '-' characters being\n    considered not part of a 'word' in regex.\n    */\n\n    function getAllChildren(e) {\n        // Returns all children of element. Workaround required for IE5/Windows. Ugh.\n        return e.all ? e.all : e.getElementsByTagName('*');\n    }\n\n    var bad_whitespace = /[\\t\\r\\n]/g;\n\n    function hasClass(elem, selector) {\n        var className = ' ' + selector + ' ';\n        return ((' ' + elem.className + ' ').replace(bad_whitespace, ' ').indexOf(className) >= 0);\n    }\n\n    function getElementsBySelector(selector) {\n        // Attempt to fail gracefully in lesser browsers\n        if (!document$1.getElementsByTagName) {\n            return [];\n        }\n        // Split selector in to tokens\n        var tokens = selector.split(' ');\n        var token, bits, tagName, found, foundCount, i, j, k, elements, currentContextIndex;\n        var currentContext = [document$1];\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i].replace(/^\\s+/, '').replace(/\\s+$/, '');\n            if (token.indexOf('#') > -1) {\n                // Token is an ID selector\n                bits = token.split('#');\n                tagName = bits[0];\n                var id = bits[1];\n                var element = document$1.getElementById(id);\n                if (!element || (tagName && element.nodeName.toLowerCase() != tagName)) {\n                    // element not found or tag with that ID not found, return false\n                    return [];\n                }\n                // Set currentContext to contain just this element\n                currentContext = [element];\n                continue; // Skip to next token\n            }\n            if (token.indexOf('.') > -1) {\n                // Token contains a class selector\n                bits = token.split('.');\n                tagName = bits[0];\n                var className = bits[1];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Get elements matching tag, filter them for class selector\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (found[j].className &&\n                        _.isString(found[j].className) && // some SVG elements have classNames which are not strings\n                        hasClass(found[j], className)\n                    ) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // Code to deal with attribute selectors\n            var token_match = token.match(TOKEN_MATCH_REGEX);\n            if (token_match) {\n                tagName = token_match[1];\n                var attrName = token_match[2];\n                var attrOperator = token_match[3];\n                var attrValue = token_match[4];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Grab all of the tagName elements within current context\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                var checkFunction; // This function will be used to filter the elements\n                switch (attrOperator) {\n                    case '=': // Equality\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName) == attrValue);\n                        };\n                        break;\n                    case '~': // Match one of space seperated words\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('\\\\b' + attrValue + '\\\\b')));\n                        };\n                        break;\n                    case '|': // Match start with value followed by optional hyphen\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('^' + attrValue + '-?')));\n                        };\n                        break;\n                    case '^': // Match starts with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) === 0);\n                        };\n                        break;\n                    case '$': // Match ends with value - fails with \"Warning\" in Opera 7\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).lastIndexOf(attrValue) == e.getAttribute(attrName).length - attrValue.length);\n                        };\n                        break;\n                    case '*': // Match ends with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) > -1);\n                        };\n                        break;\n                    default:\n                        // Just test for existence of attribute\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName);\n                        };\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (checkFunction(found[j])) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                // alert('Attribute Selector: '+tagName+' '+attrName+' '+attrOperator+' '+attrValue);\n                continue; // Skip to next token\n            }\n            // If we get here, token is JUST an element (not a class or ID selector)\n            tagName = token;\n            found = [];\n            foundCount = 0;\n            for (j = 0; j < currentContext.length; j++) {\n                elements = currentContext[j].getElementsByTagName(tagName);\n                for (k = 0; k < elements.length; k++) {\n                    found[foundCount++] = elements[k];\n                }\n            }\n            currentContext = found;\n        }\n        return currentContext;\n    }\n\n    return function(query) {\n        if (_.isElement(query)) {\n            return [query];\n        } else if (_.isObject(query) && !_.isUndefined(query.length)) {\n            return query;\n        } else {\n            return getElementsBySelector.call(this, query);\n        }\n    };\n})();\n\nvar CAMPAIGN_KEYWORDS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term', 'utm_id', 'utm_source_platform','utm_campaign_id', 'utm_creative_format', 'utm_marketing_tactic'];\nvar CLICK_IDS = ['dclid', 'fbclid', 'gclid', 'ko_click_id', 'li_fat_id', 'msclkid', 'sccid', 'ttclid', 'twclid', 'wbraid'];\n\n_.info = {\n    campaignParams: function(default_value) {\n        var kw = '',\n            params = {};\n        _.each(CAMPAIGN_KEYWORDS, function(kwkey) {\n            kw = _.getQueryParam(document$1.URL, kwkey);\n            if (kw.length) {\n                params[kwkey] = kw;\n            } else if (default_value !== undefined) {\n                params[kwkey] = default_value;\n            }\n        });\n\n        return params;\n    },\n\n    clickParams: function() {\n        var id = '',\n            params = {};\n        _.each(CLICK_IDS, function(idkey) {\n            id = _.getQueryParam(document$1.URL, idkey);\n            if (id.length) {\n                params[idkey] = id;\n            }\n        });\n\n        return params;\n    },\n\n    marketingParams: function() {\n        return _.extend(_.info.campaignParams(), _.info.clickParams());\n    },\n\n    searchEngine: function(referrer) {\n        if (referrer.search('https?://(.*)google.([^/?]*)') === 0) {\n            return 'google';\n        } else if (referrer.search('https?://(.*)bing.com') === 0) {\n            return 'bing';\n        } else if (referrer.search('https?://(.*)yahoo.com') === 0) {\n            return 'yahoo';\n        } else if (referrer.search('https?://(.*)duckduckgo.com') === 0) {\n            return 'duckduckgo';\n        } else {\n            return null;\n        }\n    },\n\n    searchInfo: function(referrer) {\n        var search = _.info.searchEngine(referrer),\n            param = (search != 'yahoo') ? 'q' : 'p',\n            ret = {};\n\n        if (search !== null) {\n            ret['$search_engine'] = search;\n\n            var keyword = _.getQueryParam(referrer, param);\n            if (keyword.length) {\n                ret['mp_keyword'] = keyword;\n            }\n        }\n\n        return ret;\n    },\n\n    /**\n     * This function detects which browser is running this script.\n     * The order of the checks are important since many user agents\n     * include key words used in later checks.\n     */\n    browser: function(user_agent, vendor, opera) {\n        vendor = vendor || ''; // vendor is undefined for at least IE9\n        if (opera || _.includes(user_agent, ' OPR/')) {\n            if (_.includes(user_agent, 'Mini')) {\n                return 'Opera Mini';\n            }\n            return 'Opera';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (_.includes(user_agent, 'IEMobile') || _.includes(user_agent, 'WPDesktop')) {\n            return 'Internet Explorer Mobile';\n        } else if (_.includes(user_agent, 'SamsungBrowser/')) {\n            // https://developer.samsung.com/internet/user-agent-string-format\n            return 'Samsung Internet';\n        } else if (_.includes(user_agent, 'Edge') || _.includes(user_agent, 'Edg/')) {\n            return 'Microsoft Edge';\n        } else if (_.includes(user_agent, 'FBIOS')) {\n            return 'Facebook Mobile';\n        } else if (_.includes(user_agent, 'Chrome')) {\n            return 'Chrome';\n        } else if (_.includes(user_agent, 'CriOS')) {\n            return 'Chrome iOS';\n        } else if (_.includes(user_agent, 'UCWEB') || _.includes(user_agent, 'UCBrowser')) {\n            return 'UC Browser';\n        } else if (_.includes(user_agent, 'FxiOS')) {\n            return 'Firefox iOS';\n        } else if (_.includes(vendor, 'Apple')) {\n            if (_.includes(user_agent, 'Mobile')) {\n                return 'Mobile Safari';\n            }\n            return 'Safari';\n        } else if (_.includes(user_agent, 'Android')) {\n            return 'Android Mobile';\n        } else if (_.includes(user_agent, 'Konqueror')) {\n            return 'Konqueror';\n        } else if (_.includes(user_agent, 'Firefox')) {\n            return 'Firefox';\n        } else if (_.includes(user_agent, 'MSIE') || _.includes(user_agent, 'Trident/')) {\n            return 'Internet Explorer';\n        } else if (_.includes(user_agent, 'Gecko')) {\n            return 'Mozilla';\n        } else {\n            return '';\n        }\n    },\n\n    /**\n     * This function detects which browser version is running this script,\n     * parsing major and minor version (e.g., 42.1). User agent strings from:\n     * http://www.useragentstring.com/pages/useragentstring.php\n     */\n    browserVersion: function(userAgent, vendor, opera) {\n        var browser = _.info.browser(userAgent, vendor, opera);\n        var versionRegexs = {\n            'Internet Explorer Mobile': /rv:(\\d+(\\.\\d+)?)/,\n            'Microsoft Edge': /Edge?\\/(\\d+(\\.\\d+)?)/,\n            'Chrome': /Chrome\\/(\\d+(\\.\\d+)?)/,\n            'Chrome iOS': /CriOS\\/(\\d+(\\.\\d+)?)/,\n            'UC Browser' : /(UCBrowser|UCWEB)\\/(\\d+(\\.\\d+)?)/,\n            'Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Mobile Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Opera': /(Opera|OPR)\\/(\\d+(\\.\\d+)?)/,\n            'Firefox': /Firefox\\/(\\d+(\\.\\d+)?)/,\n            'Firefox iOS': /FxiOS\\/(\\d+(\\.\\d+)?)/,\n            'Konqueror': /Konqueror:(\\d+(\\.\\d+)?)/,\n            'BlackBerry': /BlackBerry (\\d+(\\.\\d+)?)/,\n            'Android Mobile': /android\\s(\\d+(\\.\\d+)?)/,\n            'Samsung Internet': /SamsungBrowser\\/(\\d+(\\.\\d+)?)/,\n            'Internet Explorer': /(rv:|MSIE )(\\d+(\\.\\d+)?)/,\n            'Mozilla': /rv:(\\d+(\\.\\d+)?)/\n        };\n        var regex = versionRegexs[browser];\n        if (regex === undefined) {\n            return null;\n        }\n        var matches = userAgent.match(regex);\n        if (!matches) {\n            return null;\n        }\n        return parseFloat(matches[matches.length - 2]);\n    },\n\n    os: function() {\n        var a = userAgent;\n        if (/Windows/i.test(a)) {\n            if (/Phone/.test(a) || /WPDesktop/.test(a)) {\n                return 'Windows Phone';\n            }\n            return 'Windows';\n        } else if (/(iPhone|iPad|iPod)/.test(a)) {\n            return 'iOS';\n        } else if (/Android/.test(a)) {\n            return 'Android';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {\n            return 'BlackBerry';\n        } else if (/Mac/i.test(a)) {\n            return 'Mac OS X';\n        } else if (/Linux/.test(a)) {\n            return 'Linux';\n        } else if (/CrOS/.test(a)) {\n            return 'Chrome OS';\n        } else {\n            return '';\n        }\n    },\n\n    device: function(user_agent) {\n        if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {\n            return 'Windows Phone';\n        } else if (/iPad/.test(user_agent)) {\n            return 'iPad';\n        } else if (/iPod/.test(user_agent)) {\n            return 'iPod Touch';\n        } else if (/iPhone/.test(user_agent)) {\n            return 'iPhone';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (/Android/.test(user_agent)) {\n            return 'Android';\n        } else {\n            return '';\n        }\n    },\n\n    referringDomain: function(referrer) {\n        var split = referrer.split('/');\n        if (split.length >= 3) {\n            return split[2];\n        }\n        return '';\n    },\n\n    currentUrl: function() {\n        return win.location.href;\n    },\n\n    properties: function(extra_props) {\n        if (typeof extra_props !== 'object') {\n            extra_props = {};\n        }\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera),\n            '$referrer': document$1.referrer,\n            '$referring_domain': _.info.referringDomain(document$1.referrer),\n            '$device': _.info.device(userAgent)\n        }), {\n            '$current_url': _.info.currentUrl(),\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera),\n            '$screen_height': screen.height,\n            '$screen_width': screen.width,\n            'mp_lib': 'web',\n            '$lib_version': Config.LIB_VERSION,\n            '$insert_id': cheap_guid(),\n            'time': _.timestamp() / 1000 // epoch time in seconds\n        }, _.strip_empty_properties(extra_props));\n    },\n\n    people_properties: function() {\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera)\n        }), {\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera)\n        });\n    },\n\n    mpPageViewProperties: function() {\n        return _.strip_empty_properties({\n            'current_page_title': document$1.title,\n            'current_domain': win.location.hostname,\n            'current_url_path': win.location.pathname,\n            'current_url_protocol': win.location.protocol,\n            'current_url_search': win.location.search\n        });\n    }\n};\n\nvar cheap_guid = function(maxlen) {\n    var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n    return maxlen ? guid.substring(0, maxlen) : guid;\n};\n\n// naive way to extract domain name (example.com) from full hostname (my.sub.example.com)\nvar SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\\.[a-z]+$/i;\n// this next one attempts to account for some ccSLDs, e.g. extracting oxford.ac.uk from www.oxford.ac.uk\nvar DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\\.[a-z.]{2,6}$/i;\n/**\n * Attempts to extract main domain name from full hostname, using a few blunt heuristics. For\n * common TLDs like .com/.org that always have a simple SLD.TLD structure (example.com), we\n * simply extract the last two .-separated parts of the hostname (SIMPLE_DOMAIN_MATCH_REGEX).\n * For others, we attempt to account for short ccSLD+TLD combos (.ac.uk) with the legacy\n * DOMAIN_MATCH_REGEX (kept to maintain backwards compatibility with existing Mixpanel\n * integrations). The only _reliable_ way to extract domain from hostname is with an up-to-date\n * list like at https://publicsuffix.org/ so for cases that this helper fails at, the SDK\n * offers the 'cookie_domain' config option to set it explicitly.\n * @example\n * extract_domain('my.sub.example.com')\n * // 'example.com'\n */\nvar extract_domain = function(hostname) {\n    var domain_regex = DOMAIN_MATCH_REGEX;\n    var parts = hostname.split('.');\n    var tld = parts[parts.length - 1];\n    if (tld.length > 4 || tld === 'com' || tld === 'org') {\n        domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;\n    }\n    var matches = hostname.match(domain_regex);\n    return matches ? matches[0] : '';\n};\n\n/**\n * Check whether we have network connection. default to true for browsers that don't support navigator.onLine (IE)\n * @returns {boolean}\n */\nvar isOnline = function() {\n    var onLine = win.navigator['onLine'];\n    return _.isUndefined(onLine) || onLine;\n};\n\nvar JSONStringify = null, JSONParse = null;\nif (typeof JSON !== 'undefined') {\n    JSONStringify = JSON.stringify;\n    JSONParse = JSON.parse;\n}\nJSONStringify = JSONStringify || _.JSONEncode;\nJSONParse = JSONParse || _.JSONDecode;\n\n// EXPORTS (for closure compiler)\n_['toArray']                = _.toArray;\n_['isObject']               = _.isObject;\n_['JSONEncode']             = _.JSONEncode;\n_['JSONDecode']             = _.JSONDecode;\n_['isBlockedUA']            = _.isBlockedUA;\n_['isEmptyObject']          = _.isEmptyObject;\n_['info']                   = _.info;\n_['info']['device']         = _.info.device;\n_['info']['browser']        = _.info.browser;\n_['info']['browserVersion'] = _.info.browserVersion;\n_['info']['properties']     = _.info.properties;\n_['NPO']                    = NpoPromise;\n\n/**\n * GDPR utils\n *\n * The General Data Protection Regulation (GDPR) is a regulation in EU law on data protection\n * and privacy for all individuals within the European Union. It addresses the export of personal\n * data outside the EU. The GDPR aims primarily to give control back to citizens and residents\n * over their personal data and to simplify the regulatory environment for international business\n * by unifying the regulation within the EU.\n *\n * This set of utilities is intended to enable opt in/out functionality in the Mixpanel JS SDK.\n * These functions are used internally by the SDK and are not intended to be publicly exposed.\n */\n\n/**\n * A function used to track a Mixpanel event (e.g. MixpanelLib.track)\n * @callback trackFunction\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n */\n\n/** Public **/\n\nvar GDPR_DEFAULT_PERSISTENCE_PREFIX = '__mp_opt_in_out_';\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction optIn(token, options) {\n    _optInOut(true, token, options);\n}\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-out cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-out cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-out cookie is set as secure or not\n */\nfunction optOut(token, options) {\n    _optInOut(false, token, options);\n}\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} whether the user has opted in to the given opt type\n */\nfunction hasOptedIn(token, options) {\n    return _getStorageValue(token, options) === '1';\n}\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the user has opted out of the given opt type\n */\nfunction hasOptedOut(token, options) {\n    if (_hasDoNotTrackFlagOn(options)) {\n        console$1.warn('This browser has \"Do Not Track\" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the \"Do Not Track\" browser setting, initialize the Mixpanel instance with the config \"ignore_dnt: true\"');\n        return true;\n    }\n    var optedOut = _getStorageValue(token, options) === '0';\n    if (optedOut) {\n        console$1.warn('You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.');\n    }\n    return optedOut;\n}\n\n/**\n * Wrap a MixpanelLib method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelLib(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this.get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelPeople method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelPeople(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelGroup method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelGroup(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction clearOptInOut(token, options) {\n    options = options || {};\n    _getStorage(options).remove(\n        _getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain\n    );\n}\n\n/** Private **/\n\n/**\n * Get storage util\n * @param {Object} [options]\n * @param {string} [options.persistenceType]\n * @returns {object} either _.cookie or _.localstorage\n */\nfunction _getStorage(options) {\n    options = options || {};\n    return options.persistenceType === 'localStorage' ? _.localStorage : _.cookie;\n}\n\n/**\n * Get the name of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the name of the cookie for the given opt type\n */\nfunction _getStorageKey(token, options) {\n    options = options || {};\n    return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;\n}\n\n/**\n * Get the value of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the value of the cookie for the given opt type\n */\nfunction _getStorageValue(token, options) {\n    return _getStorage(options).get(_getStorageKey(token, options));\n}\n\n/**\n * Check whether the user has set the DNT/doNotTrack setting to true in their browser\n * @param {Object} [options]\n * @param {string} [options.window] - alternate window object to check; used to force various DNT settings in browser tests\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the DNT setting is true\n */\nfunction _hasDoNotTrackFlagOn(options) {\n    if (options && options.ignoreDnt) {\n        return false;\n    }\n    var win$1 = (options && options.window) || win;\n    var nav = win$1['navigator'] || {};\n    var hasDntOn = false;\n\n    _.each([\n        nav['doNotTrack'], // standard\n        nav['msDoNotTrack'],\n        win$1['doNotTrack']\n    ], function(dntValue) {\n        if (_.includes([true, 1, '1', 'yes'], dntValue)) {\n            hasDntOn = true;\n        }\n    });\n\n    return hasDntOn;\n}\n\n/**\n * Set cookie/localstorage for the user indicating that they are opted in or out for the given opt type\n * @param {boolean} optValue - whether to opt the user in or out for the given opt type\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction _optInOut(optValue, token, options) {\n    if (!_.isString(token) || !token.length) {\n        console$1.error('gdpr.' + (optValue ? 'optIn' : 'optOut') + ' called with an invalid token');\n        return;\n    }\n\n    options = options || {};\n\n    _getStorage(options).set(\n        _getStorageKey(token, options),\n        optValue ? 1 : 0,\n        _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null,\n        !!options.crossSubdomainCookie,\n        !!options.secureCookie,\n        !!options.crossSiteCookie,\n        options.cookieDomain\n    );\n\n    if (options.track && optValue) { // only track event if opting in (optValue=true)\n        options.track(options.trackEventName || '$opt_in', options.trackProperties, {\n            'send_immediately': true\n        });\n    }\n}\n\n/**\n * Wrap a method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @param {function} getConfigValue - getter function for the Mixpanel API token and other options to be used with opt-out check\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction _addOptOutCheck(method, getConfigValue) {\n    return function() {\n        var optedOut = false;\n\n        try {\n            var token = getConfigValue.call(this, 'token');\n            var ignoreDnt = getConfigValue.call(this, 'ignore_dnt');\n            var persistenceType = getConfigValue.call(this, 'opt_out_tracking_persistence_type');\n            var persistencePrefix = getConfigValue.call(this, 'opt_out_tracking_cookie_prefix');\n            var win = getConfigValue.call(this, 'window'); // used to override window during browser tests\n\n            if (token) { // if there was an issue getting the token, continue method execution as normal\n                optedOut = hasOptedOut(token, {\n                    ignoreDnt: ignoreDnt,\n                    persistenceType: persistenceType,\n                    persistencePrefix: persistencePrefix,\n                    window: win\n                });\n            }\n        } catch(err) {\n            console$1.error('Unexpected error when checking tracking opt-out status: ' + err);\n        }\n\n        if (!optedOut) {\n            return method.apply(this, arguments);\n        }\n\n        var callback = arguments[arguments.length - 1];\n        if (typeof(callback) === 'function') {\n            callback(0);\n        }\n\n        return;\n    };\n}\n\nvar logger$4 = console_with_prefix('lock');\n\n/**\n * SharedLock: a mutex built on HTML5 localStorage, to ensure that only one browser\n * window/tab at a time will be able to access shared resources.\n *\n * Based on the Alur and Taubenfeld fast lock\n * (http://www.cs.rochester.edu/research/synchronization/pseudocode/fastlock.html)\n * with an added timeout to ensure there will be eventual progress in the event\n * that a window is closed in the middle of the callback.\n *\n * Implementation based on the original version by David Wolever (https://github.com/wolever)\n * at https://gist.github.com/wolever/5fd7573d1ef6166e8f8c4af286a69432.\n *\n * @example\n * const myLock = new SharedLock('some-key');\n * myLock.withLock(function() {\n *   console.log('I hold the mutex!');\n * });\n *\n * @constructor\n */\nvar SharedLock = function(key, options) {\n    options = options || {};\n\n    this.storageKey = key;\n    this.storage = options.storage || window.localStorage;\n    this.pollIntervalMS = options.pollIntervalMS || 100;\n    this.timeoutMS = options.timeoutMS || 2000;\n\n    // dependency-inject promise implementation for testing purposes\n    this.promiseImpl = options.promiseImpl || PromisePolyfill;\n};\n\n// pass in a specific pid to test contention scenarios; otherwise\n// it is chosen randomly for each acquisition attempt\nSharedLock.prototype.withLock = function(lockedCB, pid) {\n    var Promise = this.promiseImpl;\n    return new Promise(_.bind(function (resolve, reject) {\n        var i = pid || (new Date().getTime() + '|' + Math.random());\n        var startTime = new Date().getTime();\n\n        var key = this.storageKey;\n        var pollIntervalMS = this.pollIntervalMS;\n        var timeoutMS = this.timeoutMS;\n        var storage = this.storage;\n\n        var keyX = key + ':X';\n        var keyY = key + ':Y';\n        var keyZ = key + ':Z';\n\n        var delay = function(cb) {\n            if (new Date().getTime() - startTime > timeoutMS) {\n                logger$4.error('Timeout waiting for mutex on ' + key + '; clearing lock. [' + i + ']');\n                storage.removeItem(keyZ);\n                storage.removeItem(keyY);\n                loop();\n                return;\n            }\n            setTimeout(function() {\n                try {\n                    cb();\n                } catch(err) {\n                    reject(err);\n                }\n            }, pollIntervalMS * (Math.random() + 0.1));\n        };\n\n        var waitFor = function(predicate, cb) {\n            if (predicate()) {\n                cb();\n            } else {\n                delay(function() {\n                    waitFor(predicate, cb);\n                });\n            }\n        };\n\n        var getSetY = function() {\n            var valY = storage.getItem(keyY);\n            if (valY && valY !== i) { // if Y == i then this process already has the lock (useful for test cases)\n                return false;\n            } else {\n                storage.setItem(keyY, i);\n                if (storage.getItem(keyY) === i) {\n                    return true;\n                } else {\n                    if (!localStorageSupported(storage, true)) {\n                        reject(new Error('localStorage support dropped while acquiring lock'));\n                    }\n                    return false;\n                }\n            }\n        };\n\n        var loop = function() {\n            storage.setItem(keyX, i);\n\n            waitFor(getSetY, function() {\n                if (storage.getItem(keyX) === i) {\n                    criticalSection();\n                    return;\n                }\n\n                delay(function() {\n                    if (storage.getItem(keyY) !== i) {\n                        loop();\n                        return;\n                    }\n                    waitFor(function() {\n                        return !storage.getItem(keyZ);\n                    }, criticalSection);\n                });\n            });\n        };\n\n        var criticalSection = function() {\n            storage.setItem(keyZ, '1');\n            var removeLock = function () {\n                storage.removeItem(keyZ);\n                if (storage.getItem(keyY) === i) {\n                    storage.removeItem(keyY);\n                }\n                if (storage.getItem(keyX) === i) {\n                    storage.removeItem(keyX);\n                }\n            };\n\n            lockedCB()\n                .then(function (ret) {\n                    removeLock();\n                    resolve(ret);\n                })\n                .catch(function (err) {\n                    removeLock();\n                    reject(err);\n                });\n        };\n\n        try {\n            if (localStorageSupported(storage, true)) {\n                loop();\n            } else {\n                throw new Error('localStorage support check failed');\n            }\n        } catch(err) {\n            reject(err);\n        }\n    }, this));\n};\n\n/**\n * @typedef {import('./wrapper').StorageWrapper}\n */\n\n/**\n * @type {StorageWrapper}\n */\nvar LocalStorageWrapper = function (storageOverride) {\n    this.storage = storageOverride || localStorage;\n};\n\nLocalStorageWrapper.prototype.init = function () {\n    return PromisePolyfill.resolve();\n};\n\nLocalStorageWrapper.prototype.setItem = function (key, value) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.setItem(key, value);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nLocalStorageWrapper.prototype.getItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        var item;\n        try {\n            item = this.storage.getItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve(item);\n    }, this));\n};\n\nLocalStorageWrapper.prototype.removeItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nvar logger$3 = console_with_prefix('batch');\n\n/**\n * RequestQueue: queue for batching API requests with localStorage backup for retries.\n * Maintains an in-memory queue which represents the source of truth for the current\n * page, but also writes all items out to a copy in the browser's localStorage, which\n * can be read on subsequent pageloads and retried. For batchability, all the request\n * items in the queue should be of the same type (events, people updates, group updates)\n * so they can be sent in a single request to the same API endpoint.\n *\n * LocalStorage keying and locking: In order for reloads and subsequent pageloads of\n * the same site to access the same persisted data, they must share the same localStorage\n * key (for instance based on project token and queue type). Therefore access to the\n * localStorage entry is guarded by an asynchronous mutex (SharedLock) to prevent\n * simultaneously open windows/tabs from overwriting each other's data (which would lead\n * to data loss in some situations).\n * @constructor\n */\nvar RequestQueue = function (storageKey, options) {\n    options = options || {};\n    this.storageKey = storageKey;\n    this.usePersistence = options.usePersistence;\n    if (this.usePersistence) {\n        this.queueStorage = options.queueStorage || new LocalStorageWrapper();\n        this.lock = new SharedLock(storageKey, { storage: options.sharedLockStorage || window.localStorage });\n        this.queueStorage.init();\n    }\n    this.reportError = options.errorReporter || _.bind(logger$3.error, logger$3);\n\n    this.pid = options.pid || null; // pass pid to test out storage lock contention scenarios\n\n    this.memQueue = [];\n    this.initialized = false;\n};\n\nRequestQueue.prototype.ensureInit = function () {\n    if (this.initialized) {\n        return PromisePolyfill.resolve();\n    }\n\n    return this.queueStorage\n        .init()\n        .then(_.bind(function () {\n            this.initialized = true;\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error initializing queue persistence. Disabling persistence', err);\n            this.initialized = true;\n            this.usePersistence = false;\n        }, this));\n};\n\n/**\n * Add one item to queues (memory and localStorage). The queued entry includes\n * the given item along with an auto-generated ID and a \"flush-after\" timestamp.\n * It is expected that the item will be sent over the network and dequeued\n * before the flush-after time; if this doesn't happen it is considered orphaned\n * (e.g., the original tab where it was enqueued got closed before it could be\n * sent) and the item can be sent by any tab that finds it in localStorage.\n *\n * The final callback param is called with a param indicating success or\n * failure of the enqueue operation; it is asynchronous because the localStorage\n * lock is asynchronous.\n */\nRequestQueue.prototype.enqueue = function (item, flushInterval) {\n    var queueEntry = {\n        'id': cheap_guid(),\n        'flushAfter': new Date().getTime() + flushInterval * 2,\n        'payload': item\n    };\n\n    if (!this.usePersistence) {\n        this.memQueue.push(queueEntry);\n        return PromisePolyfill.resolve(true);\n    } else {\n\n        var enqueueItem = _.bind(function () {\n            return this.ensureInit()\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    storedQueue.push(queueEntry);\n                    return this.saveToStorage(storedQueue);\n                }, this))\n                .then(_.bind(function (succeeded) {\n                    // only add to in-memory queue when storage succeeds\n                    if (succeeded) {\n                        this.memQueue.push(queueEntry);\n                    }\n                    return succeeded;\n                }, this))\n                .catch(_.bind(function (err) {\n                    this.reportError('Error enqueueing item', err, item);\n                    return false;\n                }, this));\n        }, this);\n\n        return this.lock\n            .withLock(enqueueItem, this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                return false;\n            }, this));\n    }\n};\n\n/**\n * Read out the given number of queue entries. If this.memQueue\n * has fewer than batchSize items, then look for \"orphaned\" items\n * in the persisted queue (items where the 'flushAfter' time has\n * already passed).\n */\nRequestQueue.prototype.fillBatch = function (batchSize) {\n    var batch = this.memQueue.slice(0, batchSize);\n    if (this.usePersistence && batch.length < batchSize) {\n        // don't need lock just to read events; localStorage is thread-safe\n        // and the worst that could happen is a duplicate send of some\n        // orphaned events, which will be deduplicated on the server side\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                if (storedQueue.length) {\n                // item IDs already in batch; don't duplicate out of storage\n                    var idsInBatch = {}; // poor man's Set\n                    _.each(batch, function (item) {\n                        idsInBatch[item['id']] = true;\n                    });\n\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (new Date().getTime() > item['flushAfter'] && !idsInBatch[item['id']]) {\n                            item.orphaned = true;\n                            batch.push(item);\n                            if (batch.length >= batchSize) {\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                return batch;\n            }, this));\n    } else {\n        return PromisePolyfill.resolve(batch);\n    }\n};\n\n/**\n * Remove items with matching 'id' from array (immutably)\n * also remove any item without a valid id (e.g., malformed\n * storage entries).\n */\nvar filterOutIDsAndInvalid = function (items, idSet) {\n    var filteredItems = [];\n    _.each(items, function (item) {\n        if (item['id'] && !idSet[item['id']]) {\n            filteredItems.push(item);\n        }\n    });\n    return filteredItems;\n};\n\n/**\n * Remove items with matching IDs from both in-memory queue\n * and persisted queue\n */\nRequestQueue.prototype.removeItemsByID = function (ids) {\n    var idSet = {}; // poor man's Set\n    _.each(ids, function (id) {\n        idSet[id] = true;\n    });\n\n    this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        var removeFromStorage = _.bind(function () {\n            return this.ensureInit()\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);\n                    return this.saveToStorage(storedQueue);\n                }, this))\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    // an extra check: did storage report success but somehow\n                    // the items are still there?\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (item['id'] && !!idSet[item['id']]) {\n                            throw new Error('Item not removed from storage');\n                        }\n                    }\n                    return true;\n                }, this))\n                .catch(_.bind(function (err) {\n                    this.reportError('Error removing items', err, ids);\n                    return false;\n                }, this));\n        }, this);\n\n        return this.lock\n            .withLock(removeFromStorage, this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                if (!localStorageSupported(this.queueStorage.storage, true)) {\n                    // Looks like localStorage writes have stopped working sometime after\n                    // initialization (probably full), and so nobody can acquire locks\n                    // anymore. Consider it temporarily safe to remove items without the\n                    // lock, since nobody's writing successfully anyway.\n                    return removeFromStorage()\n                        .then(_.bind(function (success) {\n                            if (!success) {\n                                // OK, we couldn't even write out the smaller queue. Try clearing it\n                                // entirely.\n                                return this.queueStorage.removeItem(this.storageKey).then(function () {\n                                    return success;\n                                });\n                            }\n                            return success;\n                        }, this))\n                        .catch(_.bind(function (err) {\n                            this.reportError('Error clearing queue', err);\n                            return false;\n                        }, this));\n                } else {\n                    return false;\n                }\n            }, this));\n    }\n};\n\n// internal helper for RequestQueue.updatePayloads\nvar updatePayloads = function (existingItems, itemsToUpdate) {\n    var newItems = [];\n    _.each(existingItems, function (item) {\n        var id = item['id'];\n        if (id in itemsToUpdate) {\n            var newPayload = itemsToUpdate[id];\n            if (newPayload !== null) {\n                item['payload'] = newPayload;\n                newItems.push(item);\n            }\n        } else {\n            // no update\n            newItems.push(item);\n        }\n    });\n    return newItems;\n};\n\n/**\n * Update payloads of given items in both in-memory queue and\n * persisted queue. Items set to null are removed from queues.\n */\nRequestQueue.prototype.updatePayloads = function (itemsToUpdate) {\n    this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.lock\n            .withLock(_.bind(function lockAcquired() {\n                return this.ensureInit()\n                    .then(_.bind(function () {\n                        return this.readFromStorage();\n                    }, this))\n                    .then(_.bind(function (storedQueue) {\n                        storedQueue = updatePayloads(storedQueue, itemsToUpdate);\n                        return this.saveToStorage(storedQueue);\n                    }, this))\n                    .catch(_.bind(function (err) {\n                        this.reportError('Error updating items', itemsToUpdate, err);\n                        return false;\n                    }, this));\n            }, this), this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                return false;\n            }, this));\n    }\n};\n\n/**\n * Read and parse items array from localStorage entry, handling\n * malformed/missing data if necessary.\n */\nRequestQueue.prototype.readFromStorage = function () {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.getItem(this.storageKey);\n        }, this))\n        .then(_.bind(function (storageEntry) {\n            if (storageEntry) {\n                storageEntry = JSONParse(storageEntry);\n                if (!_.isArray(storageEntry)) {\n                    this.reportError('Invalid storage entry:', storageEntry);\n                    storageEntry = null;\n                }\n            }\n            return storageEntry || [];\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error retrieving queue', err);\n            return [];\n        }, this));\n};\n\n/**\n * Serialize the given items array to localStorage.\n */\nRequestQueue.prototype.saveToStorage = function (queue) {\n    try {\n        var serialized = JSONStringify(queue);\n    } catch (err) {\n        this.reportError('Error serializing queue', err);\n        return PromisePolyfill.resolve(false);\n    }\n\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.setItem(this.storageKey, serialized);\n        }, this))\n        .then(function () {\n            return true;\n        })\n        .catch(_.bind(function (err) {\n            this.reportError('Error saving queue', err);\n            return false;\n        }, this));\n};\n\n/**\n * Clear out queues (memory and localStorage).\n */\nRequestQueue.prototype.clear = function () {\n    this.memQueue = [];\n\n    if (this.usePersistence) {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.queueStorage.removeItem(this.storageKey);\n            }, this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n\n// maximum interval between request retries after exponential backoff\nvar MAX_RETRY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\n\nvar logger$2 = console_with_prefix('batch');\n\n/**\n * RequestBatcher: manages the queueing, flushing, retry etc of requests of one\n * type (events, people, groups).\n * Uses RequestQueue to manage the backing store.\n * @constructor\n */\nvar RequestBatcher = function(storageKey, options) {\n    this.errorReporter = options.errorReporter;\n    this.queue = new RequestQueue(storageKey, {\n        errorReporter: _.bind(this.reportError, this),\n        queueStorage: options.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        usePersistence: options.usePersistence\n    });\n\n    this.libConfig = options.libConfig;\n    this.sendRequest = options.sendRequestFunc;\n    this.beforeSendHook = options.beforeSendHook;\n    this.stopAllBatching = options.stopAllBatchingFunc;\n\n    // seed variable batch size + flush interval with configured values\n    this.batchSize = this.libConfig['batch_size'];\n    this.flushInterval = this.libConfig['batch_flush_interval_ms'];\n\n    this.stopped = !this.libConfig['batch_autostart'];\n    this.consecutiveRemovalFailures = 0;\n\n    // extra client-side dedupe\n    this.itemIdsSentSuccessfully = {};\n\n    // Make the flush occur at the interval specified by flushIntervalMs, default behavior will attempt consecutive flushes\n    // as long as the queue is not empty. This is useful for high-frequency events like Session Replay where we might end up\n    // in a request loop and get ratelimited by the server.\n    this.flushOnlyOnInterval = options.flushOnlyOnInterval || false;\n};\n\n/**\n * Add one item to queue.\n */\nRequestBatcher.prototype.enqueue = function(item) {\n    return this.queue.enqueue(item, this.flushInterval);\n};\n\n/**\n * Start flushing batches at the configured time interval. Must call\n * this method upon SDK init in order to send anything over the network.\n */\nRequestBatcher.prototype.start = function() {\n    this.stopped = false;\n    this.consecutiveRemovalFailures = 0;\n    return this.flush();\n};\n\n/**\n * Stop flushing batches. Can be restarted by calling start().\n */\nRequestBatcher.prototype.stop = function() {\n    this.stopped = true;\n    if (this.timeoutID) {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n    }\n};\n\n/**\n * Clear out queue.\n */\nRequestBatcher.prototype.clear = function() {\n    return this.queue.clear();\n};\n\n/**\n * Restore batch size configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetBatchSize = function() {\n    this.batchSize = this.libConfig['batch_size'];\n};\n\n/**\n * Restore flush interval time configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetFlush = function() {\n    this.scheduleFlush(this.libConfig['batch_flush_interval_ms']);\n};\n\n/**\n * Schedule the next flush in the given number of milliseconds.\n */\nRequestBatcher.prototype.scheduleFlush = function(flushMS) {\n    this.flushInterval = flushMS;\n    if (!this.stopped) { // don't schedule anymore if batching has been stopped\n        this.timeoutID = setTimeout(_.bind(function() {\n            if (!this.stopped) {\n                this.flush();\n            }\n        }, this), this.flushInterval);\n    }\n};\n\n/**\n * Send a request using the sendRequest callback, but promisified.\n * TODO: sendRequest should be promisified in the first place.\n */\nRequestBatcher.prototype.sendRequestPromise = function(data, options) {\n    return new PromisePolyfill(_.bind(function(resolve) {\n        this.sendRequest(data, options, resolve);\n    }, this));\n};\n\n\n/**\n * Flush one batch to network. Depending on success/failure modes, it will either\n * remove the batch from the queue or leave it in for retry, and schedule the next\n * flush. In cases of most network or API failures, it will back off exponentially\n * when retrying.\n * @param {Object} [options]\n * @param {boolean} [options.sendBeacon] - whether to send batch with\n * navigator.sendBeacon (only useful for sending batches before page unloads, as\n * sendBeacon offers no callbacks or status indications)\n */\nRequestBatcher.prototype.flush = function(options) {\n    if (this.requestInProgress) {\n        logger$2.log('Flush: Request already in progress');\n        return PromisePolyfill.resolve();\n    }\n\n    this.requestInProgress = true;\n\n    options = options || {};\n    var timeoutMS = this.libConfig['batch_request_timeout_ms'];\n    var startTime = new Date().getTime();\n    var currentBatchSize = this.batchSize;\n\n    return this.queue.fillBatch(currentBatchSize)\n        .then(_.bind(function(batch) {\n\n            // if there's more items in the queue than the batch size, attempt\n            // to flush again after the current batch is done.\n            var attemptSecondaryFlush = batch.length === currentBatchSize;\n            var dataForRequest = [];\n            var transformedItems = {};\n            _.each(batch, function(item) {\n                var payload = item['payload'];\n                if (this.beforeSendHook && !item.orphaned) {\n                    payload = this.beforeSendHook(payload);\n                }\n                if (payload) {\n                    // mp_sent_by_lib_version prop captures which lib version actually\n                    // sends each event (regardless of which version originally queued\n                    // it for sending)\n                    if (payload['event'] && payload['properties']) {\n                        payload['properties'] = _.extend(\n                            {},\n                            payload['properties'],\n                            {'mp_sent_by_lib_version': Config.LIB_VERSION}\n                        );\n                    }\n                    var addPayload = true;\n                    var itemId = item['id'];\n                    if (itemId) {\n                        if ((this.itemIdsSentSuccessfully[itemId] || 0) > 5) {\n                            this.reportError('[dupe] item ID sent too many times, not sending', {\n                                item: item,\n                                batchSize: batch.length,\n                                timesSent: this.itemIdsSentSuccessfully[itemId]\n                            });\n                            addPayload = false;\n                        }\n                    } else {\n                        this.reportError('[dupe] found item with no ID', {item: item});\n                    }\n\n                    if (addPayload) {\n                        dataForRequest.push(payload);\n                    }\n                }\n                transformedItems[item['id']] = payload;\n            }, this);\n\n            if (dataForRequest.length < 1) {\n                this.requestInProgress = false;\n                this.resetFlush();\n                return PromisePolyfill.resolve(); // nothing to do\n            }\n\n            var removeItemsFromQueue = _.bind(function () {\n                return this.queue\n                    .removeItemsByID(\n                        _.map(batch, function (item) {\n                            return item['id'];\n                        })\n                    )\n                    .then(_.bind(function (succeeded) {\n                        // client-side dedupe\n                        _.each(batch, _.bind(function(item) {\n                            var itemId = item['id'];\n                            if (itemId) {\n                                this.itemIdsSentSuccessfully[itemId] = this.itemIdsSentSuccessfully[itemId] || 0;\n                                this.itemIdsSentSuccessfully[itemId]++;\n                                if (this.itemIdsSentSuccessfully[itemId] > 5) {\n                                    this.reportError('[dupe] item ID sent too many times', {\n                                        item: item,\n                                        batchSize: batch.length,\n                                        timesSent: this.itemIdsSentSuccessfully[itemId]\n                                    });\n                                }\n                            } else {\n                                this.reportError('[dupe] found item with no ID while removing', {item: item});\n                            }\n                        }, this));\n\n                        if (succeeded) {\n                            this.consecutiveRemovalFailures = 0;\n                            if (this.flushOnlyOnInterval && !attemptSecondaryFlush) {\n                                this.resetFlush(); // schedule next batch with a delay\n                                return PromisePolyfill.resolve();\n                            } else {\n                                return this.flush(); // handle next batch if the queue isn't empty\n                            }\n                        } else {\n                            if (++this.consecutiveRemovalFailures > 5) {\n                                this.reportError('Too many queue failures; disabling batching system.');\n                                this.stopAllBatching();\n                            } else {\n                                this.resetFlush();\n                            }\n                            return PromisePolyfill.resolve();\n                        }\n                    }, this));\n            }, this);\n\n            var batchSendCallback = _.bind(function(res) {\n                this.requestInProgress = false;\n\n                try {\n\n                    // handle API response in a try-catch to make sure we can reset the\n                    // flush operation if something goes wrong\n\n                    if (options.unloading) {\n                        // update persisted data to include hook transformations\n                        return this.queue.updatePayloads(transformedItems);\n                    } else if (\n                        _.isObject(res) &&\n                            res.error === 'timeout' &&\n                            new Date().getTime() - startTime >= timeoutMS\n                    ) {\n                        this.reportError('Network timeout; retrying');\n                        return this.flush();\n                    } else if (\n                        _.isObject(res) &&\n                            (\n                                res.httpStatusCode >= 500\n                                || res.httpStatusCode === 429\n                                || (res.httpStatusCode <= 0 && !isOnline())\n                                || res.error === 'timeout'\n                            )\n                    ) {\n                        // network or API error, or 429 Too Many Requests, retry\n                        var retryMS = this.flushInterval * 2;\n                        if (res.retryAfter) {\n                            retryMS = (parseInt(res.retryAfter, 10) * 1000) || retryMS;\n                        }\n                        retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);\n                        this.reportError('Error; retry in ' + retryMS + ' ms');\n                        this.scheduleFlush(retryMS);\n                        return PromisePolyfill.resolve();\n                    } else if (_.isObject(res) && res.httpStatusCode === 413) {\n                        // 413 Payload Too Large\n                        if (batch.length > 1) {\n                            var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));\n                            this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);\n                            this.reportError('413 response; reducing batch size to ' + this.batchSize);\n                            this.resetFlush();\n                            return PromisePolyfill.resolve();\n                        } else {\n                            this.reportError('Single-event request too large; dropping', batch);\n                            this.resetBatchSize();\n                            return removeItemsFromQueue();\n                        }\n                    } else {\n                        // successful network request+response; remove each item in batch from queue\n                        // (even if it was e.g. a 400, in which case retrying won't help)\n                        return removeItemsFromQueue();\n                    }\n                } catch(err) {\n                    this.reportError('Error handling API response', err);\n                    this.resetFlush();\n                }\n            }, this);\n            var requestOptions = {\n                method: 'POST',\n                verbose: true,\n                ignore_json_errors: true, // eslint-disable-line camelcase\n                timeout_ms: timeoutMS // eslint-disable-line camelcase\n            };\n            if (options.unloading) {\n                requestOptions.transport = 'sendBeacon';\n            }\n            logger$2.log('MIXPANEL REQUEST:', dataForRequest);\n            return this.sendRequestPromise(dataForRequest, requestOptions).then(batchSendCallback);\n        }, this))\n        .catch(_.bind(function(err) {\n            this.reportError('Error flushing request queue', err);\n            this.resetFlush();\n        }, this));\n};\n\n/**\n * Log error to global logger and optional user-defined logger.\n */\nRequestBatcher.prototype.reportError = function(msg, err) {\n    logger$2.error.apply(logger$2.error, arguments);\n    if (this.errorReporter) {\n        try {\n            if (!(err instanceof Error)) {\n                err = new Error(msg);\n            }\n            this.errorReporter(msg, err);\n        } catch(err) {\n            logger$2.error(err);\n        }\n    }\n};\n\nvar logger$1 = console_with_prefix('recorder');\nvar CompressionStream = win['CompressionStream'];\n\nvar RECORDER_BATCHER_LIB_CONFIG = {\n    'batch_size': 1000,\n    'batch_flush_interval_ms': 10 * 1000,\n    'batch_request_timeout_ms': 90 * 1000,\n    'batch_autostart': true\n};\n\nvar ACTIVE_SOURCES = new Set([\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n    IncrementalSource.Selection,\n]);\n\nfunction isUserEvent(ev) {\n    return ev.type === EventType.IncrementalSnapshot && ACTIVE_SOURCES.has(ev.data.source);\n}\n\n/**\n * This class encapsulates a single session recording and its lifecycle.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n * @param {String} [options.replayId] - unique uuid for a single replay\n * @param {Function} [options.onIdleTimeout] - callback when a recording reaches idle timeout\n * @param {Function} [options.onMaxLengthReached] - callback when a recording reaches its maximum length\n * @param {Function} [options.rrwebRecord] - rrweb's `record` function\n */\nvar SessionRecording = function(options) {\n    this._mixpanel = options.mixpanelInstance;\n    this._onIdleTimeout = options.onIdleTimeout;\n    this._onMaxLengthReached = options.onMaxLengthReached;\n    this._rrwebRecord = options.rrwebRecord;\n\n    this.replayId = options.replayId;\n\n    // internal rrweb stopRecording function\n    this._stopRecording = null;\n\n    this.seqNo = 0;\n    this.replayStartTime = null;\n    this.replayStartUrl = null;\n    this.batchStartUrl = null;\n\n    this.idleTimeoutId = null;\n    this.maxTimeoutId = null;\n\n    this.recordMaxMs = MAX_RECORDING_MS;\n    this.recordMinMs = 0;\n\n    // each replay has its own batcher key to avoid conflicts between rrweb events of different recordings\n    // this will be important when persistence is introduced\n    var batcherKey = '__mprec_' + this.getConfig('token') + '_' + this.replayId;\n    this.batcher = new RequestBatcher(batcherKey, {\n        errorReporter: _.bind(this.reportError, this),\n        flushOnlyOnInterval: true,\n        libConfig: RECORDER_BATCHER_LIB_CONFIG,\n        sendRequestFunc: _.bind(this.flushEventsWithOptOut, this),\n        usePersistence: false\n    });\n};\n\nSessionRecording.prototype.getConfig = function(configVar) {\n    return this._mixpanel.get_config(configVar);\n};\n\n// Alias for getConfig, used by the common addOptOutCheckMixpanelLib function which\n// reaches into this class instance and expects the snake case version of the function.\n// eslint-disable-next-line camelcase\nSessionRecording.prototype.get_config = function(configVar) {\n    return this.getConfig(configVar);\n};\n\nSessionRecording.prototype.startRecording = function (shouldStopBatcher) {\n    if (this._stopRecording !== null) {\n        logger$1.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    this.recordMaxMs = this.getConfig('record_max_ms');\n    if (this.recordMaxMs > MAX_RECORDING_MS) {\n        this.recordMaxMs = MAX_RECORDING_MS;\n        logger$1.critical('record_max_ms cannot be greater than ' + MAX_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    this.recordMinMs = this.getConfig('record_min_ms');\n    if (this.recordMinMs > MAX_VALUE_FOR_MIN_RECORDING_MS) {\n        this.recordMinMs = MAX_VALUE_FOR_MIN_RECORDING_MS;\n        logger$1.critical('record_min_ms cannot be greater than ' + MAX_VALUE_FOR_MIN_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    this.replayStartTime = new Date().getTime();\n    this.batchStartUrl = _.info.currentUrl();\n    this.replayStartUrl = _.info.currentUrl();\n\n    if (shouldStopBatcher || this.recordMinMs > 0) {\n        // the primary case for shouldStopBatcher is when we're starting recording after a reset\n        // and don't want to send anything over the network until there's\n        // actual user activity\n        // this also applies if the minimum recording length has not been hit yet\n        // so that we don't send data until we know the recording will be long enough\n        this.batcher.stop();\n    } else {\n        this.batcher.start();\n    }\n\n    var resetIdleTimeout = _.bind(function () {\n        clearTimeout(this.idleTimeoutId);\n        this.idleTimeoutId = setTimeout(this._onIdleTimeout, this.getConfig('record_idle_timeout_ms'));\n    }, this);\n\n    var blockSelector = this.getConfig('record_block_selector');\n    if (blockSelector === '' || blockSelector === null) {\n        blockSelector = undefined;\n    }\n\n    this._stopRecording = this._rrwebRecord({\n        'emit': _.bind(function (ev) {\n            this.batcher.enqueue(ev);\n            if (isUserEvent(ev)) {\n                if (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs) {\n                    // start flushing again after user activity\n                    this.batcher.start();\n                }\n                resetIdleTimeout();\n            }\n        }, this),\n        'blockClass': this.getConfig('record_block_class'),\n        'blockSelector': blockSelector,\n        'collectFonts': this.getConfig('record_collect_fonts'),\n        'dataURLOptions': { // canvas image options (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL)\n            'type': 'image/webp',\n            'quality': 0.6\n        },\n        'maskAllInputs': true,\n        'maskTextClass': this.getConfig('record_mask_text_class'),\n        'maskTextSelector': this.getConfig('record_mask_text_selector'),\n        'recordCanvas': this.getConfig('record_canvas'),\n        'sampling': {\n            'canvas': 15\n        }\n    });\n\n    if (typeof this._stopRecording !== 'function') {\n        this.reportError('rrweb failed to start, skipping this recording.');\n        this._stopRecording = null;\n        this.stopRecording(); // stop batcher looping and any timeouts\n        return;\n    }\n\n    resetIdleTimeout();\n\n    this.maxTimeoutId = setTimeout(_.bind(this._onMaxLengthReached, this), this.recordMaxMs);\n};\n\nSessionRecording.prototype.stopRecording = function () {\n    if (!this.isRrwebStopped()) {\n        try {\n            this._stopRecording();\n        } catch (err) {\n            this.reportError('Error with rrweb stopRecording', err);\n        }\n        this._stopRecording = null;\n    }\n\n    if (this.batcher.stopped) {\n        // never got user activity to flush after reset, so just clear the batcher\n        this.batcher.clear();\n    } else {\n        // flush any remaining events from running batcher\n        this.batcher.flush();\n        this.batcher.stop();\n    }\n\n    clearTimeout(this.idleTimeoutId);\n    clearTimeout(this.maxTimeoutId);\n};\n\nSessionRecording.prototype.isRrwebStopped = function () {\n    return this._stopRecording === null;\n};\n\n/**\n * Flushes the current batch of events to the server, but passes an opt-out callback to make sure\n * we stop recording and dump any queued events if the user has opted out.\n */\nSessionRecording.prototype.flushEventsWithOptOut = function (data, options, cb) {\n    this._flushEvents(data, options, cb, _.bind(this._onOptOut, this));\n};\n\nSessionRecording.prototype._onOptOut = function (code) {\n    // addOptOutCheckMixpanelLib invokes this function with code=0 when the user has opted out\n    if (code === 0) {\n        this.stopRecording();\n    }\n};\n\nSessionRecording.prototype._sendRequest = function(currentReplayId, reqParams, reqBody, callback) {\n    var onSuccess = _.bind(function (response, responseBody) {\n        // Update batch specific props only if the request was successful to guarantee ordering.\n        // RequestBatcher will always flush the next batch after the previous one succeeds.\n        // extra check to see if the replay ID has changed so that we don't increment the seqNo on the wrong replay\n        if (response.status === 200 && this.replayId === currentReplayId) {\n            this.seqNo++;\n            this.batchStartUrl = _.info.currentUrl();\n        }\n        callback({\n            status: 0,\n            httpStatusCode: response.status,\n            responseBody: responseBody,\n            retryAfter: response.headers.get('Retry-After')\n        });\n    }, this);\n\n    win['fetch'](this.getConfig('api_host') + '/' + this.getConfig('api_routes')['record'] + '?' + new URLSearchParams(reqParams), {\n        'method': 'POST',\n        'headers': {\n            'Authorization': 'Basic ' + btoa(this.getConfig('token') + ':'),\n            'Content-Type': 'application/octet-stream'\n        },\n        'body': reqBody,\n    }).then(function (response) {\n        response.json().then(function (responseBody) {\n            onSuccess(response, responseBody);\n        }).catch(function (error) {\n            callback({error: error});\n        });\n    }).catch(function (error) {\n        callback({error: error, httpStatusCode: 0});\n    });\n};\n\nSessionRecording.prototype._flushEvents = addOptOutCheckMixpanelLib(function (data, options, callback) {\n    const numEvents = data.length;\n\n    if (numEvents > 0) {\n        var replayId = this.replayId;\n        // each rrweb event has a timestamp - leverage those to get time properties\n        var batchStartTime = data[0].timestamp;\n        if (this.seqNo === 0 || !this.replayStartTime) {\n            // extra safety net so that we don't send a null replay start time\n            if (this.seqNo !== 0) {\n                this.reportError('Replay start time not set but seqNo is not 0. Using current batch start time as a fallback.');\n            }\n\n            this.replayStartTime = batchStartTime;\n        }\n        var replayLengthMs = data[numEvents - 1].timestamp - this.replayStartTime;\n\n        var reqParams = {\n            '$current_url': this.batchStartUrl,\n            '$lib_version': Config.LIB_VERSION,\n            'batch_start_time': batchStartTime / 1000,\n            'distinct_id': String(this._mixpanel.get_distinct_id()),\n            'mp_lib': 'web',\n            'replay_id': replayId,\n            'replay_length_ms': replayLengthMs,\n            'replay_start_time': this.replayStartTime / 1000,\n            'replay_start_url': this.replayStartUrl,\n            'seq': this.seqNo\n        };\n        var eventsJson = _.JSONEncode(data);\n\n        // send ID management props if they exist\n        var deviceId = this._mixpanel.get_property('$device_id');\n        if (deviceId) {\n            reqParams['$device_id'] = deviceId;\n        }\n        var userId = this._mixpanel.get_property('$user_id');\n        if (userId) {\n            reqParams['$user_id'] = userId;\n        }\n\n        if (CompressionStream) {\n            var jsonStream = new Blob([eventsJson], {type: 'application/json'}).stream();\n            var gzipStream = jsonStream.pipeThrough(new CompressionStream('gzip'));\n            new Response(gzipStream)\n                .blob()\n                .then(_.bind(function(compressedBlob) {\n                    reqParams['format'] = 'gzip';\n                    this._sendRequest(replayId, reqParams, compressedBlob, callback);\n                }, this));\n        } else {\n            reqParams['format'] = 'body';\n            this._sendRequest(replayId, reqParams, eventsJson, callback);\n        }\n    }\n});\n\n\nSessionRecording.prototype.reportError = function(msg, err) {\n    logger$1.error.apply(logger$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.getConfig('error_reporter')(msg, err);\n    } catch(err) {\n        logger$1.error(err);\n    }\n};\n\nvar logger = console_with_prefix('recorder');\n\n/**\n * Recorder API: manages recordings and exposes methods public to the core Mixpanel library.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n */\nvar MixpanelRecorder = function(mixpanelInstance) {\n    this._mixpanel = mixpanelInstance;\n    this.activeRecording = null;\n};\n\nMixpanelRecorder.prototype.startRecording = function(shouldStopBatcher) {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        logger.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    var onIdleTimeout = _.bind(function () {\n        logger.log('Idle timeout reached, restarting recording.');\n        this.resetRecording();\n    }, this);\n\n    var onMaxLengthReached = _.bind(function () {\n        logger.log('Max recording length reached, stopping recording.');\n        this.resetRecording();\n    }, this);\n\n    this.activeRecording = new SessionRecording({\n        mixpanelInstance: this._mixpanel,\n        onIdleTimeout: onIdleTimeout,\n        onMaxLengthReached: onMaxLengthReached,\n        replayId: _.UUID(),\n        rrwebRecord: record\n    });\n\n    this.activeRecording.startRecording(shouldStopBatcher);\n};\n\nMixpanelRecorder.prototype.stopRecording = function() {\n    if (this.activeRecording) {\n        this.activeRecording.stopRecording();\n        this.activeRecording = null;\n    }\n};\n\nMixpanelRecorder.prototype.resetRecording = function () {\n    this.stopRecording();\n    this.startRecording(true);\n};\n\nMixpanelRecorder.prototype.getActiveReplayId = function () {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        return this.activeRecording.replayId;\n    } else {\n        return null;\n    }\n};\n\n// getter so that older mixpanel-core versions can still retrieve the replay ID\n// when pulling the latest recorder bundle from the CDN\nObject.defineProperty(MixpanelRecorder.prototype, 'replayId', {\n    get: function () {\n        return this.getActiveReplayId();\n    }\n});\n\nwin['__mp_recorder'] = MixpanelRecorder;\n\n/* eslint camelcase: \"off\" */\n\n/**\n * DomTracker Object\n * @constructor\n */\nvar DomTracker = function() {};\n\n\n// interface\nDomTracker.prototype.create_properties = function() {};\nDomTracker.prototype.event_handler = function() {};\nDomTracker.prototype.after_track_handler = function() {};\n\nDomTracker.prototype.init = function(mixpanel_instance) {\n    this.mp = mixpanel_instance;\n    return this;\n};\n\n/**\n * @param {Object|string} query\n * @param {string} event_name\n * @param {Object=} properties\n * @param {function=} user_callback\n */\nDomTracker.prototype.track = function(query, event_name, properties, user_callback) {\n    var that = this;\n    var elements = _.dom_query(query);\n\n    if (elements.length === 0) {\n        console$1.error('The DOM query (' + query + ') returned 0 elements');\n        return;\n    }\n\n    _.each(elements, function(element) {\n        _.register_event(element, this.override_event, function(e) {\n            var options = {};\n            var props = that.create_properties(properties, this);\n            var timeout = that.mp.get_config('track_links_timeout');\n\n            that.event_handler(e, this, options);\n\n            // in case the mixpanel servers don't get back to us in time\n            window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);\n\n            // fire the tracking event\n            that.mp.track(event_name, props, that.track_callback(user_callback, props, options));\n        });\n    }, this);\n\n    return true;\n};\n\n/**\n * @param {function} user_callback\n * @param {Object} props\n * @param {boolean=} timeout_occured\n */\nDomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {\n    timeout_occured = timeout_occured || false;\n    var that = this;\n\n    return function() {\n        // options is referenced from both callbacks, so we can have\n        // a 'lock' of sorts to ensure only one fires\n        if (options.callback_fired) { return; }\n        options.callback_fired = true;\n\n        if (user_callback && user_callback(timeout_occured, props) === false) {\n            // user can prevent the default functionality by\n            // returning false from their callback\n            return;\n        }\n\n        that.after_track_handler(props, options, timeout_occured);\n    };\n};\n\nDomTracker.prototype.create_properties = function(properties, element) {\n    var props;\n\n    if (typeof(properties) === 'function') {\n        props = properties(element);\n    } else {\n        props = _.extend({}, properties);\n    }\n\n    return props;\n};\n\n/**\n * LinkTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar LinkTracker = function() {\n    this.override_event = 'click';\n};\n_.inherit(LinkTracker, DomTracker);\n\nLinkTracker.prototype.create_properties = function(properties, element) {\n    var props = LinkTracker.superclass.create_properties.apply(this, arguments);\n\n    if (element.href) { props['url'] = element.href; }\n\n    return props;\n};\n\nLinkTracker.prototype.event_handler = function(evt, element, options) {\n    options.new_tab = (\n        evt.which === 2 ||\n        evt.metaKey ||\n        evt.ctrlKey ||\n        element.target === '_blank'\n    );\n    options.href = element.href;\n\n    if (!options.new_tab) {\n        evt.preventDefault();\n    }\n};\n\nLinkTracker.prototype.after_track_handler = function(props, options) {\n    if (options.new_tab) { return; }\n\n    setTimeout(function() {\n        window.location = options.href;\n    }, 0);\n};\n\n/**\n * FormTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar FormTracker = function() {\n    this.override_event = 'submit';\n};\n_.inherit(FormTracker, DomTracker);\n\nFormTracker.prototype.event_handler = function(evt, element, options) {\n    options.element = element;\n    evt.preventDefault();\n};\n\nFormTracker.prototype.after_track_handler = function(props, options) {\n    setTimeout(function() {\n        options.element.submit();\n    }, 0);\n};\n\n/* eslint camelcase: \"off\" */\n\n/** @const */ var SET_ACTION      = '$set';\n/** @const */ var SET_ONCE_ACTION = '$set_once';\n/** @const */ var UNSET_ACTION    = '$unset';\n/** @const */ var ADD_ACTION      = '$add';\n/** @const */ var APPEND_ACTION   = '$append';\n/** @const */ var UNION_ACTION    = '$union';\n/** @const */ var REMOVE_ACTION   = '$remove';\n/** @const */ var DELETE_ACTION   = '$delete';\n\n// Common internal methods for mixpanel.people and mixpanel.group APIs.\n// These methods shouldn't involve network I/O.\nvar apiActions = {\n    set_action: function(prop, to) {\n        var data = {};\n        var $set = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set[k] = v;\n                }\n            }, this);\n        } else {\n            $set[prop] = to;\n        }\n\n        data[SET_ACTION] = $set;\n        return data;\n    },\n\n    unset_action: function(prop) {\n        var data = {};\n        var $unset = [];\n        if (!_.isArray(prop)) {\n            prop = [prop];\n        }\n\n        _.each(prop, function(k) {\n            if (!this._is_reserved_property(k)) {\n                $unset.push(k);\n            }\n        }, this);\n\n        data[UNSET_ACTION] = $unset;\n        return data;\n    },\n\n    set_once_action: function(prop, to) {\n        var data = {};\n        var $set_once = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set_once[k] = v;\n                }\n            }, this);\n        } else {\n            $set_once[prop] = to;\n        }\n        data[SET_ONCE_ACTION] = $set_once;\n        return data;\n    },\n\n    union_action: function(list_name, values) {\n        var data = {};\n        var $union = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $union[k] = _.isArray(v) ? v : [v];\n                }\n            }, this);\n        } else {\n            $union[list_name] = _.isArray(values) ? values : [values];\n        }\n        data[UNION_ACTION] = $union;\n        return data;\n    },\n\n    append_action: function(list_name, value) {\n        var data = {};\n        var $append = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $append[k] = v;\n                }\n            }, this);\n        } else {\n            $append[list_name] = value;\n        }\n        data[APPEND_ACTION] = $append;\n        return data;\n    },\n\n    remove_action: function(list_name, value) {\n        var data = {};\n        var $remove = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $remove[k] = v;\n                }\n            }, this);\n        } else {\n            $remove[list_name] = value;\n        }\n        data[REMOVE_ACTION] = $remove;\n        return data;\n    },\n\n    delete_action: function() {\n        var data = {};\n        data[DELETE_ACTION] = '';\n        return data;\n    }\n};\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel Group Object\n * @constructor\n */\nvar MixpanelGroup = function() {};\n\n_.extend(MixpanelGroup.prototype, apiActions);\n\nMixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {\n    this._mixpanel = mixpanel_instance;\n    this._group_key = group_key;\n    this._group_id = group_id;\n};\n\n/**\n * Set properties on a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, dates, or lists\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Set properties on a group, only if they do not yet exist.\n * This will not overwrite previous group property values, unlike\n * group.set().\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set_once('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set_once({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, lists or dates\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Unset properties on a group permanently.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').unset('Founded');\n *\n * @param {String} prop The name of the property.\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/**\n * Merge a given list with a list-valued group property, excluding duplicate values.\n *\n * ### Usage:\n *\n *     // merge a value to a list, creating it if needed\n *     mixpanel.get_group('company', 'mixpanel').union('Location', ['San Francisco', 'London']);\n *\n * @param {String} list_name Name of the property.\n * @param {Array} values Values to merge with the given property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/**\n * Permanently delete a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').delete();\n *\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype['delete'] = addOptOutCheckMixpanelGroup(function(callback) {\n    // bracket notation above prevents a minification error related to reserved words\n    var data = this.delete_action();\n    return this._send_request(data, callback);\n});\n\n/**\n * Remove a property from a group. The value will be ignored if doesn't exist.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').remove('Location', 'London');\n *\n * @param {String} list_name Name of the property.\n * @param {Object} value Value to remove from the given group property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\nMixpanelGroup.prototype._send_request = function(data, callback) {\n    data['$group_key'] = this._group_key;\n    data['$group_id'] = this._group_id;\n    data['$token'] = this._get_config('token');\n\n    var date_encoded_data = _.encodeDates(data);\n    return this._mixpanel._track_or_batch({\n        type: 'groups',\n        data: date_encoded_data,\n        endpoint: this._get_config('api_host') + '/' +  this._get_config('api_routes')['groups'],\n        batcher: this._mixpanel.request_batchers.groups\n    }, callback);\n};\n\nMixpanelGroup.prototype._is_reserved_property = function(prop) {\n    return prop === '$group_key' || prop === '$group_id';\n};\n\nMixpanelGroup.prototype._get_config = function(conf) {\n    return this._mixpanel.get_config(conf);\n};\n\nMixpanelGroup.prototype.toString = function() {\n    return this._mixpanel.toString() + '.group.' + this._group_key + '.' + this._group_id;\n};\n\n// MixpanelGroup Exports\nMixpanelGroup.prototype['remove']   = MixpanelGroup.prototype.remove;\nMixpanelGroup.prototype['set']      = MixpanelGroup.prototype.set;\nMixpanelGroup.prototype['set_once'] = MixpanelGroup.prototype.set_once;\nMixpanelGroup.prototype['union']    = MixpanelGroup.prototype.union;\nMixpanelGroup.prototype['unset']    = MixpanelGroup.prototype.unset;\nMixpanelGroup.prototype['toString'] = MixpanelGroup.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel People Object\n * @constructor\n */\nvar MixpanelPeople = function() {};\n\n_.extend(MixpanelPeople.prototype, apiActions);\n\nMixpanelPeople.prototype._init = function(mixpanel_instance) {\n    this._mixpanel = mixpanel_instance;\n};\n\n/*\n* Set properties on a user record.\n*\n* ### Usage:\n*\n*     mixpanel.people.set('gender', 'm');\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set({\n*         'Company': 'Acme',\n*         'Plan': 'Premium',\n*         'Upgrade date': new Date()\n*     });\n*     // properties can be strings, integers, dates, or lists\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    // make sure that the referrer info has been updated and saved\n    if (this._get_config('save_referrer')) {\n        this._mixpanel['persistence'].update_referrer_info(document.referrer);\n    }\n\n    // update $set object with default people properties\n    data[SET_ACTION] = _.extend(\n        {},\n        _.info.people_properties(),\n        data[SET_ACTION]\n    );\n    return this._send_request(data, callback);\n});\n\n/*\n* Set properties on a user record, only if they do not yet exist.\n* This will not overwrite previous people property values, unlike\n* people.set().\n*\n* ### Usage:\n*\n*     mixpanel.people.set_once('First Login Date', new Date());\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set_once({\n*         'First Login Date': new Date(),\n*         'Starting Plan': 'Premium'\n*     });\n*\n*     // properties can be strings, integers or dates\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/*\n* Unset properties on a user record (permanently removes the properties and their values from a profile).\n*\n* ### Usage:\n*\n*     mixpanel.people.unset('gender');\n*\n*     // or unset multiple properties at once\n*     mixpanel.people.unset(['gender', 'Company']);\n*\n* @param {Array|String} prop If a string, this is the name of the property. If an array, this is a list of property names.\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/*\n* Increment/decrement numeric people analytics properties.\n*\n* ### Usage:\n*\n*     mixpanel.people.increment('page_views', 1);\n*\n*     // or, for convenience, if you're just incrementing a counter by\n*     // 1, you can simply do\n*     mixpanel.people.increment('page_views');\n*\n*     // to decrement a counter, pass a negative number\n*     mixpanel.people.increment('credits_left', -1);\n*\n*     // like mixpanel.people.set(), you can increment multiple\n*     // properties at once:\n*     mixpanel.people.increment({\n*         counter1: 1,\n*         counter2: 6\n*     });\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.\n* @param {Number} [by] An amount to increment the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {\n    var data = {};\n    var $add = {};\n    if (_.isObject(prop)) {\n        _.each(prop, function(v, k) {\n            if (!this._is_reserved_property(k)) {\n                if (isNaN(parseFloat(v))) {\n                    console$1.error('Invalid increment value passed to mixpanel.people.increment - must be a number');\n                    return;\n                } else {\n                    $add[k] = v;\n                }\n            }\n        }, this);\n        callback = by;\n    } else {\n        // convenience: mixpanel.people.increment('property'); will\n        // increment 'property' by 1\n        if (_.isUndefined(by)) {\n            by = 1;\n        }\n        $add[prop] = by;\n    }\n    data[ADD_ACTION] = $add;\n\n    return this._send_request(data, callback);\n});\n\n/*\n* Append a value to a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     // append a value to a list, creating it if needed\n*     mixpanel.people.append('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.append({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value An item to append to the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.append_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Remove a value from a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     mixpanel.people.remove('School', 'UCB');\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value Item to remove from the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Merge a given list with a list-valued people analytics property,\n* excluding duplicate values.\n*\n* ### Usage:\n*\n*     // merge a value to a list, creating it if needed\n*     mixpanel.people.union('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.union({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n*     // like mixpanel.people.append(), you can append multiple\n*     // values to the same list:\n*     mixpanel.people.union({\n*         list1: ['bob', 'billy']\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] Value / values to merge with the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/*\n * Record that you have charged the current user a certain amount\n * of money. Charges recorded with track_charge() will appear in the\n * Mixpanel revenue report.\n *\n * ### Usage:\n *\n *     // charge a user $50\n *     mixpanel.people.track_charge(50);\n *\n *     // charge a user $30.50 on the 2nd of january\n *     mixpanel.people.track_charge(30.50, {\n *         '$time': new Date('jan 1 2012')\n *     });\n *\n * @param {Number} amount The amount of money charged to the current user\n * @param {Object} [properties] An associative array of properties associated with the charge\n * @param {Function} [callback] If provided, the callback will be called when the server responds\n * @deprecated\n */\nMixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function(amount, properties, callback) {\n    if (!_.isNumber(amount)) {\n        amount = parseFloat(amount);\n        if (isNaN(amount)) {\n            console$1.error('Invalid value passed to mixpanel.people.track_charge - must be a number');\n            return;\n        }\n    }\n\n    return this.append('$transactions', _.extend({\n        '$amount': amount\n    }, properties), callback);\n});\n\n/*\n * Permanently clear all revenue report transactions from the\n * current user's people analytics profile.\n *\n * ### Usage:\n *\n *     mixpanel.people.clear_charges();\n *\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n * @deprecated\n */\nMixpanelPeople.prototype.clear_charges = function(callback) {\n    return this.set('$transactions', [], callback);\n};\n\n/*\n* Permanently deletes the current people analytics profile from\n* Mixpanel (using the current distinct_id).\n*\n* ### Usage:\n*\n*     // remove the all data you have stored about the current user\n*     mixpanel.people.delete_user();\n*\n*/\nMixpanelPeople.prototype.delete_user = function() {\n    if (!this._identify_called()) {\n        console$1.error('mixpanel.people.delete_user() requires you to call identify() first');\n        return;\n    }\n    var data = {'$delete': this._mixpanel.get_distinct_id()};\n    return this._send_request(data);\n};\n\nMixpanelPeople.prototype.toString = function() {\n    return this._mixpanel.toString() + '.people';\n};\n\nMixpanelPeople.prototype._send_request = function(data, callback) {\n    data['$token'] = this._get_config('token');\n    data['$distinct_id'] = this._mixpanel.get_distinct_id();\n    var device_id = this._mixpanel.get_property('$device_id');\n    var user_id = this._mixpanel.get_property('$user_id');\n    var had_persisted_distinct_id = this._mixpanel.get_property('$had_persisted_distinct_id');\n    if (device_id) {\n        data['$device_id'] = device_id;\n    }\n    if (user_id) {\n        data['$user_id'] = user_id;\n    }\n    if (had_persisted_distinct_id) {\n        data['$had_persisted_distinct_id'] = had_persisted_distinct_id;\n    }\n\n    var date_encoded_data = _.encodeDates(data);\n\n    if (!this._identify_called()) {\n        this._enqueue(data);\n        if (!_.isUndefined(callback)) {\n            if (this._get_config('verbose')) {\n                callback({status: -1, error: null});\n            } else {\n                callback(-1);\n            }\n        }\n        return _.truncate(date_encoded_data, 255);\n    }\n\n    return this._mixpanel._track_or_batch({\n        type: 'people',\n        data: date_encoded_data,\n        endpoint: this._get_config('api_host') + '/' +  this._get_config('api_routes')['engage'],\n        batcher: this._mixpanel.request_batchers.people\n    }, callback);\n};\n\nMixpanelPeople.prototype._get_config = function(conf_var) {\n    return this._mixpanel.get_config(conf_var);\n};\n\nMixpanelPeople.prototype._identify_called = function() {\n    return this._mixpanel._flags.identify_called === true;\n};\n\n// Queue up engage operations if identify hasn't been called yet.\nMixpanelPeople.prototype._enqueue = function(data) {\n    if (SET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ACTION, data);\n    } else if (SET_ONCE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ONCE_ACTION, data);\n    } else if (UNSET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNSET_ACTION, data);\n    } else if (ADD_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(ADD_ACTION, data);\n    } else if (APPEND_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, data);\n    } else if (REMOVE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, data);\n    } else if (UNION_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNION_ACTION, data);\n    } else {\n        console$1.error('Invalid call to _enqueue():', data);\n    }\n};\n\nMixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {\n    var _this = this;\n    var queued_data = _.extend({}, this._mixpanel['persistence'].load_queue(action));\n    var action_params = queued_data;\n\n    if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {\n        _this._mixpanel['persistence']._pop_from_people_queue(action, queued_data);\n        _this._mixpanel['persistence'].save();\n        if (queue_to_params_fn) {\n            action_params = queue_to_params_fn(queued_data);\n        }\n        action_method.call(_this, action_params, function(response, data) {\n            // on bad response, we want to add it back to the queue\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(action, queued_data);\n            }\n            if (!_.isUndefined(callback)) {\n                callback(response, data);\n            }\n        });\n    }\n};\n\n// Flush queued engage operations - order does not matter,\n// and there are network level race conditions anyway\nMixpanelPeople.prototype._flush = function(\n    _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    var _this = this;\n\n    this._flush_one_queue(SET_ACTION, this.set, _set_callback);\n    this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);\n    this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) { return _.keys(queue); });\n    this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);\n    this._flush_one_queue(UNION_ACTION, this.union, _union_callback);\n\n    // we have to fire off each $append individually since there is\n    // no concat method server side\n    var $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n    if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {\n        var $append_item;\n        var append_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, $append_item);\n            }\n            if (!_.isUndefined(_append_callback)) {\n                _append_callback(response, data);\n            }\n        };\n        for (var i = $append_queue.length - 1; i >= 0; i--) {\n            $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n            $append_item = $append_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($append_item)) {\n                _this.append($append_item, append_callback);\n            }\n        }\n    }\n\n    // same for $remove\n    var $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n    if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {\n        var $remove_item;\n        var remove_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, $remove_item);\n            }\n            if (!_.isUndefined(_remove_callback)) {\n                _remove_callback(response, data);\n            }\n        };\n        for (var j = $remove_queue.length - 1; j >= 0; j--) {\n            $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n            $remove_item = $remove_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($remove_item)) {\n                _this.remove($remove_item, remove_callback);\n            }\n        }\n    }\n};\n\nMixpanelPeople.prototype._is_reserved_property = function(prop) {\n    return prop === '$distinct_id' || prop === '$token' || prop === '$device_id' || prop === '$user_id' || prop === '$had_persisted_distinct_id';\n};\n\n// MixpanelPeople Exports\nMixpanelPeople.prototype['set']           = MixpanelPeople.prototype.set;\nMixpanelPeople.prototype['set_once']      = MixpanelPeople.prototype.set_once;\nMixpanelPeople.prototype['unset']         = MixpanelPeople.prototype.unset;\nMixpanelPeople.prototype['increment']     = MixpanelPeople.prototype.increment;\nMixpanelPeople.prototype['append']        = MixpanelPeople.prototype.append;\nMixpanelPeople.prototype['remove']        = MixpanelPeople.prototype.remove;\nMixpanelPeople.prototype['union']         = MixpanelPeople.prototype.union;\nMixpanelPeople.prototype['track_charge']  = MixpanelPeople.prototype.track_charge;\nMixpanelPeople.prototype['clear_charges'] = MixpanelPeople.prototype.clear_charges;\nMixpanelPeople.prototype['delete_user']   = MixpanelPeople.prototype.delete_user;\nMixpanelPeople.prototype['toString']      = MixpanelPeople.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n/*\n * Constants\n */\n/** @const */ var SET_QUEUE_KEY          = '__mps';\n/** @const */ var SET_ONCE_QUEUE_KEY     = '__mpso';\n/** @const */ var UNSET_QUEUE_KEY        = '__mpus';\n/** @const */ var ADD_QUEUE_KEY          = '__mpa';\n/** @const */ var APPEND_QUEUE_KEY       = '__mpap';\n/** @const */ var REMOVE_QUEUE_KEY       = '__mpr';\n/** @const */ var UNION_QUEUE_KEY        = '__mpu';\n// This key is deprecated, but we want to check for it to see whether aliasing is allowed.\n/** @const */ var PEOPLE_DISTINCT_ID_KEY = '$people_distinct_id';\n/** @const */ var ALIAS_ID_KEY           = '__alias';\n/** @const */ var EVENT_TIMERS_KEY       = '__timers';\n/** @const */ var RESERVED_PROPERTIES = [\n    SET_QUEUE_KEY,\n    SET_ONCE_QUEUE_KEY,\n    UNSET_QUEUE_KEY,\n    ADD_QUEUE_KEY,\n    APPEND_QUEUE_KEY,\n    REMOVE_QUEUE_KEY,\n    UNION_QUEUE_KEY,\n    PEOPLE_DISTINCT_ID_KEY,\n    ALIAS_ID_KEY,\n    EVENT_TIMERS_KEY\n];\n\n/**\n * Mixpanel Persistence Object\n * @constructor\n */\nvar MixpanelPersistence = function(config) {\n    this['props'] = {};\n    this.campaign_params_saved = false;\n\n    if (config['persistence_name']) {\n        this.name = 'mp_' + config['persistence_name'];\n    } else {\n        this.name = 'mp_' + config['token'] + '_mixpanel';\n    }\n\n    var storage_type = config['persistence'];\n    if (storage_type !== 'cookie' && storage_type !== 'localStorage') {\n        console$1.critical('Unknown persistence type ' + storage_type + '; falling back to cookie');\n        storage_type = config['persistence'] = 'cookie';\n    }\n\n    if (storage_type === 'localStorage' && _.localStorage.is_supported()) {\n        this.storage = _.localStorage;\n    } else {\n        this.storage = _.cookie;\n    }\n\n    this.load();\n    this.update_config(config);\n    this.upgrade();\n    this.save();\n};\n\nMixpanelPersistence.prototype.properties = function() {\n    var p = {};\n\n    this.load();\n\n    // Filter out reserved properties\n    _.each(this['props'], function(v, k) {\n        if (!_.include(RESERVED_PROPERTIES, k)) {\n            p[k] = v;\n        }\n    });\n    return p;\n};\n\nMixpanelPersistence.prototype.load = function() {\n    if (this.disabled) { return; }\n\n    var entry = this.storage.parse(this.name);\n\n    if (entry) {\n        this['props'] = _.extend({}, entry);\n    }\n};\n\nMixpanelPersistence.prototype.upgrade = function() {\n    var old_cookie,\n        old_localstorage;\n\n    // if transferring from cookie to localStorage or vice-versa, copy existing\n    // super properties over to new storage mode\n    if (this.storage === _.localStorage) {\n        old_cookie = _.cookie.parse(this.name);\n\n        _.cookie.remove(this.name);\n        _.cookie.remove(this.name, true);\n\n        if (old_cookie) {\n            this.register_once(old_cookie);\n        }\n    } else if (this.storage === _.cookie) {\n        old_localstorage = _.localStorage.parse(this.name);\n\n        _.localStorage.remove(this.name);\n\n        if (old_localstorage) {\n            this.register_once(old_localstorage);\n        }\n    }\n};\n\nMixpanelPersistence.prototype.save = function() {\n    if (this.disabled) { return; }\n\n    this.storage.set(\n        this.name,\n        _.JSONEncode(this['props']),\n        this.expire_days,\n        this.cross_subdomain,\n        this.secure,\n        this.cross_site,\n        this.cookie_domain\n    );\n};\n\nMixpanelPersistence.prototype.load_prop = function(key) {\n    this.load();\n    return this['props'][key];\n};\n\nMixpanelPersistence.prototype.remove = function() {\n    // remove both domain and subdomain cookies\n    this.storage.remove(this.name, false, this.cookie_domain);\n    this.storage.remove(this.name, true, this.cookie_domain);\n};\n\n// removes the storage entry and deletes all loaded data\n// forced name for tests\nMixpanelPersistence.prototype.clear = function() {\n    this.remove();\n    this['props'] = {};\n};\n\n/**\n* @param {Object} props\n* @param {*=} default_value\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register_once = function(props, default_value, days) {\n    if (_.isObject(props)) {\n        if (typeof(default_value) === 'undefined') { default_value = 'None'; }\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n\n        _.each(props, function(val, prop) {\n            if (!this['props'].hasOwnProperty(prop) || this['props'][prop] === default_value) {\n                this['props'][prop] = val;\n            }\n        }, this);\n\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\n/**\n* @param {Object} props\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register = function(props, days) {\n    if (_.isObject(props)) {\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n        _.extend(this['props'], props);\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\nMixpanelPersistence.prototype.unregister = function(prop) {\n    this.load();\n    if (prop in this['props']) {\n        delete this['props'][prop];\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.update_search_keyword = function(referrer) {\n    this.register(_.info.searchInfo(referrer));\n};\n\n// EXPORTED METHOD, we test this directly.\nMixpanelPersistence.prototype.update_referrer_info = function(referrer) {\n    // If referrer doesn't exist, we want to note the fact that it was type-in traffic.\n    this.register_once({\n        '$initial_referrer': referrer || '$direct',\n        '$initial_referring_domain': _.info.referringDomain(referrer) || '$direct'\n    }, '');\n};\n\nMixpanelPersistence.prototype.get_referrer_info = function() {\n    return _.strip_empty_properties({\n        '$initial_referrer': this['props']['$initial_referrer'],\n        '$initial_referring_domain': this['props']['$initial_referring_domain']\n    });\n};\n\nMixpanelPersistence.prototype.update_config = function(config) {\n    this.default_expiry = this.expire_days = config['cookie_expiration'];\n    this.set_disabled(config['disable_persistence']);\n    this.set_cookie_domain(config['cookie_domain']);\n    this.set_cross_site(config['cross_site_cookie']);\n    this.set_cross_subdomain(config['cross_subdomain_cookie']);\n    this.set_secure(config['secure_cookie']);\n};\n\nMixpanelPersistence.prototype.set_disabled = function(disabled) {\n    this.disabled = disabled;\n    if (this.disabled) {\n        this.remove();\n    } else {\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {\n    if (cookie_domain !== this.cookie_domain) {\n        this.remove();\n        this.cookie_domain = cookie_domain;\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_site = function(cross_site) {\n    if (cross_site !== this.cross_site) {\n        this.cross_site = cross_site;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {\n    if (cross_subdomain !== this.cross_subdomain) {\n        this.cross_subdomain = cross_subdomain;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.get_cross_subdomain = function() {\n    return this.cross_subdomain;\n};\n\nMixpanelPersistence.prototype.set_secure = function(secure) {\n    if (secure !== this.secure) {\n        this.secure = secure ? true : false;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype._add_to_people_queue = function(queue, data) {\n    var q_key = this._get_queue_key(queue),\n        q_data = data[queue],\n        set_q = this._get_or_create_queue(SET_ACTION),\n        set_once_q = this._get_or_create_queue(SET_ONCE_ACTION),\n        unset_q = this._get_or_create_queue(UNSET_ACTION),\n        add_q = this._get_or_create_queue(ADD_ACTION),\n        union_q = this._get_or_create_queue(UNION_ACTION),\n        remove_q = this._get_or_create_queue(REMOVE_ACTION, []),\n        append_q = this._get_or_create_queue(APPEND_ACTION, []);\n\n    if (q_key === SET_QUEUE_KEY) {\n        // Update the set queue - we can override any existing values\n        _.extend(set_q, q_data);\n        // if there was a pending increment, override it\n        // with the set.\n        this._pop_from_people_queue(ADD_ACTION, q_data);\n        // if there was a pending union, override it\n        // with the set.\n        this._pop_from_people_queue(UNION_ACTION, q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === SET_ONCE_QUEUE_KEY) {\n        // only queue the data if there is not already a set_once call for it.\n        _.each(q_data, function(v, k) {\n            if (!(k in set_once_q)) {\n                set_once_q[k] = v;\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNSET_QUEUE_KEY) {\n        _.each(q_data, function(prop) {\n\n            // undo previously-queued actions on this key\n            _.each([set_q, set_once_q, add_q, union_q], function(enqueued_obj) {\n                if (prop in enqueued_obj) {\n                    delete enqueued_obj[prop];\n                }\n            });\n            _.each(append_q, function(append_obj) {\n                if (prop in append_obj) {\n                    delete append_obj[prop];\n                }\n            });\n\n            unset_q[prop] = true;\n\n        });\n    } else if (q_key === ADD_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            // If it exists in the set queue, increment\n            // the value\n            if (k in set_q) {\n                set_q[k] += v;\n            } else {\n                // If it doesn't exist, update the add\n                // queue\n                if (!(k in add_q)) {\n                    add_q[k] = 0;\n                }\n                add_q[k] += v;\n            }\n        }, this);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNION_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            if (_.isArray(v)) {\n                if (!(k in union_q)) {\n                    union_q[k] = [];\n                }\n                // We may send duplicates, the server will dedup them.\n                union_q[k] = union_q[k].concat(v);\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === REMOVE_QUEUE_KEY) {\n        remove_q.push(q_data);\n        this._pop_from_people_queue(APPEND_ACTION, q_data);\n    } else if (q_key === APPEND_QUEUE_KEY) {\n        append_q.push(q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    }\n\n    console$1.log('MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):');\n    console$1.log(data);\n\n    this.save();\n};\n\nMixpanelPersistence.prototype._pop_from_people_queue = function(queue, data) {\n    var q = this['props'][this._get_queue_key(queue)];\n    if (!_.isUndefined(q)) {\n        _.each(data, function(v, k) {\n            if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {\n                // list actions: only remove if both k+v match\n                // e.g. remove should not override append in a case like\n                // append({foo: 'bar'}); remove({foo: 'qux'})\n                _.each(q, function(queued_action) {\n                    if (queued_action[k] === v) {\n                        delete queued_action[k];\n                    }\n                });\n            } else {\n                delete q[k];\n            }\n        }, this);\n    }\n};\n\nMixpanelPersistence.prototype.load_queue = function(queue) {\n    return this.load_prop(this._get_queue_key(queue));\n};\n\nMixpanelPersistence.prototype._get_queue_key = function(queue) {\n    if (queue === SET_ACTION) {\n        return SET_QUEUE_KEY;\n    } else if (queue === SET_ONCE_ACTION) {\n        return SET_ONCE_QUEUE_KEY;\n    } else if (queue === UNSET_ACTION) {\n        return UNSET_QUEUE_KEY;\n    } else if (queue === ADD_ACTION) {\n        return ADD_QUEUE_KEY;\n    } else if (queue === APPEND_ACTION) {\n        return APPEND_QUEUE_KEY;\n    } else if (queue === REMOVE_ACTION) {\n        return REMOVE_QUEUE_KEY;\n    } else if (queue === UNION_ACTION) {\n        return UNION_QUEUE_KEY;\n    } else {\n        console$1.error('Invalid queue:', queue);\n    }\n};\n\nMixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {\n    var key = this._get_queue_key(queue);\n    default_val = _.isUndefined(default_val) ? {} : default_val;\n    return this['props'][key] || (this['props'][key] = default_val);\n};\n\nMixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    timers[event_name] = timestamp;\n    this['props'][EVENT_TIMERS_KEY] = timers;\n    this.save();\n};\n\nMixpanelPersistence.prototype.remove_event_timer = function(event_name) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    var timestamp = timers[event_name];\n    if (!_.isUndefined(timestamp)) {\n        delete this['props'][EVENT_TIMERS_KEY][event_name];\n        this.save();\n    }\n    return timestamp;\n};\n\n/* eslint camelcase: \"off\" */\n\n/*\n * Mixpanel JS Library\n *\n * Copyright 2012, Mixpanel, Inc. All Rights Reserved\n * http://mixpanel.com/\n *\n * Includes portions of Underscore.js\n * http://documentcloud.github.com/underscore/\n * (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT License.\n */\n\n// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @output_file_name mixpanel-2.8.min.js\n// ==/ClosureCompiler==\n\n/*\nSIMPLE STYLE GUIDE:\n\nthis.x === public function\nthis._x === internal - only use within this file\nthis.__x === private - only use within the class\n\nGlobals should be all caps\n*/\n\nvar init_type;       // MODULE or SNIPPET loader\n// allow bundlers to specify how extra code (recorder bundle) should be loaded\n// eslint-disable-next-line no-unused-vars\nvar load_extra_bundle = function(src, _onload) {\n    throw new Error(src + ' not available in this build.');\n};\n\nvar mixpanel_master; // main mixpanel instance / object\nvar INIT_MODULE  = 0;\nvar INIT_SNIPPET = 1;\n\nvar IDENTITY_FUNC = function(x) {return x;};\nvar NOOP_FUNC = function() {};\n\n/** @const */ var PRIMARY_INSTANCE_NAME = 'mixpanel';\n/** @const */ var PAYLOAD_TYPE_BASE64   = 'base64';\n/** @const */ var PAYLOAD_TYPE_JSON     = 'json';\n/** @const */ var DEVICE_ID_PREFIX      = '$device:';\n\n\n/*\n * Dynamic... constants? Is that an oxymoron?\n */\n// http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n// https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#withCredentials\nvar USE_XHR = (win.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest());\n\n// IE<10 does not support cross-origin XHR's but script tags\n// with defer won't block window.onload; ENQUEUE_REQUESTS\n// should only be true for Opera<12\nvar ENQUEUE_REQUESTS = !USE_XHR && (userAgent.indexOf('MSIE') === -1) && (userAgent.indexOf('Mozilla') === -1);\n\n// save reference to navigator.sendBeacon so it can be minified\nvar sendBeacon = null;\nif (navigator['sendBeacon']) {\n    sendBeacon = function() {\n        // late reference to navigator.sendBeacon to allow patching/spying\n        return navigator['sendBeacon'].apply(navigator, arguments);\n    };\n}\n\nvar DEFAULT_API_ROUTES = {\n    'track': 'track/',\n    'engage': 'engage/',\n    'groups': 'groups/',\n    'record': 'record/'\n};\n\n/*\n * Module-level globals\n */\nvar DEFAULT_CONFIG = {\n    'api_host':                          'https://api-js.mixpanel.com',\n    'api_routes':                        DEFAULT_API_ROUTES,\n    'api_method':                        'POST',\n    'api_transport':                     'XHR',\n    'api_payload_format':                PAYLOAD_TYPE_BASE64,\n    'app_host':                          'https://mixpanel.com',\n    'cdn':                               'https://cdn.mxpnl.com',\n    'cross_site_cookie':                 false,\n    'cross_subdomain_cookie':            true,\n    'error_reporter':                    NOOP_FUNC,\n    'persistence':                       'cookie',\n    'persistence_name':                  '',\n    'cookie_domain':                     '',\n    'cookie_name':                       '',\n    'loaded':                            NOOP_FUNC,\n    'mp_loader':                         null,\n    'track_marketing':                   true,\n    'track_pageview':                    false,\n    'skip_first_touch_marketing':        false,\n    'store_google':                      true,\n    'stop_utm_persistence':              false,\n    'save_referrer':                     true,\n    'test':                              false,\n    'verbose':                           false,\n    'img':                               false,\n    'debug':                             false,\n    'track_links_timeout':               300,\n    'cookie_expiration':                 365,\n    'upgrade':                           false,\n    'disable_persistence':               false,\n    'disable_cookie':                    false,\n    'secure_cookie':                     false,\n    'ip':                                true,\n    'opt_out_tracking_by_default':       false,\n    'opt_out_persistence_by_default':    false,\n    'opt_out_tracking_persistence_type': 'localStorage',\n    'opt_out_tracking_cookie_prefix':    null,\n    'property_blacklist':                [],\n    'xhr_headers':                       {}, // { header: value, header2: value }\n    'ignore_dnt':                        false,\n    'batch_requests':                    true,\n    'batch_size':                        50,\n    'batch_flush_interval_ms':           5000,\n    'batch_request_timeout_ms':          90000,\n    'batch_autostart':                   true,\n    'hooks':                             {},\n    'record_block_class':                new RegExp('^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$'),\n    'record_block_selector':             'img, video',\n    'record_canvas':                     false,\n    'record_collect_fonts':              false,\n    'record_idle_timeout_ms':            30 * 60 * 1000, // 30 minutes\n    'record_mask_text_class':            new RegExp('^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$'),\n    'record_mask_text_selector':         '*',\n    'record_max_ms':                     MAX_RECORDING_MS,\n    'record_min_ms':                     0,\n    'record_sessions_percent':           0,\n    'recorder_src':                      'https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js'\n};\n\nvar DOM_LOADED = false;\n\n/**\n * Mixpanel Library Object\n * @constructor\n */\nvar MixpanelLib = function() {};\n\n\n/**\n * create_mplib(token:string, config:object, name:string)\n *\n * This function is used by the init method of MixpanelLib objects\n * as well as the main initializer at the end of the JSLib (that\n * initializes document.mixpanel as well as any additional instances\n * declared before this file has loaded).\n */\nvar create_mplib = function(token, config, name) {\n    var instance,\n        target = (name === PRIMARY_INSTANCE_NAME) ? mixpanel_master : mixpanel_master[name];\n\n    if (target && init_type === INIT_MODULE) {\n        instance = target;\n    } else {\n        if (target && !_.isArray(target)) {\n            console$1.error('You have already initialized ' + name);\n            return;\n        }\n        instance = new MixpanelLib();\n    }\n\n    instance._cached_groups = {}; // cache groups in a pool\n\n    instance._init(token, config, name);\n\n    instance['people'] = new MixpanelPeople();\n    instance['people']._init(instance);\n\n    if (!instance.get_config('skip_first_touch_marketing')) {\n        // We need null UTM params in the object because\n        // UTM parameters act as a tuple. If any UTM param\n        // is present, then we set all UTM params including\n        // empty ones together\n        var utm_params = _.info.campaignParams(null);\n        var initial_utm_params = {};\n        var has_utm = false;\n        _.each(utm_params, function(utm_value, utm_key) {\n            initial_utm_params['initial_' + utm_key] = utm_value;\n            if (utm_value) {\n                has_utm = true;\n            }\n        });\n        if (has_utm) {\n            instance['people'].set_once(initial_utm_params);\n        }\n    }\n\n    // if any instance on the page has debug = true, we set the\n    // global debug to be true\n    Config.DEBUG = Config.DEBUG || instance.get_config('debug');\n\n    // if target is not defined, we called init after the lib already\n    // loaded, so there won't be an array of things to execute\n    if (!_.isUndefined(target) && _.isArray(target)) {\n        // Crunch through the people queue first - we queue this data up &\n        // flush on identify, so it's better to do all these operations first\n        instance._execute_array.call(instance['people'], target['people']);\n        instance._execute_array(target);\n    }\n\n    return instance;\n};\n\n// Initialization methods\n\n/**\n * This function initializes a new instance of the Mixpanel tracking object.\n * All new instances are added to the main mixpanel object as sub properties (such as\n * mixpanel.library_name) and also returned by this function. To define a\n * second instance on the page, you would call:\n *\n *     mixpanel.init('new token', { your: 'config' }, 'library_name');\n *\n * and use it like so:\n *\n *     mixpanel.library_name.track(...);\n *\n * @param {String} token   Your Mixpanel API token\n * @param {Object} [config]  A dictionary of config options to override. <a href=\"https://github.com/mixpanel/mixpanel-js/blob/v2.46.0/src/mixpanel-core.js#L88-L127\">See a list of default config options</a>.\n * @param {String} [name]    The name for the new mixpanel instance that you want created\n */\nMixpanelLib.prototype.init = function (token, config, name) {\n    if (_.isUndefined(name)) {\n        this.report_error('You must name your new library: init(token, config, name)');\n        return;\n    }\n    if (name === PRIMARY_INSTANCE_NAME) {\n        this.report_error('You must initialize the main mixpanel object right after you include the Mixpanel js snippet');\n        return;\n    }\n\n    var instance = create_mplib(token, config, name);\n    mixpanel_master[name] = instance;\n    instance._loaded();\n\n    return instance;\n};\n\n// mixpanel._init(token:string, config:object, name:string)\n//\n// This function sets up the current instance of the mixpanel\n// library.  The difference between this method and the init(...)\n// method is this one initializes the actual instance, whereas the\n// init(...) method sets up a new library and calls _init on it.\n//\nMixpanelLib.prototype._init = function(token, config, name) {\n    config = config || {};\n\n    this['__loaded'] = true;\n    this['config'] = {};\n\n    var variable_features = {};\n\n    // default to JSON payload for standard mixpanel.com API hosts\n    if (!('api_payload_format' in config)) {\n        var api_host = config['api_host'] || DEFAULT_CONFIG['api_host'];\n        if (api_host.match(/\\.mixpanel\\.com/)) {\n            variable_features['api_payload_format'] = PAYLOAD_TYPE_JSON;\n        }\n    }\n\n    this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {\n        'name': name,\n        'token': token,\n        'callback_fn': ((name === PRIMARY_INSTANCE_NAME) ? name : PRIMARY_INSTANCE_NAME + '.' + name) + '._jsc'\n    }));\n\n    this['_jsc'] = NOOP_FUNC;\n\n    this.__dom_loaded_queue = [];\n    this.__request_queue = [];\n    this.__disabled_events = [];\n    this._flags = {\n        'disable_all_events': false,\n        'identify_called': false\n    };\n\n    // set up request queueing/batching\n    this.request_batchers = {};\n    this._batch_requests = this.get_config('batch_requests');\n    if (this._batch_requests) {\n        if (!_.localStorage.is_supported(true) || !USE_XHR) {\n            this._batch_requests = false;\n            console$1.log('Turning off Mixpanel request-queueing; needs XHR and localStorage support');\n            _.each(this.get_batcher_configs(), function(batcher_config) {\n                console$1.log('Clearing batch queue ' + batcher_config.queue_key);\n                _.localStorage.remove(batcher_config.queue_key);\n            });\n        } else {\n            this.init_batchers();\n            if (sendBeacon && win.addEventListener) {\n                // Before page closes or hides (user tabs away etc), attempt to flush any events\n                // queued up via navigator.sendBeacon. Since sendBeacon doesn't report success/failure,\n                // events will not be removed from the persistent store; if the site is loaded again,\n                // the events will be flushed again on startup and deduplicated on the Mixpanel server\n                // side.\n                // There is no reliable way to capture only page close events, so we lean on the\n                // visibilitychange and pagehide events as recommended at\n                // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes.\n                // These events fire when the user clicks away from the current page/tab, so will occur\n                // more frequently than page unload, but are the only mechanism currently for capturing\n                // this scenario somewhat reliably.\n                var flush_on_unload = _.bind(function() {\n                    if (!this.request_batchers.events.stopped) {\n                        this.request_batchers.events.flush({unloading: true});\n                    }\n                }, this);\n                win.addEventListener('pagehide', function(ev) {\n                    if (ev['persisted']) {\n                        flush_on_unload();\n                    }\n                });\n                win.addEventListener('visibilitychange', function() {\n                    if (document$1['visibilityState'] === 'hidden') {\n                        flush_on_unload();\n                    }\n                });\n            }\n        }\n    }\n\n    this['persistence'] = this['cookie'] = new MixpanelPersistence(this['config']);\n    this.unpersisted_superprops = {};\n    this._gdpr_init();\n\n    var uuid = _.UUID();\n    if (!this.get_distinct_id()) {\n        // There is no need to set the distinct id\n        // or the device id if something was already stored\n        // in the persitence\n        this.register_once({\n            'distinct_id': DEVICE_ID_PREFIX + uuid,\n            '$device_id': uuid\n        }, '');\n    }\n\n    var track_pageview_option = this.get_config('track_pageview');\n    if (track_pageview_option) {\n        this._init_url_change_tracking(track_pageview_option);\n    }\n\n    if (this.get_config('record_sessions_percent') > 0 && Math.random() * 100 <= this.get_config('record_sessions_percent')) {\n        this.start_session_recording();\n    }\n};\n\nMixpanelLib.prototype.start_session_recording = addOptOutCheckMixpanelLib(function () {\n    if (!win['MutationObserver']) {\n        console$1.critical('Browser does not support MutationObserver; skipping session recording');\n        return;\n    }\n\n    var handleLoadedRecorder = _.bind(function() {\n        this._recorder = this._recorder || new win['__mp_recorder'](this);\n        this._recorder['startRecording']();\n    }, this);\n\n    if (_.isUndefined(win['__mp_recorder'])) {\n        load_extra_bundle(this.get_config('recorder_src'), handleLoadedRecorder);\n    } else {\n        handleLoadedRecorder();\n    }\n});\n\nMixpanelLib.prototype.stop_session_recording = function () {\n    if (this._recorder) {\n        this._recorder['stopRecording']();\n    } else {\n        console$1.critical('Session recorder module not loaded');\n    }\n};\n\nMixpanelLib.prototype.get_session_recording_properties = function () {\n    var props = {};\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        props['$mp_replay_id'] = replay_id;\n    }\n    return props;\n};\n\nMixpanelLib.prototype.get_session_replay_url = function () {\n    var replay_url = null;\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        var query_params = _.HTTPBuildQuery({\n            'replay_id': replay_id,\n            'distinct_id': this.get_distinct_id(),\n            'token': this.get_config('token')\n        });\n        replay_url = 'https://mixpanel.com/projects/replay-redirect?' + query_params;\n    }\n    return replay_url;\n};\n\nMixpanelLib.prototype._get_session_replay_id = function () {\n    var replay_id = null;\n    if (this._recorder) {\n        replay_id = this._recorder['replayId'];\n    }\n    return replay_id || null;\n};\n\n// Private methods\n\nMixpanelLib.prototype._loaded = function() {\n    this.get_config('loaded')(this);\n    this._set_default_superprops();\n    this['people'].set_once(this['persistence'].get_referrer_info());\n\n    // `store_google` is now deprecated and previously stored UTM parameters are cleared\n    // from persistence by default.\n    if (this.get_config('store_google') && this.get_config('stop_utm_persistence')) {\n        var utm_params = _.info.campaignParams(null);\n        _.each(utm_params, function(_utm_value, utm_key) {\n            // We need to unregister persisted UTM parameters so old values\n            // are not mixed with the new UTM parameters\n            this.unregister(utm_key);\n        }.bind(this));\n    }\n};\n\n// update persistence with info on referrer, UTM params, etc\nMixpanelLib.prototype._set_default_superprops = function() {\n    this['persistence'].update_search_keyword(document$1.referrer);\n    // Registering super properties for UTM persistence by 'store_google' is deprecated.\n    if (this.get_config('store_google') && !this.get_config('stop_utm_persistence')) {\n        this.register(_.info.campaignParams());\n    }\n    if (this.get_config('save_referrer')) {\n        this['persistence'].update_referrer_info(document$1.referrer);\n    }\n};\n\nMixpanelLib.prototype._dom_loaded = function() {\n    _.each(this.__dom_loaded_queue, function(item) {\n        this._track_dom.apply(this, item);\n    }, this);\n\n    if (!this.has_opted_out_tracking()) {\n        _.each(this.__request_queue, function(item) {\n            this._send_request.apply(this, item);\n        }, this);\n    }\n\n    delete this.__dom_loaded_queue;\n    delete this.__request_queue;\n};\n\nMixpanelLib.prototype._track_dom = function(DomClass, args) {\n    if (this.get_config('img')) {\n        this.report_error('You can\\'t use DOM tracking functions with img = true.');\n        return false;\n    }\n\n    if (!DOM_LOADED) {\n        this.__dom_loaded_queue.push([DomClass, args]);\n        return false;\n    }\n\n    var dt = new DomClass().init(this);\n    return dt.track.apply(dt, args);\n};\n\nMixpanelLib.prototype._init_url_change_tracking = function(track_pageview_option) {\n    var previous_tracked_url = '';\n    var tracked = this.track_pageview();\n    if (tracked) {\n        previous_tracked_url = _.info.currentUrl();\n    }\n\n    if (_.include(['full-url', 'url-with-path-and-query-string', 'url-with-path'], track_pageview_option)) {\n        win.addEventListener('popstate', function() {\n            win.dispatchEvent(new Event('mp_locationchange'));\n        });\n        win.addEventListener('hashchange', function() {\n            win.dispatchEvent(new Event('mp_locationchange'));\n        });\n        var nativePushState = win.history.pushState;\n        if (typeof nativePushState === 'function') {\n            win.history.pushState = function(state, unused, url) {\n                nativePushState.call(win.history, state, unused, url);\n                win.dispatchEvent(new Event('mp_locationchange'));\n            };\n        }\n        var nativeReplaceState = win.history.replaceState;\n        if (typeof nativeReplaceState === 'function') {\n            win.history.replaceState = function(state, unused, url) {\n                nativeReplaceState.call(win.history, state, unused, url);\n                win.dispatchEvent(new Event('mp_locationchange'));\n            };\n        }\n        win.addEventListener('mp_locationchange', function() {\n            var current_url = _.info.currentUrl();\n            var should_track = false;\n            if (track_pageview_option === 'full-url') {\n                should_track = current_url !== previous_tracked_url;\n            } else if (track_pageview_option === 'url-with-path-and-query-string') {\n                should_track = current_url.split('#')[0] !== previous_tracked_url.split('#')[0];\n            } else if (track_pageview_option === 'url-with-path') {\n                should_track = current_url.split('#')[0].split('?')[0] !== previous_tracked_url.split('#')[0].split('?')[0];\n            }\n\n            if (should_track) {\n                var tracked = this.track_pageview();\n                if (tracked) {\n                    previous_tracked_url = current_url;\n                }\n            }\n        }.bind(this));\n    }\n};\n\n/**\n * _prepare_callback() should be called by callers of _send_request for use\n * as the callback argument.\n *\n * If there is no callback, this returns null.\n * If we are going to make XHR/XDR requests, this returns a function.\n * If we are going to use script tags, this returns a string to use as the\n * callback GET param.\n */\nMixpanelLib.prototype._prepare_callback = function(callback, data) {\n    if (_.isUndefined(callback)) {\n        return null;\n    }\n\n    if (USE_XHR) {\n        var callback_function = function(response) {\n            callback(response, data);\n        };\n        return callback_function;\n    } else {\n        // if the user gives us a callback, we store as a random\n        // property on this instances jsc function and update our\n        // callback string to reflect that.\n        var jsc = this['_jsc'];\n        var randomized_cb = '' + Math.floor(Math.random() * 100000000);\n        var callback_string = this.get_config('callback_fn') + '[' + randomized_cb + ']';\n        jsc[randomized_cb] = function(response) {\n            delete jsc[randomized_cb];\n            callback(response, data);\n        };\n        return callback_string;\n    }\n};\n\nMixpanelLib.prototype._send_request = function(url, data, options, callback) {\n    var succeeded = true;\n\n    if (ENQUEUE_REQUESTS) {\n        this.__request_queue.push(arguments);\n        return succeeded;\n    }\n\n    var DEFAULT_OPTIONS = {\n        method: this.get_config('api_method'),\n        transport: this.get_config('api_transport'),\n        verbose: this.get_config('verbose')\n    };\n    var body_data = null;\n\n    if (!callback && (_.isFunction(options) || typeof options === 'string')) {\n        callback = options;\n        options = null;\n    }\n    options = _.extend(DEFAULT_OPTIONS, options || {});\n    if (!USE_XHR) {\n        options.method = 'GET';\n    }\n    var use_post = options.method === 'POST';\n    var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === 'sendbeacon';\n\n    // needed to correctly format responses\n    var verbose_mode = options.verbose;\n    if (data['verbose']) { verbose_mode = true; }\n\n    if (this.get_config('test')) { data['test'] = 1; }\n    if (verbose_mode) { data['verbose'] = 1; }\n    if (this.get_config('img')) { data['img'] = 1; }\n    if (!USE_XHR) {\n        if (callback) {\n            data['callback'] = callback;\n        } else if (verbose_mode || this.get_config('test')) {\n            // Verbose output (from verbose mode, or an error in test mode) is a json blob,\n            // which by itself is not valid javascript. Without a callback, this verbose output will\n            // cause an error when returned via jsonp, so we force a no-op callback param.\n            // See the ECMA script spec: http://www.ecma-international.org/ecma-262/5.1/#sec-12.4\n            data['callback'] = '(function(){})';\n        }\n    }\n\n    data['ip'] = this.get_config('ip')?1:0;\n    data['_'] = new Date().getTime().toString();\n\n    if (use_post) {\n        body_data = 'data=' + encodeURIComponent(data['data']);\n        delete data['data'];\n    }\n\n    url += '?' + _.HTTPBuildQuery(data);\n\n    var lib = this;\n    if ('img' in data) {\n        var img = document$1.createElement('img');\n        img.src = url;\n        document$1.body.appendChild(img);\n    } else if (use_sendBeacon) {\n        try {\n            succeeded = sendBeacon(url, body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n        try {\n            if (callback) {\n                callback(succeeded ? 1 : 0);\n            }\n        } catch (e) {\n            lib.report_error(e);\n        }\n    } else if (USE_XHR) {\n        try {\n            var req = new XMLHttpRequest();\n            req.open(options.method, url, true);\n\n            var headers = this.get_config('xhr_headers');\n            if (use_post) {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n            _.each(headers, function(headerValue, headerName) {\n                req.setRequestHeader(headerName, headerValue);\n            });\n\n            if (options.timeout_ms && typeof req.timeout !== 'undefined') {\n                req.timeout = options.timeout_ms;\n                var start_time = new Date().getTime();\n            }\n\n            // send the mp_optout cookie\n            // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n            req.withCredentials = true;\n            req.onreadystatechange = function () {\n                if (req.readyState === 4) { // XMLHttpRequest.DONE == 4, except in safari 4\n                    if (req.status === 200) {\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response;\n                                try {\n                                    response = _.JSONDecode(req.responseText);\n                                } catch (e) {\n                                    lib.report_error(e);\n                                    if (options.ignore_json_errors) {\n                                        response = req.responseText;\n                                    } else {\n                                        return;\n                                    }\n                                }\n                                callback(response);\n                            } else {\n                                callback(Number(req.responseText));\n                            }\n                        }\n                    } else {\n                        var error;\n                        if (\n                            req.timeout &&\n                            !req.status &&\n                            new Date().getTime() - start_time >= req.timeout\n                        ) {\n                            error = 'timeout';\n                        } else {\n                            error = 'Bad HTTP status: ' + req.status + ' ' + req.statusText;\n                        }\n                        lib.report_error(error);\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response_headers = req['responseHeaders'] || {};\n                                callback({status: 0, httpStatusCode: req['status'], error: error, retryAfter: response_headers['Retry-After']});\n                            } else {\n                                callback(0);\n                            }\n                        }\n                    }\n                }\n            };\n            req.send(body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n    } else {\n        var script = document$1.createElement('script');\n        script.type = 'text/javascript';\n        script.async = true;\n        script.defer = true;\n        script.src = url;\n        var s = document$1.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(script, s);\n    }\n\n    return succeeded;\n};\n\n/**\n * _execute_array() deals with processing any mixpanel function\n * calls that were called before the Mixpanel library were loaded\n * (and are thus stored in an array so they can be called later)\n *\n * Note: we fire off all the mixpanel function calls && user defined\n * functions BEFORE we fire off mixpanel tracking calls. This is so\n * identify/register/set_config calls can properly modify early\n * tracking calls.\n *\n * @param {Array} array\n */\nMixpanelLib.prototype._execute_array = function(array) {\n    var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];\n    _.each(array, function(item) {\n        if (item) {\n            fn_name = item[0];\n            if (_.isArray(fn_name)) {\n                tracking_calls.push(item); // chained call e.g. mixpanel.get_group().set()\n            } else if (typeof(item) === 'function') {\n                item.call(this);\n            } else if (_.isArray(item) && fn_name === 'alias') {\n                alias_calls.push(item);\n            } else if (_.isArray(item) && fn_name.indexOf('track') !== -1 && typeof(this[fn_name]) === 'function') {\n                tracking_calls.push(item);\n            } else {\n                other_calls.push(item);\n            }\n        }\n    }, this);\n\n    var execute = function(calls, context) {\n        _.each(calls, function(item) {\n            if (_.isArray(item[0])) {\n                // chained call\n                var caller = context;\n                _.each(item, function(call) {\n                    caller = caller[call[0]].apply(caller, call.slice(1));\n                });\n            } else {\n                this[item[0]].apply(this, item.slice(1));\n            }\n        }, context);\n    };\n\n    execute(alias_calls, this);\n    execute(other_calls, this);\n    execute(tracking_calls, this);\n};\n\n// request queueing utils\n\nMixpanelLib.prototype.are_batchers_initialized = function() {\n    return !!this.request_batchers.events;\n};\n\nMixpanelLib.prototype.get_batcher_configs = function() {\n    var queue_prefix = '__mpq_' + this.get_config('token');\n    var api_routes = this.get_config('api_routes');\n    this._batcher_configs = this._batcher_configs || {\n        events: {type: 'events', endpoint: '/' + api_routes['track'], queue_key: queue_prefix + '_ev'},\n        people: {type: 'people', endpoint: '/' + api_routes['engage'], queue_key: queue_prefix + '_pp'},\n        groups: {type: 'groups', endpoint: '/' + api_routes['groups'], queue_key: queue_prefix + '_gr'}\n    };\n    return this._batcher_configs;\n};\n\nMixpanelLib.prototype.init_batchers = function() {\n    if (!this.are_batchers_initialized()) {\n        var batcher_for = _.bind(function(attrs) {\n            return new RequestBatcher(\n                attrs.queue_key,\n                {\n                    libConfig: this['config'],\n                    errorReporter: this.get_config('error_reporter'),\n                    sendRequestFunc: _.bind(function(data, options, cb) {\n                        this._send_request(\n                            this.get_config('api_host') + attrs.endpoint,\n                            this._encode_data_for_request(data),\n                            options,\n                            this._prepare_callback(cb, data)\n                        );\n                    }, this),\n                    beforeSendHook: _.bind(function(item) {\n                        return this._run_hook('before_send_' + attrs.type, item);\n                    }, this),\n                    stopAllBatchingFunc: _.bind(this.stop_batch_senders, this),\n                    usePersistence: true\n                }\n            );\n        }, this);\n        var batcher_configs = this.get_batcher_configs();\n        this.request_batchers = {\n            events: batcher_for(batcher_configs.events),\n            people: batcher_for(batcher_configs.people),\n            groups: batcher_for(batcher_configs.groups)\n        };\n    }\n    if (this.get_config('batch_autostart')) {\n        this.start_batch_senders();\n    }\n};\n\nMixpanelLib.prototype.start_batch_senders = function() {\n    this._batchers_were_started = true;\n    if (this.are_batchers_initialized()) {\n        this._batch_requests = true;\n        _.each(this.request_batchers, function(batcher) {\n            batcher.start();\n        });\n    }\n};\n\nMixpanelLib.prototype.stop_batch_senders = function() {\n    this._batch_requests = false;\n    _.each(this.request_batchers, function(batcher) {\n        batcher.stop();\n        batcher.clear();\n    });\n};\n\n/**\n * push() keeps the standard async-array-push\n * behavior around after the lib is loaded.\n * This is only useful for external integrations that\n * do not wish to rely on our convenience methods\n * (created in the snippet).\n *\n * ### Usage:\n *     mixpanel.push(['register', { a: 'b' }]);\n *\n * @param {Array} item A [function_name, args...] array to be executed\n */\nMixpanelLib.prototype.push = function(item) {\n    this._execute_array([item]);\n};\n\n/**\n * Disable events on the Mixpanel object. If passed no arguments,\n * this function disables tracking of any event. If passed an\n * array of event names, those events will be disabled, but other\n * events will continue to be tracked.\n *\n * Note: this function does not stop other mixpanel functions from\n * firing, such as register() or people.set().\n *\n * @param {Array} [events] An array of event names to disable\n */\nMixpanelLib.prototype.disable = function(events) {\n    if (typeof(events) === 'undefined') {\n        this._flags.disable_all_events = true;\n    } else {\n        this.__disabled_events = this.__disabled_events.concat(events);\n    }\n};\n\nMixpanelLib.prototype._encode_data_for_request = function(data) {\n    var encoded_data = _.JSONEncode(data);\n    if (this.get_config('api_payload_format') === PAYLOAD_TYPE_BASE64) {\n        encoded_data = _.base64Encode(encoded_data);\n    }\n    return {'data': encoded_data};\n};\n\n// internal method for handling track vs batch-enqueue logic\nMixpanelLib.prototype._track_or_batch = function(options, callback) {\n    var truncated_data = _.truncate(options.data, 255);\n    var endpoint = options.endpoint;\n    var batcher = options.batcher;\n    var should_send_immediately = options.should_send_immediately;\n    var send_request_options = options.send_request_options || {};\n    callback = callback || NOOP_FUNC;\n\n    var request_enqueued_or_initiated = true;\n    var send_request_immediately = _.bind(function() {\n        if (!send_request_options.skip_hooks) {\n            truncated_data = this._run_hook('before_send_' + options.type, truncated_data);\n        }\n        if (truncated_data) {\n            console$1.log('MIXPANEL REQUEST:');\n            console$1.log(truncated_data);\n            return this._send_request(\n                endpoint,\n                this._encode_data_for_request(truncated_data),\n                send_request_options,\n                this._prepare_callback(callback, truncated_data)\n            );\n        } else {\n            return null;\n        }\n    }, this);\n\n    if (this._batch_requests && !should_send_immediately) {\n        batcher.enqueue(truncated_data).then(function(succeeded) {\n            if (succeeded) {\n                callback(1, truncated_data);\n            } else {\n                send_request_immediately();\n            }\n        });\n    } else {\n        request_enqueued_or_initiated = send_request_immediately();\n    }\n\n    return request_enqueued_or_initiated && truncated_data;\n};\n\n/**\n * Track an event. This is the most important and\n * frequently used Mixpanel function.\n *\n * ### Usage:\n *\n *     // track an event named 'Registered'\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n *     // track an event using navigator.sendBeacon\n *     mixpanel.track('Left page', {'duration_seconds': 35}, {transport: 'sendBeacon'});\n *\n * To track link clicks or form submissions, see track_links() or track_forms().\n *\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Object} [options] Optional configuration for this track request.\n * @param {String} [options.transport] Transport method for network request ('xhr' or 'sendBeacon').\n * @param {Boolean} [options.send_immediately] Whether to bypass batching/queueing and send track request immediately.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    var transport = options['transport']; // external API, don't minify 'transport' prop\n    if (transport) {\n        options.transport = transport; // 'transport' prop name can be minified internally\n    }\n    var should_send_immediately = options['send_immediately'];\n    if (typeof callback !== 'function') {\n        callback = NOOP_FUNC;\n    }\n\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.track');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        callback(0);\n        return;\n    }\n\n    // set defaults\n    properties = _.extend({}, properties);\n    properties['token'] = this.get_config('token');\n\n    // set $duration if time_event was previously called for this event\n    var start_timestamp = this['persistence'].remove_event_timer(event_name);\n    if (!_.isUndefined(start_timestamp)) {\n        var duration_in_ms = new Date().getTime() - start_timestamp;\n        properties['$duration'] = parseFloat((duration_in_ms / 1000).toFixed(3));\n    }\n\n    this._set_default_superprops();\n\n    var marketing_properties = this.get_config('track_marketing')\n        ? _.info.marketingParams()\n        : {};\n\n    // note: extend writes to the first object, so lets make sure we\n    // don't write to the persistence properties object and info\n    // properties object by passing in a new object\n\n    // update properties with pageview info and super-properties\n    properties = _.extend(\n        {},\n        _.info.properties({'mp_loader': this.get_config('mp_loader')}),\n        marketing_properties,\n        this['persistence'].properties(),\n        this.unpersisted_superprops,\n        this.get_session_recording_properties(),\n        properties\n    );\n\n    var property_blacklist = this.get_config('property_blacklist');\n    if (_.isArray(property_blacklist)) {\n        _.each(property_blacklist, function(blacklisted_prop) {\n            delete properties[blacklisted_prop];\n        });\n    } else {\n        this.report_error('Invalid value for property_blacklist config: ' + property_blacklist);\n    }\n\n    var data = {\n        'event': event_name,\n        'properties': properties\n    };\n    var ret = this._track_or_batch({\n        type: 'events',\n        data: data,\n        endpoint: this.get_config('api_host') + '/' + this.get_config('api_routes')['track'],\n        batcher: this.request_batchers.events,\n        should_send_immediately: should_send_immediately,\n        send_request_options: options\n    }, callback);\n\n    return ret;\n});\n\n/**\n * Register the current user into one/many groups.\n *\n * ### Usage:\n *\n *      mixpanel.set_group('company', ['mixpanel', 'google']) // an array of IDs\n *      mixpanel.set_group('company', 'mixpanel')\n *      mixpanel.set_group('company', 128746312)\n *\n * @param {String} group_key Group key\n * @param {Array|String|Number} group_ids An array of group IDs, or a singular group ID\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n *\n */\nMixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {\n    if (!_.isArray(group_ids)) {\n        group_ids = [group_ids];\n    }\n    var prop = {};\n    prop[group_key] = group_ids;\n    this.register(prop);\n    return this['people'].set(group_key, group_ids, callback);\n});\n\n/**\n * Add a new group for this user.\n *\n * ### Usage:\n *\n *      mixpanel.add_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_values = this.get_property(group_key);\n    var prop = {};\n    if (old_values === undefined) {\n        prop[group_key] = [group_id];\n        this.register(prop);\n    } else {\n        if (old_values.indexOf(group_id) === -1) {\n            old_values.push(group_id);\n            prop[group_key] = old_values;\n            this.register(prop);\n        }\n    }\n    return this['people'].union(group_key, group_id, callback);\n});\n\n/**\n * Remove a group from this user.\n *\n * ### Usage:\n *\n *      mixpanel.remove_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_value = this.get_property(group_key);\n    // if the value doesn't exist, the persistent store is unchanged\n    if (old_value !== undefined) {\n        var idx = old_value.indexOf(group_id);\n        if (idx > -1) {\n            old_value.splice(idx, 1);\n            this.register({group_key: old_value});\n        }\n        if (old_value.length === 0) {\n            this.unregister(group_key);\n        }\n    }\n    return this['people'].remove(group_key, group_id, callback);\n});\n\n/**\n * Track an event with specific groups.\n *\n * ### Usage:\n *\n *      mixpanel.track_with_groups('purchase', {'product': 'iphone'}, {'University': ['UCB', 'UCLA']})\n *\n * @param {String} event_name The name of the event (see `mixpanel.track()`)\n * @param {Object=} properties A set of properties to include with the event you're sending (see `mixpanel.track()`)\n * @param {Object=} groups An object mapping group name keys to one or more values\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {\n    var tracking_props = _.extend({}, properties || {});\n    _.each(groups, function(v, k) {\n        if (v !== null && v !== undefined) {\n            tracking_props[k] = v;\n        }\n    });\n    return this.track(event_name, tracking_props, callback);\n});\n\nMixpanelLib.prototype._create_map_key = function (group_key, group_id) {\n    return group_key + '_' + JSON.stringify(group_id);\n};\n\nMixpanelLib.prototype._remove_group_from_cache = function (group_key, group_id) {\n    delete this._cached_groups[this._create_map_key(group_key, group_id)];\n};\n\n/**\n * Look up reference to a Mixpanel group\n *\n * ### Usage:\n *\n *       mixpanel.get_group(group_key, group_id)\n *\n * @param {String} group_key Group key\n * @param {Object} group_id A valid Mixpanel property type\n * @returns {Object} A MixpanelGroup identifier\n */\nMixpanelLib.prototype.get_group = function (group_key, group_id) {\n    var map_key = this._create_map_key(group_key, group_id);\n    var group = this._cached_groups[map_key];\n    if (group === undefined || group._group_key !== group_key || group._group_id !== group_id) {\n        group = new MixpanelGroup();\n        group._init(this, group_key, group_id);\n        this._cached_groups[map_key] = group;\n    }\n    return group;\n};\n\n/**\n * Track a default Mixpanel page view event, which includes extra default event properties to\n * improve page view data.\n *\n * ### Usage:\n *\n *     // track a default $mp_web_page_view event\n *     mixpanel.track_pageview();\n *\n *     // track a page view event with additional event properties\n *     mixpanel.track_pageview({'ab_test_variant': 'card-layout-b'});\n *\n *     // example approach to track page views on different page types as event properties\n *     mixpanel.track_pageview({'page': 'pricing'});\n *     mixpanel.track_pageview({'page': 'homepage'});\n *\n *     // UNCOMMON: Tracking a page view event with a custom event_name option. NOT expected to be used for\n *     // individual pages on the same site or product. Use cases for custom event_name may be page\n *     // views on different products or internal applications that are considered completely separate\n *     mixpanel.track_pageview({'page': 'customer-search'}, {'event_name': '[internal] Admin Page View'});\n *\n * ### Notes:\n *\n * The `config.track_pageview` option for <a href=\"#mixpanelinit\">mixpanel.init()</a>\n * may be turned on for tracking page loads automatically.\n *\n *     // track only page loads\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: true});\n *\n *     // track when the URL changes in any manner\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'full-url'});\n *\n *     // track when the URL changes, ignoring any changes in the hash part\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path-and-query-string'});\n *\n *     // track when the path changes, ignoring any query parameter or hash changes\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path'});\n *\n * @param {Object} [properties] An optional set of additional properties to send with the page view event\n * @param {Object} [options] Page view tracking options\n * @param {String} [options.event_name] - Alternate name for the tracking event\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(properties, options) {\n    if (typeof properties !== 'object') {\n        properties = {};\n    }\n    options = options || {};\n    var event_name = options['event_name'] || '$mp_web_page_view';\n\n    var default_page_properties = _.extend(\n        _.info.mpPageViewProperties(),\n        _.info.campaignParams(),\n        _.info.clickParams()\n    );\n\n    var event_properties = _.extend(\n        {},\n        default_page_properties,\n        properties\n    );\n\n    return this.track(event_name, event_properties);\n});\n\n/**\n * Track clicks on a set of document elements. Selector must be a\n * valid query. Elements must exist on the page at the time track_links is called.\n *\n * ### Usage:\n *\n *     // track click for link id #nav\n *     mixpanel.track_links('#nav', 'Clicked Nav Link');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the Mixpanel\n * servers to respond. If they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] A properties object or function that returns a dictionary of properties when passed a DOMElement\n */\nMixpanelLib.prototype.track_links = function() {\n    return this._track_dom.call(this, LinkTracker, arguments);\n};\n\n/**\n * Track form submissions. Selector must be a valid query.\n *\n * ### Usage:\n *\n *     // track submission for form id 'register'\n *     mixpanel.track_forms('#register', 'Created Account');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the mixpanel\n * servers to respond, if they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement\n */\nMixpanelLib.prototype.track_forms = function() {\n    return this._track_dom.call(this, FormTracker, arguments);\n};\n\n/**\n * Time an event by including the time between this call and a\n * later 'track' call for the same event in the properties sent\n * with the event.\n *\n * ### Usage:\n *\n *     // time an event named 'Registered'\n *     mixpanel.time_event('Registered');\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n * When called for a particular event name, the next track call for that event\n * name will include the elapsed time between the 'time_event' and 'track'\n * calls. This value is stored as seconds in the '$duration' property.\n *\n * @param {String} event_name The name of the event.\n */\nMixpanelLib.prototype.time_event = function(event_name) {\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.time_event');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        return;\n    }\n\n    this['persistence'].set_event_timer(event_name,  new Date().getTime());\n};\n\nvar REGISTER_DEFAULTS = {\n    'persistent': true\n};\n/**\n * Helper to parse options param for register methods, maintaining\n * legacy support for plain \"days\" param instead of options object\n * @param {Number|Object} [days_or_options] 'days' option (Number), or Options object for register methods\n * @returns {Object} options object\n */\nvar options_for_register = function(days_or_options) {\n    var options;\n    if (_.isObject(days_or_options)) {\n        options = days_or_options;\n    } else if (!_.isUndefined(days_or_options)) {\n        options = {'days': days_or_options};\n    } else {\n        options = {};\n    }\n    return _.extend({}, REGISTER_DEFAULTS, options);\n};\n\n/**\n * Register a set of super properties, which are included with all\n * events. This will overwrite previous super property values.\n *\n * ### Usage:\n *\n *     // register 'Gender' as a super property\n *     mixpanel.register({'Gender': 'Female'});\n *\n *     // register several super properties when a user signs up\n *     mixpanel.register({\n *         'Email': 'jdoe@example.com',\n *         'Account Type': 'Free'\n *     });\n *\n *     // register only for the current pageload\n *     mixpanel.register({'Name': 'Pat'}, {persistent: false});\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register = function(props, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register(props, options['days']);\n    } else {\n        _.extend(this.unpersisted_superprops, props);\n    }\n};\n\n/**\n * Register a set of super properties only once. This will not\n * overwrite previous super property values, unlike register().\n *\n * ### Usage:\n *\n *     // register a super property for the first time only\n *     mixpanel.register_once({\n *         'First Login Date': new Date().toISOString()\n *     });\n *\n *     // register once, only for the current pageload\n *     mixpanel.register_once({\n *         'First interaction time': new Date().toISOString()\n *     }, 'None', {persistent: false});\n *\n * ### Notes:\n *\n * If default_value is specified, current super properties\n * with that value will be overwritten.\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {*} [default_value] Value to override if already set in super properties (ex: 'False') Default: 'None'\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register_once(props, default_value, options['days']);\n    } else {\n        if (typeof(default_value) === 'undefined') {\n            default_value = 'None';\n        }\n        _.each(props, function(val, prop) {\n            if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {\n                this.unpersisted_superprops[prop] = val;\n            }\n        }, this);\n    }\n};\n\n/**\n * Delete a super property stored with the current user.\n *\n * @param {String} property The name of the super property to remove\n * @param {Object} [options]\n * @param {boolean} [options.persistent=true] - whether to look in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.unregister = function(property, options) {\n    options = options_for_register(options);\n    if (options['persistent']) {\n        this['persistence'].unregister(property);\n    } else {\n        delete this.unpersisted_superprops[property];\n    }\n};\n\nMixpanelLib.prototype._register_single = function(prop, value) {\n    var props = {};\n    props[prop] = value;\n    this.register(props);\n};\n\n/**\n * Identify a user with a unique ID to track user activity across\n * devices, tie a user to their events, and create a user profile.\n * If you never call this method, unique visitors are tracked using\n * a UUID generated the first time they visit the site.\n *\n * Call identify when you know the identity of the current user,\n * typically after login or signup. We recommend against using\n * identify for anonymous visitors to your site.\n *\n * ### Notes:\n * If your project has\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the identify method will connect pre- and\n * post-authentication events when appropriate.\n *\n * If your project does not have ID Merge enabled, identify will\n * change the user's local distinct_id to the unique ID you pass.\n * Events tracked prior to authentication will not be connected\n * to the same user identity. If ID Merge is disabled, alias can\n * be used to connect pre- and post-registration events.\n *\n * @param {String} [unique_id] A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.\n */\nMixpanelLib.prototype.identify = function(\n    new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    // Optional Parameters\n    //  _set_callback:function  A callback to be run if and when the People set queue is flushed\n    //  _add_callback:function  A callback to be run if and when the People add queue is flushed\n    //  _append_callback:function  A callback to be run if and when the People append queue is flushed\n    //  _set_once_callback:function  A callback to be run if and when the People set_once queue is flushed\n    //  _union_callback:function  A callback to be run if and when the People union queue is flushed\n    //  _unset_callback:function  A callback to be run if and when the People unset queue is flushed\n\n    var previous_distinct_id = this.get_distinct_id();\n    if (new_distinct_id && previous_distinct_id !== new_distinct_id) {\n        // we allow the following condition if previous distinct_id is same as new_distinct_id\n        // so that you can force flush people updates for anonymous profiles.\n        if (typeof new_distinct_id === 'string' && new_distinct_id.indexOf(DEVICE_ID_PREFIX) === 0) {\n            this.report_error('distinct_id cannot have $device: prefix');\n            return -1;\n        }\n        this.register({'$user_id': new_distinct_id});\n    }\n\n    if (!this.get_property('$device_id')) {\n        // The persisted distinct id might not actually be a device id at all\n        // it might be a distinct id of the user from before\n        var device_id = previous_distinct_id;\n        this.register_once({\n            '$had_persisted_distinct_id': true,\n            '$device_id': device_id\n        }, '');\n    }\n\n    // identify only changes the distinct id if it doesn't match either the existing or the alias;\n    // if it's new, blow away the alias as well.\n    if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {\n        this.unregister(ALIAS_ID_KEY);\n        this.register({'distinct_id': new_distinct_id});\n    }\n    this._flags.identify_called = true;\n    // Flush any queued up people requests\n    this['people']._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);\n\n    // send an $identify event any time the distinct_id is changing - logic on the server\n    // will determine whether or not to do anything with it.\n    if (new_distinct_id !== previous_distinct_id) {\n        this.track('$identify', {\n            'distinct_id': new_distinct_id,\n            '$anon_distinct_id': previous_distinct_id\n        }, {skip_hooks: true});\n    }\n};\n\n/**\n * Clears super properties and generates a new random distinct_id for this instance.\n * Useful for clearing data when a user logs out.\n */\nMixpanelLib.prototype.reset = function() {\n    this['persistence'].clear();\n    this._flags.identify_called = false;\n    var uuid = _.UUID();\n    this.register_once({\n        'distinct_id': DEVICE_ID_PREFIX + uuid,\n        '$device_id': uuid\n    }, '');\n};\n\n/**\n * Returns the current distinct id of the user. This is either the id automatically\n * generated by the library or the id that has been passed by a call to identify().\n *\n * ### Notes:\n *\n * get_distinct_id() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // set distinct_id after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             distinct_id = mixpanel.get_distinct_id();\n *         }\n *     });\n */\nMixpanelLib.prototype.get_distinct_id = function() {\n    return this.get_property('distinct_id');\n};\n\n/**\n * The alias method creates an alias which Mixpanel will use to\n * remap one id to another. Multiple aliases can point to the\n * same identifier.\n *\n * The following is a valid use of alias:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // You can add multiple id aliases to the existing ID\n *     mixpanel.alias('newer_id', 'existing_id');\n *\n * Aliases can also be chained - the following is a valid example:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // chain newer_id - new_id - existing_id\n *     mixpanel.alias('newer_id', 'new_id');\n *\n * Aliases cannot point to multiple identifiers - the following\n * example will not work:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // this is invalid as 'new_id' already points to 'existing_id'\n *     mixpanel.alias('new_id', 'newer_id');\n *\n * ### Notes:\n *\n * If your project does not have\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the best practice is to call alias once when a unique\n * ID is first created for a user (e.g., when a user first registers\n * for an account). Do not use alias multiple times for a single\n * user without ID Merge enabled.\n *\n * @param {String} alias A unique identifier that you want to use for this user in the future.\n * @param {String} [original] The current identifier being used for this user.\n */\nMixpanelLib.prototype.alias = function(alias, original) {\n    // If the $people_distinct_id key exists in persistence, there has been a previous\n    // mixpanel.people.identify() call made for this user. It is VERY BAD to make an alias with\n    // this ID, as it will duplicate users.\n    if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {\n        this.report_error('Attempting to create alias for existing People user - aborting.');\n        return -2;\n    }\n\n    var _this = this;\n    if (_.isUndefined(original)) {\n        original = this.get_distinct_id();\n    }\n    if (alias !== original) {\n        this._register_single(ALIAS_ID_KEY, alias);\n        return this.track('$create_alias', {\n            'alias': alias,\n            'distinct_id': original\n        }, {\n            skip_hooks: true\n        }, function() {\n            // Flush the people queue\n            _this.identify(alias);\n        });\n    } else {\n        this.report_error('alias matches current distinct_id - skipping api call.');\n        this.identify(alias);\n        return -1;\n    }\n};\n\n/**\n * Provide a string to recognize the user by. The string passed to\n * this method will appear in the Mixpanel Streams product rather\n * than an automatically generated name. Name tags do not have to\n * be unique.\n *\n * This value will only be included in Streams data.\n *\n * @param {String} name_tag A human readable name for the user\n * @deprecated\n */\nMixpanelLib.prototype.name_tag = function(name_tag) {\n    this._register_single('mp_name_tag', name_tag);\n};\n\n/**\n * Update the configuration of a mixpanel library instance.\n *\n * The default config is:\n *\n *     {\n *       // host for requests (customizable for e.g. a local proxy)\n *       api_host: 'https://api-js.mixpanel.com',\n *\n *       // endpoints for different types of requests\n *       api_routes: {\n *         track: 'track/',\n *         engage: 'engage/',\n *         groups: 'groups/',\n *       }\n *\n *       // HTTP method for tracking requests\n *       api_method: 'POST'\n *\n *       // transport for sending requests ('XHR' or 'sendBeacon')\n *       // NB: sendBeacon should only be used for scenarios such as\n *       // page unload where a \"best-effort\" attempt to send is\n *       // acceptable; the sendBeacon API does not support callbacks\n *       // or any way to know the result of the request. Mixpanel\n *       // tracking via sendBeacon will not support any event-\n *       // batching or retry mechanisms.\n *       api_transport: 'XHR'\n *\n *       // request-batching/queueing/retry\n *       batch_requests: true,\n *\n *       // maximum number of events/updates to send in a single\n *       // network request\n *       batch_size: 50,\n *\n *       // milliseconds to wait between sending batch requests\n *       batch_flush_interval_ms: 5000,\n *\n *       // milliseconds to wait for network responses to batch requests\n *       // before they are considered timed-out and retried\n *       batch_request_timeout_ms: 90000,\n *\n *       // override value for cookie domain, only useful for ensuring\n *       // correct cross-subdomain cookies on unusual domains like\n *       // subdomain.mainsite.avocat.fr; NB this cannot be used to\n *       // set cookies on a different domain than the current origin\n *       cookie_domain: ''\n *\n *       // super properties cookie expiration (in days)\n *       cookie_expiration: 365\n *\n *       // if true, cookie will be set with SameSite=None; Secure\n *       // this is only useful in special situations, like embedded\n *       // 3rd-party iframes that set up a Mixpanel instance\n *       cross_site_cookie: false\n *\n *       // super properties span subdomains\n *       cross_subdomain_cookie: true\n *\n *       // debug mode\n *       debug: false\n *\n *       // if this is true, the mixpanel cookie or localStorage entry\n *       // will be deleted, and no user persistence will take place\n *       disable_persistence: false\n *\n *       // if this is true, Mixpanel will automatically determine\n *       // City, Region and Country data using the IP address of\n *       //the client\n *       ip: true\n *\n *       // opt users out of tracking by this Mixpanel instance by default\n *       opt_out_tracking_by_default: false\n *\n *       // opt users out of browser data storage by this Mixpanel instance by default\n *       opt_out_persistence_by_default: false\n *\n *       // persistence mechanism used by opt-in/opt-out methods - cookie\n *       // or localStorage - falls back to cookie if localStorage is unavailable\n *       opt_out_tracking_persistence_type: 'localStorage'\n *\n *       // customize the name of cookie/localStorage set by opt-in/opt-out methods\n *       opt_out_tracking_cookie_prefix: null\n *\n *       // type of persistent store for super properties (cookie/\n *       // localStorage) if set to 'localStorage', any existing\n *       // mixpanel cookie value with the same persistence_name\n *       // will be transferred to localStorage and deleted\n *       persistence: 'cookie'\n *\n *       // name for super properties persistent store\n *       persistence_name: ''\n *\n *       // names of properties/superproperties which should never\n *       // be sent with track() calls\n *       property_blacklist: []\n *\n *       // if this is true, mixpanel cookies will be marked as\n *       // secure, meaning they will only be transmitted over https\n *       secure_cookie: false\n *\n *       // disables enriching user profiles with first touch marketing data\n *       skip_first_touch_marketing: false\n *\n *       // the amount of time track_links will\n *       // wait for Mixpanel's servers to respond\n *       track_links_timeout: 300\n *\n *       // adds any UTM parameters and click IDs present on the page to any events fired\n *       track_marketing: true\n *\n *       // enables automatic page view tracking using default page view events through\n *       // the track_pageview() method\n *       track_pageview: false\n *\n *       // if you set upgrade to be true, the library will check for\n *       // a cookie from our old js library and import super\n *       // properties from it, then the old cookie is deleted\n *       // The upgrade config option only works in the initialization,\n *       // so make sure you set it when you create the library.\n *       upgrade: false\n *\n *       // extra HTTP request headers to set for each API request, in\n *       // the format {'Header-Name': value}\n *       xhr_headers: {}\n *\n *       // whether to ignore or respect the web browser's Do Not Track setting\n *       ignore_dnt: false\n *     }\n *\n *\n * @param {Object} config A dictionary of new configuration values to update\n */\nMixpanelLib.prototype.set_config = function(config) {\n    if (_.isObject(config)) {\n        _.extend(this['config'], config);\n\n        var new_batch_size = config['batch_size'];\n        if (new_batch_size) {\n            _.each(this.request_batchers, function(batcher) {\n                batcher.resetBatchSize();\n            });\n        }\n\n        if (!this.get_config('persistence_name')) {\n            this['config']['persistence_name'] = this['config']['cookie_name'];\n        }\n        if (!this.get_config('disable_persistence')) {\n            this['config']['disable_persistence'] = this['config']['disable_cookie'];\n        }\n\n        if (this['persistence']) {\n            this['persistence'].update_config(this['config']);\n        }\n        Config.DEBUG = Config.DEBUG || this.get_config('debug');\n    }\n};\n\n/**\n * returns the current config object for the library.\n */\nMixpanelLib.prototype.get_config = function(prop_name) {\n    return this['config'][prop_name];\n};\n\n/**\n * Fetch a hook function from config, with safe default, and run it\n * against the given arguments\n * @param {string} hook_name which hook to retrieve\n * @returns {any|null} return value of user-provided hook, or null if nothing was returned\n */\nMixpanelLib.prototype._run_hook = function(hook_name) {\n    var ret = (this['config']['hooks'][hook_name] || IDENTITY_FUNC).apply(this, slice.call(arguments, 1));\n    if (typeof ret === 'undefined') {\n        this.report_error(hook_name + ' hook did not return a value');\n        ret = null;\n    }\n    return ret;\n};\n\n/**\n * Returns the value of the super property named property_name. If no such\n * property is set, get_property() will return the undefined value.\n *\n * ### Notes:\n *\n * get_property() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // grab value for 'user_id' after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             user_id = mixpanel.get_property('user_id');\n *         }\n *     });\n *\n * @param {String} property_name The name of the super property you want to retrieve\n */\nMixpanelLib.prototype.get_property = function(property_name) {\n    return this['persistence'].load_prop([property_name]);\n};\n\nMixpanelLib.prototype.toString = function() {\n    var name = this.get_config('name');\n    if (name !== PRIMARY_INSTANCE_NAME) {\n        name = PRIMARY_INSTANCE_NAME + '.' + name;\n    }\n    return name;\n};\n\nMixpanelLib.prototype._event_is_disabled = function(event_name) {\n    return _.isBlockedUA(userAgent) ||\n        this._flags.disable_all_events ||\n        _.include(this.__disabled_events, event_name);\n};\n\n// perform some housekeeping around GDPR opt-in/out state\nMixpanelLib.prototype._gdpr_init = function() {\n    var is_localStorage_requested = this.get_config('opt_out_tracking_persistence_type') === 'localStorage';\n\n    // try to convert opt-in/out cookies to localStorage if possible\n    if (is_localStorage_requested && _.localStorage.is_supported()) {\n        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({'persistence_type': 'cookie'})) {\n            this.opt_in_tracking({'enable_persistence': false});\n        }\n        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({'persistence_type': 'cookie'})) {\n            this.opt_out_tracking({'clear_persistence': false});\n        }\n        this.clear_opt_in_out_tracking({\n            'persistence_type': 'cookie',\n            'enable_persistence': false\n        });\n    }\n\n    // check whether the user has already opted out - if so, clear & disable persistence\n    if (this.has_opted_out_tracking()) {\n        this._gdpr_update_persistence({'clear_persistence': true});\n\n    // check whether we should opt out by default\n    // note: we don't clear persistence here by default since opt-out default state is often\n    //       used as an initial state while GDPR information is being collected\n    } else if (!this.has_opted_in_tracking() && (\n        this.get_config('opt_out_tracking_by_default') || _.cookie.get('mp_optout')\n    )) {\n        _.cookie.remove('mp_optout');\n        this.opt_out_tracking({\n            'clear_persistence': this.get_config('opt_out_persistence_by_default')\n        });\n    }\n};\n\n/**\n * Enable or disable persistence based on options\n * only enable/disable if persistence is not already in this state\n * @param {boolean} [options.clear_persistence] If true, will delete all data stored by the sdk in persistence and disable it\n * @param {boolean} [options.enable_persistence] If true, will re-enable sdk persistence\n */\nMixpanelLib.prototype._gdpr_update_persistence = function(options) {\n    var disabled;\n    if (options && options['clear_persistence']) {\n        disabled = true;\n    } else if (options && options['enable_persistence']) {\n        disabled = false;\n    } else {\n        return;\n    }\n\n    if (!this.get_config('disable_persistence') && this['persistence'].disabled !== disabled) {\n        this['persistence'].set_disabled(disabled);\n    }\n\n    if (disabled) {\n        this.stop_batch_senders();\n    } else {\n        // only start batchers after opt-in if they have previously been started\n        // in order to avoid unintentionally starting up batching for the first time\n        if (this._batchers_were_started) {\n            this.start_batch_senders();\n        }\n    }\n};\n\n// call a base gdpr function after constructing the appropriate token and options args\nMixpanelLib.prototype._gdpr_call_func = function(func, options) {\n    options = _.extend({\n        'track': _.bind(this.track, this),\n        'persistence_type': this.get_config('opt_out_tracking_persistence_type'),\n        'cookie_prefix': this.get_config('opt_out_tracking_cookie_prefix'),\n        'cookie_expiration': this.get_config('cookie_expiration'),\n        'cross_site_cookie': this.get_config('cross_site_cookie'),\n        'cross_subdomain_cookie': this.get_config('cross_subdomain_cookie'),\n        'cookie_domain': this.get_config('cookie_domain'),\n        'secure_cookie': this.get_config('secure_cookie'),\n        'ignore_dnt': this.get_config('ignore_dnt')\n    }, options);\n\n    // check if localStorage can be used for recording opt out status, fall back to cookie if not\n    if (!_.localStorage.is_supported()) {\n        options['persistence_type'] = 'cookie';\n    }\n\n    return func(this.get_config('token'), {\n        track: options['track'],\n        trackEventName: options['track_event_name'],\n        trackProperties: options['track_properties'],\n        persistenceType: options['persistence_type'],\n        persistencePrefix: options['cookie_prefix'],\n        cookieDomain: options['cookie_domain'],\n        cookieExpiration: options['cookie_expiration'],\n        crossSiteCookie: options['cross_site_cookie'],\n        crossSubdomainCookie: options['cross_subdomain_cookie'],\n        secureCookie: options['secure_cookie'],\n        ignoreDnt: options['ignore_dnt']\n    });\n};\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user in\n *     mixpanel.opt_in_tracking();\n *\n *     // opt user in with specific event name, properties, cookie configuration\n *     mixpanel.opt_in_tracking({\n *         track_event_name: 'User opted in',\n *         track_event_properties: {\n *             'Email': 'jdoe@example.com'\n *         },\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {function} [options.track] Function used for tracking a Mixpanel event to record the opt-in action (default is this Mixpanel instance's track method)\n * @param {string} [options.track_event_name=$opt_in] Event name to be used for tracking the opt-in action\n * @param {Object} [options.track_properties] Set of properties to be tracked along with the opt-in action\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_in_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(optIn, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user out\n *     mixpanel.opt_out_tracking();\n *\n *     // opt user out with different cookie configuration from Mixpanel instance\n *     mixpanel.opt_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.delete_user=true] If true, will delete the currently identified user's profile and clear all charges after opting the user out\n * @param {boolean} [options.clear_persistence=true] If true, will delete all data stored by the sdk in persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_out_tracking = function(options) {\n    options = _.extend({\n        'clear_persistence': true,\n        'delete_user': true\n    }, options);\n\n    // delete user and clear charges since these methods may be disabled by opt-out\n    if (options['delete_user'] && this['people'] && this['people']._identify_called()) {\n        this['people'].delete_user();\n        this['people'].clear_charges();\n    }\n\n    this._gdpr_call_func(optOut, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_in = mixpanel.has_opted_in_tracking();\n *     // use has_opted_in value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-in status\n */\nMixpanelLib.prototype.has_opted_in_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedIn, options);\n};\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_out = mixpanel.has_opted_out_tracking();\n *     // use has_opted_out value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-out status\n */\nMixpanelLib.prototype.has_opted_out_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedOut, options);\n};\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // clear user's opt-in/out status\n *     mixpanel.clear_opt_in_out_tracking();\n *\n *     // clear user's opt-in/out status with specific cookie configuration - should match\n *     // configuration used when opt_in_tracking/opt_out_tracking methods were called.\n *     mixpanel.clear_opt_in_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(clearOptInOut, options);\n    this._gdpr_update_persistence(options);\n};\n\nMixpanelLib.prototype.report_error = function(msg, err) {\n    console$1.error.apply(console$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.get_config('error_reporter')(msg, err);\n    } catch(err) {\n        console$1.error(err);\n    }\n};\n\n// EXPORTS (for closure compiler)\n\n// MixpanelLib Exports\nMixpanelLib.prototype['init']                               = MixpanelLib.prototype.init;\nMixpanelLib.prototype['reset']                              = MixpanelLib.prototype.reset;\nMixpanelLib.prototype['disable']                            = MixpanelLib.prototype.disable;\nMixpanelLib.prototype['time_event']                         = MixpanelLib.prototype.time_event;\nMixpanelLib.prototype['track']                              = MixpanelLib.prototype.track;\nMixpanelLib.prototype['track_links']                        = MixpanelLib.prototype.track_links;\nMixpanelLib.prototype['track_forms']                        = MixpanelLib.prototype.track_forms;\nMixpanelLib.prototype['track_pageview']                     = MixpanelLib.prototype.track_pageview;\nMixpanelLib.prototype['register']                           = MixpanelLib.prototype.register;\nMixpanelLib.prototype['register_once']                      = MixpanelLib.prototype.register_once;\nMixpanelLib.prototype['unregister']                         = MixpanelLib.prototype.unregister;\nMixpanelLib.prototype['identify']                           = MixpanelLib.prototype.identify;\nMixpanelLib.prototype['alias']                              = MixpanelLib.prototype.alias;\nMixpanelLib.prototype['name_tag']                           = MixpanelLib.prototype.name_tag;\nMixpanelLib.prototype['set_config']                         = MixpanelLib.prototype.set_config;\nMixpanelLib.prototype['get_config']                         = MixpanelLib.prototype.get_config;\nMixpanelLib.prototype['get_property']                       = MixpanelLib.prototype.get_property;\nMixpanelLib.prototype['get_distinct_id']                    = MixpanelLib.prototype.get_distinct_id;\nMixpanelLib.prototype['toString']                           = MixpanelLib.prototype.toString;\nMixpanelLib.prototype['opt_out_tracking']                   = MixpanelLib.prototype.opt_out_tracking;\nMixpanelLib.prototype['opt_in_tracking']                    = MixpanelLib.prototype.opt_in_tracking;\nMixpanelLib.prototype['has_opted_out_tracking']             = MixpanelLib.prototype.has_opted_out_tracking;\nMixpanelLib.prototype['has_opted_in_tracking']              = MixpanelLib.prototype.has_opted_in_tracking;\nMixpanelLib.prototype['clear_opt_in_out_tracking']          = MixpanelLib.prototype.clear_opt_in_out_tracking;\nMixpanelLib.prototype['get_group']                          = MixpanelLib.prototype.get_group;\nMixpanelLib.prototype['set_group']                          = MixpanelLib.prototype.set_group;\nMixpanelLib.prototype['add_group']                          = MixpanelLib.prototype.add_group;\nMixpanelLib.prototype['remove_group']                       = MixpanelLib.prototype.remove_group;\nMixpanelLib.prototype['track_with_groups']                  = MixpanelLib.prototype.track_with_groups;\nMixpanelLib.prototype['start_batch_senders']                = MixpanelLib.prototype.start_batch_senders;\nMixpanelLib.prototype['stop_batch_senders']                 = MixpanelLib.prototype.stop_batch_senders;\nMixpanelLib.prototype['start_session_recording']            = MixpanelLib.prototype.start_session_recording;\nMixpanelLib.prototype['stop_session_recording']             = MixpanelLib.prototype.stop_session_recording;\nMixpanelLib.prototype['get_session_recording_properties']   = MixpanelLib.prototype.get_session_recording_properties;\nMixpanelLib.prototype['get_session_replay_url']             = MixpanelLib.prototype.get_session_replay_url;\nMixpanelLib.prototype['DEFAULT_API_ROUTES']                 = DEFAULT_API_ROUTES;\n\n// MixpanelPersistence Exports\nMixpanelPersistence.prototype['properties']            = MixpanelPersistence.prototype.properties;\nMixpanelPersistence.prototype['update_search_keyword'] = MixpanelPersistence.prototype.update_search_keyword;\nMixpanelPersistence.prototype['update_referrer_info']  = MixpanelPersistence.prototype.update_referrer_info;\nMixpanelPersistence.prototype['get_cross_subdomain']   = MixpanelPersistence.prototype.get_cross_subdomain;\nMixpanelPersistence.prototype['clear']                 = MixpanelPersistence.prototype.clear;\n\n\nvar instances = {};\nvar extend_mp = function() {\n    // add all the sub mixpanel instances\n    _.each(instances, function(instance, name) {\n        if (name !== PRIMARY_INSTANCE_NAME) { mixpanel_master[name] = instance; }\n    });\n\n    // add private functions as _\n    mixpanel_master['_'] = _;\n};\n\nvar override_mp_init_func = function() {\n    // we override the snippets init function to handle the case where a\n    // user initializes the mixpanel library after the script loads & runs\n    mixpanel_master['init'] = function(token, config, name) {\n        if (name) {\n            // initialize a sub library\n            if (!mixpanel_master[name]) {\n                mixpanel_master[name] = instances[name] = create_mplib(token, config, name);\n                mixpanel_master[name]._loaded();\n            }\n            return mixpanel_master[name];\n        } else {\n            var instance = mixpanel_master;\n\n            if (instances[PRIMARY_INSTANCE_NAME]) {\n                // main mixpanel lib already initialized\n                instance = instances[PRIMARY_INSTANCE_NAME];\n            } else if (token) {\n                // intialize the main mixpanel lib\n                instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);\n                instance._loaded();\n                instances[PRIMARY_INSTANCE_NAME] = instance;\n            }\n\n            mixpanel_master = instance;\n            if (init_type === INIT_SNIPPET) {\n                win[PRIMARY_INSTANCE_NAME] = mixpanel_master;\n            }\n            extend_mp();\n        }\n    };\n};\n\nvar add_dom_loaded_handler = function() {\n    // Cross browser DOM Loaded support\n    function dom_loaded_handler() {\n        // function flag since we only want to execute this once\n        if (dom_loaded_handler.done) { return; }\n        dom_loaded_handler.done = true;\n\n        DOM_LOADED = true;\n        ENQUEUE_REQUESTS = false;\n\n        _.each(instances, function(inst) {\n            inst._dom_loaded();\n        });\n    }\n\n    function do_scroll_check() {\n        try {\n            document$1.documentElement.doScroll('left');\n        } catch(e) {\n            setTimeout(do_scroll_check, 1);\n            return;\n        }\n\n        dom_loaded_handler();\n    }\n\n    if (document$1.addEventListener) {\n        if (document$1.readyState === 'complete') {\n            // safari 4 can fire the DOMContentLoaded event before loading all\n            // external JS (including this file). you will see some copypasta\n            // on the internet that checks for 'complete' and 'loaded', but\n            // 'loaded' is an IE thing\n            dom_loaded_handler();\n        } else {\n            document$1.addEventListener('DOMContentLoaded', dom_loaded_handler, false);\n        }\n    } else if (document$1.attachEvent) {\n        // IE\n        document$1.attachEvent('onreadystatechange', dom_loaded_handler);\n\n        // check to make sure we arn't in a frame\n        var toplevel = false;\n        try {\n            toplevel = win.frameElement === null;\n        } catch(e) {\n            // noop\n        }\n\n        if (document$1.documentElement.doScroll && toplevel) {\n            do_scroll_check();\n        }\n    }\n\n    // fallback handler, always will work\n    _.register_event(win, 'load', dom_loaded_handler, true);\n};\n\nfunction init_as_module(bundle_loader) {\n    load_extra_bundle = bundle_loader;\n    init_type = INIT_MODULE;\n    mixpanel_master = new MixpanelLib();\n\n    override_mp_init_func();\n    mixpanel_master['init']();\n    add_dom_loaded_handler();\n\n    return mixpanel_master;\n}\n\n// For loading separate bundles asynchronously via script tag\n\n// For builds that have everything in one bundle, no extra work.\nfunction loadNoop (_src, onload) {\n    onload();\n}\n\n/* eslint camelcase: \"off\" */\n\nvar mixpanel = init_as_module(loadNoop);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELDBEQUEwRDtBQUMxRCwwREFBMEQsb0NBQW9DLHNCQUFzQjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EseUNBQXlDLDBCQUEwQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUErRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXLEVBQUUsU0FBUyxFQUFFLFdBQVc7QUFDN0Q7QUFDQTtBQUNBLDBCQUEwQixXQUFXLEVBQUUsU0FBUyxFQUFFLFdBQVc7QUFDN0Q7QUFDQTtBQUNBLDBCQUEwQixXQUFXLEVBQUUsK0JBQStCLEVBQUUsV0FBVztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVyxFQUFFLGdCQUFnQixFQUFFLFdBQVc7QUFDaEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMElBQTBJLDhEQUE4RCwrTUFBK007QUFDbmEsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELElBQUk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNFpBQTRaO0FBQ3hhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUcsR0FBRyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMseUNBQXlDO0FBQ3pDLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFzTTtBQUNsTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHlCQUF5QiwrRUFBK0U7QUFDcEw7QUFDQSxtRkFBbUYseUJBQXlCLCtEQUErRDtBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUErRCxpQkFBaUI7QUFDaEg7QUFDQSx3Q0FBd0MsTUFBTSwrQkFBK0IsWUFBWTtBQUN6Rix1Q0FBdUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUM1RixvQ0FBb0M7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLEdBQUcsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNENBQTRDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0EsZ0RBQWdELElBQUk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNEO0FBQ0EsU0FBUztBQUNUOztBQUVBLENBQUM7QUFDRCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRkFBa0Y7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdDQUFnQztBQUNqRjtBQUNBLHFDQUFxQztBQUNyQztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsT0FBTztBQUN2QiwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFFBQVEsMkJBQTJCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixZQUFZLGtXQUFrVyxxQkFBcUI7QUFDblk7QUFDQSx1TEFBdUw7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNDQUFzQztBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4Qiw0Q0FBNEM7QUFDMUUsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQStDO0FBQzdFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBDQUEwQyw4Q0FBOEM7QUFDeEYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0Q0FBNEM7QUFDdEYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwwQ0FBMEMsbUNBQW1DO0FBQzdFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMENBQTBDLDhDQUE4QztBQUN4RixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBDQUEwQyw0Q0FBNEM7QUFDdEYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwwQ0FBMEMsOENBQThDO0FBQ3hGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0NBQWtDO0FBQzVFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDJDQUEyQztBQUN6RixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0NBQXNDO0FBQ3BGLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUE2QztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELGdDQUFnQztBQUNoQyxpQ0FBaUMsTUFBTSwwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FB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QXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxT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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLElBQUk7QUFDZCxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUEsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVcsR0FBRyxRQUFRLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNB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Q0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUUsNkJBQTZCO0FBQ3RHLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQSwyRUFBMkUsNkJBQTZCO0FBQ3hHLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEI7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUUrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FjZXhsYWJzLy4vbm9kZV9tb2R1bGVzL21peHBhbmVsLWJyb3dzZXIvZGlzdC9taXhwYW5lbC5tb2R1bGUuanM/MjU3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTm9kZVR5cGU7XHJcbihmdW5jdGlvbiAoTm9kZVR5cGUpIHtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRG9jdW1lbnRUeXBlXCJdID0gMV0gPSBcIkRvY3VtZW50VHlwZVwiO1xyXG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNEQVRBXCJdID0gNF0gPSBcIkNEQVRBXCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xyXG59KShOb2RlVHlwZSB8fCAoTm9kZVR5cGUgPSB7fSkpO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobikge1xyXG4gICAgcmV0dXJuIG4ubm9kZVR5cGUgPT09IG4uRUxFTUVOVF9OT0RFO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChuKSB7XHJcbiAgICBjb25zdCBob3N0ID0gbiA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLmhvc3Q7XHJcbiAgICByZXR1cm4gQm9vbGVhbigoaG9zdCA9PT0gbnVsbCB8fCBob3N0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3N0LnNoYWRvd1Jvb3QpID09PSBuKTtcclxufVxyXG5mdW5jdGlvbiBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNoYWRvd1Jvb3QpID09PSAnW29iamVjdCBTaGFkb3dSb290XSc7XHJcbn1cclxuZnVuY3Rpb24gZml4QnJvd3NlckNvbXBhdGliaWxpdHlJc3N1ZXNJbkNTUyhjc3NUZXh0KSB7XHJcbiAgICBpZiAoY3NzVGV4dC5pbmNsdWRlcygnIGJhY2tncm91bmQtY2xpcDogdGV4dDsnKSAmJlxyXG4gICAgICAgICFjc3NUZXh0LmluY2x1ZGVzKCcgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7JykpIHtcclxuICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKCcgYmFja2dyb3VuZC1jbGlwOiB0ZXh0OycsICcgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7IGJhY2tncm91bmQtY2xpcDogdGV4dDsnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjc3NUZXh0O1xyXG59XHJcbmZ1bmN0aW9uIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlKSB7XHJcbiAgICBjb25zdCB7IGNzc1RleHQgfSA9IHJ1bGU7XHJcbiAgICBpZiAoY3NzVGV4dC5zcGxpdCgnXCInKS5sZW5ndGggPCAzKVxyXG4gICAgICAgIHJldHVybiBjc3NUZXh0O1xyXG4gICAgY29uc3Qgc3RhdGVtZW50ID0gWydAaW1wb3J0JywgYHVybCgke0pTT04uc3RyaW5naWZ5KHJ1bGUuaHJlZil9KWBdO1xyXG4gICAgaWYgKHJ1bGUubGF5ZXJOYW1lID09PSAnJykge1xyXG4gICAgICAgIHN0YXRlbWVudC5wdXNoKGBsYXllcmApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocnVsZS5sYXllck5hbWUpIHtcclxuICAgICAgICBzdGF0ZW1lbnQucHVzaChgbGF5ZXIoJHtydWxlLmxheWVyTmFtZX0pYCk7XHJcbiAgICB9XHJcbiAgICBpZiAocnVsZS5zdXBwb3J0c1RleHQpIHtcclxuICAgICAgICBzdGF0ZW1lbnQucHVzaChgc3VwcG9ydHMoJHtydWxlLnN1cHBvcnRzVGV4dH0pYCk7XHJcbiAgICB9XHJcbiAgICBpZiAocnVsZS5tZWRpYS5sZW5ndGgpIHtcclxuICAgICAgICBzdGF0ZW1lbnQucHVzaChydWxlLm1lZGlhLm1lZGlhVGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhdGVtZW50LmpvaW4oJyAnKSArICc7JztcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZXNoZWV0KHMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcnVsZXMgPSBzLnJ1bGVzIHx8IHMuY3NzUnVsZXM7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVzXHJcbiAgICAgICAgICAgID8gZml4QnJvd3NlckNvbXBhdGliaWxpdHlJc3N1ZXNJbkNTUyhBcnJheS5mcm9tKHJ1bGVzLCBzdHJpbmdpZnlSdWxlKS5qb2luKCcnKSlcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5UnVsZShydWxlKSB7XHJcbiAgICBsZXQgaW1wb3J0U3RyaW5naWZpZWQ7XHJcbiAgICBpZiAoaXNDU1NJbXBvcnRSdWxlKHJ1bGUpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaW1wb3J0U3RyaW5naWZpZWQgPVxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5U3R5bGVzaGVldChydWxlLnN0eWxlU2hlZXQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0NTU1N0eWxlUnVsZShydWxlKSAmJiBydWxlLnNlbGVjdG9yVGV4dC5pbmNsdWRlcygnOicpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpeFNhZmFyaUNvbG9ucyhydWxlLmNzc1RleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGltcG9ydFN0cmluZ2lmaWVkIHx8IHJ1bGUuY3NzVGV4dDtcclxufVxyXG5mdW5jdGlvbiBmaXhTYWZhcmlDb2xvbnMoY3NzU3RyaW5naWZpZWQpIHtcclxuICAgIGNvbnN0IHJlZ2V4ID0gLyhcXFsoPzpbXFx3LV0rKVteXFxcXF0pKDooPzpbXFx3LV0rKVxcXSkvZ207XHJcbiAgICByZXR1cm4gY3NzU3RyaW5naWZpZWQucmVwbGFjZShyZWdleCwgJyQxXFxcXCQyJyk7XHJcbn1cclxuZnVuY3Rpb24gaXNDU1NJbXBvcnRSdWxlKHJ1bGUpIHtcclxuICAgIHJldHVybiAnc3R5bGVTaGVldCcgaW4gcnVsZTtcclxufVxyXG5mdW5jdGlvbiBpc0NTU1N0eWxlUnVsZShydWxlKSB7XHJcbiAgICByZXR1cm4gJ3NlbGVjdG9yVGV4dCcgaW4gcnVsZTtcclxufVxyXG5jbGFzcyBNaXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRJZChuKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghbilcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGNvbnN0IGlkID0gKF9hID0gdGhpcy5nZXRNZXRhKG4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQ7XHJcbiAgICAgICAgcmV0dXJuIGlkICE9PSBudWxsICYmIGlkICE9PSB2b2lkIDAgPyBpZCA6IC0xO1xyXG4gICAgfVxyXG4gICAgZ2V0Tm9kZShpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkTm9kZU1hcC5nZXQoaWQpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRJZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pZE5vZGVNYXAua2V5cygpKTtcclxuICAgIH1cclxuICAgIGdldE1ldGEobikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmdldChuKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTm9kZUZyb21NYXAobikge1xyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZChuKTtcclxuICAgICAgICB0aGlzLmlkTm9kZU1hcC5kZWxldGUoaWQpO1xyXG4gICAgICAgIGlmIChuLmNoaWxkTm9kZXMpIHtcclxuICAgICAgICAgICAgbi5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4gdGhpcy5yZW1vdmVOb2RlRnJvbU1hcChjaGlsZE5vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXMoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuaGFzKGlkKTtcclxuICAgIH1cclxuICAgIGhhc05vZGUobm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmhhcyhub2RlKTtcclxuICAgIH1cclxuICAgIGFkZChuLCBtZXRhKSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSBtZXRhLmlkO1xyXG4gICAgICAgIHRoaXMuaWROb2RlTWFwLnNldChpZCwgbik7XHJcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcC5zZXQobiwgbWV0YSk7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlKGlkLCBuKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkTm9kZSA9IHRoaXMuZ2V0Tm9kZShpZCk7XHJcbiAgICAgICAgaWYgKG9sZE5vZGUpIHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMubm9kZU1ldGFNYXAuZ2V0KG9sZE5vZGUpO1xyXG4gICAgICAgICAgICBpZiAobWV0YSlcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4sIG1ldGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlkTm9kZU1hcC5zZXQoaWQsIG4pO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlTWlycm9yKCkge1xyXG4gICAgcmV0dXJuIG5ldyBNaXJyb3IoKTtcclxufVxyXG5mdW5jdGlvbiBtYXNrSW5wdXRWYWx1ZSh7IGVsZW1lbnQsIG1hc2tJbnB1dE9wdGlvbnMsIHRhZ05hbWUsIHR5cGUsIHZhbHVlLCBtYXNrSW5wdXRGbiwgfSkge1xyXG4gICAgbGV0IHRleHQgPSB2YWx1ZSB8fCAnJztcclxuICAgIGNvbnN0IGFjdHVhbFR5cGUgPSB0eXBlICYmIHRvTG93ZXJDYXNlKHR5cGUpO1xyXG4gICAgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fFxyXG4gICAgICAgIChhY3R1YWxUeXBlICYmIG1hc2tJbnB1dE9wdGlvbnNbYWN0dWFsVHlwZV0pKSB7XHJcbiAgICAgICAgaWYgKG1hc2tJbnB1dEZuKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSBtYXNrSW5wdXRGbih0ZXh0LCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHQgPSAnKicucmVwZWF0KHRleHQubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGV4dDtcclxufVxyXG5mdW5jdGlvbiB0b0xvd2VyQ2FzZShzdHIpIHtcclxuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcclxufVxyXG5jb25zdCBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSA9ICdfX3Jyd2ViX29yaWdpbmFsX18nO1xyXG5mdW5jdGlvbiBpczJEQ2FudmFzQmxhbmsoY2FudmFzKSB7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIGlmICghY3R4KVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgY29uc3QgY2h1bmtTaXplID0gNTA7XHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCArPSBjaHVua1NpemUpIHtcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkgKz0gY2h1bmtTaXplKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdldEltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGE7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsR2V0SW1hZ2VEYXRhID0gT1JJR0lOQUxfQVRUUklCVVRFX05BTUUgaW4gZ2V0SW1hZ2VEYXRhXHJcbiAgICAgICAgICAgICAgICA/IGdldEltYWdlRGF0YVtPUklHSU5BTF9BVFRSSUJVVEVfTkFNRV1cclxuICAgICAgICAgICAgICAgIDogZ2V0SW1hZ2VEYXRhO1xyXG4gICAgICAgICAgICBjb25zdCBwaXhlbEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShvcmlnaW5hbEdldEltYWdlRGF0YS5jYWxsKGN0eCwgeCwgeSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMud2lkdGggLSB4KSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMuaGVpZ2h0IC0geSkpLmRhdGEuYnVmZmVyKTtcclxuICAgICAgICAgICAgaWYgKHBpeGVsQnVmZmVyLnNvbWUoKHBpeGVsKSA9PiBwaXhlbCAhPT0gMCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5wdXRUeXBlKGVsZW1lbnQpIHtcclxuICAgIGNvbnN0IHR5cGUgPSBlbGVtZW50LnR5cGU7XHJcbiAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcnItaXMtcGFzc3dvcmQnKVxyXG4gICAgICAgID8gJ3Bhc3N3b3JkJ1xyXG4gICAgICAgIDogdHlwZVxyXG4gICAgICAgICAgICA/XHJcbiAgICAgICAgICAgICAgICB0b0xvd2VyQ2FzZSh0eXBlKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdEZpbGVFeHRlbnNpb24ocGF0aCwgYmFzZVVSTCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgbGV0IHVybDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVVJMICE9PSBudWxsICYmIGJhc2VVUkwgIT09IHZvaWQgMCA/IGJhc2VVUkwgOiB3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZWdleCA9IC9cXC4oWzAtOWEtel0rKSg/OiQpL2k7XHJcbiAgICBjb25zdCBtYXRjaCA9IHVybC5wYXRobmFtZS5tYXRjaChyZWdleCk7XHJcbiAgICByZXR1cm4gKF9hID0gbWF0Y2ggPT09IG51bGwgfHwgbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoWzFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xyXG59XG5cbmxldCBfaWQgPSAxO1xyXG5jb25zdCB0YWdOYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdbXmEtejAtOS1fOl0nKTtcclxuY29uc3QgSUdOT1JFRF9OT0RFID0gLTI7XHJcbmZ1bmN0aW9uIGdlbklkKCkge1xyXG4gICAgcmV0dXJuIF9pZCsrO1xyXG59XHJcbmZ1bmN0aW9uIGdldFZhbGlkVGFnTmFtZShlbGVtZW50KSB7XHJcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiAnZm9ybSc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9jZXNzZWRUYWdOYW1lID0gdG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcclxuICAgIGlmICh0YWdOYW1lUmVnZXgudGVzdChwcm9jZXNzZWRUYWdOYW1lKSkge1xyXG4gICAgICAgIHJldHVybiAnZGl2JztcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9jZXNzZWRUYWdOYW1lO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RPcmlnaW4odXJsKSB7XHJcbiAgICBsZXQgb3JpZ2luID0gJyc7XHJcbiAgICBpZiAodXJsLmluZGV4T2YoJy8vJykgPiAtMSkge1xyXG4gICAgICAgIG9yaWdpbiA9IHVybC5zcGxpdCgnLycpLnNsaWNlKDAsIDMpLmpvaW4oJy8nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG9yaWdpbiA9IHVybC5zcGxpdCgnLycpWzBdO1xyXG4gICAgfVxyXG4gICAgb3JpZ2luID0gb3JpZ2luLnNwbGl0KCc/JylbMF07XHJcbiAgICByZXR1cm4gb3JpZ2luO1xyXG59XHJcbmxldCBjYW52YXNTZXJ2aWNlO1xyXG5sZXQgY2FudmFzQ3R4O1xyXG5jb25zdCBVUkxfSU5fQ1NTX1JFRiA9IC91cmxcXCgoPzooJykoW14nXSopJ3woXCIpKC4qPylcInwoW14pXSopKVxcKS9nbTtcclxuY29uc3QgVVJMX1BST1RPQ09MX01BVENIID0gL14oPzpbYS16K10rOik/XFwvXFwvL2k7XHJcbmNvbnN0IFVSTF9XV1dfTUFUQ0ggPSAvXnd3d1xcLi4qL2k7XHJcbmNvbnN0IERBVEFfVVJJID0gL14oZGF0YTopKFteLF0qKSwoLiopL2k7XHJcbmZ1bmN0aW9uIGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIGhyZWYpIHtcclxuICAgIHJldHVybiAoY3NzVGV4dCB8fCAnJykucmVwbGFjZShVUkxfSU5fQ1NTX1JFRiwgKG9yaWdpbiwgcXVvdGUxLCBwYXRoMSwgcXVvdGUyLCBwYXRoMiwgcGF0aDMpID0+IHtcclxuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGgxIHx8IHBhdGgyIHx8IHBhdGgzO1xyXG4gICAgICAgIGNvbnN0IG1heWJlUXVvdGUgPSBxdW90ZTEgfHwgcXVvdGUyIHx8ICcnO1xyXG4gICAgICAgIGlmICghZmlsZVBhdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFVSTF9QUk9UT0NPTF9NQVRDSC50ZXN0KGZpbGVQYXRoKSB8fCBVUkxfV1dXX01BVENILnRlc3QoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2ZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKERBVEFfVVJJLnRlc3QoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2ZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbGVQYXRoWzBdID09PSAnLycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7ZXh0cmFjdE9yaWdpbihocmVmKSArIGZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBocmVmLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBmaWxlUGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xyXG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7c3RhY2suam9pbignLycpfSR7bWF5YmVRdW90ZX0pYDtcclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IFNSQ1NFVF9OT1RfU1BBQ0VTID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvO1xyXG5jb25zdCBTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyA9IC9eWywgXFx0XFxuXFxyXFx1MDAwY10rLztcclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xyXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XHJcbiAgICB9XHJcbiAgICBsZXQgcG9zID0gMDtcclxuICAgIGZ1bmN0aW9uIGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ0V4KSB7XHJcbiAgICAgICAgbGV0IGNoYXJzO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcmVnRXguZXhlYyhhdHRyaWJ1dGVWYWx1ZS5zdWJzdHJpbmcocG9zKSk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGNoYXJzID0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIHBvcyArPSBjaGFycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFycztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9DT01NQVNfT1JfU1BBQ0VTKTtcclxuICAgICAgICBpZiAocG9zID49IGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHVybCA9IGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9OT1RfU1BBQ0VTKTtcclxuICAgICAgICBpZiAodXJsLnNsaWNlKC0xKSA9PT0gJywnKSB7XHJcbiAgICAgICAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZGVzY3JpcHRvcnNTdHIgPSAnJztcclxuICAgICAgICAgICAgdXJsID0gYWJzb2x1dGVUb0RvYyhkb2MsIHVybCk7XHJcbiAgICAgICAgICAgIGxldCBpblBhcmVucyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGF0dHJpYnV0ZVZhbHVlLmNoYXJBdChwb3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWluUGFyZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJygnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyZW5zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyZW5zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNTdHIgKz0gYztcclxuICAgICAgICAgICAgICAgIHBvcyArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcsICcpO1xyXG59XHJcbmZ1bmN0aW9uIGFic29sdXRlVG9Eb2MoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xyXG4gICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCBhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYSA9IGRvYy5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICBhLmhyZWYgPSBhdHRyaWJ1dGVWYWx1ZTtcclxuICAgIHJldHVybiBhLmhyZWY7XHJcbn1cclxuZnVuY3Rpb24gaXNTVkdFbGVtZW50KGVsKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihlbC50YWdOYW1lID09PSAnc3ZnJyB8fCBlbC5vd25lclNWR0VsZW1lbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEhyZWYoKSB7XHJcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgYS5ocmVmID0gJyc7XHJcbiAgICByZXR1cm4gYS5ocmVmO1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybUF0dHJpYnV0ZShkb2MsIHRhZ05hbWUsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUgPT09ICdzcmMnIHx8XHJcbiAgICAgICAgKG5hbWUgPT09ICdocmVmJyAmJiAhKHRhZ05hbWUgPT09ICd1c2UnICYmIHZhbHVlWzBdID09PSAnIycpKSkge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3hsaW5rOmhyZWYnICYmIHZhbHVlWzBdICE9PSAnIycpIHtcclxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdiYWNrZ3JvdW5kJyAmJlxyXG4gICAgICAgICh0YWdOYW1lID09PSAndGFibGUnIHx8IHRhZ05hbWUgPT09ICd0ZCcgfHwgdGFnTmFtZSA9PT0gJ3RoJykpIHtcclxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdzcmNzZXQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEFic29sdXRlU3Jjc2V0U3RyaW5nKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvU3R5bGVzaGVldCh2YWx1ZSwgZ2V0SHJlZigpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRhZ05hbWUgPT09ICdvYmplY3QnICYmIG5hbWUgPT09ICdkYXRhJykge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGlnbm9yZUF0dHJpYnV0ZSh0YWdOYW1lLCBuYW1lLCBfdmFsdWUpIHtcclxuICAgIHJldHVybiAodGFnTmFtZSA9PT0gJ3ZpZGVvJyB8fCB0YWdOYW1lID09PSAnYXVkaW8nKSAmJiBuYW1lID09PSAnYXV0b3BsYXknO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0Jsb2NrZWRFbGVtZW50KGVsZW1lbnQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoYmxvY2tDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlSW5kZXggPSBlbGVtZW50LmNsYXNzTGlzdC5sZW5ndGg7IGVJbmRleC0tOykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc0xpc3RbZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChibG9ja0NsYXNzLnRlc3QoY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChibG9ja1NlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoYmxvY2tTZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBjbGFzc01hdGNoZXNSZWdleChub2RlLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgIGlmICghbm9kZSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gbm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICBpZiAoIWNoZWNrQW5jZXN0b3JzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTWF0Y2hlc1JlZ2V4KG5vZGUucGFyZW50Tm9kZSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGVJbmRleCA9IG5vZGUuY2xhc3NMaXN0Lmxlbmd0aDsgZUluZGV4LS07KSB7XHJcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gbm9kZS5jbGFzc0xpc3RbZUluZGV4XTtcclxuICAgICAgICBpZiAocmVnZXgudGVzdChjbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghY2hlY2tBbmNlc3RvcnMpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIGNsYXNzTWF0Y2hlc1JlZ2V4KG5vZGUucGFyZW50Tm9kZSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcclxufVxyXG5mdW5jdGlvbiBuZWVkTWFza2luZ1RleHQobm9kZSwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZWwgPSBub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERVxyXG4gICAgICAgICAgICA/IG5vZGVcclxuICAgICAgICAgICAgOiBub2RlLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGVsID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtYXNrVGV4dENsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5jbG9zZXN0KGAuJHttYXNrVGV4dENsYXNzfWApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhtYXNrVGV4dENsYXNzKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGNsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBtYXNrVGV4dENsYXNzLCBjaGVja0FuY2VzdG9ycykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hc2tUZXh0U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xvc2VzdChtYXNrVGV4dFNlbGVjdG9yKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5tYXRjaGVzKG1hc2tUZXh0U2VsZWN0b3IpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBvbmNlSWZyYW1lTG9hZGVkKGlmcmFtZUVsLCBsaXN0ZW5lciwgaWZyYW1lTG9hZFRpbWVvdXQpIHtcclxuICAgIGNvbnN0IHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XHJcbiAgICBpZiAoIXdpbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBmaXJlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHJlYWR5U3RhdGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlYWR5U3RhdGUgPSB3aW4uZG9jdW1lbnQucmVhZHlTdGF0ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChyZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFmaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGlmcmFtZUxvYWRUaW1lb3V0KTtcclxuICAgICAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYmxhbmtVcmwgPSAnYWJvdXQ6YmxhbmsnO1xyXG4gICAgaWYgKHdpbi5sb2NhdGlvbi5ocmVmICE9PSBibGFua1VybCB8fFxyXG4gICAgICAgIGlmcmFtZUVsLnNyYyA9PT0gYmxhbmtVcmwgfHxcclxuICAgICAgICBpZnJhbWVFbC5zcmMgPT09ICcnKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChsaXN0ZW5lciwgMCk7XHJcbiAgICAgICAgcmV0dXJuIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbGlzdGVuZXIpO1xyXG59XHJcbmZ1bmN0aW9uIG9uY2VTdHlsZXNoZWV0TG9hZGVkKGxpbmssIGxpc3RlbmVyLCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpIHtcclxuICAgIGxldCBmaXJlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHN0eWxlU2hlZXRMb2FkZWQ7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHN0eWxlU2hlZXRMb2FkZWQgPSBsaW5rLnNoZWV0O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0eWxlU2hlZXRMb2FkZWQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWZpcmVkKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpO1xyXG4gICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgICAgZmlyZWQgPSB0cnVlO1xyXG4gICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKG4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgZG9jLCBtaXJyb3IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG5lZWRzTWFzaywgaW5saW5lU3R5bGVzaGVldCwgbWFza0lucHV0T3B0aW9ucyA9IHt9LCBtYXNrVGV4dEZuLCBtYXNrSW5wdXRGbiwgZGF0YVVSTE9wdGlvbnMgPSB7fSwgaW5saW5lSW1hZ2VzLCByZWNvcmRDYW52YXMsIGtlZXBJZnJhbWVTcmNGbiwgbmV3bHlBZGRlZEVsZW1lbnQgPSBmYWxzZSwgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCByb290SWQgPSBnZXRSb290SWQoZG9jLCBtaXJyb3IpO1xyXG4gICAgc3dpdGNoIChuLm5vZGVUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBuLkRPQ1VNRU5UX05PREU6XHJcbiAgICAgICAgICAgIGlmIChuLmNvbXBhdE1vZGUgIT09ICdDU1MxQ29tcGF0Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21wYXRNb2RlOiBuLmNvbXBhdE1vZGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBjYXNlIG4uRE9DVU1FTlRfVFlQRV9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuRG9jdW1lbnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogbi5uYW1lLFxyXG4gICAgICAgICAgICAgICAgcHVibGljSWQ6IG4ucHVibGljSWQsXHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1JZDogbi5zeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIG4uRUxFTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRWxlbWVudE5vZGUobiwge1xyXG4gICAgICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICBuZXdseUFkZGVkRWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY2FzZSBuLlRFWFRfTk9ERTpcclxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRleHROb2RlKG4sIHtcclxuICAgICAgICAgICAgICAgIG5lZWRzTWFzayxcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgICAgICByb290SWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2Ugbi5DREFUQV9TRUNUSU9OX05PREU6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5DREFUQSxcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiAnJyxcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIG4uQ09NTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuQ29tbWVudCxcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiBuLnRleHRDb250ZW50IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgcm9vdElkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRSb290SWQoZG9jLCBtaXJyb3IpIHtcclxuICAgIGlmICghbWlycm9yLmhhc05vZGUoZG9jKSlcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgZG9jSWQgPSBtaXJyb3IuZ2V0SWQoZG9jKTtcclxuICAgIHJldHVybiBkb2NJZCA9PT0gMSA/IHVuZGVmaW5lZCA6IGRvY0lkO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZVRleHROb2RlKG4sIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHsgbmVlZHNNYXNrLCBtYXNrVGV4dEZuLCByb290SWQgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBwYXJlbnRUYWdOYW1lID0gbi5wYXJlbnROb2RlICYmIG4ucGFyZW50Tm9kZS50YWdOYW1lO1xyXG4gICAgbGV0IHRleHRDb250ZW50ID0gbi50ZXh0Q29udGVudDtcclxuICAgIGNvbnN0IGlzU3R5bGUgPSBwYXJlbnRUYWdOYW1lID09PSAnU1RZTEUnID8gdHJ1ZSA6IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlzU2NyaXB0ID0gcGFyZW50VGFnTmFtZSA9PT0gJ1NDUklQVCcgPyB0cnVlIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKGlzU3R5bGUgJiYgdGV4dENvbnRlbnQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAobi5uZXh0U2libGluZyB8fCBuLnByZXZpb3VzU2libGluZykge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChfYSA9IG4ucGFyZW50Tm9kZS5zaGVldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNzc1J1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQobi5wYXJlbnROb2RlLnNoZWV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IGdldCBDU1Mgc3R5bGVzIGZyb20gdGV4dCdzIHBhcmVudE5vZGUuIEVycm9yOiAke2Vycn1gLCBuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dENvbnRlbnQgPSBhYnNvbHV0ZVRvU3R5bGVzaGVldCh0ZXh0Q29udGVudCwgZ2V0SHJlZigpKTtcclxuICAgIH1cclxuICAgIGlmIChpc1NjcmlwdCkge1xyXG4gICAgICAgIHRleHRDb250ZW50ID0gJ1NDUklQVF9QTEFDRUhPTERFUic7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzU3R5bGUgJiYgIWlzU2NyaXB0ICYmIHRleHRDb250ZW50ICYmIG5lZWRzTWFzaykge1xyXG4gICAgICAgIHRleHRDb250ZW50ID0gbWFza1RleHRGblxyXG4gICAgICAgICAgICA/IG1hc2tUZXh0Rm4odGV4dENvbnRlbnQsIG4ucGFyZW50RWxlbWVudClcclxuICAgICAgICAgICAgOiB0ZXh0Q29udGVudC5yZXBsYWNlKC9bXFxTXS9nLCAnKicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBOb2RlVHlwZS5UZXh0LFxyXG4gICAgICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudCB8fCAnJyxcclxuICAgICAgICBpc1N0eWxlLFxyXG4gICAgICAgIHJvb3RJZCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplRWxlbWVudE5vZGUobiwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgeyBkb2MsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGlubGluZVN0eWxlc2hlZXQsIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSwgbWFza0lucHV0Rm4sIGRhdGFVUkxPcHRpb25zID0ge30sIGlubGluZUltYWdlcywgcmVjb3JkQ2FudmFzLCBrZWVwSWZyYW1lU3JjRm4sIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsIHJvb3RJZCwgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBuZWVkQmxvY2sgPSBfaXNCbG9ja2VkRWxlbWVudChuLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcclxuICAgIGNvbnN0IHRhZ05hbWUgPSBnZXRWYWxpZFRhZ05hbWUobik7XHJcbiAgICBsZXQgYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgY29uc3QgbGVuID0gbi5hdHRyaWJ1dGVzLmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBjb25zdCBhdHRyID0gbi5hdHRyaWJ1dGVzW2ldO1xyXG4gICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhZ05hbWUsIGF0dHIubmFtZSwgYXR0ci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyLm5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKGRvYywgdGFnTmFtZSwgdG9Mb3dlckNhc2UoYXR0ci5uYW1lKSwgYXR0ci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdsaW5rJyAmJiBpbmxpbmVTdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVzaGVldCA9IEFycmF5LmZyb20oZG9jLnN0eWxlU2hlZXRzKS5maW5kKChzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBzLmhyZWYgPT09IG4uaHJlZjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgY3NzVGV4dCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHN0eWxlc2hlZXQpIHtcclxuICAgICAgICAgICAgY3NzVGV4dCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQoc3R5bGVzaGVldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjc3NUZXh0KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnJlbDtcclxuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuaHJlZjtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIHN0eWxlc2hlZXQuaHJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdzdHlsZScgJiZcclxuICAgICAgICBuLnNoZWV0ICYmXHJcbiAgICAgICAgIShuLmlubmVyVGV4dCB8fCBuLnRleHRDb250ZW50IHx8ICcnKS50cmltKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgY3NzVGV4dCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQobi5zaGVldCk7XHJcbiAgICAgICAgaWYgKGNzc1RleHQpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIGdldEhyZWYoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdpbnB1dCcgfHwgdGFnTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCB0YWdOYW1lID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbi52YWx1ZTtcclxuICAgICAgICBjb25zdCBjaGVja2VkID0gbi5jaGVja2VkO1xyXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgIT09ICdyYWRpbycgJiZcclxuICAgICAgICAgICAgYXR0cmlidXRlcy50eXBlICE9PSAnY2hlY2tib3gnICYmXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudHlwZSAhPT0gJ3N1Ym1pdCcgJiZcclxuICAgICAgICAgICAgYXR0cmlidXRlcy50eXBlICE9PSAnYnV0dG9uJyAmJlxyXG4gICAgICAgICAgICB2YWx1ZSkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnZhbHVlID0gbWFza0lucHV0VmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbixcclxuICAgICAgICAgICAgICAgIHR5cGU6IGdldElucHV0VHlwZShuKSxcclxuICAgICAgICAgICAgICAgIHRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoZWNrZWQpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5jaGVja2VkID0gY2hlY2tlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ29wdGlvbicpIHtcclxuICAgICAgICBpZiAobi5zZWxlY3RlZCAmJiAhbWFza0lucHV0T3B0aW9uc1snc2VsZWN0J10pIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5zZWxlY3RlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2NhbnZhcycgJiYgcmVjb3JkQ2FudmFzKSB7XHJcbiAgICAgICAgaWYgKG4uX19jb250ZXh0ID09PSAnMmQnKSB7XHJcbiAgICAgICAgICAgIGlmICghaXMyRENhbnZhc0JsYW5rKG4pKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBuLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghKCdfX2NvbnRleHQnIGluIG4pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0RhdGFVUkwgPSBuLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcclxuICAgICAgICAgICAgY29uc3QgYmxhbmtDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgYmxhbmtDYW52YXMud2lkdGggPSBuLndpZHRoO1xyXG4gICAgICAgICAgICBibGFua0NhbnZhcy5oZWlnaHQgPSBuLmhlaWdodDtcclxuICAgICAgICAgICAgY29uc3QgYmxhbmtDYW52YXNEYXRhVVJMID0gYmxhbmtDYW52YXMudG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xyXG4gICAgICAgICAgICBpZiAoY2FudmFzRGF0YVVSTCAhPT0gYmxhbmtDYW52YXNEYXRhVVJMKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBjYW52YXNEYXRhVVJMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdpbWcnICYmIGlubGluZUltYWdlcykge1xyXG4gICAgICAgIGlmICghY2FudmFzU2VydmljZSkge1xyXG4gICAgICAgICAgICBjYW52YXNTZXJ2aWNlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICBjYW52YXNDdHggPSBjYW52YXNTZXJ2aWNlLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGltYWdlID0gbjtcclxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGltYWdlLmNyb3NzT3JpZ2luO1xyXG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICAgICAgY29uc3QgcmVjb3JkSW5saW5lSW1hZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZWNvcmRJbmxpbmVJbWFnZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNTZXJ2aWNlLndpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzU2VydmljZS5oZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY2FudmFzQ3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBjYW52YXNTZXJ2aWNlLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBpbmxpbmUgaW1nIHNyYz0ke2ltYWdlLmN1cnJlbnRTcmN9ISBFcnJvcjogJHtlcnJ9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2xkVmFsdWVcclxuICAgICAgICAgICAgICAgID8gKGF0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4gPSBvbGRWYWx1ZSlcclxuICAgICAgICAgICAgICAgIDogaW1hZ2UucmVtb3ZlQXR0cmlidXRlKCdjcm9zc29yaWdpbicpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxXaWR0aCAhPT0gMClcclxuICAgICAgICAgICAgcmVjb3JkSW5saW5lSW1hZ2UoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZWNvcmRJbmxpbmVJbWFnZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2F1ZGlvJyB8fCB0YWdOYW1lID09PSAndmlkZW8nKSB7XHJcbiAgICAgICAgY29uc3QgbWVkaWFBdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFTdGF0ZSA9IG4ucGF1c2VkXHJcbiAgICAgICAgICAgID8gJ3BhdXNlZCdcclxuICAgICAgICAgICAgOiAncGxheWVkJztcclxuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFDdXJyZW50VGltZSA9IG4uY3VycmVudFRpbWU7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhUGxheWJhY2tSYXRlID0gbi5wbGF5YmFja1JhdGU7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhTXV0ZWQgPSBuLm11dGVkO1xyXG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYUxvb3AgPSBuLmxvb3A7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhVm9sdW1lID0gbi52b2x1bWU7XHJcbiAgICB9XHJcbiAgICBpZiAoIW5ld2x5QWRkZWRFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKG4uc2Nyb2xsTGVmdCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbExlZnQgPSBuLnNjcm9sbExlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLnNjcm9sbFRvcCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbFRvcCA9IG4uc2Nyb2xsVG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuZWVkQmxvY2spIHtcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgYXR0cmlidXRlcyA9IHtcclxuICAgICAgICAgICAgY2xhc3M6IGF0dHJpYnV0ZXMuY2xhc3MsXHJcbiAgICAgICAgICAgIHJyX3dpZHRoOiBgJHt3aWR0aH1weGAsXHJcbiAgICAgICAgICAgIHJyX2hlaWdodDogYCR7aGVpZ2h0fXB4YCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHRhZ05hbWUgPT09ICdpZnJhbWUnICYmICFrZWVwSWZyYW1lU3JjRm4oYXR0cmlidXRlcy5zcmMpKSB7XHJcbiAgICAgICAgaWYgKCFuLmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3NyYyA9IGF0dHJpYnV0ZXMuc3JjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5zcmM7XHJcbiAgICB9XHJcbiAgICBsZXQgaXNDdXN0b21FbGVtZW50O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKVxyXG4gICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogTm9kZVR5cGUuRWxlbWVudCxcclxuICAgICAgICB0YWdOYW1lLFxyXG4gICAgICAgIGF0dHJpYnV0ZXMsXHJcbiAgICAgICAgY2hpbGROb2RlczogW10sXHJcbiAgICAgICAgaXNTVkc6IGlzU1ZHRWxlbWVudChuKSB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgbmVlZEJsb2NrLFxyXG4gICAgICAgIHJvb3RJZCxcclxuICAgICAgICBpc0N1c3RvbTogaXNDdXN0b21FbGVtZW50LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBsb3dlcklmRXhpc3RzKG1heWJlQXR0cikge1xyXG4gICAgaWYgKG1heWJlQXR0ciA9PT0gdW5kZWZpbmVkIHx8IG1heWJlQXR0ciA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXliZUF0dHIudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzbGltRE9NRXhjbHVkZWQoc24sIHNsaW1ET01PcHRpb25zKSB7XHJcbiAgICBpZiAoc2xpbURPTU9wdGlvbnMuY29tbWVudCAmJiBzbi50eXBlID09PSBOb2RlVHlwZS5Db21tZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzbi50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLnNjcmlwdCAmJlxyXG4gICAgICAgICAgICAoc24udGFnTmFtZSA9PT0gJ3NjcmlwdCcgfHxcclxuICAgICAgICAgICAgICAgIChzbi50YWdOYW1lID09PSAnbGluaycgJiZcclxuICAgICAgICAgICAgICAgICAgICAoc24uYXR0cmlidXRlcy5yZWwgPT09ICdwcmVsb2FkJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gJ21vZHVsZXByZWxvYWQnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXMuYXMgPT09ICdzY3JpcHQnKSB8fFxyXG4gICAgICAgICAgICAgICAgKHNuLnRhZ05hbWUgPT09ICdsaW5rJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXMucmVsID09PSAncHJlZmV0Y2gnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNuLmF0dHJpYnV0ZXMuaHJlZiA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0RmlsZUV4dGVuc2lvbihzbi5hdHRyaWJ1dGVzLmhyZWYpID09PSAnanMnKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRGYXZpY29uICYmXHJcbiAgICAgICAgICAgICgoc24udGFnTmFtZSA9PT0gJ2xpbmsnICYmIHNuLmF0dHJpYnV0ZXMucmVsID09PSAnc2hvcnRjdXQgaWNvbicpIHx8XHJcbiAgICAgICAgICAgICAgICAoc24udGFnTmFtZSA9PT0gJ21ldGEnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXm1zYXBwbGljYXRpb24tdGlsZShpbWFnZXxjb2xvcikkLykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnYXBwbGljYXRpb24tbmFtZScgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09ICdpY29uJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gJ2FwcGxlLXRvdWNoLWljb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSAnc2hvcnRjdXQgaWNvbicpKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNuLnRhZ05hbWUgPT09ICdtZXRhJykge1xyXG4gICAgICAgICAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFEZXNjS2V5d29yZHMgJiZcclxuICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXmRlc2NyaXB0aW9ufGtleXdvcmRzJC8pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVNvY2lhbCAmJlxyXG4gICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL14ob2d8dHdpdHRlcnxmYik6LykgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL14ob2d8dHdpdHRlcik6LykgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdwaW50ZXJlc3QnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFSb2JvdHMgJiZcclxuICAgICAgICAgICAgICAgIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdyb2JvdHMnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnZ29vZ2xlYm90JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2Jpbmdib3QnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFIdHRwRXF1aXYgJiZcclxuICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXNbJ2h0dHAtZXF1aXYnXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YUF1dGhvcnNoaXAgJiZcclxuICAgICAgICAgICAgICAgIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdhdXRob3InIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnZ2VuZXJhdG9yJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2ZyYW1ld29yaycgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdwdWJsaXNoZXInIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAncHJvZ2lkJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15hcnRpY2xlOi8pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXnByb2R1Y3Q6LykpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVZlcmlmaWNhdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2dvb2dsZS1zaXRlLXZlcmlmaWNhdGlvbicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICd5YW5kZXgtdmVyaWZpY2F0aW9uJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2NzcmYtdG9rZW4nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAncDpkb21haW5fdmVyaWZ5JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3ZlcmlmeS12MScgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICd2ZXJpZmljYXRpb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnc2hvcGlmeS1jaGVja291dC1hcGktdG9rZW4nKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZVdpdGhJZChuLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IGRvYywgbWlycm9yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yLCBza2lwQ2hpbGQgPSBmYWxzZSwgaW5saW5lU3R5bGVzaGVldCA9IHRydWUsIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSwgbWFza1RleHRGbiwgbWFza0lucHV0Rm4sIHNsaW1ET01PcHRpb25zLCBkYXRhVVJMT3B0aW9ucyA9IHt9LCBpbmxpbmVJbWFnZXMgPSBmYWxzZSwgcmVjb3JkQ2FudmFzID0gZmFsc2UsIG9uU2VyaWFsaXplLCBvbklmcmFtZUxvYWQsIGlmcmFtZUxvYWRUaW1lb3V0ID0gNTAwMCwgb25TdHlsZXNoZWV0TG9hZCwgc3R5bGVzaGVldExvYWRUaW1lb3V0ID0gNTAwMCwga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2UsIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsIH0gPSBvcHRpb25zO1xyXG4gICAgbGV0IHsgbmVlZHNNYXNrIH0gPSBvcHRpb25zO1xyXG4gICAgbGV0IHsgcHJlc2VydmVXaGl0ZVNwYWNlID0gdHJ1ZSB9ID0gb3B0aW9ucztcclxuICAgIGlmICghbmVlZHNNYXNrICYmXHJcbiAgICAgICAgbi5jaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgY29uc3QgY2hlY2tBbmNlc3RvcnMgPSBuZWVkc01hc2sgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICBuZWVkc01hc2sgPSBuZWVkTWFza2luZ1RleHQobiwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgX3NlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplTm9kZShuLCB7XHJcbiAgICAgICAgZG9jLFxyXG4gICAgICAgIG1pcnJvcixcclxuICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgbmVlZHNNYXNrLFxyXG4gICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIG5ld2x5QWRkZWRFbGVtZW50LFxyXG4gICAgfSk7XHJcbiAgICBpZiAoIV9zZXJpYWxpemVkTm9kZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihuLCAnbm90IHNlcmlhbGl6ZWQnKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGxldCBpZDtcclxuICAgIGlmIChtaXJyb3IuaGFzTm9kZShuKSkge1xyXG4gICAgICAgIGlkID0gbWlycm9yLmdldElkKG4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2xpbURPTUV4Y2x1ZGVkKF9zZXJpYWxpemVkTm9kZSwgc2xpbURPTU9wdGlvbnMpIHx8XHJcbiAgICAgICAgKCFwcmVzZXJ2ZVdoaXRlU3BhY2UgJiZcclxuICAgICAgICAgICAgX3NlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLlRleHQgJiZcclxuICAgICAgICAgICAgIV9zZXJpYWxpemVkTm9kZS5pc1N0eWxlICYmXHJcbiAgICAgICAgICAgICFfc2VyaWFsaXplZE5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyQvZ20sICcnKS5sZW5ndGgpKSB7XHJcbiAgICAgICAgaWQgPSBJR05PUkVEX05PREU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZCA9IGdlbklkKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IE9iamVjdC5hc3NpZ24oX3NlcmlhbGl6ZWROb2RlLCB7IGlkIH0pO1xyXG4gICAgbWlycm9yLmFkZChuLCBzZXJpYWxpemVkTm9kZSk7XHJcbiAgICBpZiAoaWQgPT09IElHTk9SRURfTk9ERSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKG9uU2VyaWFsaXplKSB7XHJcbiAgICAgICAgb25TZXJpYWxpemUobik7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVjb3JkQ2hpbGQgPSAhc2tpcENoaWxkO1xyXG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQpIHtcclxuICAgICAgICByZWNvcmRDaGlsZCA9IHJlY29yZENoaWxkICYmICFzZXJpYWxpemVkTm9kZS5uZWVkQmxvY2s7XHJcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWROb2RlLm5lZWRCbG9jaztcclxuICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gbi5zaGFkb3dSb290O1xyXG4gICAgICAgIGlmIChzaGFkb3dSb290ICYmIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QpKVxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5pc1NoYWRvd0hvc3QgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5Eb2N1bWVudCB8fFxyXG4gICAgICAgIHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQpICYmXHJcbiAgICAgICAgcmVjb3JkQ2hpbGQpIHtcclxuICAgICAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZFdoaXRlc3BhY2UgJiZcclxuICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCAmJlxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAnaGVhZCcpIHtcclxuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ5cGFzc09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGRvYyxcclxuICAgICAgICAgICAgbWlycm9yLFxyXG4gICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICBuZWVkc01hc2ssXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgIHNraXBDaGlsZCxcclxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcclxuICAgICAgICAgICAgb25TZXJpYWxpemUsXHJcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcclxuICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQsXHJcbiAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcclxuICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gJ3RleHRhcmVhJyAmJlxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnZhbHVlICE9PSB1bmRlZmluZWQpIDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZE4gb2YgQXJyYXkuZnJvbShuLmNoaWxkTm9kZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChjaGlsZE4sIGJ5cGFzc09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRWxlbWVudChuKSAmJiBuLnNoYWRvd1Jvb3QpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZE4gb2YgQXJyYXkuZnJvbShuLnNoYWRvd1Jvb3QuY2hpbGROb2RlcykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTiwgYnlwYXNzT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZENoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzTmF0aXZlU2hhZG93RG9tKG4uc2hhZG93Um9vdCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcmlhbGl6ZWRDaGlsZE5vZGUuaXNTaGFkb3cgPSB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobi5wYXJlbnROb2RlICYmXHJcbiAgICAgICAgaXNTaGFkb3dSb290KG4ucGFyZW50Tm9kZSkgJiZcclxuICAgICAgICBpc05hdGl2ZVNoYWRvd0RvbShuLnBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgc2VyaWFsaXplZE5vZGUuaXNTaGFkb3cgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAnaWZyYW1lJykge1xyXG4gICAgICAgIG9uY2VJZnJhbWVMb2FkZWQobiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZnJhbWVEb2MgPSBuLmNvbnRlbnREb2N1bWVudDtcclxuICAgICAgICAgICAgaWYgKGlmcmFtZURvYyAmJiBvbklmcmFtZUxvYWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRJZnJhbWVOb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChpZnJhbWVEb2MsIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2M6IGlmcmFtZURvYyxcclxuICAgICAgICAgICAgICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzTWFzayxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcclxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZSxcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZElmcmFtZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQobiwgc2VyaWFsaXplZElmcmFtZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgaWZyYW1lTG9hZFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAnbGluaycgJiZcclxuICAgICAgICB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSAnc3R5bGVzaGVldCcgfHxcclxuICAgICAgICAgICAgKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSAncHJlbG9hZCcgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgICAgICBleHRyYWN0RmlsZUV4dGVuc2lvbihzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYpID09PSAnY3NzJykpKSB7XHJcbiAgICAgICAgb25jZVN0eWxlc2hlZXRMb2FkZWQobiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob25TdHlsZXNoZWV0TG9hZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZExpbmtOb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChuLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvcixcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNNYXNrLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU2VyaWFsaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dCxcclxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcclxuICAgICAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkTGlua05vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkKG4sIHNlcmlhbGl6ZWRMaW5rTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBzdHlsZXNoZWV0TG9hZFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xyXG59XHJcbmZ1bmN0aW9uIHNuYXBzaG90KG4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgbWlycm9yID0gbmV3IE1pcnJvcigpLCBibG9ja0NsYXNzID0gJ3JyLWJsb2NrJywgYmxvY2tTZWxlY3RvciA9IG51bGwsIG1hc2tUZXh0Q2xhc3MgPSAncnItbWFzaycsIG1hc2tUZXh0U2VsZWN0b3IgPSBudWxsLCBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSwgaW5saW5lSW1hZ2VzID0gZmFsc2UsIHJlY29yZENhbnZhcyA9IGZhbHNlLCBtYXNrQWxsSW5wdXRzID0gZmFsc2UsIG1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuLCBzbGltRE9NID0gZmFsc2UsIGRhdGFVUkxPcHRpb25zLCBwcmVzZXJ2ZVdoaXRlU3BhY2UsIG9uU2VyaWFsaXplLCBvbklmcmFtZUxvYWQsIGlmcmFtZUxvYWRUaW1lb3V0LCBvblN0eWxlc2hlZXRMb2FkLCBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsIGtlZXBJZnJhbWVTcmNGbiA9ICgpID0+IGZhbHNlLCB9ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0cnVlLFxyXG4gICAgICAgICAgICBkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxyXG4gICAgICAgICAgICBlbWFpbDogdHJ1ZSxcclxuICAgICAgICAgICAgbW9udGg6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWJlcjogdHJ1ZSxcclxuICAgICAgICAgICAgcmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIHNlYXJjaDogdHJ1ZSxcclxuICAgICAgICAgICAgdGVsOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiB0cnVlLFxyXG4gICAgICAgICAgICB0aW1lOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmw6IHRydWUsXHJcbiAgICAgICAgICAgIHdlZWs6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHRhcmVhOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHRydWUsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0cnVlLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IG1hc2tBbGxJbnB1dHMgPT09IGZhbHNlXHJcbiAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHRydWUsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBtYXNrQWxsSW5wdXRzO1xyXG4gICAgY29uc3Qgc2xpbURPTU9wdGlvbnMgPSBzbGltRE9NID09PSB0cnVlIHx8IHNsaW1ET00gPT09ICdhbGwnXHJcbiAgICAgICAgP1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzY3JpcHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb21tZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZEZhdmljb246IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkV2hpdGVzcGFjZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBzbGltRE9NID09PSAnYWxsJyxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkTWV0YUh0dHBFcXVpdjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgOiBzbGltRE9NID09PSBmYWxzZVxyXG4gICAgICAgICAgICA/IHt9XHJcbiAgICAgICAgICAgIDogc2xpbURPTTtcclxuICAgIHJldHVybiBzZXJpYWxpemVOb2RlV2l0aElkKG4sIHtcclxuICAgICAgICBkb2M6IG4sXHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcclxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcclxuICAgICAgICBvblNlcmlhbGl6ZSxcclxuICAgICAgICBvbklmcmFtZUxvYWQsXHJcbiAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcclxuICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXHJcbiAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiBmYWxzZSxcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIG9uKHR5cGUsIGZuLCB0YXJnZXQgPSBkb2N1bWVudCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9O1xyXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcclxufVxyXG5jb25zdCBERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcgPSAnUGxlYXNlIHN0b3AgaW1wb3J0IG1pcnJvciBkaXJlY3RseS4gSW5zdGVhZCBvZiB0aGF0LCcgK1xyXG4gICAgJ1xcclxcbicgK1xyXG4gICAgJ25vdyB5b3UgY2FuIHVzZSByZXBsYXllci5nZXRNaXJyb3IoKSB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBvZiBhIHJlcGxheWVyLCcgK1xyXG4gICAgJ1xcclxcbicgK1xyXG4gICAgJ29yIHlvdSBjYW4gdXNlIHJlY29yZC5taXJyb3IgdG8gYWNjZXNzIHRoZSBtaXJyb3IgaW5zdGFuY2UgZHVyaW5nIHJlY29yZGluZy4nO1xyXG5sZXQgX21pcnJvciA9IHtcclxuICAgIG1hcDoge30sXHJcbiAgICBnZXRJZCgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfSxcclxuICAgIGdldE5vZGUoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZU5vZGVGcm9tTWFwKCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgIH0sXHJcbiAgICBoYXMoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICB9LFxyXG59O1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlByb3h5ICYmIHdpbmRvdy5SZWZsZWN0KSB7XHJcbiAgICBfbWlycm9yID0gbmV3IFByb3h5KF9taXJyb3IsIHtcclxuICAgICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xyXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ21hcCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgbGV0IHRpbWVvdXQgPSBudWxsO1xyXG4gICAgbGV0IHByZXZpb3VzID0gMDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcztcclxuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xyXG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XHJcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9LCByZW1haW5pbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaG9va1NldHRlcih0YXJnZXQsIGtleSwgZCwgaXNSZXZva2VkLCB3aW4gPSB3aW5kb3cpIHtcclxuICAgIGNvbnN0IG9yaWdpbmFsID0gd2luLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xyXG4gICAgd2luLk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgaXNSZXZva2VkXHJcbiAgICAgICAgPyBkXHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbCAmJiBvcmlnaW5hbC5zZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICByZXR1cm4gKCkgPT4gaG9va1NldHRlcih0YXJnZXQsIGtleSwgb3JpZ2luYWwgfHwge30sIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoKHNvdXJjZSwgbmFtZSwgcmVwbGFjZW1lbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCEobmFtZSBpbiBzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gc291cmNlW25hbWVdO1xyXG4gICAgICAgIGNvbnN0IHdyYXBwZWQgPSByZXBsYWNlbWVudChvcmlnaW5hbCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3cmFwcGVkID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdyYXBwZWQucHJvdG90eXBlID0gd3JhcHBlZC5wcm90b3R5cGUgfHwge307XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWQsIHtcclxuICAgICAgICAgICAgICAgIF9fcnJ3ZWJfb3JpZ2luYWxfXzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb3VyY2VbbmFtZV0gPSB3cmFwcGVkO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHNvdXJjZVtuYW1lXSA9IG9yaWdpbmFsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxubGV0IG5vd1RpbWVzdGFtcCA9IERhdGUubm93O1xyXG5pZiAoISgvWzEtOV1bMC05XXsxMn0vLnRlc3QoRGF0ZS5ub3coKS50b1N0cmluZygpKSkpIHtcclxuICAgIG5vd1RpbWVzdGFtcCA9ICgpID0+IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbCh3aW4pIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBkb2Muc2Nyb2xsaW5nRWxlbWVudFxyXG4gICAgICAgICAgICA/IGRvYy5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnRcclxuICAgICAgICAgICAgOiB3aW4ucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyB3aW4ucGFnZVhPZmZzZXRcclxuICAgICAgICAgICAgICAgIDogKGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKF9iID0gKF9hID0gZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2Nyb2xsTGVmdCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKF9jID0gZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zY3JvbGxMZWZ0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgdG9wOiBkb2Muc2Nyb2xsaW5nRWxlbWVudFxyXG4gICAgICAgICAgICA/IGRvYy5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcFxyXG4gICAgICAgICAgICA6IHdpbi5wYWdlWU9mZnNldCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IHdpbi5wYWdlWU9mZnNldFxyXG4gICAgICAgICAgICAgICAgOiAoZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKChfZSA9IChfZCA9IGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5ib2R5KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnNjcm9sbFRvcCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKF9mID0gZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHkpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zY3JvbGxUb3ApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuICh3aW5kb3cuaW5uZXJIZWlnaHQgfHxcclxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHx8XHJcbiAgICAgICAgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpKTtcclxufVxyXG5mdW5jdGlvbiBnZXRXaW5kb3dXaWR0aCgpIHtcclxuICAgIHJldHVybiAod2luZG93LmlubmVyV2lkdGggfHxcclxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkgfHxcclxuICAgICAgICAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnRPZk5vZGUobm9kZSkge1xyXG4gICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbCA9IG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFXHJcbiAgICAgICAgPyBub2RlXHJcbiAgICAgICAgOiBub2RlLnBhcmVudEVsZW1lbnQ7XHJcbiAgICByZXR1cm4gZWw7XHJcbn1cclxuZnVuY3Rpb24gaXNCbG9ja2VkKG5vZGUsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKSB7XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbCA9IGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUpO1xyXG4gICAgaWYgKCFlbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGJsb2NrQ2xhc3MpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmIChjaGVja0FuY2VzdG9ycyAmJiBlbC5jbG9zZXN0KCcuJyArIGJsb2NrQ2xhc3MpICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY2xhc3NNYXRjaGVzUmVnZXgoZWwsIGJsb2NrQ2xhc3MsIGNoZWNrQW5jZXN0b3JzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICBpZiAoYmxvY2tTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmIChlbC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdChibG9ja1NlbGVjdG9yKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNTZXJpYWxpemVkKG4sIG1pcnJvcikge1xyXG4gICAgcmV0dXJuIG1pcnJvci5nZXRJZChuKSAhPT0gLTE7XHJcbn1cclxuZnVuY3Rpb24gaXNJZ25vcmVkKG4sIG1pcnJvcikge1xyXG4gICAgcmV0dXJuIG1pcnJvci5nZXRJZChuKSA9PT0gSUdOT1JFRF9OT0RFO1xyXG59XHJcbmZ1bmN0aW9uIGlzQW5jZXN0b3JSZW1vdmVkKHRhcmdldCwgbWlycm9yKSB7XHJcbiAgICBpZiAoaXNTaGFkb3dSb290KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgaWYgKCFtaXJyb3IuaGFzKGlkKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5wYXJlbnROb2RlICYmXHJcbiAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IHRhcmdldC5ET0NVTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0YXJnZXQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzQW5jZXN0b3JSZW1vdmVkKHRhcmdldC5wYXJlbnROb2RlLCBtaXJyb3IpO1xyXG59XHJcbmZ1bmN0aW9uIGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpIHtcclxuICAgIHJldHVybiBCb29sZWFuKGV2ZW50LmNoYW5nZWRUb3VjaGVzKTtcclxufVxyXG5mdW5jdGlvbiBwb2x5ZmlsbCh3aW4gPSB3aW5kb3cpIHtcclxuICAgIGlmICgnTm9kZUxpc3QnIGluIHdpbiAmJiAhd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XHJcbiAgICAgICAgd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlXHJcbiAgICAgICAgICAgIC5mb3JFYWNoO1xyXG4gICAgfVxyXG4gICAgaWYgKCdET01Ub2tlbkxpc3QnIGluIHdpbiAmJiAhd2luLkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xyXG4gICAgICAgIHdpbi5ET01Ub2tlbkxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGVcclxuICAgICAgICAgICAgLmZvckVhY2g7XHJcbiAgICB9XHJcbiAgICBpZiAoIU5vZGUucHJvdG90eXBlLmNvbnRhaW5zKSB7XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuY29udGFpbnMgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIGlmICghKDAgaW4gYXJncykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlICgobm9kZSA9IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU2VyaWFsaXplZElmcmFtZShuLCBtaXJyb3IpIHtcclxuICAgIHJldHVybiBCb29sZWFuKG4ubm9kZU5hbWUgPT09ICdJRlJBTUUnICYmIG1pcnJvci5nZXRNZXRhKG4pKTtcclxufVxyXG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KG4sIG1pcnJvcikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4obi5ub2RlTmFtZSA9PT0gJ0xJTksnICYmXHJcbiAgICAgICAgbi5ub2RlVHlwZSA9PT0gbi5FTEVNRU5UX05PREUgJiZcclxuICAgICAgICBuLmdldEF0dHJpYnV0ZSAmJlxyXG4gICAgICAgIG4uZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ3N0eWxlc2hlZXQnICYmXHJcbiAgICAgICAgbWlycm9yLmdldE1ldGEobikpO1xyXG59XHJcbmZ1bmN0aW9uIGhhc1NoYWRvd1Jvb3Qobikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4obiA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLnNoYWRvd1Jvb3QpO1xyXG59XHJcbmNsYXNzIFN0eWxlU2hlZXRNaXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IDE7XHJcbiAgICAgICAgdGhpcy5zdHlsZUlETWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmlkU3R5bGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRJZChzdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN0eWxlSURNYXAuZ2V0KHN0eWxlc2hlZXQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTtcclxuICAgIH1cclxuICAgIGhhcyhzdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVJRE1hcC5oYXMoc3R5bGVzaGVldCk7XHJcbiAgICB9XHJcbiAgICBhZGQoc3R5bGVzaGVldCwgaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXMoc3R5bGVzaGVldCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldElkKHN0eWxlc2hlZXQpO1xyXG4gICAgICAgIGxldCBuZXdJZDtcclxuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBuZXdJZCA9IHRoaXMuaWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBuZXdJZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuc3R5bGVJRE1hcC5zZXQoc3R5bGVzaGVldCwgbmV3SWQpO1xyXG4gICAgICAgIHRoaXMuaWRTdHlsZU1hcC5zZXQobmV3SWQsIHN0eWxlc2hlZXQpO1xyXG4gICAgICAgIHJldHVybiBuZXdJZDtcclxuICAgIH1cclxuICAgIGdldFN0eWxlKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRTdHlsZU1hcC5nZXQoaWQpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnN0eWxlSURNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMuaWRTdHlsZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmlkID0gMTtcclxuICAgIH1cclxuICAgIGdlbmVyYXRlSWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQrKztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRTaGFkb3dIb3N0KG4pIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBsZXQgc2hhZG93SG9zdCA9IG51bGw7XHJcbiAgICBpZiAoKChfYiA9IChfYSA9IG4uZ2V0Um9vdE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG4pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iubm9kZVR5cGUpID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiZcclxuICAgICAgICBuLmdldFJvb3ROb2RlKCkuaG9zdClcclxuICAgICAgICBzaGFkb3dIb3N0ID0gbi5nZXRSb290Tm9kZSgpLmhvc3Q7XHJcbiAgICByZXR1cm4gc2hhZG93SG9zdDtcclxufVxyXG5mdW5jdGlvbiBnZXRSb290U2hhZG93SG9zdChuKSB7XHJcbiAgICBsZXQgcm9vdFNoYWRvd0hvc3QgPSBuO1xyXG4gICAgbGV0IHNoYWRvd0hvc3Q7XHJcbiAgICB3aGlsZSAoKHNoYWRvd0hvc3QgPSBnZXRTaGFkb3dIb3N0KHJvb3RTaGFkb3dIb3N0KSkpXHJcbiAgICAgICAgcm9vdFNoYWRvd0hvc3QgPSBzaGFkb3dIb3N0O1xyXG4gICAgcmV0dXJuIHJvb3RTaGFkb3dIb3N0O1xyXG59XHJcbmZ1bmN0aW9uIHNoYWRvd0hvc3RJbkRvbShuKSB7XHJcbiAgICBjb25zdCBkb2MgPSBuLm93bmVyRG9jdW1lbnQ7XHJcbiAgICBpZiAoIWRvYylcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBjb25zdCBzaGFkb3dIb3N0ID0gZ2V0Um9vdFNoYWRvd0hvc3Qobik7XHJcbiAgICByZXR1cm4gZG9jLmNvbnRhaW5zKHNoYWRvd0hvc3QpO1xyXG59XHJcbmZ1bmN0aW9uIGluRG9tKG4pIHtcclxuICAgIGNvbnN0IGRvYyA9IG4ub3duZXJEb2N1bWVudDtcclxuICAgIGlmICghZG9jKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBkb2MuY29udGFpbnMobikgfHwgc2hhZG93SG9zdEluRG9tKG4pO1xyXG59XG5cbnZhciBFdmVudFR5cGUkMSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlJDEgfHwge30pO1xudmFyIEluY3JlbWVudGFsU291cmNlJDEgPSAvKiBAX19QVVJFX18gKi8gKChJbmNyZW1lbnRhbFNvdXJjZTIpID0+IHtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk11dGF0aW9uXCJdID0gMF0gPSBcIk11dGF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZU1vdmVcIl0gPSAxXSA9IFwiTW91c2VNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gMl0gPSBcIk1vdXNlSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNjcm9sbFwiXSA9IDNdID0gXCJTY3JvbGxcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlZpZXdwb3J0UmVzaXplXCJdID0gNF0gPSBcIlZpZXdwb3J0UmVzaXplXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJJbnB1dFwiXSA9IDVdID0gXCJJbnB1dFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVG91Y2hNb3ZlXCJdID0gNl0gPSBcIlRvdWNoTW92ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTWVkaWFJbnRlcmFjdGlvblwiXSA9IDddID0gXCJNZWRpYUludGVyYWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZVNoZWV0UnVsZVwiXSA9IDhdID0gXCJTdHlsZVNoZWV0UnVsZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ2FudmFzTXV0YXRpb25cIl0gPSA5XSA9IFwiQ2FudmFzTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkZvbnRcIl0gPSAxMF0gPSBcIkZvbnRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkxvZ1wiXSA9IDExXSA9IFwiTG9nXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJEcmFnXCJdID0gMTJdID0gXCJEcmFnXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZURlY2xhcmF0aW9uXCJdID0gMTNdID0gXCJTdHlsZURlY2xhcmF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTZWxlY3Rpb25cIl0gPSAxNF0gPSBcIlNlbGVjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQWRvcHRlZFN0eWxlU2hlZXRcIl0gPSAxNV0gPSBcIkFkb3B0ZWRTdHlsZVNoZWV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDdXN0b21FbGVtZW50XCJdID0gMTZdID0gXCJDdXN0b21FbGVtZW50XCI7XG4gIHJldHVybiBJbmNyZW1lbnRhbFNvdXJjZTI7XG59KShJbmNyZW1lbnRhbFNvdXJjZSQxIHx8IHt9KTtcbnZhciBNb3VzZUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1vdXNlSW50ZXJhY3Rpb25zMikgPT4ge1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VVcFwiXSA9IDBdID0gXCJNb3VzZVVwXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZURvd25cIl0gPSAxXSA9IFwiTW91c2VEb3duXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDbGlja1wiXSA9IDJdID0gXCJDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ29udGV4dE1lbnVcIl0gPSAzXSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkRibENsaWNrXCJdID0gNF0gPSBcIkRibENsaWNrXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJGb2N1c1wiXSA9IDVdID0gXCJGb2N1c1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQmx1clwiXSA9IDZdID0gXCJCbHVyXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaFN0YXJ0XCJdID0gN10gPSBcIlRvdWNoU3RhcnRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoTW92ZV9EZXBhcnRlZFwiXSA9IDhdID0gXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoRW5kXCJdID0gOV0gPSBcIlRvdWNoRW5kXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaENhbmNlbFwiXSA9IDEwXSA9IFwiVG91Y2hDYW5jZWxcIjtcbiAgcmV0dXJuIE1vdXNlSW50ZXJhY3Rpb25zMjtcbn0pKE1vdXNlSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBQb2ludGVyVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gKChQb2ludGVyVHlwZXMyKSA9PiB7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIk1vdXNlXCJdID0gMF0gPSBcIk1vdXNlXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlBlblwiXSA9IDFdID0gXCJQZW5cIjtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiVG91Y2hcIl0gPSAyXSA9IFwiVG91Y2hcIjtcbiAgcmV0dXJuIFBvaW50ZXJUeXBlczI7XG59KShQb2ludGVyVHlwZXMgfHwge30pO1xudmFyIENhbnZhc0NvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gKChDYW52YXNDb250ZXh0MikgPT4ge1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIjJEXCJdID0gMF0gPSBcIjJEXCI7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0xcIl0gPSAxXSA9IFwiV2ViR0xcIjtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCJXZWJHTDJcIl0gPSAyXSA9IFwiV2ViR0wyXCI7XG4gIHJldHVybiBDYW52YXNDb250ZXh0Mjtcbn0pKENhbnZhc0NvbnRleHQgfHwge30pO1xuXG5mdW5jdGlvbiBpc05vZGVJbkxpbmtlZExpc3Qobikge1xyXG4gICAgcmV0dXJuICdfX2xuJyBpbiBuO1xyXG59XHJcbmNsYXNzIERvdWJsZUxpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldChwb3NpdGlvbikge1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIG91dHNpZGUgb2YgbGlzdCByYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcG9zaXRpb247IGluZGV4KyspIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnQubmV4dCkgfHwgbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICBhZGROb2RlKG4pIHtcclxuICAgICAgICBjb25zdCBub2RlID0ge1xyXG4gICAgICAgICAgICB2YWx1ZTogbixcclxuICAgICAgICAgICAgcHJldmlvdXM6IG51bGwsXHJcbiAgICAgICAgICAgIG5leHQ6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBuLl9fbG4gPSBub2RlO1xyXG4gICAgICAgIGlmIChuLnByZXZpb3VzU2libGluZyAmJiBpc05vZGVJbkxpbmtlZExpc3Qobi5wcmV2aW91c1NpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBuLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQ7XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIG5vZGUucHJldmlvdXMgPSBuLnByZXZpb3VzU2libGluZy5fX2xuO1xyXG4gICAgICAgICAgICBuLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cyA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobi5uZXh0U2libGluZyAmJlxyXG4gICAgICAgICAgICBpc05vZGVJbkxpbmtlZExpc3Qobi5uZXh0U2libGluZykgJiZcclxuICAgICAgICAgICAgbi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBuLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXM7XHJcbiAgICAgICAgICAgIG5vZGUucHJldmlvdXMgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICBub2RlLm5leHQgPSBuLm5leHRTaWJsaW5nLl9fbG47XHJcbiAgICAgICAgICAgIG4ubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cyA9IG5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZDtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUubmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlbmd0aCsrO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTm9kZShuKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudCA9IG4uX19sbjtcclxuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY3VycmVudC5wcmV2aW91cykge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5leHQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dC5wcmV2aW91cyA9IGN1cnJlbnQucHJldmlvdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBjdXJyZW50LnByZXZpb3VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLl9fbG4pIHtcclxuICAgICAgICAgICAgZGVsZXRlIG4uX19sbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcclxuICAgIH1cclxufVxyXG5jb25zdCBtb3ZlS2V5ID0gKGlkLCBwYXJlbnRJZCkgPT4gYCR7aWR9QCR7cGFyZW50SWR9YDtcclxuY2xhc3MgTXV0YXRpb25CdWZmZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGV4dHMgPSBbXTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVzID0gW107XHJcbiAgICAgICAgdGhpcy5tYXBSZW1vdmVzID0gW107XHJcbiAgICAgICAgdGhpcy5tb3ZlZE1hcCA9IHt9O1xyXG4gICAgICAgIHRoaXMuYWRkZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5tb3ZlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmRyb3BwZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb25zID0gKG11dGF0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaCh0aGlzLnByb2Nlc3NNdXRhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5lbWl0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mcm96ZW4gfHwgdGhpcy5sb2NrZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhZGRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkSWRzID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRMaXN0ID0gbmV3IERvdWJsZUxpbmtlZExpc3QoKTtcclxuICAgICAgICAgICAgY29uc3QgZ2V0TmV4dElkID0gKG4pID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBucyA9IG47XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dElkID0gSUdOT1JFRF9OT0RFO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRJZCA9PT0gSUdOT1JFRF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnMgPSBucyAmJiBucy5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICBuZXh0SWQgPSBucyAmJiB0aGlzLm1pcnJvci5nZXRJZChucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dElkO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwdXNoQWRkID0gKG4pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghbi5wYXJlbnROb2RlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIWluRG9tKG4pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbi5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChuLnBhcmVudE5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1pcnJvci5nZXRJZChnZXRTaGFkb3dIb3N0KG4pKVxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5taXJyb3IuZ2V0SWQobi5wYXJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChuKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCA9PT0gLTEgfHwgbmV4dElkID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRMaXN0LmFkZE5vZGUobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzbiA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQobiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvYzogdGhpcy5kb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzOiB0aGlzLmJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogdGhpcy5ibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IHRoaXMubWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiB0aGlzLm1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IHRoaXMuaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiB0aGlzLm1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRGbjogdGhpcy5tYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiB0aGlzLm1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiB0aGlzLnNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiB0aGlzLmRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogdGhpcy5yZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiB0aGlzLmlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZTogKGN1cnJlbnROKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUoY3VycmVudE4sIHRoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pZnJhbWVNYW5hZ2VyLmFkZElmcmFtZShjdXJyZW50Tik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQoY3VycmVudE4sIHRoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci50cmFja0xpbmtFbGVtZW50KGN1cnJlbnROKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLmFkZFNoYWRvd1Jvb3Qobi5zaGFkb3dSb290LCB0aGlzLmRvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogKGlmcmFtZSwgY2hpbGRTbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlmcmFtZU1hbmFnZXIuYXR0YWNoSWZyYW1lKGlmcmFtZSwgY2hpbGRTbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiAobGluaywgY2hpbGRTbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmssIGNoaWxkU24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChzbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IHNuLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkSWRzLmFkZChzbi5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLm1hcFJlbW92ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5yZW1vdmVOb2RlRnJvbU1hcCh0aGlzLm1hcFJlbW92ZXMuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBuIG9mIHRoaXMubW92ZWRTZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzLCBuLCB0aGlzLm1pcnJvcikgJiZcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5tb3ZlZFNldC5oYXMobi5wYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHVzaEFkZChuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5hZGRlZFNldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FuY2VzdG9ySW5TZXQodGhpcy5kcm9wcGVkU2V0LCBuKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzLCBuLCB0aGlzLm1pcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoQWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBbmNlc3RvckluU2V0KHRoaXMubW92ZWRTZXQsIG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaEFkZChuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcHBlZFNldC5hZGQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHdoaWxlIChhZGRMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5taXJyb3IuZ2V0SWQoY2FuZGlkYXRlLnZhbHVlLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChjYW5kaWRhdGUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCAhPT0gLTEgJiYgbmV4dElkICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gY2FuZGlkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWlsTm9kZSA9IGFkZExpc3QudGFpbDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGFpbE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX25vZGUgPSB0YWlsTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKF9ub2RlLnZhbHVlLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKF9ub2RlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0SWQgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IF9ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5oYW5kbGVkTm9kZSA9IF9ub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmhhbmRsZWROb2RlLnBhcmVudE5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oYW5kbGVkTm9kZS5wYXJlbnROb2RlLm5vZGVUeXBlID09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd0hvc3QgPSB1bmhhbmRsZWROb2RlLnBhcmVudE5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ob3N0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKHNoYWRvd0hvc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gX25vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhZGRMaXN0LmhlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTGlzdC5yZW1vdmVOb2RlKGFkZExpc3QuaGVhZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZS5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShub2RlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHB1c2hBZGQobm9kZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgICAgICAgICAgIHRleHRzOiB0aGlzLnRleHRzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgodGV4dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB0ZXh0Lm5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4ucGFyZW50Tm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihuLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5taXJyb3IuZ2V0SWQobiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXh0LnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHRleHQpID0+ICFhZGRlZElkcy5oYXModGV4dC5pZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodGV4dCkgPT4gdGhpcy5taXJyb3IuaGFzKHRleHQuaWQpKSxcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gYXR0cmlidXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5zdHlsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZkFzU3RyID0gSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlLnN0eWxlRGlmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZEFzU3RyID0gSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlLl91bmNoYW5nZWRTdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZkFzU3RyLmxlbmd0aCA8IGF0dHJpYnV0ZXMuc3R5bGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRpZmZBc1N0ciArIHVuY2hhbmdlZEFzU3RyKS5zcGxpdCgndmFyKCcpLmxlbmd0aCA9PT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlLnNwbGl0KCd2YXIoJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IGF0dHJpYnV0ZS5zdHlsZURpZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMubWlycm9yLmdldElkKGF0dHJpYnV0ZS5ub2RlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChhdHRyaWJ1dGUpID0+ICFhZGRlZElkcy5oYXMoYXR0cmlidXRlLmlkKSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChhdHRyaWJ1dGUpID0+IHRoaXMubWlycm9yLmhhcyhhdHRyaWJ1dGUuaWQpKSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IHRoaXMucmVtb3ZlcyxcclxuICAgICAgICAgICAgICAgIGFkZHMsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICghcGF5bG9hZC50ZXh0cy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICFwYXlsb2FkLmF0dHJpYnV0ZXMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAhcGF5bG9hZC5yZW1vdmVzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgIXBheWxvYWQuYWRkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRleHRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFkZGVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRyb3BwZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZWRNYXAgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHBheWxvYWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24gPSAodGV4dGFyZWEpID0+IHtcclxuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmF0dHJpYnV0ZU1hcC5nZXQodGV4dGFyZWEpO1xyXG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogdGV4dGFyZWEsXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVEaWZmOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTWFwLnNldCh0ZXh0YXJlYSwgaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzLnZhbHVlID0gQXJyYXkuZnJvbSh0ZXh0YXJlYS5jaGlsZE5vZGVzLCAoY24pID0+IGNuLnRleHRDb250ZW50IHx8ICcnKS5qb2luKCcnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc011dGF0aW9uID0gKG0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzSWdub3JlZChtLnRhcmdldCwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChtLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoYXJhY3RlckRhdGEnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtLnRhcmdldC50ZXh0Q29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChtLnRhcmdldCwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gbS5vbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5lZWRNYXNraW5nVGV4dChtLnRhcmdldCwgdGhpcy5tYXNrVGV4dENsYXNzLCB0aGlzLm1hc2tUZXh0U2VsZWN0b3IsIHRydWUpICYmIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1hc2tUZXh0Rm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1hc2tUZXh0Rm4odmFsdWUsIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG0udGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZS5yZXBsYWNlKC9bXFxTXS9nLCAnKicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG0udGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdHRyaWJ1dGVOYW1lID0gbS5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IG0udGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWFza0lucHV0VmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogdGhpcy5tYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogdGFyZ2V0LnRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogdGhpcy5tYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IG0ub2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuYXR0cmlidXRlTWFwLmdldChtLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnSUZSQU1FJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID09PSAnc3JjJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5rZWVwSWZyYW1lU3JjRm4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9ICdycl9zcmMnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbS50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRGlmZjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTWFwLnNldChtLnRhcmdldCwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSAndHlwZScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnRhZ05hbWUgPT09ICdJTlBVVCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG0ub2xkVmFsdWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgPT09ICdwYXNzd29yZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS1yci1pcy1wYXNzd29yZCcsICd0cnVlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhcmdldC50YWdOYW1lLCBhdHRyaWJ1dGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSB0cmFuc2Zvcm1BdHRyaWJ1dGUodGhpcy5kb2MsIHRvTG93ZXJDYXNlKHRhcmdldC50YWdOYW1lKSwgdG9Mb3dlckNhc2UoYXR0cmlidXRlTmFtZSksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy51bmF0dGFjaGVkRG9jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmF0dGFjaGVkRG9jID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuYXR0YWNoZWREb2MgPSB0aGlzLmRvYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSB0aGlzLnVuYXR0YWNoZWREb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ub2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQuc2V0QXR0cmlidXRlKCdzdHlsZScsIG0ub2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwbmFtZSBvZiBBcnJheS5mcm9tKHRhcmdldC5zdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQcmlvcml0eSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IG9sZC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQcmlvcml0eSAhPT0gb2xkLnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdQcmlvcml0eSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gW25ld1ZhbHVlLCBuZXdQcmlvcml0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uX3VuY2hhbmdlZFN0eWxlc1twbmFtZV0gPSBbbmV3VmFsdWUsIG5ld1ByaW9yaXR5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBuYW1lIG9mIEFycmF5LmZyb20ob2xkLnN0eWxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSkgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoaWxkTGlzdCc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgdHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobS50YXJnZXQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihtLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbS5hZGRlZE5vZGVzLmZvckVhY2goKG4pID0+IHRoaXMuZ2VuQWRkcyhuLCBtLnRhcmdldCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG0ucmVtb3ZlZE5vZGVzLmZvckVhY2goKG4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gdGhpcy5taXJyb3IuZ2V0SWQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gaXNTaGFkb3dSb290KG0udGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1pcnJvci5nZXRJZChtLnRhcmdldC5ob3N0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLm1pcnJvci5nZXRJZChtLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSWdub3JlZChuLCB0aGlzLm1pcnJvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc1NlcmlhbGl6ZWQobiwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkZWRTZXQuaGFzKG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwRGVsZXRlKHRoaXMuYWRkZWRTZXQsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmFkZChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhtLnRhcmdldCkgJiYgbm9kZUlkID09PSAtMSkgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FuY2VzdG9yUmVtb3ZlZChtLnRhcmdldCwgdGhpcy5taXJyb3IpKSA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubW92ZWRTZXQuaGFzKG4pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVkTWFwW21vdmVLZXkobm9kZUlkLCBwYXJlbnRJZCldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwRGVsZXRlKHRoaXMubW92ZWRTZXQsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTaGFkb3c6IGlzU2hhZG93Um9vdChtLnRhcmdldCkgJiYgaXNOYXRpdmVTaGFkb3dEb20obS50YXJnZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwUmVtb3Zlcy5wdXNoKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdlbkFkZHMgPSAobiwgdGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZE5vZGVNYW5hZ2VyLmluT3RoZXJCdWZmZXIobiwgdGhpcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhuKSB8fCB0aGlzLm1vdmVkU2V0LmhhcyhuKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yLmhhc05vZGUobikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yZWQobiwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlZFNldC5hZGQobik7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0aGlzLm1pcnJvci5oYXNOb2RlKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZCA9IHRoaXMubWlycm9yLmdldElkKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SWQgJiYgdGFyZ2V0SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlZE1hcFttb3ZlS2V5KHRoaXMubWlycm9yLmdldElkKG4pLCB0YXJnZXRJZCldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkZWRTZXQuYWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmRlbGV0ZShuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChuLCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpKSB7XHJcbiAgICAgICAgICAgICAgICBuLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROKSA9PiB0aGlzLmdlbkFkZHMoY2hpbGROKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4uc2hhZG93Um9vdC5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZE5vZGVNYW5hZ2VyLmFkZChjaGlsZE4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbkFkZHMoY2hpbGROLCBuKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpbml0KG9wdGlvbnMpIHtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdtdXRhdGlvbkNiJyxcclxuICAgICAgICAgICAgJ2Jsb2NrQ2xhc3MnLFxyXG4gICAgICAgICAgICAnYmxvY2tTZWxlY3RvcicsXHJcbiAgICAgICAgICAgICdtYXNrVGV4dENsYXNzJyxcclxuICAgICAgICAgICAgJ21hc2tUZXh0U2VsZWN0b3InLFxyXG4gICAgICAgICAgICAnaW5saW5lU3R5bGVzaGVldCcsXHJcbiAgICAgICAgICAgICdtYXNrSW5wdXRPcHRpb25zJyxcclxuICAgICAgICAgICAgJ21hc2tUZXh0Rm4nLFxyXG4gICAgICAgICAgICAnbWFza0lucHV0Rm4nLFxyXG4gICAgICAgICAgICAna2VlcElmcmFtZVNyY0ZuJyxcclxuICAgICAgICAgICAgJ3JlY29yZENhbnZhcycsXHJcbiAgICAgICAgICAgICdpbmxpbmVJbWFnZXMnLFxyXG4gICAgICAgICAgICAnc2xpbURPTU9wdGlvbnMnLFxyXG4gICAgICAgICAgICAnZGF0YVVSTE9wdGlvbnMnLFxyXG4gICAgICAgICAgICAnZG9jJyxcclxuICAgICAgICAgICAgJ21pcnJvcicsXHJcbiAgICAgICAgICAgICdpZnJhbWVNYW5hZ2VyJyxcclxuICAgICAgICAgICAgJ3N0eWxlc2hlZXRNYW5hZ2VyJyxcclxuICAgICAgICAgICAgJ3NoYWRvd0RvbU1hbmFnZXInLFxyXG4gICAgICAgICAgICAnY2FudmFzTWFuYWdlcicsXHJcbiAgICAgICAgICAgICdwcm9jZXNzZWROb2RlTWFuYWdlcicsXHJcbiAgICAgICAgXS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnJlZXplKCkge1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZnJlZXplKCk7XHJcbiAgICB9XHJcbiAgICB1bmZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmZyZWV6ZSgpO1xyXG4gICAgICAgIHRoaXMuZW1pdCgpO1xyXG4gICAgfVxyXG4gICAgaXNGcm96ZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvemVuO1xyXG4gICAgfVxyXG4gICAgbG9jaygpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmxvY2soKTtcclxuICAgIH1cclxuICAgIHVubG9jaygpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmxvY2soKTtcclxuICAgICAgICB0aGlzLmVtaXQoKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5yZXNldCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlZXBEZWxldGUoYWRkc1NldCwgbikge1xyXG4gICAgYWRkc1NldC5kZWxldGUobik7XHJcbiAgICBuLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROKSA9PiBkZWVwRGVsZXRlKGFkZHNTZXQsIGNoaWxkTikpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuLCBtaXJyb3IpIHtcclxuICAgIGlmIChyZW1vdmVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuLCBtaXJyb3IpO1xyXG59XHJcbmZ1bmN0aW9uIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbiwgbWlycm9yKSB7XHJcbiAgICBjb25zdCB7IHBhcmVudE5vZGUgfSA9IG47XHJcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJlbnRJZCA9IG1pcnJvci5nZXRJZChwYXJlbnROb2RlKTtcclxuICAgIGlmIChyZW1vdmVzLnNvbWUoKHIpID0+IHIuaWQgPT09IHBhcmVudElkKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgcGFyZW50Tm9kZSwgbWlycm9yKTtcclxufVxyXG5mdW5jdGlvbiBpc0FuY2VzdG9ySW5TZXQoc2V0LCBuKSB7XHJcbiAgICBpZiAoc2V0LnNpemUgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBuKTtcclxufVxyXG5mdW5jdGlvbiBfaXNBbmNlc3RvckluU2V0KHNldCwgbikge1xyXG4gICAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSBuO1xyXG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNldC5oYXMocGFyZW50Tm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgcGFyZW50Tm9kZSk7XHJcbn1cblxubGV0IGVycm9ySGFuZGxlcjtcclxuZnVuY3Rpb24gcmVnaXN0ZXJFcnJvckhhbmRsZXIoaGFuZGxlcikge1xyXG4gICAgZXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcclxufVxyXG5mdW5jdGlvbiB1bnJlZ2lzdGVyRXJyb3JIYW5kbGVyKCkge1xyXG4gICAgZXJyb3JIYW5kbGVyID0gdW5kZWZpbmVkO1xyXG59XHJcbmNvbnN0IGNhbGxiYWNrV3JhcHBlciA9IChjYikgPT4ge1xyXG4gICAgaWYgKCFlcnJvckhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gY2I7XHJcbiAgICB9XHJcbiAgICBjb25zdCBycndlYldyYXBwZWQgPSAoKC4uLnJlc3QpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2IoLi4ucmVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JIYW5kbGVyICYmIGVycm9ySGFuZGxlcihlcnJvcikgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBycndlYldyYXBwZWQ7XHJcbn07XG5cbmNvbnN0IG11dGF0aW9uQnVmZmVycyA9IFtdO1xyXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoJ2NvbXBvc2VkUGF0aCcgaW4gZXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xyXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdwYXRoJyBpbiBldmVudCAmJiBldmVudC5wYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucGF0aFswXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBldmVudCAmJiBldmVudC50YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIob3B0aW9ucywgcm9vdEVsKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgY29uc3QgbXV0YXRpb25CdWZmZXIgPSBuZXcgTXV0YXRpb25CdWZmZXIoKTtcclxuICAgIG11dGF0aW9uQnVmZmVycy5wdXNoKG11dGF0aW9uQnVmZmVyKTtcclxuICAgIG11dGF0aW9uQnVmZmVyLmluaXQob3B0aW9ucyk7XHJcbiAgICBsZXQgbXV0YXRpb25PYnNlcnZlckN0b3IgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fFxyXG4gICAgICAgIHdpbmRvdy5fX3JyTXV0YXRpb25PYnNlcnZlcjtcclxuICAgIGNvbnN0IGFuZ3VsYXJab25lU3ltYm9sID0gKF9iID0gKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LlpvbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fX3N5bWJvbF9fKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgJ011dGF0aW9uT2JzZXJ2ZXInKTtcclxuICAgIGlmIChhbmd1bGFyWm9uZVN5bWJvbCAmJlxyXG4gICAgICAgIHdpbmRvd1thbmd1bGFyWm9uZVN5bWJvbF0pIHtcclxuICAgICAgICBtdXRhdGlvbk9ic2VydmVyQ3RvciA9IHdpbmRvd1thbmd1bGFyWm9uZVN5bWJvbF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBtdXRhdGlvbk9ic2VydmVyQ3RvcihjYWxsYmFja1dyYXBwZXIobXV0YXRpb25CdWZmZXIucHJvY2Vzc011dGF0aW9ucy5iaW5kKG11dGF0aW9uQnVmZmVyKSkpO1xyXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWwsIHtcclxuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxyXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxyXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2JzZXJ2ZXI7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE1vdmVPYnNlcnZlcih7IG1vdXNlbW92ZUNiLCBzYW1wbGluZywgZG9jLCBtaXJyb3IsIH0pIHtcclxuICAgIGlmIChzYW1wbGluZy5tb3VzZW1vdmUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gJ251bWJlcicgPyBzYW1wbGluZy5tb3VzZW1vdmUgOiA1MDtcclxuICAgIGNvbnN0IGNhbGxiYWNrVGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZUNhbGxiYWNrID09PSAnbnVtYmVyJ1xyXG4gICAgICAgID8gc2FtcGxpbmcubW91c2Vtb3ZlQ2FsbGJhY2tcclxuICAgICAgICA6IDUwMDtcclxuICAgIGxldCBwb3NpdGlvbnMgPSBbXTtcclxuICAgIGxldCB0aW1lQmFzZWxpbmU7XHJcbiAgICBjb25zdCB3cmFwcGVkQ2IgPSB0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKHNvdXJjZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvdGFsT2Zmc2V0ID0gRGF0ZS5ub3coKSAtIHRpbWVCYXNlbGluZTtcclxuICAgICAgICBtb3VzZW1vdmVDYihwb3NpdGlvbnMubWFwKChwKSA9PiB7XHJcbiAgICAgICAgICAgIHAudGltZU9mZnNldCAtPSB0b3RhbE9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSksIHNvdXJjZSk7XHJcbiAgICAgICAgcG9zaXRpb25zID0gW107XHJcbiAgICAgICAgdGltZUJhc2VsaW5lID0gbnVsbDtcclxuICAgIH0pLCBjYWxsYmFja1RocmVzaG9sZCk7XHJcbiAgICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKGV2dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XHJcbiAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2dClcclxuICAgICAgICAgICAgPyBldnQuY2hhbmdlZFRvdWNoZXNbMF1cclxuICAgICAgICAgICAgOiBldnQ7XHJcbiAgICAgICAgaWYgKCF0aW1lQmFzZWxpbmUpIHtcclxuICAgICAgICAgICAgdGltZUJhc2VsaW5lID0gbm93VGltZXN0YW1wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgeDogY2xpZW50WCxcclxuICAgICAgICAgICAgeTogY2xpZW50WSxcclxuICAgICAgICAgICAgaWQ6IG1pcnJvci5nZXRJZCh0YXJnZXQpLFxyXG4gICAgICAgICAgICB0aW1lT2Zmc2V0OiBub3dUaW1lc3RhbXAoKSAtIHRpbWVCYXNlbGluZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB3cmFwcGVkQ2IodHlwZW9mIERyYWdFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZ0IGluc3RhbmNlb2YgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgID8gSW5jcmVtZW50YWxTb3VyY2UkMS5EcmFnXHJcbiAgICAgICAgICAgIDogZXZ0IGluc3RhbmNlb2YgTW91c2VFdmVudFxyXG4gICAgICAgICAgICAgICAgPyBJbmNyZW1lbnRhbFNvdXJjZSQxLk1vdXNlTW92ZVxyXG4gICAgICAgICAgICAgICAgOiBJbmNyZW1lbnRhbFNvdXJjZSQxLlRvdWNoTW92ZSk7XHJcbiAgICB9KSwgdGhyZXNob2xkLCB7XHJcbiAgICAgICAgdHJhaWxpbmc6IGZhbHNlLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXHJcbiAgICAgICAgb24oJ21vdXNlbW92ZScsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxyXG4gICAgICAgIG9uKCd0b3VjaG1vdmUnLCB1cGRhdGVQb3NpdGlvbiwgZG9jKSxcclxuICAgICAgICBvbignZHJhZycsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0TW91c2VJbnRlcmFjdGlvbk9ic2VydmVyKHsgbW91c2VJbnRlcmFjdGlvbkNiLCBkb2MsIG1pcnJvciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2FtcGxpbmcsIH0pIHtcclxuICAgIGlmIChzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRpc2FibGVNYXAgPSBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB0cnVlIHx8XHJcbiAgICAgICAgc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyB7fVxyXG4gICAgICAgIDogc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbjtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBsZXQgY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcclxuICAgIGNvbnN0IGdldEhhbmRsZXIgPSAoZXZlbnRLZXkpID0+IHtcclxuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHBvaW50ZXJUeXBlID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IHRoaXNFdmVudEtleSA9IGV2ZW50S2V5O1xyXG4gICAgICAgICAgICBpZiAoJ3BvaW50ZXJUeXBlJyBpbiBldmVudCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5wb2ludGVyVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21vdXNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuTW91c2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvdWNoJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Blbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlBlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlRG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRXZlbnRLZXkgPSAnVG91Y2hTdGFydCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuTW91c2VVcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRXZlbnRLZXkgPSAnVG91Y2hFbmQnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuUGVuKSA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlRvdWNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXNFdmVudEtleS5zdGFydHNXaXRoKCdUb3VjaCcpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAodGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoJ01vdXNlJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Nb3VzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldID09PSBNb3VzZUludGVyYWN0aW9ucy5DbGljaykge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBjdXJyZW50UG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQ7XHJcbiAgICAgICAgICAgIGlmICghZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWlycm9yLmdldElkKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcclxuICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKG1vdXNlSW50ZXJhY3Rpb25DYikoT2JqZWN0LmFzc2lnbih7IHR5cGU6IE1vdXNlSW50ZXJhY3Rpb25zW3RoaXNFdmVudEtleV0sIGlkLCB4OiBjbGllbnRYLCB5OiBjbGllbnRZIH0sIChwb2ludGVyVHlwZSAhPT0gbnVsbCAmJiB7IHBvaW50ZXJUeXBlIH0pKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBPYmplY3Qua2V5cyhNb3VzZUludGVyYWN0aW9ucylcclxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IE51bWJlci5pc05hTihOdW1iZXIoa2V5KSkgJiZcclxuICAgICAgICAha2V5LmVuZHNXaXRoKCdfRGVwYXJ0ZWQnKSAmJlxyXG4gICAgICAgIGRpc2FibGVNYXBba2V5XSAhPT0gZmFsc2UpXHJcbiAgICAgICAgLmZvckVhY2goKGV2ZW50S2V5KSA9PiB7XHJcbiAgICAgICAgbGV0IGV2ZW50TmFtZSA9IHRvTG93ZXJDYXNlKGV2ZW50S2V5KTtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gZ2V0SGFuZGxlcihldmVudEtleSk7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VEb3duOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZVVwOlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS5yZXBsYWNlKCdtb3VzZScsICdwb2ludGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoU3RhcnQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoRW5kOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVycy5wdXNoKG9uKGV2ZW50TmFtZSwgaGFuZGxlciwgZG9jKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0U2Nyb2xsT2JzZXJ2ZXIoeyBzY3JvbGxDYiwgZG9jLCBtaXJyb3IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHNhbXBsaW5nLCB9KSB7XHJcbiAgICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKGV2dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgfHxcclxuICAgICAgICAgICAgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXcpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsTGVmdFRvcCA9IGdldFdpbmRvd1Njcm9sbChkb2MuZGVmYXVsdFZpZXcpO1xyXG4gICAgICAgICAgICBzY3JvbGxDYih7XHJcbiAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgIHg6IHNjcm9sbExlZnRUb3AubGVmdCxcclxuICAgICAgICAgICAgICAgIHk6IHNjcm9sbExlZnRUb3AudG9wLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNjcm9sbENiKHtcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgeDogdGFyZ2V0LnNjcm9sbExlZnQsXHJcbiAgICAgICAgICAgICAgICB5OiB0YXJnZXQuc2Nyb2xsVG9wLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KSwgc2FtcGxpbmcuc2Nyb2xsIHx8IDEwMCkpO1xyXG4gICAgcmV0dXJuIG9uKCdzY3JvbGwnLCB1cGRhdGVQb3NpdGlvbiwgZG9jKTtcclxufVxyXG5mdW5jdGlvbiBpbml0Vmlld3BvcnRSZXNpemVPYnNlcnZlcih7IHZpZXdwb3J0UmVzaXplQ2IgfSwgeyB3aW4gfSkge1xyXG4gICAgbGV0IGxhc3RIID0gLTE7XHJcbiAgICBsZXQgbGFzdFcgPSAtMTtcclxuICAgIGNvbnN0IHVwZGF0ZURpbWVuc2lvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGdldFdpbmRvd0hlaWdodCgpO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0V2luZG93V2lkdGgoKTtcclxuICAgICAgICBpZiAobGFzdEggIT09IGhlaWdodCB8fCBsYXN0VyAhPT0gd2lkdGgpIHtcclxuICAgICAgICAgICAgdmlld3BvcnRSZXNpemVDYih7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogTnVtYmVyKHdpZHRoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKGhlaWdodCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsYXN0SCA9IGhlaWdodDtcclxuICAgICAgICAgICAgbGFzdFcgPSB3aWR0aDtcclxuICAgICAgICB9XHJcbiAgICB9KSwgMjAwKSk7XHJcbiAgICByZXR1cm4gb24oJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbiwgd2luKTtcclxufVxyXG5jb25zdCBJTlBVVF9UQUdTID0gWydJTlBVVCcsICdURVhUQVJFQScsICdTRUxFQ1QnXTtcclxuY29uc3QgbGFzdElucHV0VmFsdWVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiBpbml0SW5wdXRPYnNlcnZlcih7IGlucHV0Q2IsIGRvYywgbWlycm9yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBpZ25vcmVDbGFzcywgaWdub3JlU2VsZWN0b3IsIG1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dEZuLCBzYW1wbGluZywgdXNlclRyaWdnZXJlZE9uSW5wdXQsIH0pIHtcclxuICAgIGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihldmVudCkge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XHJcbiAgICAgICAgY29uc3QgdXNlclRyaWdnZXJlZCA9IGV2ZW50LmlzVHJ1c3RlZDtcclxuICAgICAgICBjb25zdCB0YWdOYW1lID0gdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lO1xyXG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFnTmFtZSA9PT0gJ09QVElPTicpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGFyZ2V0IHx8XHJcbiAgICAgICAgICAgICF0YWdOYW1lIHx8XHJcbiAgICAgICAgICAgIElOUFVUX1RBR1MuaW5kZXhPZih0YWdOYW1lKSA8IDAgfHxcclxuICAgICAgICAgICAgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcykgfHxcclxuICAgICAgICAgICAgKGlnbm9yZVNlbGVjdG9yICYmIHRhcmdldC5tYXRjaGVzKGlnbm9yZVNlbGVjdG9yKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGV4dCA9IHRhcmdldC52YWx1ZTtcclxuICAgICAgICBsZXQgaXNDaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldElucHV0VHlwZSh0YXJnZXQpIHx8ICcnO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICAgICAgaXNDaGVja2VkID0gdGFyZ2V0LmNoZWNrZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSBtYXNrSW5wdXRWYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgdGFnTmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dCxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2JXaXRoRGVkdXAodGFyZ2V0LCB1c2VyVHJpZ2dlcmVkT25JbnB1dFxyXG4gICAgICAgICAgICA/IHsgdGV4dCwgaXNDaGVja2VkLCB1c2VyVHJpZ2dlcmVkIH1cclxuICAgICAgICAgICAgOiB7IHRleHQsIGlzQ2hlY2tlZCB9KTtcclxuICAgICAgICBjb25zdCBuYW1lID0gdGFyZ2V0Lm5hbWU7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAmJiBpc0NoZWNrZWQpIHtcclxuICAgICAgICAgICAgZG9jXHJcbiAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvckFsbChgaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCIke25hbWV9XCJdYClcclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsICE9PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZWwudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2JXaXRoRGVkdXAoZWwsIHVzZXJUcmlnZ2VyZWRPbklucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyB0ZXh0LCBpc0NoZWNrZWQ6ICFpc0NoZWNrZWQsIHVzZXJUcmlnZ2VyZWQ6IGZhbHNlIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHRleHQsIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2JXaXRoRGVkdXAodGFyZ2V0LCB2KSB7XHJcbiAgICAgICAgY29uc3QgbGFzdElucHV0VmFsdWUgPSBsYXN0SW5wdXRWYWx1ZU1hcC5nZXQodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWxhc3RJbnB1dFZhbHVlIHx8XHJcbiAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlLnRleHQgIT09IHYudGV4dCB8fFxyXG4gICAgICAgICAgICBsYXN0SW5wdXRWYWx1ZS5pc0NoZWNrZWQgIT09IHYuaXNDaGVja2VkKSB7XHJcbiAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlTWFwLnNldCh0YXJnZXQsIHYpO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoaW5wdXRDYikoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2KSwgeyBpZCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZXZlbnRzID0gc2FtcGxpbmcuaW5wdXQgPT09ICdsYXN0JyA/IFsnY2hhbmdlJ10gOiBbJ2lucHV0JywgJ2NoYW5nZSddO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBldmVudHMubWFwKChldmVudE5hbWUpID0+IG9uKGV2ZW50TmFtZSwgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlciksIGRvYykpO1xyXG4gICAgY29uc3QgY3VycmVudFdpbmRvdyA9IGRvYy5kZWZhdWx0VmlldztcclxuICAgIGlmICghY3VycmVudFdpbmRvdykge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvciA9IGN1cnJlbnRXaW5kb3cuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnKTtcclxuICAgIGNvbnN0IGhvb2tQcm9wZXJ0aWVzID0gW1xyXG4gICAgICAgIFtjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgJ2NoZWNrZWQnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsICd2YWx1ZSddLFxyXG4gICAgICAgIFtjdXJyZW50V2luZG93LkhUTUxUZXh0QXJlYUVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsICdzZWxlY3RlZEluZGV4J10sXHJcbiAgICAgICAgW2N1cnJlbnRXaW5kb3cuSFRNTE9wdGlvbkVsZW1lbnQucHJvdG90eXBlLCAnc2VsZWN0ZWQnXSxcclxuICAgIF07XHJcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yICYmIHByb3BlcnR5RGVzY3JpcHRvci5zZXQpIHtcclxuICAgICAgICBoYW5kbGVycy5wdXNoKC4uLmhvb2tQcm9wZXJ0aWVzLm1hcCgocCkgPT4gaG9va1NldHRlcihwWzBdLCBwWzFdLCB7XHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrV3JhcHBlcihldmVudEhhbmRsZXIpKHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcnVzdGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sIGZhbHNlLCBjdXJyZW50V2luZG93KSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnMocnVsZSkge1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XHJcbiAgICBmdW5jdGlvbiByZWN1cnNlKGNoaWxkUnVsZSwgcG9zKSB7XHJcbiAgICAgICAgaWYgKChoYXNOZXN0ZWRDU1NSdWxlKCdDU1NHcm91cGluZ1J1bGUnKSAmJlxyXG4gICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU0dyb3VwaW5nUnVsZSkgfHxcclxuICAgICAgICAgICAgKGhhc05lc3RlZENTU1J1bGUoJ0NTU01lZGlhUnVsZScpICYmXHJcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU01lZGlhUnVsZSkgfHxcclxuICAgICAgICAgICAgKGhhc05lc3RlZENTU1J1bGUoJ0NTU1N1cHBvcnRzUnVsZScpICYmXHJcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU1N1cHBvcnRzUnVsZSkgfHxcclxuICAgICAgICAgICAgKGhhc05lc3RlZENTU1J1bGUoJ0NTU0NvbmRpdGlvblJ1bGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NDb25kaXRpb25SdWxlKSkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlcyA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFJ1bGUuY3NzUnVsZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHJ1bGVzLmluZGV4T2YoY2hpbGRSdWxlKTtcclxuICAgICAgICAgICAgcG9zLnVuc2hpZnQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZFJ1bGUucGFyZW50U3R5bGVTaGVldCkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlcyA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQuY3NzUnVsZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHJ1bGVzLmluZGV4T2YoY2hpbGRSdWxlKTtcclxuICAgICAgICAgICAgcG9zLnVuc2hpZnQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlY3Vyc2UocnVsZSwgcG9zaXRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBnZXRJZEFuZFN0eWxlSWQoc2hlZXQsIG1pcnJvciwgc3R5bGVNaXJyb3IpIHtcclxuICAgIGxldCBpZCwgc3R5bGVJZDtcclxuICAgIGlmICghc2hlZXQpXHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgaWYgKHNoZWV0Lm93bmVyTm9kZSlcclxuICAgICAgICBpZCA9IG1pcnJvci5nZXRJZChzaGVldC5vd25lck5vZGUpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHN0eWxlSWQgPSBzdHlsZU1pcnJvci5nZXRJZChzaGVldCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgaWQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTdHlsZVNoZWV0T2JzZXJ2ZXIoeyBzdHlsZVNoZWV0UnVsZUNiLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyIH0sIHsgd2luIH0pIHtcclxuICAgIGlmICghd2luLkNTU1N0eWxlU2hlZXQgfHwgIXdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZSkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluc2VydFJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZTtcclxuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KGluc2VydFJ1bGUsIHtcclxuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW3J1bGUsIGluZGV4XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBhZGRzOiBbeyBydWxlLCBpbmRleCB9XSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGRlbGV0ZVJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZTtcclxuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlID0gbmV3IFByb3h5KGRlbGV0ZVJ1bGUsIHtcclxuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW2luZGV4XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVzOiBbeyBpbmRleCB9XSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICB9KTtcclxuICAgIGxldCByZXBsYWNlO1xyXG4gICAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlKSB7XHJcbiAgICAgICAgcmVwbGFjZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlO1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gbmV3IFByb3h5KHJlcGxhY2UsIHtcclxuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbdGV4dF0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZTogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbGV0IHJlcGxhY2VTeW5jO1xyXG4gICAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYykge1xyXG4gICAgICAgIHJlcGxhY2VTeW5jID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jO1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IG5ldyBQcm94eShyZXBsYWNlU3luYywge1xyXG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFt0ZXh0XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZywgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlU3luYzogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzID0ge307XHJcbiAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKCdDU1NHcm91cGluZ1J1bGUnKSkge1xyXG4gICAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NHcm91cGluZ1J1bGUgPSB3aW4uQ1NTR3JvdXBpbmdSdWxlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZSgnQ1NTTWVkaWFSdWxlJykpIHtcclxuICAgICAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU01lZGlhUnVsZSA9IHdpbi5DU1NNZWRpYVJ1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoJ0NTU0NvbmRpdGlvblJ1bGUnKSkge1xyXG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTQ29uZGl0aW9uUnVsZSA9IHdpbi5DU1NDb25kaXRpb25SdWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKCdDU1NTdXBwb3J0c1J1bGUnKSkge1xyXG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTU3VwcG9ydHNSdWxlID0gd2luLkNTU1N1cHBvcnRzUnVsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB1bm1vZGlmaWVkRnVuY3Rpb25zID0ge307XHJcbiAgICBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMpLmZvckVhY2goKFt0eXBlS2V5LCB0eXBlXSkgPT4ge1xyXG4gICAgICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0gPSB7XHJcbiAgICAgICAgICAgIGluc2VydFJ1bGU6IHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUsXHJcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGU6IHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZSwge1xyXG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtydWxlLCBpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcucGFyZW50U3R5bGVTaGVldCwgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5nZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eSh1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGUsIHtcclxuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbaW5kZXhdID0gYXJndW1lbnRzTGlzdDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbmRleDogWy4uLmdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZyksIGluZGV4XSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gaW5zZXJ0UnVsZTtcclxuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IGRlbGV0ZVJ1bGU7XHJcbiAgICAgICAgcmVwbGFjZSAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UgPSByZXBsYWNlKTtcclxuICAgICAgICByZXBsYWNlU3luYyAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jID0gcmVwbGFjZVN5bmMpO1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaCgoW3R5cGVLZXksIHR5cGVdKSA9PiB7XHJcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmluc2VydFJ1bGU7XHJcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcih7IG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIsIH0sIGhvc3QpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgbGV0IGhvc3RJZCA9IG51bGw7XHJcbiAgICBpZiAoaG9zdC5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcpXHJcbiAgICAgICAgaG9zdElkID0gbWlycm9yLmdldElkKGhvc3QpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGhvc3RJZCA9IG1pcnJvci5nZXRJZChob3N0Lmhvc3QpO1xyXG4gICAgY29uc3QgcGF0Y2hUYXJnZXQgPSBob3N0Lm5vZGVOYW1lID09PSAnI2RvY3VtZW50J1xyXG4gICAgICAgID8gKF9hID0gaG9zdC5kZWZhdWx0VmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLkRvY3VtZW50XHJcbiAgICAgICAgOiAoX2MgPSAoX2IgPSBob3N0Lm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZWZhdWx0VmlldykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLlNoYWRvd1Jvb3Q7XHJcbiAgICBjb25zdCBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvciA9IChwYXRjaFRhcmdldCA9PT0gbnVsbCB8fCBwYXRjaFRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlKVxyXG4gICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXRjaFRhcmdldCA9PT0gbnVsbCB8fCBwYXRjaFRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlLCAnYWRvcHRlZFN0eWxlU2hlZXRzJylcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlmIChob3N0SWQgPT09IG51bGwgfHxcclxuICAgICAgICBob3N0SWQgPT09IC0xIHx8XHJcbiAgICAgICAgIXBhdGNoVGFyZ2V0IHx8XHJcbiAgICAgICAgIW9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yKVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0LCAnYWRvcHRlZFN0eWxlU2hlZXRzJywge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5nZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KHNoZWV0cykge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChfYSA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLnNldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgc2hlZXRzKTtcclxuICAgICAgICAgICAgaWYgKGhvc3RJZCAhPT0gbnVsbCAmJiBob3N0SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0LCAnYWRvcHRlZFN0eWxlU2hlZXRzJywge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcclxuICAgICAgICAgICAgZ2V0OiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5nZXQsXHJcbiAgICAgICAgICAgIHNldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcih7IHN0eWxlRGVjbGFyYXRpb25DYiwgbWlycm9yLCBpZ25vcmVDU1NBdHRyaWJ1dGVzLCBzdHlsZXNoZWV0TWFuYWdlciwgfSwgeyB3aW4gfSkge1xyXG4gICAgY29uc3Qgc2V0UHJvcGVydHkgPSB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHk7XHJcbiAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBuZXcgUHJveHkoc2V0UHJvcGVydHksIHtcclxuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCBbcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eV0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0UHJvcGVydHkuYXBwbHkodGhpc0FyZywgW3Byb3BlcnR5LCB2YWx1ZSwgcHJpb3JpdHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoKF9hID0gdGhpc0FyZy5wYXJlbnRSdWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50U3R5bGVTaGVldCwgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgIGlmICgoaWQgJiYgaWQgIT09IC0xKSB8fCAoc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcucGFyZW50UnVsZSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCByZW1vdmVQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eTtcclxuICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IG5ldyBQcm94eShyZW1vdmVQcm9wZXJ0eSwge1xyXG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eV0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlUHJvcGVydHkuYXBwbHkodGhpc0FyZywgW3Byb3BlcnR5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKChfYSA9IHRoaXNBcmcucGFyZW50UnVsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IHNldFByb3BlcnR5O1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcih7IG1lZGlhSW50ZXJhY3Rpb25DYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgbWlycm9yLCBzYW1wbGluZywgZG9jLCB9KSB7XHJcbiAgICBjb25zdCBoYW5kbGVyID0gY2FsbGJhY2tXcmFwcGVyKCh0eXBlKSA9PiB0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xyXG4gICAgICAgIGlmICghdGFyZ2V0IHx8XHJcbiAgICAgICAgICAgIGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VGltZSwgdm9sdW1lLCBtdXRlZCwgcGxheWJhY2tSYXRlLCBsb29wIH0gPSB0YXJnZXQ7XHJcbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiKHtcclxuICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgaWQ6IG1pcnJvci5nZXRJZCh0YXJnZXQpLFxyXG4gICAgICAgICAgICBjdXJyZW50VGltZSxcclxuICAgICAgICAgICAgdm9sdW1lLFxyXG4gICAgICAgICAgICBtdXRlZCxcclxuICAgICAgICAgICAgcGxheWJhY2tSYXRlLFxyXG4gICAgICAgICAgICBsb29wLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSksIHNhbXBsaW5nLm1lZGlhIHx8IDUwMCkpO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXHJcbiAgICAgICAgb24oJ3BsYXknLCBoYW5kbGVyKDApLCBkb2MpLFxyXG4gICAgICAgIG9uKCdwYXVzZScsIGhhbmRsZXIoMSksIGRvYyksXHJcbiAgICAgICAgb24oJ3NlZWtlZCcsIGhhbmRsZXIoMiksIGRvYyksXHJcbiAgICAgICAgb24oJ3ZvbHVtZWNoYW5nZScsIGhhbmRsZXIoMyksIGRvYyksXHJcbiAgICAgICAgb24oJ3JhdGVjaGFuZ2UnLCBoYW5kbGVyKDQpLCBkb2MpLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0Rm9udE9ic2VydmVyKHsgZm9udENiLCBkb2MgfSkge1xyXG4gICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xyXG4gICAgaWYgKCF3aW4pIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgY29uc3QgZm9udE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICBjb25zdCBvcmlnaW5hbEZvbnRGYWNlID0gd2luLkZvbnRGYWNlO1xyXG4gICAgd2luLkZvbnRGYWNlID0gZnVuY3Rpb24gRm9udEZhY2UoZmFtaWx5LCBzb3VyY2UsIGRlc2NyaXB0b3JzKSB7XHJcbiAgICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgb3JpZ2luYWxGb250RmFjZShmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpO1xyXG4gICAgICAgIGZvbnRNYXAuc2V0KGZvbnRGYWNlLCB7XHJcbiAgICAgICAgICAgIGZhbWlseSxcclxuICAgICAgICAgICAgYnVmZmVyOiB0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJyxcclxuICAgICAgICAgICAgZGVzY3JpcHRvcnMsXHJcbiAgICAgICAgICAgIGZvbnRTb3VyY2U6IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICA/IHNvdXJjZVxyXG4gICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KHNvdXJjZSkpKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm9udEZhY2U7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChkb2MuZm9udHMsICdhZGQnLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZvbnRGYWNlKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBmb250TWFwLmdldChmb250RmFjZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRDYihwKTtcclxuICAgICAgICAgICAgICAgICAgICBmb250TWFwLmRlbGV0ZShmb250RmFjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtmb250RmFjZV0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIGhhbmRsZXJzLnB1c2goKCkgPT4ge1xyXG4gICAgICAgIHdpbi5Gb250RmFjZSA9IG9yaWdpbmFsRm9udEZhY2U7XHJcbiAgICB9KTtcclxuICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTZWxlY3Rpb25PYnNlcnZlcihwYXJhbSkge1xyXG4gICAgY29uc3QgeyBkb2MsIG1pcnJvciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2VsZWN0aW9uQ2IgfSA9IHBhcmFtO1xyXG4gICAgbGV0IGNvbGxhcHNlZCA9IHRydWU7XHJcbiAgICBjb25zdCB1cGRhdGVTZWxlY3Rpb24gPSBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCAoY29sbGFwc2VkICYmIChzZWxlY3Rpb24gPT09IG51bGwgfHwgc2VsZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbGxhcHNlZCA9IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCB8fCBmYWxzZTtcclxuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHNlbGVjdGlvbi5yYW5nZUNvdW50IHx8IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCB9ID0gcmFuZ2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrZWQgPSBpc0Jsb2NrZWQoc3RhcnRDb250YWluZXIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpIHx8XHJcbiAgICAgICAgICAgICAgICBpc0Jsb2NrZWQoZW5kQ29udGFpbmVyLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKGJsb2NrZWQpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IG1pcnJvci5nZXRJZChzdGFydENvbnRhaW5lciksXHJcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCxcclxuICAgICAgICAgICAgICAgIGVuZDogbWlycm9yLmdldElkKGVuZENvbnRhaW5lciksXHJcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxlY3Rpb25DYih7IHJhbmdlcyB9KTtcclxuICAgIH0pO1xyXG4gICAgdXBkYXRlU2VsZWN0aW9uKCk7XHJcbiAgICByZXR1cm4gb24oJ3NlbGVjdGlvbmNoYW5nZScsIHVwZGF0ZVNlbGVjdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcih7IGRvYywgY3VzdG9tRWxlbWVudENiLCB9KSB7XHJcbiAgICBjb25zdCB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XHJcbiAgICBpZiAoIXdpbiB8fCAhd2luLmN1c3RvbUVsZW1lbnRzKVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XHJcbiAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5jdXN0b21FbGVtZW50cywgJ2RlZmluZScsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEN1c3RvbSBlbGVtZW50IGNhbGxiYWNrIGZhaWxlZCBmb3IgJHtuYW1lfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbbmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnNdKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdG9yZUhhbmRsZXI7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VIb29rcyhvLCBob29rcykge1xyXG4gICAgY29uc3QgeyBtdXRhdGlvbkNiLCBtb3VzZW1vdmVDYiwgbW91c2VJbnRlcmFjdGlvbkNiLCBzY3JvbGxDYiwgdmlld3BvcnRSZXNpemVDYiwgaW5wdXRDYiwgbWVkaWFJbnRlcmFjdGlvbkNiLCBzdHlsZVNoZWV0UnVsZUNiLCBzdHlsZURlY2xhcmF0aW9uQ2IsIGNhbnZhc011dGF0aW9uQ2IsIGZvbnRDYiwgc2VsZWN0aW9uQ2IsIGN1c3RvbUVsZW1lbnRDYiwgfSA9IG87XHJcbiAgICBvLm11dGF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5tdXRhdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5tdXRhdGlvbiguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbXV0YXRpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLm1vdXNlbW92ZUNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MubW91c2Vtb3ZlKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLm1vdXNlbW92ZSguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW91c2Vtb3ZlQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5tb3VzZUludGVyYWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5tb3VzZUludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLm1vdXNlSW50ZXJhY3Rpb24oLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vdXNlSW50ZXJhY3Rpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLnNjcm9sbENiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Muc2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnNjcm9sbCguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2Nyb2xsQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby52aWV3cG9ydFJlc2l6ZUNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Mudmlld3BvcnRSZXNpemUpIHtcclxuICAgICAgICAgICAgaG9va3Mudmlld3BvcnRSZXNpemUoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZpZXdwb3J0UmVzaXplQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5pbnB1dENiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MuaW5wdXQpIHtcclxuICAgICAgICAgICAgaG9va3MuaW5wdXQoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0Q2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5tZWRpYUludGVyYWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5tZWRpYUludGVhY3Rpb24pIHtcclxuICAgICAgICAgICAgaG9va3MubWVkaWFJbnRlYWN0aW9uKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5zdHlsZVNoZWV0UnVsZUNiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3Muc3R5bGVTaGVldFJ1bGUpIHtcclxuICAgICAgICAgICAgaG9va3Muc3R5bGVTaGVldFJ1bGUoLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0eWxlU2hlZXRSdWxlQ2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5zdHlsZURlY2xhcmF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5zdHlsZURlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnN0eWxlRGVjbGFyYXRpb24oLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLmNhbnZhc011dGF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5jYW52YXNNdXRhdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5jYW52YXNNdXRhdGlvbiguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FudmFzTXV0YXRpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLmZvbnRDYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLmZvbnQpIHtcclxuICAgICAgICAgICAgaG9va3MuZm9udCguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9udENiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8uc2VsZWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5zZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgaG9va3Muc2VsZWN0aW9uKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxlY3Rpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLmN1c3RvbUVsZW1lbnRDYiA9ICguLi5jKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLmN1c3RvbUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaG9va3MuY3VzdG9tRWxlbWVudCguLi5jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VzdG9tRWxlbWVudENiKC4uLmMpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbml0T2JzZXJ2ZXJzKG8sIGhvb2tzID0ge30pIHtcclxuICAgIGNvbnN0IGN1cnJlbnRXaW5kb3cgPSBvLmRvYy5kZWZhdWx0VmlldztcclxuICAgIGlmICghY3VycmVudFdpbmRvdykge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIG1lcmdlSG9va3MobywgaG9va3MpO1xyXG4gICAgbGV0IG11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICBpZiAoby5yZWNvcmRET00pIHtcclxuICAgICAgICBtdXRhdGlvbk9ic2VydmVyID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIobywgby5kb2MpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbW91c2Vtb3ZlSGFuZGxlciA9IGluaXRNb3ZlT2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBtb3VzZUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBzY3JvbGxIYW5kbGVyID0gaW5pdFNjcm9sbE9ic2VydmVyKG8pO1xyXG4gICAgY29uc3Qgdmlld3BvcnRSZXNpemVIYW5kbGVyID0gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIobywge1xyXG4gICAgICAgIHdpbjogY3VycmVudFdpbmRvdyxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgaW5wdXRIYW5kbGVyID0gaW5pdElucHV0T2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBtZWRpYUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNZWRpYUludGVyYWN0aW9uT2JzZXJ2ZXIobyk7XHJcbiAgICBsZXQgc3R5bGVTaGVldE9ic2VydmVyID0gKCkgPT4geyB9O1xyXG4gICAgbGV0IGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSAoKSA9PiB7IH07XHJcbiAgICBsZXQgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gKCkgPT4geyB9O1xyXG4gICAgbGV0IGZvbnRPYnNlcnZlciA9ICgpID0+IHsgfTtcclxuICAgIGlmIChvLnJlY29yZERPTSkge1xyXG4gICAgICAgIHN0eWxlU2hlZXRPYnNlcnZlciA9IGluaXRTdHlsZVNoZWV0T2JzZXJ2ZXIobywgeyB3aW46IGN1cnJlbnRXaW5kb3cgfSk7XHJcbiAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlciA9IGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKG8sIG8uZG9jKTtcclxuICAgICAgICBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSBpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKG8sIHtcclxuICAgICAgICAgICAgd2luOiBjdXJyZW50V2luZG93LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvLmNvbGxlY3RGb250cykge1xyXG4gICAgICAgICAgICBmb250T2JzZXJ2ZXIgPSBpbml0Rm9udE9ic2VydmVyKG8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGVjdGlvbk9ic2VydmVyID0gaW5pdFNlbGVjdGlvbk9ic2VydmVyKG8pO1xyXG4gICAgY29uc3QgY3VzdG9tRWxlbWVudE9ic2VydmVyID0gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihvKTtcclxuICAgIGNvbnN0IHBsdWdpbkhhbmRsZXJzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBvLnBsdWdpbnMpIHtcclxuICAgICAgICBwbHVnaW5IYW5kbGVycy5wdXNoKHBsdWdpbi5vYnNlcnZlcihwbHVnaW4uY2FsbGJhY2ssIGN1cnJlbnRXaW5kb3csIHBsdWdpbi5vcHRpb25zKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYikgPT4gYi5yZXNldCgpKTtcclxuICAgICAgICBtdXRhdGlvbk9ic2VydmVyID09PSBudWxsIHx8IG11dGF0aW9uT2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIG1vdXNlbW92ZUhhbmRsZXIoKTtcclxuICAgICAgICBtb3VzZUludGVyYWN0aW9uSGFuZGxlcigpO1xyXG4gICAgICAgIHNjcm9sbEhhbmRsZXIoKTtcclxuICAgICAgICB2aWV3cG9ydFJlc2l6ZUhhbmRsZXIoKTtcclxuICAgICAgICBpbnB1dEhhbmRsZXIoKTtcclxuICAgICAgICBtZWRpYUludGVyYWN0aW9uSGFuZGxlcigpO1xyXG4gICAgICAgIHN0eWxlU2hlZXRPYnNlcnZlcigpO1xyXG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoKTtcclxuICAgICAgICBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIoKTtcclxuICAgICAgICBmb250T2JzZXJ2ZXIoKTtcclxuICAgICAgICBzZWxlY3Rpb25PYnNlcnZlcigpO1xyXG4gICAgICAgIGN1c3RvbUVsZW1lbnRPYnNlcnZlcigpO1xyXG4gICAgICAgIHBsdWdpbkhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBoYXNOZXN0ZWRDU1NSdWxlKHByb3ApIHtcclxuICAgIHJldHVybiB0eXBlb2Ygd2luZG93W3Byb3BdICE9PSAndW5kZWZpbmVkJztcclxufVxyXG5mdW5jdGlvbiBjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUocHJvcCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZW9mIHdpbmRvd1twcm9wXSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB3aW5kb3dbcHJvcF0ucHJvdG90eXBlICYmXHJcbiAgICAgICAgJ2luc2VydFJ1bGUnIGluIHdpbmRvd1twcm9wXS5wcm90b3R5cGUgJiZcclxuICAgICAgICAnZGVsZXRlUnVsZScgaW4gd2luZG93W3Byb3BdLnByb3RvdHlwZSk7XHJcbn1cblxuY2xhc3MgQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZ2VuZXJhdGVJZEZuKSB7XHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUlkRm4gPSBnZW5lcmF0ZUlkRm47XHJcbiAgICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIH1cclxuICAgIGdldElkKGlmcmFtZSwgcmVtb3RlSWQsIGlkVG9SZW1vdGVNYXAsIHJlbW90ZVRvSWRNYXApIHtcclxuICAgICAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSBpZFRvUmVtb3RlTWFwIHx8IHRoaXMuZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSk7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gcmVtb3RlVG9JZE1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIGxldCBpZCA9IGlkVG9SZW1vdGVJZE1hcC5nZXQocmVtb3RlSWQpO1xyXG4gICAgICAgIGlmICghaWQpIHtcclxuICAgICAgICAgICAgaWQgPSB0aGlzLmdlbmVyYXRlSWRGbigpO1xyXG4gICAgICAgICAgICBpZFRvUmVtb3RlSWRNYXAuc2V0KHJlbW90ZUlkLCBpZCk7XHJcbiAgICAgICAgICAgIHJlbW90ZUlkVG9JZE1hcC5zZXQoaWQsIHJlbW90ZUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfVxyXG4gICAgZ2V0SWRzKGlmcmFtZSwgcmVtb3RlSWQpIHtcclxuICAgICAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkLm1hcCgoaWQpID0+IHRoaXMuZ2V0SWQoaWZyYW1lLCBpZCwgaWRUb1JlbW90ZUlkTWFwLCByZW1vdGVJZFRvSWRNYXApKTtcclxuICAgIH1cclxuICAgIGdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIG1hcCkge1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IG1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWQgPSByZW1vdGVJZFRvSWRNYXAuZ2V0KGlkKTtcclxuICAgICAgICBpZiAoIXJlbW90ZUlkKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVtb3RlSWRzKGlmcmFtZSwgaWRzKSB7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcclxuICAgICAgICByZXR1cm4gaWRzLm1hcCgoaWQpID0+IHRoaXMuZ2V0UmVtb3RlSWQoaWZyYW1lLCBpZCwgcmVtb3RlSWRUb0lkTWFwKSk7XHJcbiAgICB9XHJcbiAgICByZXNldChpZnJhbWUpIHtcclxuICAgICAgICBpZiAoIWlmcmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5kZWxldGUoaWZyYW1lKTtcclxuICAgICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5kZWxldGUoaWZyYW1lKTtcclxuICAgIH1cclxuICAgIGdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpIHtcclxuICAgICAgICBsZXQgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuZ2V0KGlmcmFtZSk7XHJcbiAgICAgICAgaWYgKCFpZFRvUmVtb3RlSWRNYXApIHtcclxuICAgICAgICAgICAgaWRUb1JlbW90ZUlkTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5zZXQoaWZyYW1lLCBpZFRvUmVtb3RlSWRNYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaWRUb1JlbW90ZUlkTWFwO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSkge1xyXG4gICAgICAgIGxldCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5nZXQoaWZyYW1lKTtcclxuICAgICAgICBpZiAoIXJlbW90ZUlkVG9JZE1hcCkge1xyXG4gICAgICAgICAgICByZW1vdGVJZFRvSWRNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLnNldChpZnJhbWUsIHJlbW90ZUlkVG9JZE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW1vdGVJZFRvSWRNYXA7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSWZyYW1lTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pZnJhbWVzID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yID0gbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKGdlbklkKTtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy53cmFwcGVkRW1pdCA9IG9wdGlvbnMud3JhcHBlZEVtaXQ7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlciA9IG9wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBvcHRpb25zLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcztcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IgPSBuZXcgQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IodGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvci5nZW5lcmF0ZUlkLmJpbmQodGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcikpO1xyXG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XHJcbiAgICAgICAgaWYgKHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZElmcmFtZShpZnJhbWVFbCkge1xyXG4gICAgICAgIHRoaXMuaWZyYW1lcy5zZXQoaWZyYW1lRWwsIHRydWUpO1xyXG4gICAgICAgIGlmIChpZnJhbWVFbC5jb250ZW50V2luZG93KVxyXG4gICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLnNldChpZnJhbWVFbC5jb250ZW50V2luZG93LCBpZnJhbWVFbCk7XHJcbiAgICB9XHJcbiAgICBhZGRMb2FkTGlzdGVuZXIoY2IpIHtcclxuICAgICAgICB0aGlzLmxvYWRMaXN0ZW5lciA9IGNiO1xyXG4gICAgfVxyXG4gICAgYXR0YWNoSWZyYW1lKGlmcmFtZUVsLCBjaGlsZFNuKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25DYih7XHJcbiAgICAgICAgICAgIGFkZHM6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiBjaGlsZFNuLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgcmVtb3ZlczogW10sXHJcbiAgICAgICAgICAgIHRleHRzOiBbXSxcclxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXHJcbiAgICAgICAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIChfYSA9IHRoaXMubG9hZExpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBpZnJhbWVFbCk7XHJcbiAgICAgICAgaWYgKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCAmJlxyXG4gICAgICAgICAgICBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmXHJcbiAgICAgICAgICAgIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMsIHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc3QgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQgPSBtZXNzYWdlO1xyXG4gICAgICAgIGlmIChjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLnR5cGUgIT09ICdycndlYicgfHxcclxuICAgICAgICAgICAgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQub3JpZ2luICE9PSBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLm9yaWdpbilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGlmcmFtZVNvdXJjZVdpbmRvdyA9IG1lc3NhZ2Uuc291cmNlO1xyXG4gICAgICAgIGlmICghaWZyYW1lU291cmNlV2luZG93KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgaWZyYW1lRWwgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLmdldChtZXNzYWdlLnNvdXJjZSk7XHJcbiAgICAgICAgaWYgKCFpZnJhbWVFbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkRXZlbnQgPSB0aGlzLnRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoaWZyYW1lRWwsIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuZXZlbnQpO1xyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZEV2ZW50KVxyXG4gICAgICAgICAgICB0aGlzLndyYXBwZWRFbWl0KHRyYW5zZm9ybWVkRXZlbnQsIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuaXNDaGVja291dCk7XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm1Dcm9zc09yaWdpbkV2ZW50KGlmcmFtZUVsLCBlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuRnVsbFNuYXBzaG90OiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvci5yZXNldChpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZE9uTm9kZShlLmRhdGEubm9kZSwgaWZyYW1lRWwpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdElkID0gZS5kYXRhLm5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLnNldChpZnJhbWVFbCwgcm9vdElkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hSb290SWRPbk5vZGUoZS5kYXRhLm5vZGUsIHJvb3RJZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogZS50aW1lc3RhbXAsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5NdXRhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVFbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IGUuZGF0YS5ub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuTWV0YTpcclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5Mb2FkOlxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLkRvbUNvbnRlbnRMb2FkZWQ6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLlBsdWdpbjoge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5DdXN0b206IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlLmRhdGEucGF5bG9hZCwgaWZyYW1lRWwsIFsnaWQnLCAncGFyZW50SWQnLCAncHJldmlvdXNJZCcsICduZXh0SWQnXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3Q6IHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLnNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5NdXRhdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEuYWRkcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobiwgaWZyYW1lRWwsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyZW50SWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduZXh0SWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcmV2aW91c0lkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUobi5ub2RlLCBpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb290SWQgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLmdldChpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290SWQgJiYgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShuLm5vZGUsIHJvb3RJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEucmVtb3Zlcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobiwgaWZyYW1lRWwsIFsncGFyZW50SWQnLCAnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEuYXR0cmlidXRlcy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobiwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEudGV4dHMuZm9yRWFjaCgobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKG4sIGlmcmFtZUVsLCBbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5EcmFnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5Ub3VjaE1vdmU6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLk1vdXNlTW92ZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEucG9zaXRpb25zLmZvckVhY2goKHApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhwLCBpZnJhbWVFbCwgWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuVmlld3BvcnRSZXNpemU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuTWVkaWFJbnRlcmFjdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuTW91c2VJbnRlcmFjdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuU2Nyb2xsOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5DYW52YXNNdXRhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuSW5wdXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuU3R5bGVTaGVldFJ1bGU6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLlN0eWxlRGVjbGFyYXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVN0eWxlSWRzKGUuZGF0YSwgaWZyYW1lRWwsIFsnc3R5bGVJZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5Gb250OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuU2VsZWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhyYW5nZSwgaWZyYW1lRWwsIFsnc3RhcnQnLCAnZW5kJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5BZG9wdGVkU3R5bGVTaGVldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZS5kYXRhLCBpZnJhbWVFbCwgWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZS5kYXRhLCBpZnJhbWVFbCwgWydzdHlsZUlkcyddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gZS5kYXRhLnN0eWxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHN0eWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhzdHlsZSwgaWZyYW1lRWwsIFsnc3R5bGVJZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlKGlmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialtrZXldKSAmJiB0eXBlb2Ygb2JqW2tleV0gIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBpZnJhbWVNaXJyb3IuZ2V0SWRzKGlmcmFtZUVsLCBvYmpba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZChpZnJhbWVFbCwgb2JqW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlSWRzKG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IsIG9iaiwgaWZyYW1lRWwsIGtleXMpO1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZVN0eWxlSWRzKG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cyk7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlSWRPbk5vZGUobm9kZSwgaWZyYW1lRWwpIHtcclxuICAgICAgICB0aGlzLnJlcGxhY2VJZHMobm9kZSwgaWZyYW1lRWwsIFsnaWQnLCAncm9vdElkJ10pO1xyXG4gICAgICAgIGlmICgnY2hpbGROb2RlcycgaW4gbm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkT25Ob2RlKGNoaWxkLCBpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBhdGNoUm9vdElkT25Ob2RlKG5vZGUsIHJvb3RJZCkge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IE5vZGVUeXBlLkRvY3VtZW50ICYmICFub2RlLnJvb3RJZClcclxuICAgICAgICAgICAgbm9kZS5yb290SWQgPSByb290SWQ7XHJcbiAgICAgICAgaWYgKCdjaGlsZE5vZGVzJyBpbiBub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShjaGlsZCwgcm9vdElkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYWRvd0RvbU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuc2hhZG93RG9tcyA9IG5ldyBXZWFrU2V0KCk7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxDYiA9IG9wdGlvbnMuc2Nyb2xsQ2I7XHJcbiAgICAgICAgdGhpcy5ieXBhc3NPcHRpb25zID0gb3B0aW9ucy5ieXBhc3NPcHRpb25zO1xyXG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICB9XHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnBhdGNoQXR0YWNoU2hhZG93KEVsZW1lbnQsIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGFkZFNoYWRvd1Jvb3Qoc2hhZG93Um9vdCwgZG9jKSB7XHJcbiAgICAgICAgaWYgKCFpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290KSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0RvbXMuaGFzKHNoYWRvd1Jvb3QpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5zaGFkb3dEb21zLmFkZChzaGFkb3dSb290KTtcclxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ieXBhc3NPcHRpb25zKSwgeyBkb2MsIG11dGF0aW9uQ2I6IHRoaXMubXV0YXRpb25DYiwgbWlycm9yOiB0aGlzLm1pcnJvciwgc2hhZG93RG9tTWFuYWdlcjogdGhpcyB9KSwgc2hhZG93Um9vdCk7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaCgoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCkpO1xyXG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goaW5pdFNjcm9sbE9ic2VydmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ieXBhc3NPcHRpb25zKSwgeyBzY3JvbGxDYjogdGhpcy5zY3JvbGxDYiwgZG9jOiBzaGFkb3dSb290LCBtaXJyb3I6IHRoaXMubWlycm9yIH0pKSk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJlxyXG4gICAgICAgICAgICAgICAgc2hhZG93Um9vdC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgIHRoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLCB0aGlzLm1pcnJvci5nZXRJZChzaGFkb3dSb290Lmhvc3QpKTtcclxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcih7XHJcbiAgICAgICAgICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHRoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlcixcclxuICAgICAgICAgICAgfSwgc2hhZG93Um9vdCkpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gICAgb2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWVFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFpZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cgfHwgIWlmcmFtZUVsZW1lbnQuY29udGVudERvY3VtZW50KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhpZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cuRWxlbWVudCwgaWZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgcGF0Y2hBdHRhY2hTaGFkb3coZWxlbWVudCwgZG9jKSB7XHJcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChwYXRjaChlbGVtZW50LnByb3RvdHlwZSwgJ2F0dGFjaFNoYWRvdycsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IG9yaWdpbmFsLmNhbGwodGhpcywgb3B0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgaW5Eb20odGhpcykpXHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRTaGFkb3dSb290KHRoaXMuc2hhZG93Um9vdCwgZG9jKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dSb290O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnNoYWRvd0RvbXMgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgfVxyXG59XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlciAxLjAuMSA8aHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlcj5cbiAqIENvcHlyaWdodCAoYykgMjAyMSBOaWtsYXMgdm9uIEhlcnR6ZW4gPGh0dHBzOi8vaGVydHplbi5jb20+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZVxuICovXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4vLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG52YXIgbG9va3VwID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gW10gOiBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG59XG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuICAgIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgJz0nO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgJz09JztcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbn07XG5cbmNvbnN0IGNhbnZhc1Zhck1hcCA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gdmFyaWFibGVMaXN0Rm9yKGN0eCwgY3Rvcikge1xyXG4gICAgbGV0IGNvbnRleHRNYXAgPSBjYW52YXNWYXJNYXAuZ2V0KGN0eCk7XHJcbiAgICBpZiAoIWNvbnRleHRNYXApIHtcclxuICAgICAgICBjb250ZXh0TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNhbnZhc1Zhck1hcC5zZXQoY3R4LCBjb250ZXh0TWFwKTtcclxuICAgIH1cclxuICAgIGlmICghY29udGV4dE1hcC5oYXMoY3RvcikpIHtcclxuICAgICAgICBjb250ZXh0TWFwLnNldChjdG9yLCBbXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dE1hcC5nZXQoY3Rvcik7XHJcbn1cclxuY29uc3Qgc2F2ZVdlYkdMVmFyID0gKHZhbHVlLCB3aW4sIGN0eCkgPT4ge1xyXG4gICAgaWYgKCF2YWx1ZSB8fFxyXG4gICAgICAgICEoaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QodmFsdWUsIHdpbikgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICBjb25zdCBsaXN0ID0gdmFyaWFibGVMaXN0Rm9yKGN0eCwgbmFtZSk7XHJcbiAgICBsZXQgaW5kZXggPSBsaXN0LmluZGV4T2YodmFsdWUpO1xyXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIGluZGV4ID0gbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgbGlzdC5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbmRleDtcclxufTtcclxuZnVuY3Rpb24gc2VyaWFsaXplQXJnKHZhbHVlLCB3aW4sIGN0eCkge1xyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChhcmcpID0+IHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGFyZ3M6IFtPYmplY3QudmFsdWVzKHZhbHVlKV0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGJhc2U2NCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldykge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUFyZyh2YWx1ZS5idWZmZXIsIHdpbiwgY3R4KSxcclxuICAgICAgICAgICAgICAgIHZhbHVlLmJ5dGVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5ieXRlTGVuZ3RoLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICBjb25zdCB7IHNyYyB9ID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgc3JjLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9ICdIVE1MSW1hZ2VFbGVtZW50JztcclxuICAgICAgICBjb25zdCBzcmMgPSB2YWx1ZS50b0RhdGFVUkwoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBzcmMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgYXJnczogW3NlcmlhbGl6ZUFyZyh2YWx1ZS5kYXRhLCB3aW4sIGN0eCksIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHRdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBzYXZlV2ViR0xWYXIodmFsdWUsIHdpbiwgY3R4KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5jb25zdCBzZXJpYWxpemVBcmdzID0gKGFyZ3MsIHdpbiwgY3R4KSA9PiB7XHJcbiAgICByZXR1cm4gYXJncy5tYXAoKGFyZykgPT4gc2VyaWFsaXplQXJnKGFyZywgd2luLCBjdHgpKTtcclxufTtcclxuY29uc3QgaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QgPSAodmFsdWUsIHdpbikgPT4ge1xyXG4gICAgY29uc3Qgd2ViR0xDb25zdHJ1Y3Rvck5hbWVzID0gW1xyXG4gICAgICAgICdXZWJHTEFjdGl2ZUluZm8nLFxyXG4gICAgICAgICdXZWJHTEJ1ZmZlcicsXHJcbiAgICAgICAgJ1dlYkdMRnJhbWVidWZmZXInLFxyXG4gICAgICAgICdXZWJHTFByb2dyYW0nLFxyXG4gICAgICAgICdXZWJHTFJlbmRlcmJ1ZmZlcicsXHJcbiAgICAgICAgJ1dlYkdMU2hhZGVyJyxcclxuICAgICAgICAnV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXQnLFxyXG4gICAgICAgICdXZWJHTFRleHR1cmUnLFxyXG4gICAgICAgICdXZWJHTFVuaWZvcm1Mb2NhdGlvbicsXHJcbiAgICAgICAgJ1dlYkdMVmVydGV4QXJyYXlPYmplY3QnLFxyXG4gICAgICAgICdXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTJyxcclxuICAgIF07XHJcbiAgICBjb25zdCBzdXBwb3J0ZWRXZWJHTENvbnN0cnVjdG9yTmFtZXMgPSB3ZWJHTENvbnN0cnVjdG9yTmFtZXMuZmlsdGVyKChuYW1lKSA9PiB0eXBlb2Ygd2luW25hbWVdID09PSAnZnVuY3Rpb24nKTtcclxuICAgIHJldHVybiBCb29sZWFuKHN1cHBvcnRlZFdlYkdMQ29uc3RydWN0b3JOYW1lcy5maW5kKChuYW1lKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIHdpbltuYW1lXSkpO1xyXG59O1xuXG5mdW5jdGlvbiBpbml0Q2FudmFzMkRNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBjb25zdCBwcm9wczJEID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUpO1xyXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzMkQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlW3Byb3BdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMuY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbJzJEJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgY29uc3QgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCB7XHJcbiAgICAgICAgICAgICAgICBzZXQodikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbJzJEJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRDb250ZXh0TmFtZShjb250ZXh0VHlwZSkge1xyXG4gICAgcmV0dXJuIGNvbnRleHRUeXBlID09PSAnZXhwZXJpbWVudGFsLXdlYmdsJyA/ICd3ZWJnbCcgOiBjb250ZXh0VHlwZTtcclxufVxyXG5mdW5jdGlvbiBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlKSB7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5IVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUsICdnZXRDb250ZXh0JywgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dFR5cGUsIC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4TmFtZSA9IGdldE5vcm1hbGl6ZWRDb250ZXh0TmFtZShjb250ZXh0VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ19fY29udGV4dCcgaW4gdGhpcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19jb250ZXh0ID0gY3R4TmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnd2ViZ2wnLCAnd2ViZ2wyJ10uaW5jbHVkZXMoY3R4TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnNwbGljZSgwLCAxLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2NvbnRleHRUeXBlLCAuLi5hcmdzXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdmYWlsZWQgdG8gcGF0Y2ggSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmdldENvbnRleHQnKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gcGF0Y2hHTFByb3RvdHlwZShwcm90b3R5cGUsIHR5cGUsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IsIHdpbikge1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcclxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG90eXBlKTtcclxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xyXG4gICAgICAgIGlmIChbXHJcbiAgICAgICAgICAgICdpc0NvbnRleHRMb3N0JyxcclxuICAgICAgICAgICAgJ2NhbnZhcycsXHJcbiAgICAgICAgICAgICdkcmF3aW5nQnVmZmVyV2lkdGgnLFxyXG4gICAgICAgICAgICAnZHJhd2luZ0J1ZmZlckhlaWdodCcsXHJcbiAgICAgICAgXS5pbmNsdWRlcyhwcm9wKSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGVbcHJvcF0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2gocHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVXZWJHTFZhcihyZXN1bHQsIHdpbiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0YWdOYW1lJyBpbiB0aGlzLmNhbnZhcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNCbG9ja2VkKHRoaXMuY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRBcmdzID0gc2VyaWFsaXplQXJncyhhcmdzLCB3aW4sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHJlY29yZEFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCBtdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICBjb25zdCBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIocHJvdG90eXBlLCBwcm9wLCB7XHJcbiAgICAgICAgICAgICAgICBzZXQodikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFuZGxlcnM7XHJcbn1cclxuZnVuY3Rpb24gaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlcihjYiwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IpIHtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBoYW5kbGVycy5wdXNoKC4uLnBhdGNoR0xQcm90b3R5cGUod2luLldlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsIENhbnZhc0NvbnRleHQuV2ViR0wsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IsIHdpbikpO1xyXG4gICAgaWYgKHR5cGVvZiB3aW4uV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBoYW5kbGVycy5wdXNoKC4uLnBhdGNoR0xQcm90b3R5cGUod2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLCBDYW52YXNDb250ZXh0LldlYkdMMiwgY2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG1pcnJvciwgd2luKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGZ1bmNUb1NvdXJjZShmbiwgc291cmNlbWFwQXJnKSB7XG4gICAgdmFyIHNvdXJjZW1hcCA9IHNvdXJjZW1hcEFyZyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHNvdXJjZW1hcEFyZztcbiAgICB2YXIgc291cmNlID0gZm4udG9TdHJpbmcoKTtcbiAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAgIGxpbmVzLnBvcCgpO1xuICAgIGxpbmVzLnNoaWZ0KCk7XG4gICAgdmFyIGJsYW5rUHJlZml4TGVuZ3RoID0gbGluZXNbMF0uc2VhcmNoKC9cXFMvKTtcbiAgICB2YXIgcmVnZXggPSAvKFsnXCJdKV9fd29ya2VyX2xvYWRlcl9zdHJpY3RfXyhbJ1wiXSkvZztcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnN1YnN0cmluZyhibGFua1ByZWZpeExlbmd0aCkucmVwbGFjZShyZWdleCwgJyQxdXNlIHN0cmljdCQyJykgKyAnXFxuJztcbiAgICB9XG4gICAgaWYgKHNvdXJjZW1hcCkge1xuICAgICAgICBsaW5lcy5wdXNoKCdcXC9cXC8jIHNvdXJjZU1hcHBpbmdVUkw9JyArIHNvdXJjZW1hcCArICdcXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVUkwoZm4sIHNvdXJjZW1hcEFyZykge1xuICAgIHZhciBsaW5lcyA9IGZ1bmNUb1NvdXJjZShmbiwgc291cmNlbWFwQXJnKTtcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKGxpbmVzLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5saW5lV29ya2VyRmFjdG9yeShmbiwgc291cmNlbWFwQXJnKSB7XG4gICAgdmFyIHVybDtcbiAgICByZXR1cm4gZnVuY3Rpb24gV29ya2VyRmFjdG9yeShvcHRpb25zKSB7XG4gICAgICAgIHVybCA9IHVybCB8fCBjcmVhdGVVUkwoZm4sIHNvdXJjZW1hcEFyZyk7XG4gICAgICAgIHJldHVybiBuZXcgV29ya2VyKHVybCwgb3B0aW9ucyk7XG4gICAgfTtcbn1cblxudmFyIFdvcmtlckZhY3RvcnkgPSBjcmVhdGVJbmxpbmVXb3JrZXJGYWN0b3J5KC8qIHJvbGx1cC1wbHVnaW4td2ViLXdvcmtlci1sb2FkZXIgKi9mdW5jdGlvbiAoKSB7XG4oZnVuY3Rpb24gKCkge1xuICAgICdfX3dvcmtlcl9sb2FkZXJfc3RyaWN0X18nO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBiYXNlNjQtYXJyYXlidWZmZXIgMS4wLjEgPGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXI+XG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIE5pa2xhcyB2b24gSGVydHplbiA8aHR0cHM6Ly9oZXJ0emVuLmNvbT5cbiAgICAgKiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZVxuICAgICAqL1xuICAgIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG4gICAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAoYXJyYXlidWZmZXIpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuICUgMyA9PT0gMikge1xuICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyAnPSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyAnPT0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfTtcblxuICAgIGNvbnN0IGxhc3RCbG9iTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBgJHt3aWR0aH0tJHtoZWlnaHR9YDtcclxuICAgICAgICAgICAgaWYgKCdPZmZzY3JlZW5DYW52YXMnIGluIGdsb2JhbFRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BhcmVudEJsb2JNYXAuaGFzKGlkKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwYXJlbnRCbG9iTWFwLmdldChpZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0geWllbGQgb2Zmc2NyZWVuLmNvbnZlcnRUb0Jsb2IoZGF0YVVSTE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSB5aWVsZCBibG9iLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRCbG9iTWFwLnNldChpZCwgYmFzZTY0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdvcmtlciA9IHNlbGY7XHJcbiAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoJ09mZnNjcmVlbkNhbnZhcycgaW4gZ2xvYmFsVGhpcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgYml0bWFwLCB3aWR0aCwgaGVpZ2h0LCBkYXRhVVJMT3B0aW9ucyB9ID0gZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwYXJlbnRCYXNlNjQgPSBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgYml0bWFwLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0geWllbGQgb2Zmc2NyZWVuLmNvbnZlcnRUb0Jsb2IoZGF0YVVSTE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0geWllbGQgYmxvYi5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0ID0gZW5jb2RlKGFycmF5QnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIGlmICghbGFzdEJsb2JNYXAuaGFzKGlkKSAmJiAoeWllbGQgdHJhbnNwYXJlbnRCYXNlNjQpID09PSBiYXNlNjQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlci5wb3N0TWVzc2FnZSh7IGlkIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RCbG9iTWFwLmdldChpZCkgPT09IGJhc2U2NClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlci5wb3N0TWVzc2FnZSh7IGlkOiBlLmRhdGEuaWQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XG5cbn0pKCk7XG59LCBudWxsKTtcblxuY2xhc3MgQ2FudmFzTWFuYWdlciB7XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzICYmIHRoaXMucmVzZXRPYnNlcnZlcnMoKTtcclxuICAgIH1cclxuICAgIGZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB1bmZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbG9jaygpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB1bmxvY2soKSB7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5yYWZTdGFtcHMgPSB7IGxhdGVzdElkOiAwLCBpbnZva2VJZDogbnVsbCB9O1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbiA9ICh0YXJnZXQsIG11dGF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkICE9PSB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZDtcclxuICAgICAgICAgICAgaWYgKG5ld0ZyYW1lIHx8ICF0aGlzLnJhZlN0YW1wcy5pbnZva2VJZClcclxuICAgICAgICAgICAgICAgIHRoaXMucmFmU3RhbXBzLmludm9rZUlkID0gdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuc2V0KHRhcmdldCwgW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5nZXQodGFyZ2V0KS5wdXNoKG11dGF0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHsgc2FtcGxpbmcgPSAnYWxsJywgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCByZWNvcmRDYW52YXMsIGRhdGFVUkxPcHRpb25zLCB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcclxuICAgICAgICBpZiAocmVjb3JkQ2FudmFzICYmIHNhbXBsaW5nID09PSAnYWxsJylcclxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmIChyZWNvcmRDYW52YXMgJiYgdHlwZW9mIHNhbXBsaW5nID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzRlBTT2JzZXJ2ZXIoc2FtcGxpbmcsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwge1xyXG4gICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaW5pdENhbnZhc0ZQU09ic2VydmVyKGZwcywgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHNuYXBzaG90SW5Qcm9ncmVzc01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyRmFjdG9yeSgpO1xyXG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGlkIH0gPSBlLmRhdGE7XHJcbiAgICAgICAgICAgIHNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKCEoJ2Jhc2U2NCcgaW4gZS5kYXRhKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgeyBiYXNlNjQsIHR5cGUsIHdpZHRoLCBoZWlnaHQgfSA9IGUuZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFsnMkQnXSxcclxuICAgICAgICAgICAgICAgIGNvbW1hbmRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogJ2NsZWFyUmVjdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFswLCAwLCB3aWR0aCwgaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6ICdkcmF3SW1hZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnJfdHlwZTogJ0ltYWdlQml0bWFwJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6ICdCbG9iJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFt7IHJyX3R5cGU6ICdBcnJheUJ1ZmZlcicsIGJhc2U2NCB9XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0aW1lQmV0d2VlblNuYXBzaG90cyA9IDEwMDAgLyBmcHM7XHJcbiAgICAgICAgbGV0IGxhc3RTbmFwc2hvdFRpbWUgPSAwO1xyXG4gICAgICAgIGxldCByYWZJZDtcclxuICAgICAgICBjb25zdCBnZXRDYW52YXMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRDYW52YXMgPSBbXTtcclxuICAgICAgICAgICAgd2luLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2NhbnZhcycpLmZvckVhY2goKGNhbnZhcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQoY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDYW52YXMucHVzaChjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWRDYW52YXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0YWtlQ2FudmFzU25hcHNob3RzID0gKHRpbWVzdGFtcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobGFzdFNuYXBzaG90VGltZSAmJlxyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wIC0gbGFzdFNuYXBzaG90VGltZSA8IHRpbWVCZXR3ZWVuU25hcHNob3RzKSB7XHJcbiAgICAgICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0U25hcHNob3RUaW1lID0gdGltZXN0YW1wO1xyXG4gICAgICAgICAgICBnZXRDYW52YXMoKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGNhbnZhcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1pcnJvci5nZXRJZChjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90SW5Qcm9ncmVzc01hcC5nZXQoaWQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmIChjYW52YXMud2lkdGggPT09IDAgfHwgY2FudmFzLmhlaWdodCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuc2V0KGlkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChbJ3dlYmdsJywgJ3dlYmdsMiddLmluY2x1ZGVzKGNhbnZhcy5fX2NvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KGNhbnZhcy5fX2NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LmdldENvbnRleHRBdHRyaWJ1dGVzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyKGNvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYml0bWFwID0geWllbGQgY3JlYXRlSW1hZ2VCaXRtYXAoY2FudmFzKTtcclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgYml0bWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBvcHRpb25zLmRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgfSwgW2JpdG1hcF0pO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XHJcbiAgICAgICAgdGhpcy5yZXNldE9ic2VydmVycyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2FudmFzQ29udGV4dFJlc2V0KCk7XHJcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydFJBRlRpbWVzdGFtcGluZygpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyKCk7XHJcbiAgICAgICAgY29uc3QgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBjYW52YXMyRFJlc2V0ID0gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcih0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc1dlYkdMMWFuZDJSZXNldCA9IGluaXRDYW52YXNXZWJHTE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0aGlzLm1pcnJvcik7XHJcbiAgICAgICAgdGhpcy5yZXNldE9ic2VydmVycyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2FudmFzQ29udGV4dFJlc2V0KCk7XHJcbiAgICAgICAgICAgIGNhbnZhczJEUmVzZXQoKTtcclxuICAgICAgICAgICAgY2FudmFzV2ViR0wxYW5kMlJlc2V0KCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKSk7XHJcbiAgICB9XHJcbiAgICBzdGFydFJBRlRpbWVzdGFtcGluZygpIHtcclxuICAgICAgICBjb25zdCBzZXRMYXRlc3RSQUZUaW1lc3RhbXAgPSAodGltZXN0YW1wKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkID0gdGltZXN0YW1wO1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzZXRMYXRlc3RSQUZUaW1lc3RhbXApO1xyXG4gICAgfVxyXG4gICAgZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5mb3JFYWNoKCh2YWx1ZXMsIGNhbnZhcykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMubWlycm9yLmdldElkKGNhbnZhcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkpO1xyXG4gICAgfVxyXG4gICAgZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZyb3plbiB8fCB0aGlzLmxvY2tlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZhbHVlc1dpdGhUeXBlID0gdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldChjYW52YXMpO1xyXG4gICAgICAgIGlmICghdmFsdWVzV2l0aFR5cGUgfHwgaWQgPT09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWVzV2l0aFR5cGUubWFwKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN0ID0gX19yZXN0KHZhbHVlLCBbXCJ0eXBlXCJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB2YWx1ZXNXaXRoVHlwZVswXTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IoeyBpZCwgdHlwZSwgY29tbWFuZHM6IHZhbHVlcyB9KTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZGVsZXRlKGNhbnZhcyk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU3R5bGVzaGVldE1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudHJhY2tlZExpbmtFbGVtZW50cyA9IG5ldyBXZWFrU2V0KCk7XHJcbiAgICAgICAgdGhpcy5zdHlsZU1pcnJvciA9IG5ldyBTdHlsZVNoZWV0TWlycm9yKCk7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xyXG4gICAgICAgIHRoaXMuYWRvcHRlZFN0eWxlU2hlZXRDYiA9IG9wdGlvbnMuYWRvcHRlZFN0eWxlU2hlZXRDYjtcclxuICAgIH1cclxuICAgIGF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbikge1xyXG4gICAgICAgIGlmICgnX2Nzc1RleHQnIGluIGNoaWxkU24uYXR0cmlidXRlcylcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcclxuICAgICAgICAgICAgICAgIGFkZHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlczogW10sXHJcbiAgICAgICAgICAgICAgICB0ZXh0czogW10sXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2hpbGRTbi5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogY2hpbGRTblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudHJhY2tMaW5rRWxlbWVudChsaW5rRWwpO1xyXG4gICAgfVxyXG4gICAgdHJhY2tMaW5rRWxlbWVudChsaW5rRWwpIHtcclxuICAgICAgICBpZiAodGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmhhcyhsaW5rRWwpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmFkZChsaW5rRWwpO1xyXG4gICAgICAgIHRoaXMudHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpO1xyXG4gICAgfVxyXG4gICAgYWRvcHRTdHlsZVNoZWV0cyhzaGVldHMsIGhvc3RJZCkge1xyXG4gICAgICAgIGlmIChzaGVldHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgYWRvcHRlZFN0eWxlU2hlZXREYXRhID0ge1xyXG4gICAgICAgICAgICBpZDogaG9zdElkLFxyXG4gICAgICAgICAgICBzdHlsZUlkczogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzdHlsZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHNoZWV0IG9mIHNoZWV0cykge1xyXG4gICAgICAgICAgICBsZXQgc3R5bGVJZDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0eWxlTWlycm9yLmhhcyhzaGVldCkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmFkZChzaGVldCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICBydWxlczogQXJyYXkuZnJvbShzaGVldC5ydWxlcyB8fCBDU1NSdWxlLCAociwgaW5kZXgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHN0cmluZ2lmeVJ1bGUociksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmdldElkKHNoZWV0KTtcclxuICAgICAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlSWRzLnB1c2goc3R5bGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHlsZXMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlcyA9IHN0eWxlcztcclxuICAgICAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IoYWRvcHRlZFN0eWxlU2hlZXREYXRhKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc3R5bGVNaXJyb3IucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgfVxyXG4gICAgdHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpIHtcclxuICAgIH1cclxufVxuXG5jbGFzcyBQcm9jZXNzZWROb2RlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm5vZGVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMubG9vcCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wZXJpb2RpY2FsbHlDbGVhcigpO1xyXG4gICAgfVxyXG4gICAgcGVyaW9kaWNhbGx5Q2xlYXIoKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sb29wKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZXJpb2RpY2FsbHlDbGVhcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaW5PdGhlckJ1ZmZlcihub2RlLCB0aGlzQnVmZmVyKSB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IHRoaXMubm9kZU1hcC5nZXQobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIChidWZmZXJzICYmIEFycmF5LmZyb20oYnVmZmVycykuc29tZSgoYnVmZmVyKSA9PiBidWZmZXIgIT09IHRoaXNCdWZmZXIpKTtcclxuICAgIH1cclxuICAgIGFkZChub2RlLCBidWZmZXIpIHtcclxuICAgICAgICB0aGlzLm5vZGVNYXAuc2V0KG5vZGUsICh0aGlzLm5vZGVNYXAuZ2V0KG5vZGUpIHx8IG5ldyBTZXQoKSkuYWRkKGJ1ZmZlcikpO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5sb29wID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gd3JhcEV2ZW50KGUpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGUpLCB7IHRpbWVzdGFtcDogbm93VGltZXN0YW1wKCkgfSk7XHJcbn1cclxubGV0IHdyYXBwZWRFbWl0O1xyXG5sZXQgdGFrZUZ1bGxTbmFwc2hvdDtcclxubGV0IGNhbnZhc01hbmFnZXI7XHJcbmxldCByZWNvcmRpbmcgPSBmYWxzZTtcclxuY29uc3QgbWlycm9yID0gY3JlYXRlTWlycm9yKCk7XHJcbmZ1bmN0aW9uIHJlY29yZChvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IHsgZW1pdCwgY2hlY2tvdXRFdmVyeU5tcywgY2hlY2tvdXRFdmVyeU50aCwgYmxvY2tDbGFzcyA9ICdyci1ibG9jaycsIGJsb2NrU2VsZWN0b3IgPSBudWxsLCBpZ25vcmVDbGFzcyA9ICdyci1pZ25vcmUnLCBpZ25vcmVTZWxlY3RvciA9IG51bGwsIG1hc2tUZXh0Q2xhc3MgPSAncnItbWFzaycsIG1hc2tUZXh0U2VsZWN0b3IgPSBudWxsLCBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSwgbWFza0FsbElucHV0cywgbWFza0lucHV0T3B0aW9uczogX21hc2tJbnB1dE9wdGlvbnMsIHNsaW1ET01PcHRpb25zOiBfc2xpbURPTU9wdGlvbnMsIG1hc2tJbnB1dEZuLCBtYXNrVGV4dEZuLCBob29rcywgcGFja0ZuLCBzYW1wbGluZyA9IHt9LCBkYXRhVVJMT3B0aW9ucyA9IHt9LCBtb3VzZW1vdmVXYWl0LCByZWNvcmRET00gPSB0cnVlLCByZWNvcmRDYW52YXMgPSBmYWxzZSwgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gZmFsc2UsIHJlY29yZEFmdGVyID0gb3B0aW9ucy5yZWNvcmRBZnRlciA9PT0gJ0RPTUNvbnRlbnRMb2FkZWQnXHJcbiAgICAgICAgPyBvcHRpb25zLnJlY29yZEFmdGVyXHJcbiAgICAgICAgOiAnbG9hZCcsIHVzZXJUcmlnZ2VyZWRPbklucHV0ID0gZmFsc2UsIGNvbGxlY3RGb250cyA9IGZhbHNlLCBpbmxpbmVJbWFnZXMgPSBmYWxzZSwgcGx1Z2lucywga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2UsIGlnbm9yZUNTU0F0dHJpYnV0ZXMgPSBuZXcgU2V0KFtdKSwgZXJyb3JIYW5kbGVyLCB9ID0gb3B0aW9ucztcclxuICAgIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcik7XHJcbiAgICBjb25zdCBpbkVtaXR0aW5nRnJhbWUgPSByZWNvcmRDcm9zc09yaWdpbklmcmFtZXNcclxuICAgICAgICA/IHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvd1xyXG4gICAgICAgIDogdHJ1ZTtcclxuICAgIGxldCBwYXNzRW1pdHNUb1BhcmVudCA9IGZhbHNlO1xyXG4gICAgaWYgKCFpbkVtaXR0aW5nRnJhbWUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnBhcmVudC5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBwYXNzRW1pdHNUb1BhcmVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGluRW1pdHRpbmdGcmFtZSAmJiAhZW1pdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW1pdCBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vdXNlbW92ZVdhaXQgIT09IHVuZGVmaW5lZCAmJiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNhbXBsaW5nLm1vdXNlbW92ZSA9IG1vdXNlbW92ZVdhaXQ7XHJcbiAgICB9XHJcbiAgICBtaXJyb3IucmVzZXQoKTtcclxuICAgIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0cnVlLFxyXG4gICAgICAgICAgICBkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxyXG4gICAgICAgICAgICBlbWFpbDogdHJ1ZSxcclxuICAgICAgICAgICAgbW9udGg6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWJlcjogdHJ1ZSxcclxuICAgICAgICAgICAgcmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIHNlYXJjaDogdHJ1ZSxcclxuICAgICAgICAgICAgdGVsOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiB0cnVlLFxyXG4gICAgICAgICAgICB0aW1lOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmw6IHRydWUsXHJcbiAgICAgICAgICAgIHdlZWs6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHRhcmVhOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHRydWUsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0cnVlLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IF9tYXNrSW5wdXRPcHRpb25zICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBfbWFza0lucHV0T3B0aW9uc1xyXG4gICAgICAgICAgICA6IHsgcGFzc3dvcmQ6IHRydWUgfTtcclxuICAgIGNvbnN0IHNsaW1ET01PcHRpb25zID0gX3NsaW1ET01PcHRpb25zID09PSB0cnVlIHx8IF9zbGltRE9NT3B0aW9ucyA9PT0gJ2FsbCdcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgc2NyaXB0OiB0cnVlLFxyXG4gICAgICAgICAgICBjb21tZW50OiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YUF1dGhvcnNoaXA6IF9zbGltRE9NT3B0aW9ucyA9PT0gJ2FsbCcsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBfc2xpbURPTU9wdGlvbnMgPT09ICdhbGwnLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IF9zbGltRE9NT3B0aW9uc1xyXG4gICAgICAgICAgICA/IF9zbGltRE9NT3B0aW9uc1xyXG4gICAgICAgICAgICA6IHt9O1xyXG4gICAgcG9seWZpbGwoKTtcclxuICAgIGxldCBsYXN0RnVsbFNuYXBzaG90RXZlbnQ7XHJcbiAgICBsZXQgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID0gMDtcclxuICAgIGNvbnN0IGV2ZW50UHJvY2Vzc29yID0gKGUpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zIHx8IFtdKSB7XHJcbiAgICAgICAgICAgIGlmIChwbHVnaW4uZXZlbnRQcm9jZXNzb3IpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBwbHVnaW4uZXZlbnRQcm9jZXNzb3IoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhY2tGbiAmJlxyXG4gICAgICAgICAgICAhcGFzc0VtaXRzVG9QYXJlbnQpIHtcclxuICAgICAgICAgICAgZSA9IHBhY2tGbihlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGU7XHJcbiAgICB9O1xyXG4gICAgd3JhcHBlZEVtaXQgPSAoZSwgaXNDaGVja291dCkgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoKChfYSA9IG11dGF0aW9uQnVmZmVyc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRnJvemVuKCkpICYmXHJcbiAgICAgICAgICAgIGUudHlwZSAhPT0gRXZlbnRUeXBlJDEuRnVsbFNuYXBzaG90ICYmXHJcbiAgICAgICAgICAgICEoZS50eXBlID09PSBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmXHJcbiAgICAgICAgICAgICAgICBlLmRhdGEuc291cmNlID09PSBJbmNyZW1lbnRhbFNvdXJjZSQxLk11dGF0aW9uKSkge1xyXG4gICAgICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYudW5mcmVlemUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbkVtaXR0aW5nRnJhbWUpIHtcclxuICAgICAgICAgICAgZW1pdCA9PT0gbnVsbCB8fCBlbWl0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbWl0KGV2ZW50UHJvY2Vzc29yKGUpLCBpc0NoZWNrb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFzc0VtaXRzVG9QYXJlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdycndlYicsXHJcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRQcm9jZXNzb3IoZSksXHJcbiAgICAgICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXHJcbiAgICAgICAgICAgICAgICBpc0NoZWNrb3V0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsICcqJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlLnR5cGUgPT09IEV2ZW50VHlwZSQxLkZ1bGxTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICBsYXN0RnVsbFNuYXBzaG90RXZlbnQgPSBlO1xyXG4gICAgICAgICAgICBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlLnR5cGUgPT09IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QpIHtcclxuICAgICAgICAgICAgaWYgKGUuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlJDEuTXV0YXRpb24gJiZcclxuICAgICAgICAgICAgICAgIGUuZGF0YS5pc0F0dGFjaElmcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluY3JlbWVudGFsU25hcHNob3RDb3VudCsrO1xyXG4gICAgICAgICAgICBjb25zdCBleGNlZWRDb3VudCA9IGNoZWNrb3V0RXZlcnlOdGggJiYgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID49IGNoZWNrb3V0RXZlcnlOdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4Y2VlZFRpbWUgPSBjaGVja291dEV2ZXJ5Tm1zICYmXHJcbiAgICAgICAgICAgICAgICBlLnRpbWVzdGFtcCAtIGxhc3RGdWxsU25hcHNob3RFdmVudC50aW1lc3RhbXAgPiBjaGVja291dEV2ZXJ5Tm1zO1xyXG4gICAgICAgICAgICBpZiAoZXhjZWVkQ291bnQgfHwgZXhjZWVkVGltZSkge1xyXG4gICAgICAgICAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB3cmFwcGVkTXV0YXRpb25FbWl0ID0gKG0pID0+IHtcclxuICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLk11dGF0aW9uIH0sIG0pLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB3cmFwcGVkU2Nyb2xsRW1pdCA9IChwKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5TY3JvbGwgfSwgcCksXHJcbiAgICB9KSk7XHJcbiAgICBjb25zdCB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0ID0gKHApID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLkNhbnZhc011dGF0aW9uIH0sIHApLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3Qgd3JhcHBlZEFkb3B0ZWRTdHlsZVNoZWV0RW1pdCA9IChhKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5BZG9wdGVkU3R5bGVTaGVldCB9LCBhKSxcclxuICAgIH0pKTtcclxuICAgIGNvbnN0IHN0eWxlc2hlZXRNYW5hZ2VyID0gbmV3IFN0eWxlc2hlZXRNYW5hZ2VyKHtcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0Q2I6IHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGlmcmFtZU1hbmFnZXIgPSBuZXcgSWZyYW1lTWFuYWdlcih7XHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXHJcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHN0eWxlc2hlZXRNYW5hZ2VyLFxyXG4gICAgICAgIHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyxcclxuICAgICAgICB3cmFwcGVkRW1pdCxcclxuICAgIH0pO1xyXG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucyB8fCBbXSkge1xyXG4gICAgICAgIGlmIChwbHVnaW4uZ2V0TWlycm9yKVxyXG4gICAgICAgICAgICBwbHVnaW4uZ2V0TWlycm9yKHtcclxuICAgICAgICAgICAgICAgIG5vZGVNaXJyb3I6IG1pcnJvcixcclxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luSWZyYW1lTWlycm9yOiBpZnJhbWVNYW5hZ2VyLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLFxyXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb2Nlc3NlZE5vZGVNYW5hZ2VyID0gbmV3IFByb2Nlc3NlZE5vZGVNYW5hZ2VyKCk7XHJcbiAgICBjYW52YXNNYW5hZ2VyID0gbmV3IENhbnZhc01hbmFnZXIoe1xyXG4gICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIHdpbjogd2luZG93LFxyXG4gICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgc2FtcGxpbmc6IHNhbXBsaW5nLmNhbnZhcyxcclxuICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc2hhZG93RG9tTWFuYWdlciA9IG5ldyBTaGFkb3dEb21NYW5hZ2VyKHtcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcclxuICAgICAgICBieXBhc3NPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgIHNhbXBsaW5nLFxyXG4gICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgaWZyYW1lTWFuYWdlcixcclxuICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIsXHJcbiAgICAgICAgICAgIGNhbnZhc01hbmFnZXIsXHJcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICB9KTtcclxuICAgIHRha2VGdWxsU25hcHNob3QgPSAoaXNDaGVja291dCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgaWYgKCFyZWNvcmRET00pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5NZXRhLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBocmVmOiB3aW5kb3cubG9jYXRpb24uaHJlZixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBnZXRXaW5kb3dXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBnZXRXaW5kb3dIZWlnaHQoKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSwgaXNDaGVja291dCk7XHJcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIucmVzZXQoKTtcclxuICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLmluaXQoKTtcclxuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYubG9jaygpKTtcclxuICAgICAgICBjb25zdCBub2RlID0gc25hcHNob3QoZG9jdW1lbnQsIHtcclxuICAgICAgICAgICAgbWlycm9yLFxyXG4gICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICBtYXNrQWxsSW5wdXRzOiBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICBzbGltRE9NOiBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICBvblNlcmlhbGl6ZTogKG4pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUobiwgbWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobiwgbWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChuLnNoYWRvd1Jvb3QsIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25JZnJhbWVMb2FkOiAoaWZyYW1lLCBjaGlsZFNuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xyXG4gICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IChsaW5rRWwsIGNoaWxkU24pID0+IHtcclxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNuYXBzaG90IHRoZSBkb2N1bWVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5GdWxsU25hcHNob3QsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsT2Zmc2V0OiBnZXRXaW5kb3dTY3JvbGwod2luZG93KSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSwgaXNDaGVja291dCk7XHJcbiAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLnVubG9jaygpKTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cywgbWlycm9yLmdldElkKGRvY3VtZW50KSk7XHJcbiAgICB9O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmUgPSAoZG9jKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihpbml0T2JzZXJ2ZXJzKSh7XHJcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgICAgICAgICAgbW91c2Vtb3ZlQ2I6IChwb3NpdGlvbnMsIHNvdXJjZSkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIG1vdXNlSW50ZXJhY3Rpb25DYjogKGQpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLk1vdXNlSW50ZXJhY3Rpb24gfSwgZCksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxDYjogd3JhcHBlZFNjcm9sbEVtaXQsXHJcbiAgICAgICAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiOiAoZCkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuVmlld3BvcnRSZXNpemUgfSwgZCksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBpbnB1dENiOiAodikgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuSW5wdXQgfSwgdiksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2I6IChwKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5NZWRpYUludGVyYWN0aW9uIH0sIHApLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYjogKHIpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLlN0eWxlU2hlZXRSdWxlIH0sIHIpLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiOiAocikgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuU3R5bGVEZWNsYXJhdGlvbiB9LCByKSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIGNhbnZhc011dGF0aW9uQ2I6IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQsXHJcbiAgICAgICAgICAgICAgICBmb250Q2I6IChwKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5Gb250IH0sIHApLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2I6IChwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5TZWxlY3Rpb24gfSwgcCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYjogKGMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLkN1c3RvbUVsZW1lbnQgfSwgYyksXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICBpZ25vcmVDbGFzcyxcclxuICAgICAgICAgICAgICAgIGlnbm9yZVNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgICAgIHNhbXBsaW5nLFxyXG4gICAgICAgICAgICAgICAgcmVjb3JkRE9NLFxyXG4gICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICAgICAgdXNlclRyaWdnZXJlZE9uSW5wdXQsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0Rm9udHMsXHJcbiAgICAgICAgICAgICAgICBkb2MsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIG1pcnJvcixcclxuICAgICAgICAgICAgICAgIGlmcmFtZU1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcixcclxuICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlcixcclxuICAgICAgICAgICAgICAgIGNhbnZhc01hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luczogKChfYSA9IHBsdWdpbnMgPT09IG51bGwgfHwgcGx1Z2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGx1Z2lucy5maWx0ZXIoKHApID0+IHAub2JzZXJ2ZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChwKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyOiBwLm9ic2VydmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHAub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogKHBheWxvYWQpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLlBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luOiBwLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIH0pKSkgfHwgW10sXHJcbiAgICAgICAgICAgIH0sIGhvb2tzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkTG9hZExpc3RlbmVyKChpZnJhbWVFbCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGluaXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRha2VGdWxsU25hcHNob3QoKTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGRvY3VtZW50KSk7XHJcbiAgICAgICAgICAgIHJlY29yZGluZyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fFxyXG4gICAgICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICAgIGluaXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob24oJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkRvbUNvbnRlbnRMb2FkZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge30sXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkQWZ0ZXIgPT09ICdET01Db250ZW50TG9hZGVkJylcclxuICAgICAgICAgICAgICAgICAgICBpbml0KCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvbignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuTG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRBZnRlciA9PT0gJ2xvYWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXQoKTtcclxuICAgICAgICAgICAgfSwgd2luZG93KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgcmVjb3JkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICAgIH1cclxufVxyXG5yZWNvcmQuYWRkQ3VzdG9tRXZlbnQgPSAodGFnLCBwYXlsb2FkKSA9PiB7XHJcbiAgICBpZiAoIXJlY29yZGluZykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGxlYXNlIGFkZCBjdXN0b20gZXZlbnQgYWZ0ZXIgc3RhcnQgcmVjb3JkaW5nJyk7XHJcbiAgICB9XHJcbiAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkN1c3RvbSxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIHRhZyxcclxuICAgICAgICAgICAgcGF5bG9hZCxcclxuICAgICAgICB9LFxyXG4gICAgfSkpO1xyXG59O1xyXG5yZWNvcmQuZnJlZXplUGFnZSA9ICgpID0+IHtcclxuICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi5mcmVlemUoKSk7XHJcbn07XHJcbnJlY29yZC50YWtlRnVsbFNuYXBzaG90ID0gKGlzQ2hlY2tvdXQpID0+IHtcclxuICAgIGlmICghcmVjb3JkaW5nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwbGVhc2UgdGFrZSBmdWxsIHNuYXBzaG90IGFmdGVyIHN0YXJ0IHJlY29yZGluZycpO1xyXG4gICAgfVxyXG4gICAgdGFrZUZ1bGxTbmFwc2hvdChpc0NoZWNrb3V0KTtcclxufTtcclxucmVjb3JkLm1pcnJvciA9IG1pcnJvcjtcblxudmFyIEV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlIHx8IHt9KTtcbnZhciBJbmNyZW1lbnRhbFNvdXJjZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEluY3JlbWVudGFsU291cmNlMikgPT4ge1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTXV0YXRpb25cIl0gPSAwXSA9IFwiTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlTW92ZVwiXSA9IDFdID0gXCJNb3VzZU1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlSW50ZXJhY3Rpb25cIl0gPSAyXSA9IFwiTW91c2VJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2Nyb2xsXCJdID0gM10gPSBcIlNjcm9sbFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVmlld3BvcnRSZXNpemVcIl0gPSA0XSA9IFwiVmlld3BvcnRSZXNpemVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIklucHV0XCJdID0gNV0gPSBcIklucHV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJUb3VjaE1vdmVcIl0gPSA2XSA9IFwiVG91Y2hNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNZWRpYUludGVyYWN0aW9uXCJdID0gN10gPSBcIk1lZGlhSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlU2hlZXRSdWxlXCJdID0gOF0gPSBcIlN0eWxlU2hlZXRSdWxlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDYW52YXNNdXRhdGlvblwiXSA9IDldID0gXCJDYW52YXNNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRm9udFwiXSA9IDEwXSA9IFwiRm9udFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTG9nXCJdID0gMTFdID0gXCJMb2dcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkRyYWdcIl0gPSAxMl0gPSBcIkRyYWdcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlRGVjbGFyYXRpb25cIl0gPSAxM10gPSBcIlN0eWxlRGVjbGFyYXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNlbGVjdGlvblwiXSA9IDE0XSA9IFwiU2VsZWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJBZG9wdGVkU3R5bGVTaGVldFwiXSA9IDE1XSA9IFwiQWRvcHRlZFN0eWxlU2hlZXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkN1c3RvbUVsZW1lbnRcIl0gPSAxNl0gPSBcIkN1c3RvbUVsZW1lbnRcIjtcbiAgcmV0dXJuIEluY3JlbWVudGFsU291cmNlMjtcbn0pKEluY3JlbWVudGFsU291cmNlIHx8IHt9KTtcblxudmFyIENvbmZpZyA9IHtcbiAgICBERUJVRzogZmFsc2UsXG4gICAgTElCX1ZFUlNJT046ICcyLjU4LjAnXG59O1xuXG4vLyBzaW5jZSBlczYgaW1wb3J0cyBhcmUgc3RhdGljIGFuZCB3ZSBydW4gdW5pdCB0ZXN0cyBmcm9tIHRoZSBjb25zb2xlLCB3aW5kb3cgd29uJ3QgYmUgZGVmaW5lZCB3aGVuIGltcG9ydGluZyB0aGlzIGZpbGVcbnZhciB3aW47XG5pZiAodHlwZW9mKHdpbmRvdykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGxvYyA9IHtcbiAgICAgICAgaG9zdG5hbWU6ICcnXG4gICAgfTtcbiAgICB3aW4gPSB7XG4gICAgICAgIG5hdmlnYXRvcjogeyB1c2VyQWdlbnQ6ICcnLCBvbkxpbmU6IHRydWUgfSxcbiAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2MsXG4gICAgICAgICAgICByZWZlcnJlcjogJydcbiAgICAgICAgfSxcbiAgICAgICAgc2NyZWVuOiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSxcbiAgICAgICAgbG9jYXRpb246IGxvY1xuICAgIH07XG59IGVsc2Uge1xuICAgIHdpbiA9IHdpbmRvdztcbn1cblxudmFyIHNldEltbWVkaWF0ZSA9IHdpblsnc2V0SW1tZWRpYXRlJ107XG52YXIgYnVpbHRJblByb3AsIGN5Y2xlLCBzY2hlZHVsaW5nUXVldWUsXG4gICAgVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIHRpbWVyID0gKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSA/XG4gICAgICAgIGZ1bmN0aW9uIHRpbWVyKGZuKSB7IHJldHVybiBzZXRJbW1lZGlhdGUoZm4pOyB9IDpcbiAgICAgICAgc2V0VGltZW91dDtcblxuLy8gZGFtbWl0LCBJRTguXG50cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwneCcse30pO1xuICAgIGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsLGNvbmZpZykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaixuYW1lLHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogY29uZmlnICE9PSBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuY2F0Y2ggKGVycikge1xuICAgIGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xufVxuXG4vLyBOb3RlOiB1c2luZyBhIHF1ZXVlIGluc3RlYWQgb2YgYXJyYXkgZm9yIGVmZmljaWVuY3lcbnNjaGVkdWxpbmdRdWV1ZSA9IChmdW5jdGlvbiBRdWV1ZSgpIHtcbiAgICB2YXIgZmlyc3QsIGxhc3QsIGl0ZW07XG5cbiAgICBmdW5jdGlvbiBJdGVtKGZuLHNlbGYpIHtcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICAgICAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZm4sc2VsZikge1xuICAgICAgICAgICAgaXRlbSA9IG5ldyBJdGVtKGZuLHNlbGYpO1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0Lm5leHQgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdCA9IGl0ZW07XG4gICAgICAgICAgICBpdGVtID0gdm9pZCAwO1xuICAgICAgICB9LFxuICAgICAgICBkcmFpbjogZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZpcnN0O1xuICAgICAgICAgICAgZmlyc3QgPSBsYXN0ID0gY3ljbGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChmKSB7XG4gICAgICAgICAgICAgICAgZi5mbi5jYWxsKGYuc2VsZik7XG4gICAgICAgICAgICAgICAgZiA9IGYubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5mdW5jdGlvbiBzY2hlZHVsZShmbixzZWxmKSB7XG4gICAgc2NoZWR1bGluZ1F1ZXVlLmFkZChmbixzZWxmKTtcbiAgICBpZiAoIWN5Y2xlKSB7XG4gICAgICAgIGN5Y2xlID0gdGltZXIoc2NoZWR1bGluZ1F1ZXVlLmRyYWluKTtcbiAgICB9XG59XG5cbi8vIHByb21pc2UgZHVjayB0eXBpbmdcbmZ1bmN0aW9uIGlzVGhlbmFibGUobykge1xuICAgIHZhciBfdGhlbiwgb1R5cGUgPSB0eXBlb2YgbztcblxuICAgIGlmIChvICE9PSBudWxsICYmIChvVHlwZSA9PT0gJ29iamVjdCcgfHwgb1R5cGUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIF90aGVuID0gby50aGVuO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIF90aGVuID09PSAnZnVuY3Rpb24nID8gX3RoZW4gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vdGlmeUlzb2xhdGVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICh0aGlzLnN0YXRlID09PSAxKSA/IHRoaXMuY2hhaW5baV0uc3VjY2VzcyA6IHRoaXMuY2hhaW5baV0uZmFpbHVyZSxcbiAgICAgICAgICAgIHRoaXMuY2hhaW5baV1cbiAgICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jaGFpbi5sZW5ndGggPSAwO1xufVxuXG4vLyBOT1RFOiBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gdG8gaXNvbGF0ZVxuLy8gdGhlIGB0cnkuLmNhdGNoYCBzbyB0aGF0IG90aGVyIGNvZGUgY2FuIGJlXG4vLyBvcHRpbWl6ZWQgYmV0dGVyXG5mdW5jdGlvbiBub3RpZnlJc29sYXRlZChzZWxmLGNiLGNoYWluKSB7XG4gICAgdmFyIHJldCwgX3RoZW47XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGNiID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY2hhaW4ucmVqZWN0KHNlbGYubXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHNlbGYubXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gY2IuY2FsbCh2b2lkIDAsc2VsZi5tc2cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmV0ID09PSBjaGFpbi5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgY2hhaW4ucmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKHJldCkpIHtcbiAgICAgICAgICAgICAgICBfdGhlbi5jYWxsKHJldCxjaGFpbi5yZXNvbHZlLGNoYWluLnJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFpbi5yZXNvbHZlKHJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjaGFpbi5yZWplY3QoZXJyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUobXNnKSB7XG4gICAgdmFyIF90aGVuLCBzZWxmID0gdGhpcztcblxuICAgIC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuICAgIGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuICAgIHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgIC8vIHVud3JhcFxuICAgIGlmIChzZWxmLmRlZikge1xuICAgICAgICBzZWxmID0gc2VsZi5kZWY7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgIGlmIChfdGhlbiA9IGlzVGhlbmFibGUobXNnKSkge1xuICAgICAgICAgICAgc2NoZWR1bGUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVmV3JhcHBlciA9IG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfdGhlbi5jYWxsKG1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRyZXNvbHZlJCgpeyByZXNvbHZlLmFwcGx5KGRlZldyYXBwZXIsYXJndW1lbnRzKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRyZWplY3QkKCl7IHJlamVjdC5hcHBseShkZWZXcmFwcGVyLGFyZ3VtZW50cyk7IH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QuY2FsbChkZWZXcmFwcGVyLGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLm1zZyA9IG1zZztcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAxO1xuICAgICAgICAgICAgaWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlKG5vdGlmeSxzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdC5jYWxsKG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKSxlcnIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KG1zZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuICAgIGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuICAgIHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgIC8vIHVud3JhcFxuICAgIGlmIChzZWxmLmRlZikge1xuICAgICAgICBzZWxmID0gc2VsZi5kZWY7XG4gICAgfVxuXG4gICAgc2VsZi5tc2cgPSBtc2c7XG4gICAgc2VsZi5zdGF0ZSA9IDI7XG4gICAgaWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBzY2hlZHVsZShub3RpZnksc2VsZik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLHJlc29sdmVyLHJlamVjdGVyKSB7XG4gICAgZm9yICh2YXIgaWR4PTA7IGlkeDxhcnIubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAoZnVuY3Rpb24gSUlGRShpZHgpe1xuICAgICAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShhcnJbaWR4XSlcbiAgICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gJHJlc29sdmVyJChtc2cpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIoaWR4LG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfSkoaWR4KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIE1ha2VEZWZXcmFwcGVyKHNlbGYpIHtcbiAgICB0aGlzLmRlZiA9IHNlbGY7XG4gICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gTWFrZURlZihzZWxmKSB7XG4gICAgdGhpcy5wcm9taXNlID0gc2VsZjtcbiAgICB0aGlzLnN0YXRlID0gMDtcbiAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2hhaW4gPSBbXTtcbiAgICB0aGlzLm1zZyA9IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gTnBvUHJvbWlzZShleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzWydfX05QT19fJ10gIT09IDApIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBwcm9taXNlJyk7XG4gICAgfVxuXG4gICAgLy8gaW5zdGFuY2Ugc2hhZG93aW5nIHRoZSBpbmhlcml0ZWQgXCJicmFuZFwiXG4gICAgLy8gdG8gc2lnbmFsIGFuIGFscmVhZHkgXCJpbml0aWFsaXplZFwiIHByb21pc2VcbiAgICB0aGlzWydfX05QT19fJ10gPSAxO1xuXG4gICAgdmFyIGRlZiA9IG5ldyBNYWtlRGVmKHRoaXMpO1xuXG4gICAgdGhpc1sndGhlbiddID0gZnVuY3Rpb24gdGhlbihzdWNjZXNzLGZhaWx1cmUpIHtcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0eXBlb2Ygc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJyA/IHN1Y2Nlc3MgOiB0cnVlLFxuICAgICAgICAgICAgZmFpbHVyZTogdHlwZW9mIGZhaWx1cmUgPT09ICdmdW5jdGlvbicgPyBmYWlsdXJlIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIE5vdGU6IGB0aGVuKC4uKWAgaXRzZWxmIGNhbiBiZSBib3Jyb3dlZCB0byBiZSB1c2VkIGFnYWluc3RcbiAgICAgICAgICAgIC8vIGEgZGlmZmVyZW50IHByb21pc2UgY29uc3RydWN0b3IgZm9yIG1ha2luZyB0aGUgY2hhaW5lZCBwcm9taXNlLFxuICAgICAgICAgICAgLy8gYnkgc3Vic3RpdHV0aW5nIGEgZGlmZmVyZW50IGB0aGlzYCBiaW5kaW5nLlxuICAgICAgICBvLnByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihmdW5jdGlvbiBleHRyYWN0Q2hhaW4ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgby5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYuY2hhaW4ucHVzaChvKTtcblxuICAgICAgICBpZiAoZGVmLnN0YXRlICE9PSAwKSB7XG4gICAgICAgICAgICBzY2hlZHVsZShub3RpZnksZGVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvLnByb21pc2U7XG4gICAgfTtcbiAgICB0aGlzWydjYXRjaCddID0gZnVuY3Rpb24gJGNhdGNoJChmYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLGZhaWx1cmUpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvci5jYWxsKFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgZnVuY3Rpb24gcHVibGljUmVzb2x2ZShtc2cpe1xuICAgICAgICAgICAgICAgIHJlc29sdmUuY2FsbChkZWYsbXNnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiBwdWJsaWNSZWplY3QobXNnKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0LmNhbGwoZGVmLG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0LmNhbGwoZGVmLGVycik7XG4gICAgfVxufVxuXG52YXIgUHJvbWlzZVByb3RvdHlwZSA9IGJ1aWx0SW5Qcm9wKHt9LCdjb25zdHJ1Y3RvcicsTnBvUHJvbWlzZSxcbiAgICAvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG4pO1xuXG4gICAgLy8gTm90ZTogQW5kcm9pZCA0IGNhbm5vdCB1c2UgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSguLilgIGhlcmVcbk5wb1Byb21pc2UucHJvdG90eXBlID0gUHJvbWlzZVByb3RvdHlwZTtcblxuLy8gYnVpbHQtaW4gXCJicmFuZFwiIHRvIHNpZ25hbCBhbiBcInVuaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG5idWlsdEluUHJvcChQcm9taXNlUHJvdG90eXBlLCdfX05QT19fJywwLFxuICAgIC8qY29uZmlndXJhYmxlPSovZmFsc2Vcbik7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ3Jlc29sdmUnLGZ1bmN0aW9uIFByb21pc2UkcmVzb2x2ZShtc2cpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICAvLyBub3RlOiBiZXN0IFwiaXNQcm9taXNlXCIgY2hlY2sgdGhhdCdzIHByYWN0aWNhbCBmb3Igbm93XG4gICAgaWYgKG1zZyAmJiB0eXBlb2YgbXNnID09PSAnb2JqZWN0JyAmJiBtc2dbJ19fTlBPX18nXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShtc2cpO1xuICAgIH0pO1xufSk7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ3JlamVjdCcsZnVuY3Rpb24gUHJvbWlzZSRyZWplY3QobXNnKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlamVjdChtc2cpO1xuICAgIH0pO1xufSk7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ2FsbCcsZnVuY3Rpb24gUHJvbWlzZSRhbGwoYXJyKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgaWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcignTm90IGFuIGFycmF5JykpO1xuICAgIH1cbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCwgbXNncyA9IEFycmF5KGxlbiksIGNvdW50ID0gMDtcblxuICAgICAgICBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpIHtcbiAgICAgICAgICAgIG1zZ3NbaWR4XSA9IG1zZztcbiAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG1zZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LHJlamVjdCk7XG4gICAgfSk7XG59KTtcblxuYnVpbHRJblByb3AoTnBvUHJvbWlzZSwncmFjZScsZnVuY3Rpb24gUHJvbWlzZSRyYWNlKGFycikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIGlmIChUb1N0cmluZy5jYWxsKGFycikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoJ05vdCBhbiBhcnJheScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZyl7XG4gICAgICAgICAgICByZXNvbHZlKG1zZyk7XG4gICAgICAgIH0scmVqZWN0KTtcbiAgICB9KTtcbn0pO1xuXG52YXIgUHJvbWlzZVBvbHlmaWxsO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBQcm9taXNlLnRvU3RyaW5nKCkuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMSkge1xuICAgIFByb21pc2VQb2x5ZmlsbCA9IFByb21pc2U7XG59IGVsc2Uge1xuICAgIFByb21pc2VQb2x5ZmlsbCA9IE5wb1Byb21pc2U7XG59XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIsIGVxZXFlcTogXCJvZmZcIiAqL1xuXG4vLyBNYXhpbXVtIGFsbG93ZWQgc2Vzc2lvbiByZWNvcmRpbmcgbGVuZ3RoXG52YXIgTUFYX1JFQ09SRElOR19NUyA9IDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vIDI0IGhvdXJzXG4vLyBNYXhpbXVtIGFsbG93ZWQgdmFsdWUgZm9yIG1pbmltdW0gc2Vzc2lvbiByZWNvcmRpbmcgbGVuZ3RoXG52YXIgTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TID0gOCAqIDEwMDA7IC8vIDggc2Vjb25kc1xuXG4vKlxuICogU2F2ZWQgcmVmZXJlbmNlcyB0byBsb25nIHZhcmlhYmxlIG5hbWVzLCBzbyB0aGF0IGNsb3N1cmUgY29tcGlsZXIgY2FuXG4gKiBtaW5pbWl6ZSBmaWxlIHNpemUuXG4gKi9cblxudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICBzbGljZSA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSA9IE9ialByb3RvLmhhc093blByb3BlcnR5LFxuICAgIHdpbmRvd0NvbnNvbGUgPSB3aW4uY29uc29sZSxcbiAgICBuYXZpZ2F0b3IgPSB3aW4ubmF2aWdhdG9yLFxuICAgIGRvY3VtZW50JDEgPSB3aW4uZG9jdW1lbnQsXG4gICAgd2luZG93T3BlcmEgPSB3aW4ub3BlcmEsXG4gICAgc2NyZWVuID0gd2luLnNjcmVlbixcbiAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG52YXIgbmF0aXZlQmluZCA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUZvckVhY2ggPSBBcnJheVByb3RvLmZvckVhY2gsXG4gICAgbmF0aXZlSW5kZXhPZiA9IEFycmF5UHJvdG8uaW5kZXhPZixcbiAgICBuYXRpdmVNYXAgPSBBcnJheVByb3RvLm1hcCxcbiAgICBuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICBicmVha2VyID0ge307XG5cbnZhciBfID0ge1xuICAgIHRyaW06IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSNQb2x5ZmlsbFxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG4gICAgfVxufTtcblxuLy8gQ29uc29sZSBvdmVycmlkZVxudmFyIGNvbnNvbGUkMSA9IHtcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIGxvZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChDb25maWcuREVCVUcgJiYgIV8uaXNVbmRlZmluZWQod2luZG93Q29uc29sZSkgJiYgd2luZG93Q29uc29sZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmxvZy5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUubG9nKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgd2FybjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChDb25maWcuREVCVUcgJiYgIV8uaXNVbmRlZmluZWQod2luZG93Q29uc29sZSkgJiYgd2luZG93Q29uc29sZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbJ01peHBhbmVsIHdhcm5pbmc6J10uY29uY2F0KF8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS53YXJuLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLndhcm4oYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChDb25maWcuREVCVUcgJiYgIV8uaXNVbmRlZmluZWQod2luZG93Q29uc29sZSkgJiYgd2luZG93Q29uc29sZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbJ01peHBhbmVsIGVycm9yOiddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IuYXBwbHkod2luZG93Q29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IoYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICBjcml0aWNhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFsnTWl4cGFuZWwgZXJyb3I6J10uY29uY2F0KF8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvci5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvcihhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGxvZ19mdW5jX3dpdGhfcHJlZml4ID0gZnVuY3Rpb24oZnVuYywgcHJlZml4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcmd1bWVudHNbMF0gPSAnWycgKyBwcmVmaXggKyAnXSAnICsgYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb25zb2xlJDEsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn07XG52YXIgY29uc29sZV93aXRoX3ByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxvZzogbG9nX2Z1bmNfd2l0aF9wcmVmaXgoY29uc29sZSQxLmxvZywgcHJlZml4KSxcbiAgICAgICAgZXJyb3I6IGxvZ19mdW5jX3dpdGhfcHJlZml4KGNvbnNvbGUkMS5lcnJvciwgcHJlZml4KSxcbiAgICAgICAgY3JpdGljYWw6IGxvZ19mdW5jX3dpdGhfcHJlZml4KGNvbnNvbGUkMS5jcml0aWNhbCwgcHJlZml4KVxuICAgIH07XG59O1xuXG5cbi8vIFVOREVSU0NPUkVcbi8vIEVtYmVkIHBhcnQgb2YgdGhlIFVuZGVyc2NvcmUgTGlicmFyeVxuXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIHZhciBhcmdzLCBib3VuZDtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0ge307XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICAgIHZhciBzZWxmID0gbmV3IGN0b3IoKTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kj19IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbiguLi4qKT19IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdD19IGNvbnRleHRcbiAqL1xuXy5lYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIG9iaiAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gYnJlYWtlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGJyZWFrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbl8uZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlW3Byb3BdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gZnJvbSBhIGNvbW1lbnQgb24gaHR0cDovL2Riai5vcmcvZGJqLz9wPTI4NlxuLy8gZmFpbHMgb24gb25seSBvbmUgdmVyeSByYXJlIGFuZCBkZWxpYmVyYXRlIGN1c3RvbSBvYmplY3Q6XG4vLyB2YXIgYm9tYiA9IHsgdG9TdHJpbmcgOiB1bmRlZmluZWQsIHZhbHVlT2Y6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIFwiZnVuY3Rpb24gQk9NQkEhXCI7IH19O1xuXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24oZikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAvXlxccypcXGJmdW5jdGlvblxcYi8udGVzdChmKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5fLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ2NhbGxlZScpKTtcbn07XG5cbl8udG9BcnJheSA9IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgaWYgKCFpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZS50b0FycmF5KSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZS50b0FycmF5KCk7XG4gICAgfVxuICAgIGlmIChfLmlzQXJyYXkoaXRlcmFibGUpKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcmd1bWVudHMoaXRlcmFibGUpKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF8udmFsdWVzKGl0ZXJhYmxlKTtcbn07XG5cbl8ubWFwID0gZnVuY3Rpb24oYXJyLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVNYXAgJiYgYXJyLm1hcCA9PT0gbmF0aXZlTWFwKSB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfLmVhY2goYXJyLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY2FsbGJhY2suY2FsbChjb250ZXh0LCBpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59O1xuXG5fLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBrZXk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5fLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbl8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSB7XG4gICAgICAgIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoZm91bmQgfHwgKGZvdW5kID0gKHZhbHVlID09PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJyZWFrZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG5fLmluY2x1ZGVzID0gZnVuY3Rpb24oc3RyLCBuZWVkbGUpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG59O1xuXG4vLyBVbmRlcnNjb3JlIEFkZG9uc1xuXy5pbmhlcml0ID0gZnVuY3Rpb24oc3ViY2xhc3MsIHN1cGVyY2xhc3MpIHtcbiAgICBzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgc3VwZXJjbGFzcygpO1xuICAgIHN1YmNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YmNsYXNzO1xuICAgIHN1YmNsYXNzLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc3ViY2xhc3M7XG59O1xuXG5fLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIChvYmogPT09IE9iamVjdChvYmopICYmICFfLmlzQXJyYXkob2JqKSk7XG59O1xuXG5fLmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoXy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbn07XG5cbl8uaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxuXy5pc0RhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbl8uaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IE51bWJlcl0nO1xufTtcblxuXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG59O1xuXG5fLmVuY29kZURhdGVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoXy5pc0RhdGUodikpIHtcbiAgICAgICAgICAgIG9ialtrXSA9IF8uZm9ybWF0RGF0ZSh2KTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgICBvYmpba10gPSBfLmVuY29kZURhdGVzKHYpOyAvLyByZWN1cnNlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuXy50aW1lc3RhbXAgPSBmdW5jdGlvbigpIHtcbiAgICBEYXRlLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gK25ldyBEYXRlO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG59O1xuXG5fLmZvcm1hdERhdGUgPSBmdW5jdGlvbihkKSB7XG4gICAgLy8gWVlZWS1NTS1ERFRISDpNTTpTUyBpbiBVVENcbiAgICBmdW5jdGlvbiBwYWQobikge1xuICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgfVxuICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyAnLScgK1xuICAgICAgICBwYWQoZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICBwYWQoZC5nZXRVVENEYXRlKCkpICsgJ1QnICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgK1xuICAgICAgICBwYWQoZC5nZXRVVENNaW51dGVzKCkpICsgJzonICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDU2Vjb25kcygpKTtcbn07XG5cbl8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgXy5lYWNoKHAsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcodikgJiYgdi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXRba10gPSB2O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8qXG4gKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBjb3B5IG9mIG9iamVjdCBhZnRlciB0cnVuY2F0aW5nIGl0LiAgSWZcbiAqIHBhc3NlZCBhbiBBcnJheSBvciBPYmplY3QgaXQgd2lsbCBpdGVyYXRlIHRocm91Z2ggb2JqIGFuZFxuICogdHJ1bmNhdGUgYWxsIHRoZSB2YWx1ZXMgcmVjdXJzaXZlbHkuXG4gKi9cbl8udHJ1bmNhdGUgPSBmdW5jdGlvbihvYmosIGxlbmd0aCkge1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldCA9IG9iai5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0ID0gW107XG4gICAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0LnB1c2goXy50cnVuY2F0ZSh2YWwsIGxlbmd0aCkpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gXy50cnVuY2F0ZSh2YWwsIGxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxuXy5KU09ORW5jb2RlID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihtaXhlZF92YWwpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbWl4ZWRfdmFsO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBlc2NhcGFibGUgPSAvW1xcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICAgICAgICB2YXIgbWV0YSA9IHsgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICAgICAnXCInOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgP1xuICAgICAgICAgICAgICAgICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgICAgICB9KSArICdcIicgOlxuICAgICAgICAgICAgICAgICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdHIgPSBmdW5jdGlvbihrZXksIGhvbGRlcikge1xuICAgICAgICAgICAgdmFyIGdhcCA9ICcnO1xuICAgICAgICAgICAgdmFyIGluZGVudCA9ICcgICAgJztcbiAgICAgICAgICAgIHZhciBpID0gMDsgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgICAgIHZhciBrID0gJyc7IC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICAgICAgdmFyIHYgPSAnJzsgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICAgICAgdmFyIG1pbmQgPSBnYXA7XG4gICAgICAgICAgICB2YXIgcGFydGlhbCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0eXBlIGlzICdvYmplY3QnLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG51bGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIER1ZSB0byBhIHNwZWNpZmljYXRpb24gYmx1bmRlciBpbiBFQ01BU2NyaXB0LCB0eXBlb2YgbnVsbCBpcyAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2F0Y2ggb3V0IGZvciB0aGF0IGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGUgdmFsdWUgYW4gYXJyYXk/XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBhbiBhcnJheS4gU3RyaW5naWZ5IGV2ZXJ5IGVsZW1lbnQuIFVzZSBudWxsIGFzIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBub24tSlNPTiB2YWx1ZXMuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyYWNrZXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwID8gJ1tcXG4nICsgZ2FwICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cbiAgICAgICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBnYXAgPyAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICcnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmQgKyAnfScgOiAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIHN0cignJywge1xuICAgICAgICAgICAgJyc6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2RvdWdsYXNjcm9ja2ZvcmQvSlNPTi1qcy9ibG9iL21hc3Rlci9qc29uX3BhcnNlLmpzXG4gKiBTbGlnaHRseSBtb2RpZmllZCB0byB0aHJvdyBhIHJlYWwgRXJyb3IgcmF0aGVyIHRoYW4gYSBQT0pPXG4gKi9cbl8uSlNPTkRlY29kZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgYXQsIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICAgICAgY2gsIC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICBlc2NhcGVlID0ge1xuICAgICAgICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgICAgICAgJy8nOiAnLycsXG4gICAgICAgICAgICAnYic6ICdcXGInLFxuICAgICAgICAgICAgJ2YnOiAnXFxmJyxcbiAgICAgICAgICAgICduJzogJ1xcbicsXG4gICAgICAgICAgICAncic6ICdcXHInLFxuICAgICAgICAgICAgJ3QnOiAnXFx0J1xuICAgICAgICB9LFxuICAgICAgICB0ZXh0LFxuICAgICAgICBlcnJvciA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IFN5bnRheEVycm9yKG0pO1xuICAgICAgICAgICAgZS5hdCA9IGF0O1xuICAgICAgICAgICAgZS50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB2ZXJpZnkgdGhhdCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGlmIChjICYmIGMgIT09IGNoKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIFxcJycgKyBjICsgJ1xcJyBpbnN0ZWFkIG9mIFxcJycgKyBjaCArICdcXCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgICAgICBhdCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9LFxuICAgICAgICBudW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGEgbnVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnJztcblxuICAgICAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnLSc7XG4gICAgICAgICAgICAgICAgbmV4dCgnLScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyID0gK3N0cmluZztcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdCYWQgbnVtYmVyJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBoZXgsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgICAgICB1ZmZmZjtcbiAgICAgICAgICAgIC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWZmZmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdCYWQgc3RyaW5nJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHdoaXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UuXG4gICAgICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3b3JkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyB0cnVlLCBmYWxzZSwgb3IgbnVsbC5cbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgndCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdyJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnZicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdhJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgncycpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIFwiJyArIGNoICsgJ1wiJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlLCAvLyBQbGFjZWhvbGRlciBmb3IgdGhlIHZhbHVlIGZ1bmN0aW9uLlxuICAgICAgICBhcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCdbJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTsgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdCYWQgYXJyYXknKTtcbiAgICAgICAgfSxcbiAgICAgICAgb2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhbiBvYmplY3QgdmFsdWUuXG4gICAgICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIG5leHQoJ3snKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDsgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnOicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignQmFkIG9iamVjdCcpO1xuICAgICAgICB9O1xuXG4gICAgdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZyxcbiAgICAgICAgLy8gYSBudW1iZXIsIG9yIGEgd29yZC5cbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5KCk7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2ggPj0gJzAnICYmIGNoIDw9ICc5JyA/IG51bWJlcigpIDogd29yZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlXG4gICAgLy8gYWJvdmUgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHRleHQgPSBzb3VyY2U7XG4gICAgICAgIGF0ID0gMDtcbiAgICAgICAgY2ggPSAnICc7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgZXJyb3IoJ1N5bnRheCBlcnJvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcblxuXy5iYXNlNjRFbmNvZGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGI2NCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG4gICAgdmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcbiAgICAgICAgYWMgPSAwLFxuICAgICAgICBlbmMgPSAnJyxcbiAgICAgICAgdG1wX2FyciA9IFtdO1xuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEgPSBfLnV0ZjhFbmNvZGUoZGF0YSk7XG5cbiAgICBkbyB7IC8vIHBhY2sgdGhyZWUgb2N0ZXRzIGludG8gZm91ciBoZXhldHNcbiAgICAgICAgbzEgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzIgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzMgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcblxuICAgICAgICBiaXRzID0gbzEgPDwgMTYgfCBvMiA8PCA4IHwgbzM7XG5cbiAgICAgICAgaDEgPSBiaXRzID4+IDE4ICYgMHgzZjtcbiAgICAgICAgaDIgPSBiaXRzID4+IDEyICYgMHgzZjtcbiAgICAgICAgaDMgPSBiaXRzID4+IDYgJiAweDNmO1xuICAgICAgICBoNCA9IGJpdHMgJiAweDNmO1xuXG4gICAgICAgIC8vIHVzZSBoZXhldHMgdG8gaW5kZXggaW50byBiNjQsIGFuZCBhcHBlbmQgcmVzdWx0IHRvIGVuY29kZWQgc3RyaW5nXG4gICAgICAgIHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcbiAgICB9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG4gICAgZW5jID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgIHN3aXRjaCAoZGF0YS5sZW5ndGggJSAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGVuYyA9IGVuYy5zbGljZSgwLCAtMikgKyAnPT0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGVuYyA9IGVuYy5zbGljZSgwLCAtMSkgKyAnPSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jO1xufTtcblxuXy51dGY4RW5jb2RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gKHN0cmluZyArICcnKS5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJyk7XG5cbiAgICB2YXIgdXRmdGV4dCA9ICcnLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kO1xuICAgIHZhciBzdHJpbmdsID0gMCxcbiAgICAgICAgbjtcblxuICAgIHN0YXJ0ID0gZW5kID0gMDtcbiAgICBzdHJpbmdsID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIGZvciAobiA9IDA7IG4gPCBzdHJpbmdsOyBuKyspIHtcbiAgICAgICAgdmFyIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQobik7XG4gICAgICAgIHZhciBlbmMgPSBudWxsO1xuXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH0gZWxzZSBpZiAoKGMxID4gMTI3KSAmJiAoYzEgPCAyMDQ4KSkge1xuICAgICAgICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYzEgPj4gNikgfCAxOTIsIChjMSAmIDYzKSB8IDEyOCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjMSA+PiAxMikgfCAyMjQsICgoYzEgPj4gNikgJiA2MykgfCAxMjgsIChjMSAmIDYzKSB8IDEyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRmdGV4dCArPSBlbmM7XG4gICAgICAgICAgICBzdGFydCA9IGVuZCA9IG4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgIHV0ZnRleHQgKz0gc3RyaW5nLnN1YnN0cmluZyhzdGFydCwgc3RyaW5nLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0ZnRleHQ7XG59O1xuXG5fLlVVSUQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBUaW1lLWJhc2VkIGVudHJvcHlcbiAgICB2YXIgVCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGltZSA9IDEgKiBuZXcgRGF0ZSgpOyAvLyBjcm9zcy1icm93c2VyIHZlcnNpb24gb2YgRGF0ZS5ub3coKVxuICAgICAgICB2YXIgdGlja3M7XG4gICAgICAgIGlmICh3aW4ucGVyZm9ybWFuY2UgJiYgd2luLnBlcmZvcm1hbmNlLm5vdykge1xuICAgICAgICAgICAgdGlja3MgPSB3aW4ucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gYnVzeSBsb29wXG4gICAgICAgICAgICB0aWNrcyA9IDA7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgd2hpbGUgbG9vcCBmaWd1cmVzIGhvdyBtYW55IGJyb3dzZXIgdGlja3MgZ28gYnlcbiAgICAgICAgICAgIC8vIGJlZm9yZSAxKm5ldyBEYXRlKCkgcmV0dXJucyBhIG5ldyBudW1iZXIsIGllIHRoZSBhbW91bnRcbiAgICAgICAgICAgIC8vIG9mIHRpY2tzIHRoYXQgZ28gYnkgcGVyIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICB3aGlsZSAodGltZSA9PSAxICogbmV3IERhdGUoKSkge1xuICAgICAgICAgICAgICAgIHRpY2tzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWUudG9TdHJpbmcoMTYpICsgTWF0aC5mbG9vcih0aWNrcykudG9TdHJpbmcoMTYpO1xuICAgIH07XG5cbiAgICAvLyBNYXRoLlJhbmRvbSBlbnRyb3B5XG4gICAgdmFyIFIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnJlcGxhY2UoJy4nLCAnJyk7XG4gICAgfTtcblxuICAgIC8vIFVzZXIgYWdlbnQgZW50cm9weVxuICAgIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgdGhlIHVzZXIgYWdlbnQgc3RyaW5nLCBhbmQgdGhlbiB4b3JzXG4gICAgLy8gdG9nZXRoZXIgZWFjaCBzZXF1ZW5jZSBvZiA4IGJ5dGVzLiAgVGhpcyBwcm9kdWNlcyBhIGZpbmFsXG4gICAgLy8gc2VxdWVuY2Ugb2YgOCBieXRlcyB3aGljaCBpdCByZXR1cm5zIGFzIGhleC5cbiAgICB2YXIgVUEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHVhID0gdXNlckFnZW50LFxuICAgICAgICAgICAgaSwgY2gsIGJ1ZmZlciA9IFtdLFxuICAgICAgICAgICAgcmV0ID0gMDtcblxuICAgICAgICBmdW5jdGlvbiB4b3IocmVzdWx0LCBieXRlX2FycmF5KSB7XG4gICAgICAgICAgICB2YXIgaiwgdG1wID0gMDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBieXRlX2FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdG1wIHw9IChidWZmZXJbal0gPDwgaiAqIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCBeIHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB1YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB1YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgYnVmZmVyLnVuc2hpZnQoY2ggJiAweEZGKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAgICAgICByZXQgPSB4b3IocmV0LCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXQgPSB4b3IocmV0LCBidWZmZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldC50b1N0cmluZygxNik7XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlID0gKHNjcmVlbi5oZWlnaHQgKiBzY3JlZW4ud2lkdGgpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmV0dXJuIChUKCkgKyAnLScgKyBSKCkgKyAnLScgKyBVQSgpICsgJy0nICsgc2UgKyAnLScgKyBUKCkpO1xuICAgIH07XG59KSgpO1xuXG4vLyBfLmlzQmxvY2tlZFVBKClcbi8vIFRoaXMgaXMgdG8gYmxvY2sgdmFyaW91cyB3ZWIgc3BpZGVycyBmcm9tIGV4ZWN1dGluZyBvdXIgSlMgYW5kXG4vLyBzZW5kaW5nIGZhbHNlIHRyYWNraW5nIGRhdGFcbnZhciBCTE9DS0VEX1VBX1NUUlMgPSBbXG4gICAgJ2FocmVmc2JvdCcsXG4gICAgJ2FocmVmc3NpdGVhdWRpdCcsXG4gICAgJ2JhaWR1c3BpZGVyJyxcbiAgICAnYmluZ2JvdCcsXG4gICAgJ2JpbmdwcmV2aWV3JyxcbiAgICAnY2hyb21lLWxpZ2h0aG91c2UnLFxuICAgICdmYWNlYm9va2V4dGVybmFsJyxcbiAgICAncGV0YWxib3QnLFxuICAgICdwaW50ZXJlc3QnLFxuICAgICdzY3JlYW1pbmcgZnJvZycsXG4gICAgJ3lhaG9vISBzbHVycCcsXG4gICAgJ3lhbmRleGJvdCcsXG5cbiAgICAvLyBhIHdob2xlIGJ1bmNoIG9mIGdvb2ctc3BlY2lmaWMgY3Jhd2xlcnNcbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9zZWFyY2gvZG9jcy9hZHZhbmNlZC9jcmF3bGluZy9vdmVydmlldy1nb29nbGUtY3Jhd2xlcnNcbiAgICAnYWRzYm90LWdvb2dsZScsXG4gICAgJ2FwaXMtZ29vZ2xlJyxcbiAgICAnZHVwbGV4d2ViLWdvb2dsZScsXG4gICAgJ2ZlZWRmZXRjaGVyLWdvb2dsZScsXG4gICAgJ2dvb2dsZSBmYXZpY29uJyxcbiAgICAnZ29vZ2xlIHdlYiBwcmV2aWV3JyxcbiAgICAnZ29vZ2xlLXJlYWQtYWxvdWQnLFxuICAgICdnb29nbGVib3QnLFxuICAgICdnb29nbGV3ZWJsaWdodCcsXG4gICAgJ21lZGlhcGFydG5lcnMtZ29vZ2xlJyxcbiAgICAnc3RvcmVib3QtZ29vZ2xlJ1xuXTtcbl8uaXNCbG9ja2VkVUEgPSBmdW5jdGlvbih1YSkge1xuICAgIHZhciBpO1xuICAgIHVhID0gdWEudG9Mb3dlckNhc2UoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgQkxPQ0tFRF9VQV9TVFJTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh1YS5pbmRleE9mKEJMT0NLRURfVUFfU1RSU1tpXSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PX0gZm9ybWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nPX0gYXJnX3NlcGFyYXRvclxuICovXG5fLkhUVFBCdWlsZFF1ZXJ5ID0gZnVuY3Rpb24oZm9ybWRhdGEsIGFyZ19zZXBhcmF0b3IpIHtcbiAgICB2YXIgdXNlX3ZhbCwgdXNlX2tleSwgdG1wX2FyciA9IFtdO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQoYXJnX3NlcGFyYXRvcikpIHtcbiAgICAgICAgYXJnX3NlcGFyYXRvciA9ICcmJztcbiAgICB9XG5cbiAgICBfLmVhY2goZm9ybWRhdGEsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgIHVzZV92YWwgPSBlbmNvZGVVUklDb21wb25lbnQodmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICB1c2Vfa2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSk7XG4gICAgICAgIHRtcF9hcnJbdG1wX2Fyci5sZW5ndGhdID0gdXNlX2tleSArICc9JyArIHVzZV92YWw7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG1wX2Fyci5qb2luKGFyZ19zZXBhcmF0b3IpO1xufTtcblxuXy5nZXRRdWVyeVBhcmFtID0gZnVuY3Rpb24odXJsLCBwYXJhbSkge1xuICAgIC8vIEV4cGVjdHMgYSByYXcgVVJMXG5cbiAgICBwYXJhbSA9IHBhcmFtLnJlcGxhY2UoL1tbXS9nLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS9nLCAnXFxcXF0nKTtcbiAgICB2YXIgcmVnZXhTID0gJ1tcXFxcPyZdJyArIHBhcmFtICsgJz0oW14mI10qKScsXG4gICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFMpLFxuICAgICAgICByZXN1bHRzID0gcmVnZXguZXhlYyh1cmwpO1xuICAgIGlmIChyZXN1bHRzID09PSBudWxsIHx8IChyZXN1bHRzICYmIHR5cGVvZihyZXN1bHRzWzFdKSAhPT0gJ3N0cmluZycgJiYgcmVzdWx0c1sxXS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0c1sxXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHQpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdTa2lwcGluZyBkZWNvZGluZyBmb3IgbWFsZm9ybWVkIHF1ZXJ5IHBhcmFtOiAnICsgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgIH1cbn07XG5cblxuLy8gXy5jb29raWVcbi8vIE1ldGhvZHMgcGFydGlhbGx5IGJvcnJvd2VkIGZyb20gcXVpcmtzbW9kZS5vcmcvanMvY29va2llcy5odG1sXG5fLmNvb2tpZSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIG5hbWVFUSA9IG5hbWUgKyAnPSc7XG4gICAgICAgIHZhciBjYSA9IGRvY3VtZW50JDEuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gY2FbaV07XG4gICAgICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCwgYy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGNvb2tpZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvb2tpZSA9IF8uSlNPTkRlY29kZShfLmNvb2tpZS5nZXQobmFtZSkpIHx8IHt9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2llO1xuICAgIH0sXG5cbiAgICBzZXRfc2Vjb25kczogZnVuY3Rpb24obmFtZSwgdmFsdWUsIHNlY29uZHMsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgaXNfc2VjdXJlLCBpc19jcm9zc19zaXRlLCBkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIGNkb21haW4gPSAnJyxcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnJyxcbiAgICAgICAgICAgIHNlY3VyZSA9ICcnO1xuXG4gICAgICAgIGlmIChkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNkb21haW4gPSAnOyBkb21haW49JyArIGRvbWFpbl9vdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc19jcm9zc19zdWJkb21haW4pIHtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBleHRyYWN0X2RvbWFpbihkb2N1bWVudCQxLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIGNkb21haW4gPSBkb21haW4gPyAnOyBkb21haW49LicgKyBkb21haW4gOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWNvbmRzKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoc2Vjb25kcyAqIDEwMDApKTtcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvR01UU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfY3Jvc3Nfc2l0ZSkge1xuICAgICAgICAgICAgaXNfc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlY3VyZSA9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19zZWN1cmUpIHtcbiAgICAgICAgICAgIHNlY3VyZSArPSAnOyBzZWN1cmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQkMS5jb29raWUgPSBuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArIGV4cGlyZXMgKyAnOyBwYXRoPS8nICsgY2RvbWFpbiArIHNlY3VyZTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgZGF5cywgaXNfY3Jvc3Nfc3ViZG9tYWluLCBpc19zZWN1cmUsIGlzX2Nyb3NzX3NpdGUsIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICB2YXIgY2RvbWFpbiA9ICcnLCBleHBpcmVzID0gJycsIHNlY3VyZSA9ICcnO1xuXG4gICAgICAgIGlmIChkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNkb21haW4gPSAnOyBkb21haW49JyArIGRvbWFpbl9vdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc19jcm9zc19zdWJkb21haW4pIHtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBleHRyYWN0X2RvbWFpbihkb2N1bWVudCQxLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIGNkb21haW4gPSBkb21haW4gPyAnOyBkb21haW49LicgKyBkb21haW4gOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvR01UU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfY3Jvc3Nfc2l0ZSkge1xuICAgICAgICAgICAgaXNfc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlY3VyZSA9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19zZWN1cmUpIHtcbiAgICAgICAgICAgIHNlY3VyZSArPSAnOyBzZWN1cmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld19jb29raWVfdmFsID0gbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgKyBleHBpcmVzICsgJzsgcGF0aD0vJyArIGNkb21haW4gKyBzZWN1cmU7XG4gICAgICAgIGRvY3VtZW50JDEuY29va2llID0gbmV3X2Nvb2tpZV92YWw7XG4gICAgICAgIHJldHVybiBuZXdfY29va2llX3ZhbDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lLCBpc19jcm9zc19zdWJkb21haW4sIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICBfLmNvb2tpZS5zZXQobmFtZSwgJycsIC0xLCBpc19jcm9zc19zdWJkb21haW4sIGZhbHNlLCBmYWxzZSwgZG9tYWluX292ZXJyaWRlKTtcbiAgICB9XG59O1xuXG52YXIgX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCA9IG51bGw7XG52YXIgbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gZnVuY3Rpb24oc3RvcmFnZSwgZm9yY2VDaGVjaykge1xuICAgIGlmIChfbG9jYWxTdG9yYWdlU3VwcG9ydGVkICE9PSBudWxsICYmICFmb3JjZUNoZWNrKSB7XG4gICAgICAgIHJldHVybiBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIHZhciBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIHN0b3JhZ2UgPSBzdG9yYWdlIHx8IHdpbi5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIHZhciBrZXkgPSAnX19tcGxzc18nICsgY2hlYXBfZ3VpZCg4KSxcbiAgICAgICAgICAgIHZhbCA9ICd4eXonO1xuICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWwpO1xuICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleSkgIT09IHZhbCkge1xuICAgICAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbn07XG5cbi8vIF8ubG9jYWxTdG9yYWdlXG5fLmxvY2FsU3RvcmFnZSA9IHtcbiAgICBpc19zdXBwb3J0ZWQ6IGZ1bmN0aW9uKGZvcmNlX2NoZWNrKSB7XG4gICAgICAgIHZhciBzdXBwb3J0ZWQgPSBsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQobnVsbCwgZm9yY2VfY2hlY2spO1xuICAgICAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdsb2NhbFN0b3JhZ2UgdW5zdXBwb3J0ZWQ7IGZhbGxpbmcgYmFjayB0byBjb29raWUgc3RvcmUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgIH0sXG5cbiAgICBlcnJvcjogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignbG9jYWxTdG9yYWdlIGVycm9yOiAnICsgbXNnKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gd2luLmxvY2FsU3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF8ubG9jYWxTdG9yYWdlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gXy5KU09ORGVjb2RlKF8ubG9jYWxTdG9yYWdlLmdldChuYW1lKSkgfHwge307XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW4ubG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF8ubG9jYWxTdG9yYWdlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW4ubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbl8ucmVnaXN0ZXJfZXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gd3JpdHRlbiBieSBEZWFuIEVkd2FyZHMsIDIwMDVcbiAgICAvLyB3aXRoIGlucHV0IGZyb20gVGlubyBaaWpkZWwgLSBjcmlzcEB4czRhbGwubmxcbiAgICAvLyB3aXRoIGlucHV0IGZyb20gQ2FybCBTdmVycmUgLSBtYWlsQGNhcmxzdmVycmUuY29tXG4gICAgLy8gd2l0aCBpbnB1dCBmcm9tIE1peHBhbmVsXG4gICAgLy8gaHR0cDovL2RlYW4uZWR3YXJkcy5uYW1lL3dlYmxvZy8yMDA1LzEwL2FkZC1ldmVudC9cbiAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xOTMwNDQwXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiguLi4qKX0gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9sZFNjaG9vbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVzZUNhcHR1cmVcbiAgICAgKi9cbiAgICB2YXIgcmVnaXN0ZXJfZXZlbnQgPSBmdW5jdGlvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvbGRTY2hvb2wsIHVzZUNhcHR1cmUpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVnaXN0ZXJfZXZlbnQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIgJiYgIW9sZFNjaG9vbCkge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsICEhdXNlQ2FwdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgb250eXBlID0gJ29uJyArIHR5cGU7XG4gICAgICAgICAgICB2YXIgb2xkX2hhbmRsZXIgPSBlbGVtZW50W29udHlwZV07IC8vIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgIGVsZW1lbnRbb250eXBlXSA9IG1ha2VIYW5kbGVyKGVsZW1lbnQsIGhhbmRsZXIsIG9sZF9oYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlSGFuZGxlcihlbGVtZW50LCBuZXdfaGFuZGxlciwgb2xkX2hhbmRsZXJzKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQgfHwgZml4RXZlbnQod2luLmV2ZW50KTtcblxuICAgICAgICAgICAgLy8gdGhpcyBiYXNpY2FsbHkgaGFwcGVucyBpbiBmaXJlZm94IHdoZW5ldmVyIGFub3RoZXIgc2NyaXB0XG4gICAgICAgICAgICAvLyBvdmVyd3JpdGVzIHRoZSBvbmxvYWQgY2FsbGJhY2sgYW5kIGRvZXNuJ3QgcGFzcyB0aGUgZXZlbnRcbiAgICAgICAgICAgIC8vIG9iamVjdCB0byBwcmV2aW91c2x5IGRlZmluZWQgY2FsbGJhY2tzLiAgQWxsIHRoZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gdGhhdCBkb24ndCBkZWZpbmUgd2luZG93LmV2ZW50IGltcGxlbWVudCBhZGRFdmVudExpc3RlbmVyXG4gICAgICAgICAgICAvLyBzbyB0aGUgZG9tX2xvYWRlZCBoYW5kbGVyIHdpbGwgc3RpbGwgYmUgZmlyZWQgYXMgdXN1YWwuXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJldCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkX3Jlc3VsdCwgbmV3X3Jlc3VsdDtcblxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihvbGRfaGFuZGxlcnMpKSB7XG4gICAgICAgICAgICAgICAgb2xkX3Jlc3VsdCA9IG9sZF9oYW5kbGVycyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdfcmVzdWx0ID0gbmV3X2hhbmRsZXIuY2FsbChlbGVtZW50LCBldmVudCk7XG5cbiAgICAgICAgICAgIGlmICgoZmFsc2UgPT09IG9sZF9yZXN1bHQpIHx8IChmYWxzZSA9PT0gbmV3X3Jlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZml4RXZlbnQucHJldmVudERlZmF1bHQ7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmaXhFdmVudC5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBmaXhFdmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfTtcbiAgICBmaXhFdmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVnaXN0ZXJfZXZlbnQ7XG59KSgpO1xuXG5cbnZhciBUT0tFTl9NQVRDSF9SRUdFWCA9IG5ldyBSZWdFeHAoJ14oXFxcXHcqKVxcXFxbKFxcXFx3KykoWz1+XFxcXHxcXFxcXlxcXFwkXFxcXCpdPyk9P1wiPyhbXlxcXFxdXCJdKilcIj9cXFxcXSQnKTtcblxuXy5kb21fcXVlcnkgPSAoZnVuY3Rpb24oKSB7XG4gICAgLyogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIC0gcmV0dXJucyBhbiBhcnJheSBvZiBlbGVtZW50IG9iamVjdHMgZnJvbSB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgIG1hdGNoaW5nIHRoZSBDU1Mgc2VsZWN0b3IuIFNlbGVjdG9ycyBjYW4gY29udGFpbiBlbGVtZW50IG5hbWVzLFxuICAgIGNsYXNzIG5hbWVzIGFuZCBpZHMgYW5kIGNhbiBiZSBuZXN0ZWQuIEZvciBleGFtcGxlOlxuXG4gICAgZWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5U2VsZWN0b3IoJ2RpdiNtYWluIHAgYS5leHRlcm5hbCcpXG5cbiAgICBXaWxsIHJldHVybiBhbiBhcnJheSBvZiBhbGwgJ2EnIGVsZW1lbnRzIHdpdGggJ2V4dGVybmFsJyBpbiB0aGVpclxuICAgIGNsYXNzIGF0dHJpYnV0ZSB0aGF0IGFyZSBjb250YWluZWQgaW5zaWRlICdwJyBlbGVtZW50cyB0aGF0IGFyZVxuICAgIGNvbnRhaW5lZCBpbnNpZGUgdGhlICdkaXYnIGVsZW1lbnQgd2hpY2ggaGFzIGlkPVwibWFpblwiXG5cbiAgICBOZXcgaW4gdmVyc2lvbiAwLjQ6IFN1cHBvcnQgZm9yIENTUzIgYW5kIENTUzMgYXR0cmlidXRlIHNlbGVjdG9yczpcbiAgICBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblxuICAgIFZlcnNpb24gMC40IC0gU2ltb24gV2lsbGlzb24sIE1hcmNoIDI1dGggMjAwM1xuICAgIC0tIFdvcmtzIGluIFBob2VuaXggMC41LCBNb3ppbGxhIDEuMywgT3BlcmEgNywgSW50ZXJuZXQgRXhwbG9yZXIgNiwgSW50ZXJuZXQgRXhwbG9yZXIgNSBvbiBXaW5kb3dzXG4gICAgLS0gT3BlcmEgNyBmYWlsc1xuXG4gICAgVmVyc2lvbiAwLjUgLSBDYXJsIFN2ZXJyZSwgSmFuIDd0aCAyMDEzXG4gICAgLS0gTm93IHVzZXMgalF1ZXJ5LWVzcXVlIGBoYXNDbGFzc2AgZm9yIHRlc3RpbmcgY2xhc3MgbmFtZVxuICAgIGVxdWFsaXR5LiAgVGhpcyBmaXhlcyBhIGJ1ZyByZWxhdGVkIHRvICctJyBjaGFyYWN0ZXJzIGJlaW5nXG4gICAgY29uc2lkZXJlZCBub3QgcGFydCBvZiBhICd3b3JkJyBpbiByZWdleC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0QWxsQ2hpbGRyZW4oZSkge1xuICAgICAgICAvLyBSZXR1cm5zIGFsbCBjaGlsZHJlbiBvZiBlbGVtZW50LiBXb3JrYXJvdW5kIHJlcXVpcmVkIGZvciBJRTUvV2luZG93cy4gVWdoLlxuICAgICAgICByZXR1cm4gZS5hbGwgPyBlLmFsbCA6IGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICB9XG5cbiAgICB2YXIgYmFkX3doaXRlc3BhY2UgPSAvW1xcdFxcclxcbl0vZztcblxuICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW0sIHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnICcgKyBzZWxlY3RvciArICcgJztcbiAgICAgICAgcmV0dXJuICgoJyAnICsgZWxlbS5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoYmFkX3doaXRlc3BhY2UsICcgJykuaW5kZXhPZihjbGFzc05hbWUpID49IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGZhaWwgZ3JhY2VmdWxseSBpbiBsZXNzZXIgYnJvd3NlcnNcbiAgICAgICAgaWYgKCFkb2N1bWVudCQxLmdldEVsZW1lbnRzQnlUYWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BsaXQgc2VsZWN0b3IgaW4gdG8gdG9rZW5zXG4gICAgICAgIHZhciB0b2tlbnMgPSBzZWxlY3Rvci5zcGxpdCgnICcpO1xuICAgICAgICB2YXIgdG9rZW4sIGJpdHMsIHRhZ05hbWUsIGZvdW5kLCBmb3VuZENvdW50LCBpLCBqLCBrLCBlbGVtZW50cywgY3VycmVudENvbnRleHRJbmRleDtcbiAgICAgICAgdmFyIGN1cnJlbnRDb250ZXh0ID0gW2RvY3VtZW50JDFdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5pbmRleE9mKCcjJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFRva2VuIGlzIGFuIElEIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgYml0cyA9IHRva2VuLnNwbGl0KCcjJyk7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IGJpdHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gYml0c1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50JDEuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudCB8fCAodGFnTmFtZSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gdGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCBub3QgZm91bmQgb3IgdGFnIHdpdGggdGhhdCBJRCBub3QgZm91bmQsIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50Q29udGV4dCB0byBjb250YWluIGp1c3QgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbZWxlbWVudF07XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gY29udGFpbnMgYSBjbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGJpdHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSBiaXRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBiaXRzWzFdO1xuICAgICAgICAgICAgICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lID0gJyonO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHZXQgZWxlbWVudHMgbWF0Y2hpbmcgdGFnLCBmaWx0ZXIgdGhlbSBmb3IgY2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBmb3VuZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyZW50Q29udGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gZ2V0QWxsQ2hpbGRyZW4oY3VycmVudENvbnRleHRbal0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBjdXJyZW50Q29udGV4dFtqXS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kW2ZvdW5kQ291bnQrK10gPSBlbGVtZW50c1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRbal0uY2xhc3NOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmlzU3RyaW5nKGZvdW5kW2pdLmNsYXNzTmFtZSkgJiYgLy8gc29tZSBTVkcgZWxlbWVudHMgaGF2ZSBjbGFzc05hbWVzIHdoaWNoIGFyZSBub3Qgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2xhc3MoZm91bmRbal0sIGNsYXNzTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dFtjdXJyZW50Q29udGV4dEluZGV4KytdID0gZm91bmRbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29kZSB0byBkZWFsIHdpdGggYXR0cmlidXRlIHNlbGVjdG9yc1xuICAgICAgICAgICAgdmFyIHRva2VuX21hdGNoID0gdG9rZW4ubWF0Y2goVE9LRU5fTUFUQ0hfUkVHRVgpO1xuICAgICAgICAgICAgaWYgKHRva2VuX21hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IHRva2VuX21hdGNoWzFdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IHRva2VuX21hdGNoWzJdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyT3BlcmF0b3IgPSB0b2tlbl9tYXRjaFszXTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdG9rZW5fbWF0Y2hbNF07XG4gICAgICAgICAgICAgICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAnKic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdyYWIgYWxsIG9mIHRoZSB0YWdOYW1lIGVsZW1lbnRzIHdpdGhpbiBjdXJyZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICBmb3VuZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyZW50Q29udGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gZ2V0QWxsQ2hpbGRyZW4oY3VycmVudENvbnRleHRbal0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBjdXJyZW50Q29udGV4dFtqXS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kW2ZvdW5kQ291bnQrK10gPSBlbGVtZW50c1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjaGVja0Z1bmN0aW9uOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCB0byBmaWx0ZXIgdGhlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdHRyT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnPSc6IC8vIEVxdWFsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpID09IGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ34nOiAvLyBNYXRjaCBvbmUgb2Ygc3BhY2Ugc2VwZXJhdGVkIHdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLm1hdGNoKG5ldyBSZWdFeHAoJ1xcXFxiJyArIGF0dHJWYWx1ZSArICdcXFxcYicpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3wnOiAvLyBNYXRjaCBzdGFydCB3aXRoIHZhbHVlIGZvbGxvd2VkIGJ5IG9wdGlvbmFsIGh5cGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5tYXRjaChuZXcgUmVnRXhwKCdeJyArIGF0dHJWYWx1ZSArICctPycpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ14nOiAvLyBNYXRjaCBzdGFydHMgd2l0aCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5pbmRleE9mKGF0dHJWYWx1ZSkgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICckJzogLy8gTWF0Y2ggZW5kcyB3aXRoIHZhbHVlIC0gZmFpbHMgd2l0aCBcIldhcm5pbmdcIiBpbiBPcGVyYSA3XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmxhc3RJbmRleE9mKGF0dHJWYWx1ZSkgPT0gZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmxlbmd0aCAtIGF0dHJWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzogLy8gTWF0Y2ggZW5kcyB3aXRoIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmluZGV4T2YoYXR0clZhbHVlKSA+IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgdGVzdCBmb3IgZXhpc3RlbmNlIG9mIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZm91bmQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrRnVuY3Rpb24oZm91bmRbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dFtjdXJyZW50Q29udGV4dEluZGV4KytdID0gZm91bmRbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWxlcnQoJ0F0dHJpYnV0ZSBTZWxlY3RvcjogJyt0YWdOYW1lKycgJythdHRyTmFtZSsnICcrYXR0ck9wZXJhdG9yKycgJythdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRvIG5leHQgdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB0b2tlbiBpcyBKVVNUIGFuIGVsZW1lbnQgKG5vdCBhIGNsYXNzIG9yIElEIHNlbGVjdG9yKVxuICAgICAgICAgICAgdGFnTmFtZSA9IHRva2VuO1xuICAgICAgICAgICAgZm91bmQgPSBbXTtcbiAgICAgICAgICAgIGZvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBjdXJyZW50Q29udGV4dFtqXS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICBpZiAoXy5pc0VsZW1lbnQocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3F1ZXJ5XTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHF1ZXJ5KSAmJiAhXy5pc1VuZGVmaW5lZChxdWVyeS5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RWxlbWVudHNCeVNlbGVjdG9yLmNhbGwodGhpcywgcXVlcnkpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbnZhciBDQU1QQUlHTl9LRVlXT1JEUyA9IFsndXRtX3NvdXJjZScsICd1dG1fbWVkaXVtJywgJ3V0bV9jYW1wYWlnbicsICd1dG1fY29udGVudCcsICd1dG1fdGVybScsICd1dG1faWQnLCAndXRtX3NvdXJjZV9wbGF0Zm9ybScsJ3V0bV9jYW1wYWlnbl9pZCcsICd1dG1fY3JlYXRpdmVfZm9ybWF0JywgJ3V0bV9tYXJrZXRpbmdfdGFjdGljJ107XG52YXIgQ0xJQ0tfSURTID0gWydkY2xpZCcsICdmYmNsaWQnLCAnZ2NsaWQnLCAna29fY2xpY2tfaWQnLCAnbGlfZmF0X2lkJywgJ21zY2xraWQnLCAnc2NjaWQnLCAndHRjbGlkJywgJ3R3Y2xpZCcsICd3YnJhaWQnXTtcblxuXy5pbmZvID0ge1xuICAgIGNhbXBhaWduUGFyYW1zOiBmdW5jdGlvbihkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgIHZhciBrdyA9ICcnLFxuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIF8uZWFjaChDQU1QQUlHTl9LRVlXT1JEUywgZnVuY3Rpb24oa3drZXkpIHtcbiAgICAgICAgICAgIGt3ID0gXy5nZXRRdWVyeVBhcmFtKGRvY3VtZW50JDEuVVJMLCBrd2tleSk7XG4gICAgICAgICAgICBpZiAoa3cubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2t3a2V5XSA9IGt3O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0X3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba3drZXldID0gZGVmYXVsdF92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgY2xpY2tQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaWQgPSAnJyxcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICBfLmVhY2goQ0xJQ0tfSURTLCBmdW5jdGlvbihpZGtleSkge1xuICAgICAgICAgICAgaWQgPSBfLmdldFF1ZXJ5UGFyYW0oZG9jdW1lbnQkMS5VUkwsIGlka2V5KTtcbiAgICAgICAgICAgIGlmIChpZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbaWRrZXldID0gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIG1hcmtldGluZ1BhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZChfLmluZm8uY2FtcGFpZ25QYXJhbXMoKSwgXy5pbmZvLmNsaWNrUGFyYW1zKCkpO1xuICAgIH0sXG5cbiAgICBzZWFyY2hFbmdpbmU6IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgICAgIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKilnb29nbGUuKFteLz9dKiknKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdnb29nbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKWJpbmcuY29tJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnYmluZyc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopeWFob28uY29tJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAneWFob28nO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKWR1Y2tkdWNrZ28uY29tJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnZHVja2R1Y2tnbyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWFyY2hJbmZvOiBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgICAgICB2YXIgc2VhcmNoID0gXy5pbmZvLnNlYXJjaEVuZ2luZShyZWZlcnJlciksXG4gICAgICAgICAgICBwYXJhbSA9IChzZWFyY2ggIT0gJ3lhaG9vJykgPyAncScgOiAncCcsXG4gICAgICAgICAgICByZXQgPSB7fTtcblxuICAgICAgICBpZiAoc2VhcmNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXRbJyRzZWFyY2hfZW5naW5lJ10gPSBzZWFyY2g7XG5cbiAgICAgICAgICAgIHZhciBrZXl3b3JkID0gXy5nZXRRdWVyeVBhcmFtKHJlZmVycmVyLCBwYXJhbSk7XG4gICAgICAgICAgICBpZiAoa2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXRbJ21wX2tleXdvcmQnXSA9IGtleXdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgd2hpY2ggYnJvd3NlciBpcyBydW5uaW5nIHRoaXMgc2NyaXB0LlxuICAgICAqIFRoZSBvcmRlciBvZiB0aGUgY2hlY2tzIGFyZSBpbXBvcnRhbnQgc2luY2UgbWFueSB1c2VyIGFnZW50c1xuICAgICAqIGluY2x1ZGUga2V5IHdvcmRzIHVzZWQgaW4gbGF0ZXIgY2hlY2tzLlxuICAgICAqL1xuICAgIGJyb3dzZXI6IGZ1bmN0aW9uKHVzZXJfYWdlbnQsIHZlbmRvciwgb3BlcmEpIHtcbiAgICAgICAgdmVuZG9yID0gdmVuZG9yIHx8ICcnOyAvLyB2ZW5kb3IgaXMgdW5kZWZpbmVkIGZvciBhdCBsZWFzdCBJRTlcbiAgICAgICAgaWYgKG9wZXJhIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJyBPUFIvJykpIHtcbiAgICAgICAgICAgIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdNaW5pJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ09wZXJhIE1pbmknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdPcGVyYSc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhCbGFja0JlcnJ5fFBsYXlCb29rfEJCMTApL2kudGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdCbGFja0JlcnJ5JztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdJRU1vYmlsZScpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1dQRGVza3RvcCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ludGVybmV0IEV4cGxvcmVyIE1vYmlsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnU2Ftc3VuZ0Jyb3dzZXIvJykpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLnNhbXN1bmcuY29tL2ludGVybmV0L3VzZXItYWdlbnQtc3RyaW5nLWZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuICdTYW1zdW5nIEludGVybmV0JztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdFZGdlJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRWRnLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01pY3Jvc29mdCBFZGdlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdGQklPUycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZhY2Vib29rIE1vYmlsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnQ2hyb21lJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdDcmlPUycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZSBpT1MnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1VDV0VCJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnVUNCcm93c2VyJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnVUMgQnJvd3Nlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRnhpT1MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGaXJlZm94IGlPUyc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh2ZW5kb3IsICdBcHBsZScpKSB7XG4gICAgICAgICAgICBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnTW9iaWxlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ01vYmlsZSBTYWZhcmknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdTYWZhcmknO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0FuZHJvaWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbmRyb2lkIE1vYmlsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnS29ucXVlcm9yJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnS29ucXVlcm9yJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdGaXJlZm94JykpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmlyZWZveCc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnTVNJRScpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1RyaWRlbnQvJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSW50ZXJuZXQgRXhwbG9yZXInO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0dlY2tvJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnTW96aWxsYSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoaWNoIGJyb3dzZXIgdmVyc2lvbiBpcyBydW5uaW5nIHRoaXMgc2NyaXB0LFxuICAgICAqIHBhcnNpbmcgbWFqb3IgYW5kIG1pbm9yIHZlcnNpb24gKGUuZy4sIDQyLjEpLiBVc2VyIGFnZW50IHN0cmluZ3MgZnJvbTpcbiAgICAgKiBodHRwOi8vd3d3LnVzZXJhZ2VudHN0cmluZy5jb20vcGFnZXMvdXNlcmFnZW50c3RyaW5nLnBocFxuICAgICAqL1xuICAgIGJyb3dzZXJWZXJzaW9uOiBmdW5jdGlvbih1c2VyQWdlbnQsIHZlbmRvciwgb3BlcmEpIHtcbiAgICAgICAgdmFyIGJyb3dzZXIgPSBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIHZlbmRvciwgb3BlcmEpO1xuICAgICAgICB2YXIgdmVyc2lvblJlZ2V4cyA9IHtcbiAgICAgICAgICAgICdJbnRlcm5ldCBFeHBsb3JlciBNb2JpbGUnOiAvcnY6KFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnTWljcm9zb2Z0IEVkZ2UnOiAvRWRnZT9cXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdDaHJvbWUnOiAvQ2hyb21lXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQ2hyb21lIGlPUyc6IC9DcmlPU1xcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ1VDIEJyb3dzZXInIDogLyhVQ0Jyb3dzZXJ8VUNXRUIpXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnU2FmYXJpJzogL1ZlcnNpb25cXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdNb2JpbGUgU2FmYXJpJzogL1ZlcnNpb25cXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdPcGVyYSc6IC8oT3BlcmF8T1BSKVxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0ZpcmVmb3gnOiAvRmlyZWZveFxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0ZpcmVmb3ggaU9TJzogL0Z4aU9TXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnS29ucXVlcm9yJzogL0tvbnF1ZXJvcjooXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdCbGFja0JlcnJ5JzogL0JsYWNrQmVycnkgKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQW5kcm9pZCBNb2JpbGUnOiAvYW5kcm9pZFxccyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ1NhbXN1bmcgSW50ZXJuZXQnOiAvU2Ftc3VuZ0Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdJbnRlcm5ldCBFeHBsb3Jlcic6IC8ocnY6fE1TSUUgKShcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ01vemlsbGEnOiAvcnY6KFxcZCsoXFwuXFxkKyk/KS9cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlZ2V4ID0gdmVyc2lvblJlZ2V4c1ticm93c2VyXTtcbiAgICAgICAgaWYgKHJlZ2V4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaGVzID0gdXNlckFnZW50Lm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMl0pO1xuICAgIH0sXG5cbiAgICBvczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gdXNlckFnZW50O1xuICAgICAgICBpZiAoL1dpbmRvd3MvaS50ZXN0KGEpKSB7XG4gICAgICAgICAgICBpZiAoL1Bob25lLy50ZXN0KGEpIHx8IC9XUERlc2t0b3AvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MgUGhvbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdXaW5kb3dzJztcbiAgICAgICAgfSBlbHNlIGlmICgvKGlQaG9uZXxpUGFkfGlQb2QpLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lPUyc7XG4gICAgICAgIH0gZWxzZSBpZiAoL0FuZHJvaWQvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQW5kcm9pZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhCbGFja0JlcnJ5fFBsYXlCb29rfEJCMTApL2kudGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdCbGFja0JlcnJ5JztcbiAgICAgICAgfSBlbHNlIGlmICgvTWFjL2kudGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdNYWMgT1MgWCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL0xpbnV4Ly50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0xpbnV4JztcbiAgICAgICAgfSBlbHNlIGlmICgvQ3JPUy8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUgT1MnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRldmljZTogZnVuY3Rpb24odXNlcl9hZ2VudCkge1xuICAgICAgICBpZiAoL1dpbmRvd3MgUGhvbmUvaS50ZXN0KHVzZXJfYWdlbnQpIHx8IC9XUERlc2t0b3AvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnV2luZG93cyBQaG9uZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoL2lQYWQvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaVBhZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL2lQb2QvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaVBvZCBUb3VjaCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL2lQaG9uZS8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpUGhvbmUnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQmxhY2tCZXJyeSc7XG4gICAgICAgIH0gZWxzZSBpZiAoL0FuZHJvaWQvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQW5kcm9pZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVmZXJyaW5nRG9tYWluOiBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgICAgICB2YXIgc3BsaXQgPSByZWZlcnJlci5zcGxpdCgnLycpO1xuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGxpdFsyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSxcblxuICAgIGN1cnJlbnRVcmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luLmxvY2F0aW9uLmhyZWY7XG4gICAgfSxcblxuICAgIHByb3BlcnRpZXM6IGZ1bmN0aW9uKGV4dHJhX3Byb3BzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXh0cmFfcHJvcHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBleHRyYV9wcm9wcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfLmV4dGVuZChfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAgICAgJyRvcyc6IF8uaW5mby5vcygpLFxuICAgICAgICAgICAgJyRicm93c2VyJzogXy5pbmZvLmJyb3dzZXIodXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSksXG4gICAgICAgICAgICAnJHJlZmVycmVyJzogZG9jdW1lbnQkMS5yZWZlcnJlcixcbiAgICAgICAgICAgICckcmVmZXJyaW5nX2RvbWFpbic6IF8uaW5mby5yZWZlcnJpbmdEb21haW4oZG9jdW1lbnQkMS5yZWZlcnJlciksXG4gICAgICAgICAgICAnJGRldmljZSc6IF8uaW5mby5kZXZpY2UodXNlckFnZW50KVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgJyRjdXJyZW50X3VybCc6IF8uaW5mby5jdXJyZW50VXJsKCksXG4gICAgICAgICAgICAnJGJyb3dzZXJfdmVyc2lvbic6IF8uaW5mby5icm93c2VyVmVyc2lvbih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKSxcbiAgICAgICAgICAgICckc2NyZWVuX2hlaWdodCc6IHNjcmVlbi5oZWlnaHQsXG4gICAgICAgICAgICAnJHNjcmVlbl93aWR0aCc6IHNjcmVlbi53aWR0aCxcbiAgICAgICAgICAgICdtcF9saWInOiAnd2ViJyxcbiAgICAgICAgICAgICckbGliX3ZlcnNpb24nOiBDb25maWcuTElCX1ZFUlNJT04sXG4gICAgICAgICAgICAnJGluc2VydF9pZCc6IGNoZWFwX2d1aWQoKSxcbiAgICAgICAgICAgICd0aW1lJzogXy50aW1lc3RhbXAoKSAvIDEwMDAgLy8gZXBvY2ggdGltZSBpbiBzZWNvbmRzXG4gICAgICAgIH0sIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyhleHRyYV9wcm9wcykpO1xuICAgIH0sXG5cbiAgICBwZW9wbGVfcHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZChfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAgICAgJyRvcyc6IF8uaW5mby5vcygpLFxuICAgICAgICAgICAgJyRicm93c2VyJzogXy5pbmZvLmJyb3dzZXIodXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSlcbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgICckYnJvd3Nlcl92ZXJzaW9uJzogXy5pbmZvLmJyb3dzZXJWZXJzaW9uKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBtcFBhZ2VWaWV3UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAgICAgJ2N1cnJlbnRfcGFnZV90aXRsZSc6IGRvY3VtZW50JDEudGl0bGUsXG4gICAgICAgICAgICAnY3VycmVudF9kb21haW4nOiB3aW4ubG9jYXRpb24uaG9zdG5hbWUsXG4gICAgICAgICAgICAnY3VycmVudF91cmxfcGF0aCc6IHdpbi5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICAgICdjdXJyZW50X3VybF9wcm90b2NvbCc6IHdpbi5sb2NhdGlvbi5wcm90b2NvbCxcbiAgICAgICAgICAgICdjdXJyZW50X3VybF9zZWFyY2gnOiB3aW4ubG9jYXRpb24uc2VhcmNoXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbnZhciBjaGVhcF9ndWlkID0gZnVuY3Rpb24obWF4bGVuKSB7XG4gICAgdmFyIGd1aWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKTtcbiAgICByZXR1cm4gbWF4bGVuID8gZ3VpZC5zdWJzdHJpbmcoMCwgbWF4bGVuKSA6IGd1aWQ7XG59O1xuXG4vLyBuYWl2ZSB3YXkgdG8gZXh0cmFjdCBkb21haW4gbmFtZSAoZXhhbXBsZS5jb20pIGZyb20gZnVsbCBob3N0bmFtZSAobXkuc3ViLmV4YW1wbGUuY29tKVxudmFyIFNJTVBMRV9ET01BSU5fTUFUQ0hfUkVHRVggPSAvW2EtejAtOV1bYS16MC05LV0qXFwuW2Etel0rJC9pO1xuLy8gdGhpcyBuZXh0IG9uZSBhdHRlbXB0cyB0byBhY2NvdW50IGZvciBzb21lIGNjU0xEcywgZS5nLiBleHRyYWN0aW5nIG94Zm9yZC5hYy51ayBmcm9tIHd3dy5veGZvcmQuYWMudWtcbnZhciBET01BSU5fTUFUQ0hfUkVHRVggPSAvW2EtejAtOV1bYS16MC05LV0rXFwuW2Etei5dezIsNn0kL2k7XG4vKipcbiAqIEF0dGVtcHRzIHRvIGV4dHJhY3QgbWFpbiBkb21haW4gbmFtZSBmcm9tIGZ1bGwgaG9zdG5hbWUsIHVzaW5nIGEgZmV3IGJsdW50IGhldXJpc3RpY3MuIEZvclxuICogY29tbW9uIFRMRHMgbGlrZSAuY29tLy5vcmcgdGhhdCBhbHdheXMgaGF2ZSBhIHNpbXBsZSBTTEQuVExEIHN0cnVjdHVyZSAoZXhhbXBsZS5jb20pLCB3ZVxuICogc2ltcGx5IGV4dHJhY3QgdGhlIGxhc3QgdHdvIC4tc2VwYXJhdGVkIHBhcnRzIG9mIHRoZSBob3N0bmFtZSAoU0lNUExFX0RPTUFJTl9NQVRDSF9SRUdFWCkuXG4gKiBGb3Igb3RoZXJzLCB3ZSBhdHRlbXB0IHRvIGFjY291bnQgZm9yIHNob3J0IGNjU0xEK1RMRCBjb21ib3MgKC5hYy51aykgd2l0aCB0aGUgbGVnYWN5XG4gKiBET01BSU5fTUFUQ0hfUkVHRVggKGtlcHQgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBNaXhwYW5lbFxuICogaW50ZWdyYXRpb25zKS4gVGhlIG9ubHkgX3JlbGlhYmxlXyB3YXkgdG8gZXh0cmFjdCBkb21haW4gZnJvbSBob3N0bmFtZSBpcyB3aXRoIGFuIHVwLXRvLWRhdGVcbiAqIGxpc3QgbGlrZSBhdCBodHRwczovL3B1YmxpY3N1ZmZpeC5vcmcvIHNvIGZvciBjYXNlcyB0aGF0IHRoaXMgaGVscGVyIGZhaWxzIGF0LCB0aGUgU0RLXG4gKiBvZmZlcnMgdGhlICdjb29raWVfZG9tYWluJyBjb25maWcgb3B0aW9uIHRvIHNldCBpdCBleHBsaWNpdGx5LlxuICogQGV4YW1wbGVcbiAqIGV4dHJhY3RfZG9tYWluKCdteS5zdWIuZXhhbXBsZS5jb20nKVxuICogLy8gJ2V4YW1wbGUuY29tJ1xuICovXG52YXIgZXh0cmFjdF9kb21haW4gPSBmdW5jdGlvbihob3N0bmFtZSkge1xuICAgIHZhciBkb21haW5fcmVnZXggPSBET01BSU5fTUFUQ0hfUkVHRVg7XG4gICAgdmFyIHBhcnRzID0gaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgdGxkID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRsZC5sZW5ndGggPiA0IHx8IHRsZCA9PT0gJ2NvbScgfHwgdGxkID09PSAnb3JnJykge1xuICAgICAgICBkb21haW5fcmVnZXggPSBTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3RuYW1lLm1hdGNoKGRvbWFpbl9yZWdleCk7XG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogJyc7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBuZXR3b3JrIGNvbm5lY3Rpb24uIGRlZmF1bHQgdG8gdHJ1ZSBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IG5hdmlnYXRvci5vbkxpbmUgKElFKVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciBpc09ubGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbkxpbmUgPSB3aW4ubmF2aWdhdG9yWydvbkxpbmUnXTtcbiAgICByZXR1cm4gXy5pc1VuZGVmaW5lZChvbkxpbmUpIHx8IG9uTGluZTtcbn07XG5cbnZhciBKU09OU3RyaW5naWZ5ID0gbnVsbCwgSlNPTlBhcnNlID0gbnVsbDtcbmlmICh0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBKU09OU3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG4gICAgSlNPTlBhcnNlID0gSlNPTi5wYXJzZTtcbn1cbkpTT05TdHJpbmdpZnkgPSBKU09OU3RyaW5naWZ5IHx8IF8uSlNPTkVuY29kZTtcbkpTT05QYXJzZSA9IEpTT05QYXJzZSB8fCBfLkpTT05EZWNvZGU7XG5cbi8vIEVYUE9SVFMgKGZvciBjbG9zdXJlIGNvbXBpbGVyKVxuX1sndG9BcnJheSddICAgICAgICAgICAgICAgID0gXy50b0FycmF5O1xuX1snaXNPYmplY3QnXSAgICAgICAgICAgICAgID0gXy5pc09iamVjdDtcbl9bJ0pTT05FbmNvZGUnXSAgICAgICAgICAgICA9IF8uSlNPTkVuY29kZTtcbl9bJ0pTT05EZWNvZGUnXSAgICAgICAgICAgICA9IF8uSlNPTkRlY29kZTtcbl9bJ2lzQmxvY2tlZFVBJ10gICAgICAgICAgICA9IF8uaXNCbG9ja2VkVUE7XG5fWydpc0VtcHR5T2JqZWN0J10gICAgICAgICAgPSBfLmlzRW1wdHlPYmplY3Q7XG5fWydpbmZvJ10gICAgICAgICAgICAgICAgICAgPSBfLmluZm87XG5fWydpbmZvJ11bJ2RldmljZSddICAgICAgICAgPSBfLmluZm8uZGV2aWNlO1xuX1snaW5mbyddWydicm93c2VyJ10gICAgICAgID0gXy5pbmZvLmJyb3dzZXI7XG5fWydpbmZvJ11bJ2Jyb3dzZXJWZXJzaW9uJ10gPSBfLmluZm8uYnJvd3NlclZlcnNpb247XG5fWydpbmZvJ11bJ3Byb3BlcnRpZXMnXSAgICAgPSBfLmluZm8ucHJvcGVydGllcztcbl9bJ05QTyddICAgICAgICAgICAgICAgICAgICA9IE5wb1Byb21pc2U7XG5cbi8qKlxuICogR0RQUiB1dGlsc1xuICpcbiAqIFRoZSBHZW5lcmFsIERhdGEgUHJvdGVjdGlvbiBSZWd1bGF0aW9uIChHRFBSKSBpcyBhIHJlZ3VsYXRpb24gaW4gRVUgbGF3IG9uIGRhdGEgcHJvdGVjdGlvblxuICogYW5kIHByaXZhY3kgZm9yIGFsbCBpbmRpdmlkdWFscyB3aXRoaW4gdGhlIEV1cm9wZWFuIFVuaW9uLiBJdCBhZGRyZXNzZXMgdGhlIGV4cG9ydCBvZiBwZXJzb25hbFxuICogZGF0YSBvdXRzaWRlIHRoZSBFVS4gVGhlIEdEUFIgYWltcyBwcmltYXJpbHkgdG8gZ2l2ZSBjb250cm9sIGJhY2sgdG8gY2l0aXplbnMgYW5kIHJlc2lkZW50c1xuICogb3ZlciB0aGVpciBwZXJzb25hbCBkYXRhIGFuZCB0byBzaW1wbGlmeSB0aGUgcmVndWxhdG9yeSBlbnZpcm9ubWVudCBmb3IgaW50ZXJuYXRpb25hbCBidXNpbmVzc1xuICogYnkgdW5pZnlpbmcgdGhlIHJlZ3VsYXRpb24gd2l0aGluIHRoZSBFVS5cbiAqXG4gKiBUaGlzIHNldCBvZiB1dGlsaXRpZXMgaXMgaW50ZW5kZWQgdG8gZW5hYmxlIG9wdCBpbi9vdXQgZnVuY3Rpb25hbGl0eSBpbiB0aGUgTWl4cGFuZWwgSlMgU0RLLlxuICogVGhlc2UgZnVuY3Rpb25zIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIFNESyBhbmQgYXJlIG5vdCBpbnRlbmRlZCB0byBiZSBwdWJsaWNseSBleHBvc2VkLlxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB1c2VkIHRvIHRyYWNrIGEgTWl4cGFuZWwgZXZlbnQgKGUuZy4gTWl4cGFuZWxMaWIudHJhY2spXG4gKiBAY2FsbGJhY2sgdHJhY2tGdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LiBUaGlzIGNhbiBiZSBhbnl0aGluZyB0aGUgdXNlciBkb2VzIC0gJ0J1dHRvbiBDbGljaycsICdTaWduIFVwJywgJ0l0ZW0gUHVyY2hhc2VkJywgZXRjLlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXZlbnQgeW91J3JlIHNlbmRpbmcuIFRoZXNlIGRlc2NyaWJlIHRoZSB1c2VyIHdobyBkaWQgdGhlIGV2ZW50IG9yIGRldGFpbHMgYWJvdXQgdGhlIGV2ZW50IGl0c2VsZi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cblxuLyoqIFB1YmxpYyAqKi9cblxudmFyIEdEUFJfREVGQVVMVF9QRVJTSVNURU5DRV9QUkVGSVggPSAnX19tcF9vcHRfaW5fb3V0Xyc7XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7dHJhY2tGdW5jdGlvbn0gW29wdGlvbnMudHJhY2tdIC0gZnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja0V2ZW50TmFtZV0gLSBldmVudCBuYW1lIHRvIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHJhY2tQcm9wZXJ0aWVzXSAtIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBvcHRJbih0b2tlbiwgb3B0aW9ucykge1xuICAgIF9vcHRJbk91dCh0cnVlLCB0b2tlbiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtb3V0IGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LW91dCBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1vdXQgY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIG9wdE91dCh0b2tlbiwgb3B0aW9ucykge1xuICAgIF9vcHRJbk91dChmYWxzZSwgdG9rZW4sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBoYXNPcHRlZEluKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlVmFsdWUodG9rZW4sIG9wdGlvbnMpID09PSAnMSc7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVEbnRdIC0gZmxhZyB0byBpZ25vcmUgYnJvd3NlciBETlQgc2V0dGluZ3MgYW5kIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGhhc09wdGVkT3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKF9oYXNEb05vdFRyYWNrRmxhZ09uKG9wdGlvbnMpKSB7XG4gICAgICAgIGNvbnNvbGUkMS53YXJuKCdUaGlzIGJyb3dzZXIgaGFzIFwiRG8gTm90IFRyYWNrXCIgZW5hYmxlZC4gVGhpcyB3aWxsIHByZXZlbnQgdGhlIE1peHBhbmVsIFNESyBmcm9tIHNlbmRpbmcgYW55IGRhdGEuIFRvIGlnbm9yZSB0aGUgXCJEbyBOb3QgVHJhY2tcIiBicm93c2VyIHNldHRpbmcsIGluaXRpYWxpemUgdGhlIE1peHBhbmVsIGluc3RhbmNlIHdpdGggdGhlIGNvbmZpZyBcImlnbm9yZV9kbnQ6IHRydWVcIicpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIG9wdGVkT3V0ID0gX2dldFN0b3JhZ2VWYWx1ZSh0b2tlbiwgb3B0aW9ucykgPT09ICcwJztcbiAgICBpZiAob3B0ZWRPdXQpIHtcbiAgICAgICAgY29uc29sZSQxLndhcm4oJ1lvdSBhcmUgb3B0ZWQgb3V0IG9mIE1peHBhbmVsIHRyYWNraW5nLiBUaGlzIHdpbGwgcHJldmVudCB0aGUgTWl4cGFuZWwgU0RLIGZyb20gc2VuZGluZyBhbnkgZGF0YS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGVkT3V0O1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbExpYiBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X2NvbmZpZyhuYW1lKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgTWl4cGFuZWxQZW9wbGUgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKG1ldGhvZCkge1xuICAgIHJldHVybiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbEdyb3VwIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKG1ldGhvZCkge1xuICAgIHJldHVybiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSB1c2VyJ3Mgb3B0IGluL291dCBzdGF0dXMgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBjbGVhck9wdEluT3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgX2dldFN0b3JhZ2Uob3B0aW9ucykucmVtb3ZlKFxuICAgICAgICBfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucyksICEhb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZSwgb3B0aW9ucy5jb29raWVEb21haW5cbiAgICApO1xufVxuXG4vKiogUHJpdmF0ZSAqKi9cblxuLyoqXG4gKiBHZXQgc3RvcmFnZSB1dGlsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXVxuICogQHJldHVybnMge29iamVjdH0gZWl0aGVyIF8uY29va2llIG9yIF8ubG9jYWxzdG9yYWdlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdG9yYWdlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGUgPT09ICdsb2NhbFN0b3JhZ2UnID8gXy5sb2NhbFN0b3JhZ2UgOiBfLmNvb2tpZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGNvb2tpZSB0aGF0IGlzIHVzZWQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZSAodHJhY2tpbmcsIGNvb2tpZSwgZXRjLilcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBjb29raWUgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiAob3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeCB8fCBHRFBSX0RFRkFVTFRfUEVSU0lTVEVOQ0VfUFJFRklYKSArIHRva2VuO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGNvb2tpZSB0aGF0IGlzIHVzZWQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZSAodHJhY2tpbmcsIGNvb2tpZSwgZXRjLilcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB2YWx1ZSBvZiB0aGUgY29va2llIGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gX2dldFN0b3JhZ2VWYWx1ZSh0b2tlbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZ2V0U3RvcmFnZShvcHRpb25zKS5nZXQoX2dldFN0b3JhZ2VLZXkodG9rZW4sIG9wdGlvbnMpKTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBzZXQgdGhlIEROVC9kb05vdFRyYWNrIHNldHRpbmcgdG8gdHJ1ZSBpbiB0aGVpciBicm93c2VyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMud2luZG93XSAtIGFsdGVybmF0ZSB3aW5kb3cgb2JqZWN0IHRvIGNoZWNrOyB1c2VkIHRvIGZvcmNlIHZhcmlvdXMgRE5UIHNldHRpbmdzIGluIGJyb3dzZXIgdGVzdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlRG50XSAtIGZsYWcgdG8gaWdub3JlIGJyb3dzZXIgRE5UIHNldHRpbmdzIGFuZCBhbHdheXMgcmV0dXJuIGZhbHNlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgRE5UIHNldHRpbmcgaXMgdHJ1ZVxuICovXG5mdW5jdGlvbiBfaGFzRG9Ob3RUcmFja0ZsYWdPbihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZ25vcmVEbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgd2luJDEgPSAob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvdykgfHwgd2luO1xuICAgIHZhciBuYXYgPSB3aW4kMVsnbmF2aWdhdG9yJ10gfHwge307XG4gICAgdmFyIGhhc0RudE9uID0gZmFsc2U7XG5cbiAgICBfLmVhY2goW1xuICAgICAgICBuYXZbJ2RvTm90VHJhY2snXSwgLy8gc3RhbmRhcmRcbiAgICAgICAgbmF2Wydtc0RvTm90VHJhY2snXSxcbiAgICAgICAgd2luJDFbJ2RvTm90VHJhY2snXVxuICAgIF0sIGZ1bmN0aW9uKGRudFZhbHVlKSB7XG4gICAgICAgIGlmIChfLmluY2x1ZGVzKFt0cnVlLCAxLCAnMScsICd5ZXMnXSwgZG50VmFsdWUpKSB7XG4gICAgICAgICAgICBoYXNEbnRPbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBoYXNEbnRPbjtcbn1cblxuLyoqXG4gKiBTZXQgY29va2llL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIHVzZXIgaW5kaWNhdGluZyB0aGF0IHRoZXkgYXJlIG9wdGVkIGluIG9yIG91dCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdFZhbHVlIC0gd2hldGhlciB0byBvcHQgdGhlIHVzZXIgaW4gb3Igb3V0IGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7dHJhY2tGdW5jdGlvbn0gW29wdGlvbnMudHJhY2tdIC0gZnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja0V2ZW50TmFtZV0gLSBldmVudCBuYW1lIHRvIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHJhY2tQcm9wZXJ0aWVzXSAtIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZURvbWFpbl0gLSBjdXN0b20gY29va2llIGRvbWFpblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1NpdGVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gX29wdEluT3V0KG9wdFZhbHVlLCB0b2tlbiwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1N0cmluZyh0b2tlbikgfHwgIXRva2VuLmxlbmd0aCkge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ2dkcHIuJyArIChvcHRWYWx1ZSA/ICdvcHRJbicgOiAnb3B0T3V0JykgKyAnIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgdG9rZW4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgX2dldFN0b3JhZ2Uob3B0aW9ucykuc2V0KFxuICAgICAgICBfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucyksXG4gICAgICAgIG9wdFZhbHVlID8gMSA6IDAsXG4gICAgICAgIF8uaXNOdW1iZXIob3B0aW9ucy5jb29raWVFeHBpcmF0aW9uKSA/IG9wdGlvbnMuY29va2llRXhwaXJhdGlvbiA6IG51bGwsXG4gICAgICAgICEhb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZSxcbiAgICAgICAgISFvcHRpb25zLnNlY3VyZUNvb2tpZSxcbiAgICAgICAgISFvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZSxcbiAgICAgICAgb3B0aW9ucy5jb29raWVEb21haW5cbiAgICApO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhY2sgJiYgb3B0VmFsdWUpIHsgLy8gb25seSB0cmFjayBldmVudCBpZiBvcHRpbmcgaW4gKG9wdFZhbHVlPXRydWUpXG4gICAgICAgIG9wdGlvbnMudHJhY2sob3B0aW9ucy50cmFja0V2ZW50TmFtZSB8fCAnJG9wdF9pbicsIG9wdGlvbnMudHJhY2tQcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAnc2VuZF9pbW1lZGlhdGVseSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFdyYXAgYSBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRDb25maWdWYWx1ZSAtIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIE1peHBhbmVsIEFQSSB0b2tlbiBhbmQgb3RoZXIgb3B0aW9ucyB0byBiZSB1c2VkIHdpdGggb3B0LW91dCBjaGVja1xuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBnZXRDb25maWdWYWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGVkT3V0ID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ3Rva2VuJyk7XG4gICAgICAgICAgICB2YXIgaWdub3JlRG50ID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnaWdub3JlX2RudCcpO1xuICAgICAgICAgICAgdmFyIHBlcnNpc3RlbmNlVHlwZSA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZScpO1xuICAgICAgICAgICAgdmFyIHBlcnNpc3RlbmNlUHJlZml4ID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnb3B0X291dF90cmFja2luZ19jb29raWVfcHJlZml4Jyk7XG4gICAgICAgICAgICB2YXIgd2luID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnd2luZG93Jyk7IC8vIHVzZWQgdG8gb3ZlcnJpZGUgd2luZG93IGR1cmluZyBicm93c2VyIHRlc3RzXG5cbiAgICAgICAgICAgIGlmICh0b2tlbikgeyAvLyBpZiB0aGVyZSB3YXMgYW4gaXNzdWUgZ2V0dGluZyB0aGUgdG9rZW4sIGNvbnRpbnVlIG1ldGhvZCBleGVjdXRpb24gYXMgbm9ybWFsXG4gICAgICAgICAgICAgICAgb3B0ZWRPdXQgPSBoYXNPcHRlZE91dCh0b2tlbiwge1xuICAgICAgICAgICAgICAgICAgICBpZ25vcmVEbnQ6IGlnbm9yZURudCxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVuY2VUeXBlOiBwZXJzaXN0ZW5jZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlbmNlUHJlZml4OiBwZXJzaXN0ZW5jZVByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93OiB3aW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignVW5leHBlY3RlZCBlcnJvciB3aGVuIGNoZWNraW5nIHRyYWNraW5nIG9wdC1vdXQgc3RhdHVzOiAnICsgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0ZWRPdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufVxuXG52YXIgbG9nZ2VyJDQgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdsb2NrJyk7XG5cbi8qKlxuICogU2hhcmVkTG9jazogYSBtdXRleCBidWlsdCBvbiBIVE1MNSBsb2NhbFN0b3JhZ2UsIHRvIGVuc3VyZSB0aGF0IG9ubHkgb25lIGJyb3dzZXJcbiAqIHdpbmRvdy90YWIgYXQgYSB0aW1lIHdpbGwgYmUgYWJsZSB0byBhY2Nlc3Mgc2hhcmVkIHJlc291cmNlcy5cbiAqXG4gKiBCYXNlZCBvbiB0aGUgQWx1ciBhbmQgVGF1YmVuZmVsZCBmYXN0IGxvY2tcbiAqIChodHRwOi8vd3d3LmNzLnJvY2hlc3Rlci5lZHUvcmVzZWFyY2gvc3luY2hyb25pemF0aW9uL3BzZXVkb2NvZGUvZmFzdGxvY2suaHRtbClcbiAqIHdpdGggYW4gYWRkZWQgdGltZW91dCB0byBlbnN1cmUgdGhlcmUgd2lsbCBiZSBldmVudHVhbCBwcm9ncmVzcyBpbiB0aGUgZXZlbnRcbiAqIHRoYXQgYSB3aW5kb3cgaXMgY2xvc2VkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNhbGxiYWNrLlxuICpcbiAqIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCB2ZXJzaW9uIGJ5IERhdmlkIFdvbGV2ZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS93b2xldmVyKVxuICogYXQgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vd29sZXZlci81ZmQ3NTczZDFlZjYxNjZlOGY4YzRhZjI4NmE2OTQzMi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbXlMb2NrID0gbmV3IFNoYXJlZExvY2soJ3NvbWUta2V5Jyk7XG4gKiBteUxvY2sud2l0aExvY2soZnVuY3Rpb24oKSB7XG4gKiAgIGNvbnNvbGUubG9nKCdJIGhvbGQgdGhlIG11dGV4IScpO1xuICogfSk7XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTaGFyZWRMb2NrID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBrZXk7XG4gICAgdGhpcy5zdG9yYWdlID0gb3B0aW9ucy5zdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgdGhpcy5wb2xsSW50ZXJ2YWxNUyA9IG9wdGlvbnMucG9sbEludGVydmFsTVMgfHwgMTAwO1xuICAgIHRoaXMudGltZW91dE1TID0gb3B0aW9ucy50aW1lb3V0TVMgfHwgMjAwMDtcblxuICAgIC8vIGRlcGVuZGVuY3ktaW5qZWN0IHByb21pc2UgaW1wbGVtZW50YXRpb24gZm9yIHRlc3RpbmcgcHVycG9zZXNcbiAgICB0aGlzLnByb21pc2VJbXBsID0gb3B0aW9ucy5wcm9taXNlSW1wbCB8fCBQcm9taXNlUG9seWZpbGw7XG59O1xuXG4vLyBwYXNzIGluIGEgc3BlY2lmaWMgcGlkIHRvIHRlc3QgY29udGVudGlvbiBzY2VuYXJpb3M7IG90aGVyd2lzZVxuLy8gaXQgaXMgY2hvc2VuIHJhbmRvbWx5IGZvciBlYWNoIGFjcXVpc2l0aW9uIGF0dGVtcHRcblNoYXJlZExvY2sucHJvdG90eXBlLndpdGhMb2NrID0gZnVuY3Rpb24obG9ja2VkQ0IsIHBpZCkge1xuICAgIHZhciBQcm9taXNlID0gdGhpcy5wcm9taXNlSW1wbDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGkgPSBwaWQgfHwgKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgJ3wnICsgTWF0aC5yYW5kb20oKSk7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICB2YXIga2V5ID0gdGhpcy5zdG9yYWdlS2V5O1xuICAgICAgICB2YXIgcG9sbEludGVydmFsTVMgPSB0aGlzLnBvbGxJbnRlcnZhbE1TO1xuICAgICAgICB2YXIgdGltZW91dE1TID0gdGhpcy50aW1lb3V0TVM7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5zdG9yYWdlO1xuXG4gICAgICAgIHZhciBrZXlYID0ga2V5ICsgJzpYJztcbiAgICAgICAgdmFyIGtleVkgPSBrZXkgKyAnOlknO1xuICAgICAgICB2YXIga2V5WiA9IGtleSArICc6Wic7XG5cbiAgICAgICAgdmFyIGRlbGF5ID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSA+IHRpbWVvdXRNUykge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQ0LmVycm9yKCdUaW1lb3V0IHdhaXRpbmcgZm9yIG11dGV4IG9uICcgKyBrZXkgKyAnOyBjbGVhcmluZyBsb2NrLiBbJyArIGkgKyAnXScpO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlaKTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5WSk7XG4gICAgICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBwb2xsSW50ZXJ2YWxNUyAqIChNYXRoLnJhbmRvbSgpICsgMC4xKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHdhaXRGb3IgPSBmdW5jdGlvbihwcmVkaWNhdGUsIGNiKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKCkpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxheShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvcihwcmVkaWNhdGUsIGNiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0U2V0WSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZhbFkgPSBzdG9yYWdlLmdldEl0ZW0oa2V5WSk7XG4gICAgICAgICAgICBpZiAodmFsWSAmJiB2YWxZICE9PSBpKSB7IC8vIGlmIFkgPT0gaSB0aGVuIHRoaXMgcHJvY2VzcyBhbHJlYWR5IGhhcyB0aGUgbG9jayAodXNlZnVsIGZvciB0ZXN0IGNhc2VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleVksIGkpO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WSkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQoc3RvcmFnZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2xvY2FsU3RvcmFnZSBzdXBwb3J0IGRyb3BwZWQgd2hpbGUgYWNxdWlyaW5nIGxvY2snKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleVgsIGkpO1xuXG4gICAgICAgICAgICB3YWl0Rm9yKGdldFNldFksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WCkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JpdGljYWxTZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxheShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdhaXRGb3IoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXN0b3JhZ2UuZ2V0SXRlbShrZXlaKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgY3JpdGljYWxTZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjcml0aWNhbFNlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlaLCAnMScpO1xuICAgICAgICAgICAgdmFyIHJlbW92ZUxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WSkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVgpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlYKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsb2NrZWRDQigpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJldCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmV0KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQoc3RvcmFnZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbG9jYWxTdG9yYWdlIHN1cHBvcnQgY2hlY2sgZmFpbGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi93cmFwcGVyJykuU3RvcmFnZVdyYXBwZXJ9XG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7U3RvcmFnZVdyYXBwZXJ9XG4gKi9cbnZhciBMb2NhbFN0b3JhZ2VXcmFwcGVyID0gZnVuY3Rpb24gKHN0b3JhZ2VPdmVycmlkZSkge1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2VPdmVycmlkZSB8fCBsb2NhbFN0b3JhZ2U7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuc2V0SXRlbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgfSwgdGhpcykpO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICB9LCB0aGlzKSk7XG59O1xuXG52YXIgbG9nZ2VyJDMgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdiYXRjaCcpO1xuXG4vKipcbiAqIFJlcXVlc3RRdWV1ZTogcXVldWUgZm9yIGJhdGNoaW5nIEFQSSByZXF1ZXN0cyB3aXRoIGxvY2FsU3RvcmFnZSBiYWNrdXAgZm9yIHJldHJpZXMuXG4gKiBNYWludGFpbnMgYW4gaW4tbWVtb3J5IHF1ZXVlIHdoaWNoIHJlcHJlc2VudHMgdGhlIHNvdXJjZSBvZiB0cnV0aCBmb3IgdGhlIGN1cnJlbnRcbiAqIHBhZ2UsIGJ1dCBhbHNvIHdyaXRlcyBhbGwgaXRlbXMgb3V0IHRvIGEgY29weSBpbiB0aGUgYnJvd3NlcidzIGxvY2FsU3RvcmFnZSwgd2hpY2hcbiAqIGNhbiBiZSByZWFkIG9uIHN1YnNlcXVlbnQgcGFnZWxvYWRzIGFuZCByZXRyaWVkLiBGb3IgYmF0Y2hhYmlsaXR5LCBhbGwgdGhlIHJlcXVlc3RcbiAqIGl0ZW1zIGluIHRoZSBxdWV1ZSBzaG91bGQgYmUgb2YgdGhlIHNhbWUgdHlwZSAoZXZlbnRzLCBwZW9wbGUgdXBkYXRlcywgZ3JvdXAgdXBkYXRlcylcbiAqIHNvIHRoZXkgY2FuIGJlIHNlbnQgaW4gYSBzaW5nbGUgcmVxdWVzdCB0byB0aGUgc2FtZSBBUEkgZW5kcG9pbnQuXG4gKlxuICogTG9jYWxTdG9yYWdlIGtleWluZyBhbmQgbG9ja2luZzogSW4gb3JkZXIgZm9yIHJlbG9hZHMgYW5kIHN1YnNlcXVlbnQgcGFnZWxvYWRzIG9mXG4gKiB0aGUgc2FtZSBzaXRlIHRvIGFjY2VzcyB0aGUgc2FtZSBwZXJzaXN0ZWQgZGF0YSwgdGhleSBtdXN0IHNoYXJlIHRoZSBzYW1lIGxvY2FsU3RvcmFnZVxuICoga2V5IChmb3IgaW5zdGFuY2UgYmFzZWQgb24gcHJvamVjdCB0b2tlbiBhbmQgcXVldWUgdHlwZSkuIFRoZXJlZm9yZSBhY2Nlc3MgdG8gdGhlXG4gKiBsb2NhbFN0b3JhZ2UgZW50cnkgaXMgZ3VhcmRlZCBieSBhbiBhc3luY2hyb25vdXMgbXV0ZXggKFNoYXJlZExvY2spIHRvIHByZXZlbnRcbiAqIHNpbXVsdGFuZW91c2x5IG9wZW4gd2luZG93cy90YWJzIGZyb20gb3ZlcndyaXRpbmcgZWFjaCBvdGhlcidzIGRhdGEgKHdoaWNoIHdvdWxkIGxlYWRcbiAqIHRvIGRhdGEgbG9zcyBpbiBzb21lIHNpdHVhdGlvbnMpLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSZXF1ZXN0UXVldWUgPSBmdW5jdGlvbiAoc3RvcmFnZUtleSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuc3RvcmFnZUtleSA9IHN0b3JhZ2VLZXk7XG4gICAgdGhpcy51c2VQZXJzaXN0ZW5jZSA9IG9wdGlvbnMudXNlUGVyc2lzdGVuY2U7XG4gICAgaWYgKHRoaXMudXNlUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVN0b3JhZ2UgPSBvcHRpb25zLnF1ZXVlU3RvcmFnZSB8fCBuZXcgTG9jYWxTdG9yYWdlV3JhcHBlcigpO1xuICAgICAgICB0aGlzLmxvY2sgPSBuZXcgU2hhcmVkTG9jayhzdG9yYWdlS2V5LCB7IHN0b3JhZ2U6IG9wdGlvbnMuc2hhcmVkTG9ja1N0b3JhZ2UgfHwgd2luZG93LmxvY2FsU3RvcmFnZSB9KTtcbiAgICAgICAgdGhpcy5xdWV1ZVN0b3JhZ2UuaW5pdCgpO1xuICAgIH1cbiAgICB0aGlzLnJlcG9ydEVycm9yID0gb3B0aW9ucy5lcnJvclJlcG9ydGVyIHx8IF8uYmluZChsb2dnZXIkMy5lcnJvciwgbG9nZ2VyJDMpO1xuXG4gICAgdGhpcy5waWQgPSBvcHRpb25zLnBpZCB8fCBudWxsOyAvLyBwYXNzIHBpZCB0byB0ZXN0IG91dCBzdG9yYWdlIGxvY2sgY29udGVudGlvbiBzY2VuYXJpb3NcblxuICAgIHRoaXMubWVtUXVldWUgPSBbXTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG59O1xuXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmVuc3VyZUluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlXG4gICAgICAgIC5pbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgcXVldWUgcGVyc2lzdGVuY2UuIERpc2FibGluZyBwZXJzaXN0ZW5jZScsIGVycik7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudXNlUGVyc2lzdGVuY2UgPSBmYWxzZTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBBZGQgb25lIGl0ZW0gdG8gcXVldWVzIChtZW1vcnkgYW5kIGxvY2FsU3RvcmFnZSkuIFRoZSBxdWV1ZWQgZW50cnkgaW5jbHVkZXNcbiAqIHRoZSBnaXZlbiBpdGVtIGFsb25nIHdpdGggYW4gYXV0by1nZW5lcmF0ZWQgSUQgYW5kIGEgXCJmbHVzaC1hZnRlclwiIHRpbWVzdGFtcC5cbiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIGl0ZW0gd2lsbCBiZSBzZW50IG92ZXIgdGhlIG5ldHdvcmsgYW5kIGRlcXVldWVkXG4gKiBiZWZvcmUgdGhlIGZsdXNoLWFmdGVyIHRpbWU7IGlmIHRoaXMgZG9lc24ndCBoYXBwZW4gaXQgaXMgY29uc2lkZXJlZCBvcnBoYW5lZFxuICogKGUuZy4sIHRoZSBvcmlnaW5hbCB0YWIgd2hlcmUgaXQgd2FzIGVucXVldWVkIGdvdCBjbG9zZWQgYmVmb3JlIGl0IGNvdWxkIGJlXG4gKiBzZW50KSBhbmQgdGhlIGl0ZW0gY2FuIGJlIHNlbnQgYnkgYW55IHRhYiB0aGF0IGZpbmRzIGl0IGluIGxvY2FsU3RvcmFnZS5cbiAqXG4gKiBUaGUgZmluYWwgY2FsbGJhY2sgcGFyYW0gaXMgY2FsbGVkIHdpdGggYSBwYXJhbSBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3JcbiAqIGZhaWx1cmUgb2YgdGhlIGVucXVldWUgb3BlcmF0aW9uOyBpdCBpcyBhc3luY2hyb25vdXMgYmVjYXVzZSB0aGUgbG9jYWxTdG9yYWdlXG4gKiBsb2NrIGlzIGFzeW5jaHJvbm91cy5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0sIGZsdXNoSW50ZXJ2YWwpIHtcbiAgICB2YXIgcXVldWVFbnRyeSA9IHtcbiAgICAgICAgJ2lkJzogY2hlYXBfZ3VpZCgpLFxuICAgICAgICAnZmx1c2hBZnRlcic6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgZmx1c2hJbnRlcnZhbCAqIDIsXG4gICAgICAgICdwYXlsb2FkJzogaXRlbVxuICAgIH07XG5cbiAgICBpZiAoIXRoaXMudXNlUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgdGhpcy5tZW1RdWV1ZS5wdXNoKHF1ZXVlRW50cnkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgZW5xdWV1ZUl0ZW0gPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZWRRdWV1ZS5wdXNoKHF1ZXVlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlVG9TdG9yYWdlKHN0b3JlZFF1ZXVlKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGFkZCB0byBpbi1tZW1vcnkgcXVldWUgd2hlbiBzdG9yYWdlIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVtUXVldWUucHVzaChxdWV1ZUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VlZGVkO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBlbnF1ZXVlaW5nIGl0ZW0nLCBlcnIsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgICAgICAud2l0aExvY2soZW5xdWV1ZUl0ZW0sIHRoaXMucGlkKVxuICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgYWNxdWlyaW5nIHN0b3JhZ2UgbG9jaycsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBvdXQgdGhlIGdpdmVuIG51bWJlciBvZiBxdWV1ZSBlbnRyaWVzLiBJZiB0aGlzLm1lbVF1ZXVlXG4gKiBoYXMgZmV3ZXIgdGhhbiBiYXRjaFNpemUgaXRlbXMsIHRoZW4gbG9vayBmb3IgXCJvcnBoYW5lZFwiIGl0ZW1zXG4gKiBpbiB0aGUgcGVyc2lzdGVkIHF1ZXVlIChpdGVtcyB3aGVyZSB0aGUgJ2ZsdXNoQWZ0ZXInIHRpbWUgaGFzXG4gKiBhbHJlYWR5IHBhc3NlZCkuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZmlsbEJhdGNoID0gZnVuY3Rpb24gKGJhdGNoU2l6ZSkge1xuICAgIHZhciBiYXRjaCA9IHRoaXMubWVtUXVldWUuc2xpY2UoMCwgYmF0Y2hTaXplKTtcbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSAmJiBiYXRjaC5sZW5ndGggPCBiYXRjaFNpemUpIHtcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCBsb2NrIGp1c3QgdG8gcmVhZCBldmVudHM7IGxvY2FsU3RvcmFnZSBpcyB0aHJlYWQtc2FmZVxuICAgICAgICAvLyBhbmQgdGhlIHdvcnN0IHRoYXQgY291bGQgaGFwcGVuIGlzIGEgZHVwbGljYXRlIHNlbmQgb2Ygc29tZVxuICAgICAgICAvLyBvcnBoYW5lZCBldmVudHMsIHdoaWNoIHdpbGwgYmUgZGVkdXBsaWNhdGVkIG9uIHRoZSBzZXJ2ZXIgc2lkZVxuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gaXRlbSBJRHMgYWxyZWFkeSBpbiBiYXRjaDsgZG9uJ3QgZHVwbGljYXRlIG91dCBvZiBzdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHNJbkJhdGNoID0ge307IC8vIHBvb3IgbWFuJ3MgU2V0XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChiYXRjaCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkc0luQmF0Y2hbaXRlbVsnaWQnXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JlZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHN0b3JlZFF1ZXVlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpID4gaXRlbVsnZmx1c2hBZnRlciddICYmICFpZHNJbkJhdGNoW2l0ZW1bJ2lkJ11dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcnBoYW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2gucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID49IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2g7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKGJhdGNoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBpdGVtcyB3aXRoIG1hdGNoaW5nICdpZCcgZnJvbSBhcnJheSAoaW1tdXRhYmx5KVxuICogYWxzbyByZW1vdmUgYW55IGl0ZW0gd2l0aG91dCBhIHZhbGlkIGlkIChlLmcuLCBtYWxmb3JtZWRcbiAqIHN0b3JhZ2UgZW50cmllcykuXG4gKi9cbnZhciBmaWx0ZXJPdXRJRHNBbmRJbnZhbGlkID0gZnVuY3Rpb24gKGl0ZW1zLCBpZFNldCkge1xuICAgIHZhciBmaWx0ZXJlZEl0ZW1zID0gW107XG4gICAgXy5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbVsnaWQnXSAmJiAhaWRTZXRbaXRlbVsnaWQnXV0pIHtcbiAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZEl0ZW1zO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaXRlbXMgd2l0aCBtYXRjaGluZyBJRHMgZnJvbSBib3RoIGluLW1lbW9yeSBxdWV1ZVxuICogYW5kIHBlcnNpc3RlZCBxdWV1ZVxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnJlbW92ZUl0ZW1zQnlJRCA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB2YXIgaWRTZXQgPSB7fTsgLy8gcG9vciBtYW4ncyBTZXRcbiAgICBfLmVhY2goaWRzLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWRTZXRbaWRdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHRoaXMubWVtUXVldWUgPSBmaWx0ZXJPdXRJRHNBbmRJbnZhbGlkKHRoaXMubWVtUXVldWUsIGlkU2V0KTtcbiAgICBpZiAoIXRoaXMudXNlUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZW1vdmVGcm9tU3RvcmFnZSA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZFF1ZXVlID0gZmlsdGVyT3V0SURzQW5kSW52YWxpZChzdG9yZWRRdWV1ZSwgaWRTZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlVG9TdG9yYWdlKHN0b3JlZFF1ZXVlKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGV4dHJhIGNoZWNrOiBkaWQgc3RvcmFnZSByZXBvcnQgc3VjY2VzcyBidXQgc29tZWhvd1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaXRlbXMgYXJlIHN0aWxsIHRoZXJlP1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JlZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHN0b3JlZFF1ZXVlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1bJ2lkJ10gJiYgISFpZFNldFtpdGVtWydpZCddXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSXRlbSBub3QgcmVtb3ZlZCBmcm9tIHN0b3JhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgcmVtb3ZpbmcgaXRlbXMnLCBlcnIsIGlkcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2tcbiAgICAgICAgICAgIC53aXRoTG9jayhyZW1vdmVGcm9tU3RvcmFnZSwgdGhpcy5waWQpXG4gICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBhY3F1aXJpbmcgc3RvcmFnZSBsb2NrJywgZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxvY2FsU3RvcmFnZVN1cHBvcnRlZCh0aGlzLnF1ZXVlU3RvcmFnZS5zdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb29rcyBsaWtlIGxvY2FsU3RvcmFnZSB3cml0ZXMgaGF2ZSBzdG9wcGVkIHdvcmtpbmcgc29tZXRpbWUgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gKHByb2JhYmx5IGZ1bGwpLCBhbmQgc28gbm9ib2R5IGNhbiBhY3F1aXJlIGxvY2tzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFueW1vcmUuIENvbnNpZGVyIGl0IHRlbXBvcmFyaWx5IHNhZmUgdG8gcmVtb3ZlIGl0ZW1zIHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvY2ssIHNpbmNlIG5vYm9keSdzIHdyaXRpbmcgc3VjY2Vzc2Z1bGx5IGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZyb21TdG9yYWdlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPSywgd2UgY291bGRuJ3QgZXZlbiB3cml0ZSBvdXQgdGhlIHNtYWxsZXIgcXVldWUuIFRyeSBjbGVhcmluZyBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGNsZWFyaW5nIHF1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9XG59O1xuXG4vLyBpbnRlcm5hbCBoZWxwZXIgZm9yIFJlcXVlc3RRdWV1ZS51cGRhdGVQYXlsb2Fkc1xudmFyIHVwZGF0ZVBheWxvYWRzID0gZnVuY3Rpb24gKGV4aXN0aW5nSXRlbXMsIGl0ZW1zVG9VcGRhdGUpIHtcbiAgICB2YXIgbmV3SXRlbXMgPSBbXTtcbiAgICBfLmVhY2goZXhpc3RpbmdJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkID0gaXRlbVsnaWQnXTtcbiAgICAgICAgaWYgKGlkIGluIGl0ZW1zVG9VcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXlsb2FkID0gaXRlbXNUb1VwZGF0ZVtpZF07XG4gICAgICAgICAgICBpZiAobmV3UGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZW1bJ3BheWxvYWQnXSA9IG5ld1BheWxvYWQ7XG4gICAgICAgICAgICAgICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIHVwZGF0ZVxuICAgICAgICAgICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXdJdGVtcztcbn07XG5cbi8qKlxuICogVXBkYXRlIHBheWxvYWRzIG9mIGdpdmVuIGl0ZW1zIGluIGJvdGggaW4tbWVtb3J5IHF1ZXVlIGFuZFxuICogcGVyc2lzdGVkIHF1ZXVlLiBJdGVtcyBzZXQgdG8gbnVsbCBhcmUgcmVtb3ZlZCBmcm9tIHF1ZXVlcy5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS51cGRhdGVQYXlsb2FkcyA9IGZ1bmN0aW9uIChpdGVtc1RvVXBkYXRlKSB7XG4gICAgdGhpcy5tZW1RdWV1ZSA9IHVwZGF0ZVBheWxvYWRzKHRoaXMubWVtUXVldWUsIGl0ZW1zVG9VcGRhdGUpO1xuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAgICAgLndpdGhMb2NrKF8uYmluZChmdW5jdGlvbiBsb2NrQWNxdWlyZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFF1ZXVlID0gdXBkYXRlUGF5bG9hZHMoc3RvcmVkUXVldWUsIGl0ZW1zVG9VcGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRvU3RvcmFnZShzdG9yZWRRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGl0ZW1zJywgaXRlbXNUb1VwZGF0ZSwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgfSwgdGhpcyksIHRoaXMucGlkKVxuICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgYWNxdWlyaW5nIHN0b3JhZ2UgbG9jaycsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBhbmQgcGFyc2UgaXRlbXMgYXJyYXkgZnJvbSBsb2NhbFN0b3JhZ2UgZW50cnksIGhhbmRsaW5nXG4gKiBtYWxmb3JtZWQvbWlzc2luZyBkYXRhIGlmIG5lY2Vzc2FyeS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5yZWFkRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yYWdlRW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlRW50cnkpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlRW50cnkgPSBKU09OUGFyc2Uoc3RvcmFnZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNBcnJheShzdG9yYWdlRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0ludmFsaWQgc3RvcmFnZSBlbnRyeTonLCBzdG9yYWdlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlRW50cnkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlRW50cnkgfHwgW107XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gaXRlbXMgYXJyYXkgdG8gbG9jYWxTdG9yYWdlLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnNhdmVUb1N0b3JhZ2UgPSBmdW5jdGlvbiAocXVldWUpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgc2VyaWFsaXplZCA9IEpTT05TdHJpbmdpZnkocXVldWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBzZXJpYWxpemluZyBxdWV1ZScsIGVycik7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIHNlcmlhbGl6ZWQpO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3Igc2F2aW5nIHF1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBDbGVhciBvdXQgcXVldWVzIChtZW1vcnkgYW5kIGxvY2FsU3RvcmFnZSkuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tZW1RdWV1ZSA9IFtdO1xuXG4gICAgaWYgKHRoaXMudXNlUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxufTtcblxuLy8gbWF4aW11bSBpbnRlcnZhbCBiZXR3ZWVuIHJlcXVlc3QgcmV0cmllcyBhZnRlciBleHBvbmVudGlhbCBiYWNrb2ZmXG52YXIgTUFYX1JFVFJZX0lOVEVSVkFMX01TID0gMTAgKiA2MCAqIDEwMDA7IC8vIDEwIG1pbnV0ZXNcblxudmFyIGxvZ2dlciQyID0gY29uc29sZV93aXRoX3ByZWZpeCgnYmF0Y2gnKTtcblxuLyoqXG4gKiBSZXF1ZXN0QmF0Y2hlcjogbWFuYWdlcyB0aGUgcXVldWVpbmcsIGZsdXNoaW5nLCByZXRyeSBldGMgb2YgcmVxdWVzdHMgb2Ygb25lXG4gKiB0eXBlIChldmVudHMsIHBlb3BsZSwgZ3JvdXBzKS5cbiAqIFVzZXMgUmVxdWVzdFF1ZXVlIHRvIG1hbmFnZSB0aGUgYmFja2luZyBzdG9yZS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUmVxdWVzdEJhdGNoZXIgPSBmdW5jdGlvbihzdG9yYWdlS2V5LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lcnJvclJlcG9ydGVyID0gb3B0aW9ucy5lcnJvclJlcG9ydGVyO1xuICAgIHRoaXMucXVldWUgPSBuZXcgUmVxdWVzdFF1ZXVlKHN0b3JhZ2VLZXksIHtcbiAgICAgICAgZXJyb3JSZXBvcnRlcjogXy5iaW5kKHRoaXMucmVwb3J0RXJyb3IsIHRoaXMpLFxuICAgICAgICBxdWV1ZVN0b3JhZ2U6IG9wdGlvbnMucXVldWVTdG9yYWdlLFxuICAgICAgICBzaGFyZWRMb2NrU3RvcmFnZTogb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSxcbiAgICAgICAgdXNlUGVyc2lzdGVuY2U6IG9wdGlvbnMudXNlUGVyc2lzdGVuY2VcbiAgICB9KTtcblxuICAgIHRoaXMubGliQ29uZmlnID0gb3B0aW9ucy5saWJDb25maWc7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCA9IG9wdGlvbnMuc2VuZFJlcXVlc3RGdW5jO1xuICAgIHRoaXMuYmVmb3JlU2VuZEhvb2sgPSBvcHRpb25zLmJlZm9yZVNlbmRIb29rO1xuICAgIHRoaXMuc3RvcEFsbEJhdGNoaW5nID0gb3B0aW9ucy5zdG9wQWxsQmF0Y2hpbmdGdW5jO1xuXG4gICAgLy8gc2VlZCB2YXJpYWJsZSBiYXRjaCBzaXplICsgZmx1c2ggaW50ZXJ2YWwgd2l0aCBjb25maWd1cmVkIHZhbHVlc1xuICAgIHRoaXMuYmF0Y2hTaXplID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX3NpemUnXTtcbiAgICB0aGlzLmZsdXNoSW50ZXJ2YWwgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnXTtcblxuICAgIHRoaXMuc3RvcHBlZCA9ICF0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfYXV0b3N0YXJ0J107XG4gICAgdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA9IDA7XG5cbiAgICAvLyBleHRyYSBjbGllbnQtc2lkZSBkZWR1cGVcbiAgICB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5ID0ge307XG5cbiAgICAvLyBNYWtlIHRoZSBmbHVzaCBvY2N1ciBhdCB0aGUgaW50ZXJ2YWwgc3BlY2lmaWVkIGJ5IGZsdXNoSW50ZXJ2YWxNcywgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGF0dGVtcHQgY29uc2VjdXRpdmUgZmx1c2hlc1xuICAgIC8vIGFzIGxvbmcgYXMgdGhlIHF1ZXVlIGlzIG5vdCBlbXB0eS4gVGhpcyBpcyB1c2VmdWwgZm9yIGhpZ2gtZnJlcXVlbmN5IGV2ZW50cyBsaWtlIFNlc3Npb24gUmVwbGF5IHdoZXJlIHdlIG1pZ2h0IGVuZCB1cFxuICAgIC8vIGluIGEgcmVxdWVzdCBsb29wIGFuZCBnZXQgcmF0ZWxpbWl0ZWQgYnkgdGhlIHNlcnZlci5cbiAgICB0aGlzLmZsdXNoT25seU9uSW50ZXJ2YWwgPSBvcHRpb25zLmZsdXNoT25seU9uSW50ZXJ2YWwgfHwgZmFsc2U7XG59O1xuXG4vKipcbiAqIEFkZCBvbmUgaXRlbSB0byBxdWV1ZS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWUuZW5xdWV1ZShpdGVtLCB0aGlzLmZsdXNoSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4gKiBTdGFydCBmbHVzaGluZyBiYXRjaGVzIGF0IHRoZSBjb25maWd1cmVkIHRpbWUgaW50ZXJ2YWwuIE11c3QgY2FsbFxuICogdGhpcyBtZXRob2QgdXBvbiBTREsgaW5pdCBpbiBvcmRlciB0byBzZW5kIGFueXRoaW5nIG92ZXIgdGhlIG5ldHdvcmsuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29uc2VjdXRpdmVSZW1vdmFsRmFpbHVyZXMgPSAwO1xuICAgIHJldHVybiB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIFN0b3AgZmx1c2hpbmcgYmF0Y2hlcy4gQ2FuIGJlIHJlc3RhcnRlZCBieSBjYWxsaW5nIHN0YXJ0KCkuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy50aW1lb3V0SUQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElEKTtcbiAgICAgICAgdGhpcy50aW1lb3V0SUQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2xlYXIgb3V0IHF1ZXVlLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlIGJhdGNoIHNpemUgY29uZmlndXJhdGlvbiB0byB3aGF0ZXZlciBpcyBzZXQgaW4gdGhlIG1haW4gU0RLLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUucmVzZXRCYXRjaFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJhdGNoU2l6ZSA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9zaXplJ107XG59O1xuXG4vKipcbiAqIFJlc3RvcmUgZmx1c2ggaW50ZXJ2YWwgdGltZSBjb25maWd1cmF0aW9uIHRvIHdoYXRldmVyIGlzIHNldCBpbiB0aGUgbWFpbiBTREsuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5yZXNldEZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY2hlZHVsZUZsdXNoKHRoaXMubGliQ29uZmlnWydiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyddKTtcbn07XG5cbi8qKlxuICogU2NoZWR1bGUgdGhlIG5leHQgZmx1c2ggaW4gdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zY2hlZHVsZUZsdXNoID0gZnVuY3Rpb24oZmx1c2hNUykge1xuICAgIHRoaXMuZmx1c2hJbnRlcnZhbCA9IGZsdXNoTVM7XG4gICAgaWYgKCF0aGlzLnN0b3BwZWQpIHsgLy8gZG9uJ3Qgc2NoZWR1bGUgYW55bW9yZSBpZiBiYXRjaGluZyBoYXMgYmVlbiBzdG9wcGVkXG4gICAgICAgIHRoaXMudGltZW91dElEID0gc2V0VGltZW91dChfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyksIHRoaXMuZmx1c2hJbnRlcnZhbCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZW5kIGEgcmVxdWVzdCB1c2luZyB0aGUgc2VuZFJlcXVlc3QgY2FsbGJhY2ssIGJ1dCBwcm9taXNpZmllZC5cbiAqIFRPRE86IHNlbmRSZXF1ZXN0IHNob3VsZCBiZSBwcm9taXNpZmllZCBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zZW5kUmVxdWVzdFByb21pc2UgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChkYXRhLCBvcHRpb25zLCByZXNvbHZlKTtcbiAgICB9LCB0aGlzKSk7XG59O1xuXG5cbi8qKlxuICogRmx1c2ggb25lIGJhdGNoIHRvIG5ldHdvcmsuIERlcGVuZGluZyBvbiBzdWNjZXNzL2ZhaWx1cmUgbW9kZXMsIGl0IHdpbGwgZWl0aGVyXG4gKiByZW1vdmUgdGhlIGJhdGNoIGZyb20gdGhlIHF1ZXVlIG9yIGxlYXZlIGl0IGluIGZvciByZXRyeSwgYW5kIHNjaGVkdWxlIHRoZSBuZXh0XG4gKiBmbHVzaC4gSW4gY2FzZXMgb2YgbW9zdCBuZXR3b3JrIG9yIEFQSSBmYWlsdXJlcywgaXQgd2lsbCBiYWNrIG9mZiBleHBvbmVudGlhbGx5XG4gKiB3aGVuIHJldHJ5aW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZW5kQmVhY29uXSAtIHdoZXRoZXIgdG8gc2VuZCBiYXRjaCB3aXRoXG4gKiBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiAob25seSB1c2VmdWwgZm9yIHNlbmRpbmcgYmF0Y2hlcyBiZWZvcmUgcGFnZSB1bmxvYWRzLCBhc1xuICogc2VuZEJlYWNvbiBvZmZlcnMgbm8gY2FsbGJhY2tzIG9yIHN0YXR1cyBpbmRpY2F0aW9ucylcbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICh0aGlzLnJlcXVlc3RJblByb2dyZXNzKSB7XG4gICAgICAgIGxvZ2dlciQyLmxvZygnRmx1c2g6IFJlcXVlc3QgYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gdHJ1ZTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0aW1lb3V0TVMgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJ107XG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciBjdXJyZW50QmF0Y2hTaXplID0gdGhpcy5iYXRjaFNpemU7XG5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5maWxsQmF0Y2goY3VycmVudEJhdGNoU2l6ZSlcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uKGJhdGNoKSB7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgbW9yZSBpdGVtcyBpbiB0aGUgcXVldWUgdGhhbiB0aGUgYmF0Y2ggc2l6ZSwgYXR0ZW1wdFxuICAgICAgICAgICAgLy8gdG8gZmx1c2ggYWdhaW4gYWZ0ZXIgdGhlIGN1cnJlbnQgYmF0Y2ggaXMgZG9uZS5cbiAgICAgICAgICAgIHZhciBhdHRlbXB0U2Vjb25kYXJ5Rmx1c2ggPSBiYXRjaC5sZW5ndGggPT09IGN1cnJlbnRCYXRjaFNpemU7XG4gICAgICAgICAgICB2YXIgZGF0YUZvclJlcXVlc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZEl0ZW1zID0ge307XG4gICAgICAgICAgICBfLmVhY2goYmF0Y2gsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGl0ZW1bJ3BheWxvYWQnXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iZWZvcmVTZW5kSG9vayAmJiAhaXRlbS5vcnBoYW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gdGhpcy5iZWZvcmVTZW5kSG9vayhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbXBfc2VudF9ieV9saWJfdmVyc2lvbiBwcm9wIGNhcHR1cmVzIHdoaWNoIGxpYiB2ZXJzaW9uIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbmRzIGVhY2ggZXZlbnQgKHJlZ2FyZGxlc3Mgb2Ygd2hpY2ggdmVyc2lvbiBvcmlnaW5hbGx5IHF1ZXVlZFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBmb3Igc2VuZGluZylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWRbJ2V2ZW50J10gJiYgcGF5bG9hZFsncHJvcGVydGllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWydwcm9wZXJ0aWVzJ10gPSBfLmV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeydtcF9zZW50X2J5X2xpYl92ZXJzaW9uJzogQ29uZmlnLkxJQl9WRVJTSU9OfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkUGF5bG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtSWQgPSBpdGVtWydpZCddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSB8fCAwKSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gaXRlbSBJRCBzZW50IHRvbyBtYW55IHRpbWVzLCBub3Qgc2VuZGluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplOiBiYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzU2VudDogdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGF5bG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGZvdW5kIGl0ZW0gd2l0aCBubyBJRCcsIHtpdGVtOiBpdGVtfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUZvclJlcXVlc3QucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZEl0ZW1zW2l0ZW1bJ2lkJ11dID0gcGF5bG9hZDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YUZvclJlcXVlc3QubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTsgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVtb3ZlSXRlbXNGcm9tUXVldWUgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVJdGVtc0J5SUQoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLm1hcChiYXRjaCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1zaWRlIGRlZHVwZVxuICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBfLmJpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtSWQgPSBpdGVtWydpZCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdID0gdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdID4gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGl0ZW0gSUQgc2VudCB0b28gbWFueSB0aW1lcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZTogYmF0Y2gubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzU2VudDogdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBmb3VuZCBpdGVtIHdpdGggbm8gSUQgd2hpbGUgcmVtb3ZpbmcnLCB7aXRlbTogaXRlbX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVSZW1vdmFsRmFpbHVyZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsdXNoT25seU9uSW50ZXJ2YWwgJiYgIWF0dGVtcHRTZWNvbmRhcnlGbHVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTsgLy8gc2NoZWR1bGUgbmV4dCBiYXRjaCB3aXRoIGEgZGVsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2goKTsgLy8gaGFuZGxlIG5leHQgYmF0Y2ggaWYgdGhlIHF1ZXVlIGlzbid0IGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKyt0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID4gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdUb28gbWFueSBxdWV1ZSBmYWlsdXJlczsgZGlzYWJsaW5nIGJhdGNoaW5nIHN5c3RlbS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wQWxsQmF0Y2hpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgYmF0Y2hTZW5kQ2FsbGJhY2sgPSBfLmJpbmQoZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgQVBJIHJlc3BvbnNlIGluIGEgdHJ5LWNhdGNoIHRvIG1ha2Ugc3VyZSB3ZSBjYW4gcmVzZXQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoIG9wZXJhdGlvbiBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZ1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBlcnNpc3RlZCBkYXRhIHRvIGluY2x1ZGUgaG9vayB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnVwZGF0ZVBheWxvYWRzKHRyYW5zZm9ybWVkSXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5pc09iamVjdChyZXMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmVycm9yID09PSAndGltZW91dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSA+PSB0aW1lb3V0TVNcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdOZXR3b3JrIHRpbWVvdXQ7IHJldHJ5aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5pc09iamVjdChyZXMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuaHR0cFN0YXR1c0NvZGUgPj0gNTAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHJlcy5odHRwU3RhdHVzQ29kZSA9PT0gNDI5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChyZXMuaHR0cFN0YXR1c0NvZGUgPD0gMCAmJiAhaXNPbmxpbmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgcmVzLmVycm9yID09PSAndGltZW91dCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV0d29yayBvciBBUEkgZXJyb3IsIG9yIDQyOSBUb28gTWFueSBSZXF1ZXN0cywgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXRyeU1TID0gdGhpcy5mbHVzaEludGVydmFsICogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMucmV0cnlBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5TVMgPSAocGFyc2VJbnQocmVzLnJldHJ5QWZ0ZXIsIDEwKSAqIDEwMDApIHx8IHJldHJ5TVM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeU1TID0gTWF0aC5taW4oTUFYX1JFVFJZX0lOVEVSVkFMX01TLCByZXRyeU1TKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yOyByZXRyeSBpbiAnICsgcmV0cnlNUyArICcgbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVGbHVzaChyZXRyeU1TKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocmVzKSAmJiByZXMuaHR0cFN0YXR1c0NvZGUgPT09IDQxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDEzIFBheWxvYWQgVG9vIExhcmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYWx2ZWRCYXRjaFNpemUgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGN1cnJlbnRCYXRjaFNpemUgLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBNYXRoLm1pbih0aGlzLmJhdGNoU2l6ZSwgaGFsdmVkQmF0Y2hTaXplLCBiYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCc0MTMgcmVzcG9uc2U7IHJlZHVjaW5nIGJhdGNoIHNpemUgdG8gJyArIHRoaXMuYmF0Y2hTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignU2luZ2xlLWV2ZW50IHJlcXVlc3QgdG9vIGxhcmdlOyBkcm9wcGluZycsIGJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QmF0Y2hTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUl0ZW1zRnJvbVF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIG5ldHdvcmsgcmVxdWVzdCtyZXNwb25zZTsgcmVtb3ZlIGVhY2ggaXRlbSBpbiBiYXRjaCBmcm9tIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoZXZlbiBpZiBpdCB3YXMgZS5nLiBhIDQwMCwgaW4gd2hpY2ggY2FzZSByZXRyeWluZyB3b24ndCBoZWxwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUl0ZW1zRnJvbVF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBoYW5kbGluZyBBUEkgcmVzcG9uc2UnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICB2ZXJib3NlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlnbm9yZV9qc29uX2Vycm9yczogdHJ1ZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgICAgICB0aW1lb3V0X21zOiB0aW1lb3V0TVMgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy51bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy50cmFuc3BvcnQgPSAnc2VuZEJlYWNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIkMi5sb2coJ01JWFBBTkVMIFJFUVVFU1Q6JywgZGF0YUZvclJlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3RQcm9taXNlKGRhdGFGb3JSZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucykudGhlbihiYXRjaFNlbmRDYWxsYmFjayk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgZmx1c2hpbmcgcmVxdWVzdCBxdWV1ZScsIGVycik7XG4gICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBMb2cgZXJyb3IgdG8gZ2xvYmFsIGxvZ2dlciBhbmQgb3B0aW9uYWwgdXNlci1kZWZpbmVkIGxvZ2dlci5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICBsb2dnZXIkMi5lcnJvci5hcHBseShsb2dnZXIkMi5lcnJvciwgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5lcnJvclJlcG9ydGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZXBvcnRlcihtc2csIGVycik7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIkMi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGxvZ2dlciQxID0gY29uc29sZV93aXRoX3ByZWZpeCgncmVjb3JkZXInKTtcbnZhciBDb21wcmVzc2lvblN0cmVhbSA9IHdpblsnQ29tcHJlc3Npb25TdHJlYW0nXTtcblxudmFyIFJFQ09SREVSX0JBVENIRVJfTElCX0NPTkZJRyA9IHtcbiAgICAnYmF0Y2hfc2l6ZSc6IDEwMDAsXG4gICAgJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJzogMTAgKiAxMDAwLFxuICAgICdiYXRjaF9yZXF1ZXN0X3RpbWVvdXRfbXMnOiA5MCAqIDEwMDAsXG4gICAgJ2JhdGNoX2F1dG9zdGFydCc6IHRydWVcbn07XG5cbnZhciBBQ1RJVkVfU09VUkNFUyA9IG5ldyBTZXQoW1xuICAgIEluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZSxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZUludGVyYWN0aW9uLFxuICAgIEluY3JlbWVudGFsU291cmNlLlNjcm9sbCxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5WaWV3cG9ydFJlc2l6ZSxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5JbnB1dCxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5Ub3VjaE1vdmUsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvbixcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnLFxuICAgIEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvbixcbl0pO1xuXG5mdW5jdGlvbiBpc1VzZXJFdmVudChldikge1xuICAgIHJldHVybiBldi50eXBlID09PSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCAmJiBBQ1RJVkVfU09VUkNFUy5oYXMoZXYuZGF0YS5zb3VyY2UpO1xufVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIGEgc2luZ2xlIHNlc3Npb24gcmVjb3JkaW5nIGFuZCBpdHMgbGlmZWN5Y2xlLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1peHBhbmVsSW5zdGFuY2VdIC0gcmVmZXJlbmNlIHRvIHRoZSBjb3JlIE1peHBhbmVsTGliXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVwbGF5SWRdIC0gdW5pcXVlIHV1aWQgZm9yIGEgc2luZ2xlIHJlcGxheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25JZGxlVGltZW91dF0gLSBjYWxsYmFjayB3aGVuIGEgcmVjb3JkaW5nIHJlYWNoZXMgaWRsZSB0aW1lb3V0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbk1heExlbmd0aFJlYWNoZWRdIC0gY2FsbGJhY2sgd2hlbiBhIHJlY29yZGluZyByZWFjaGVzIGl0cyBtYXhpbXVtIGxlbmd0aFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMucnJ3ZWJSZWNvcmRdIC0gcnJ3ZWIncyBgcmVjb3JkYCBmdW5jdGlvblxuICovXG52YXIgU2Vzc2lvblJlY29yZGluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9taXhwYW5lbCA9IG9wdGlvbnMubWl4cGFuZWxJbnN0YW5jZTtcbiAgICB0aGlzLl9vbklkbGVUaW1lb3V0ID0gb3B0aW9ucy5vbklkbGVUaW1lb3V0O1xuICAgIHRoaXMuX29uTWF4TGVuZ3RoUmVhY2hlZCA9IG9wdGlvbnMub25NYXhMZW5ndGhSZWFjaGVkO1xuICAgIHRoaXMuX3Jyd2ViUmVjb3JkID0gb3B0aW9ucy5ycndlYlJlY29yZDtcblxuICAgIHRoaXMucmVwbGF5SWQgPSBvcHRpb25zLnJlcGxheUlkO1xuXG4gICAgLy8gaW50ZXJuYWwgcnJ3ZWIgc3RvcFJlY29yZGluZyBmdW5jdGlvblxuICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcgPSBudWxsO1xuXG4gICAgdGhpcy5zZXFObyA9IDA7XG4gICAgdGhpcy5yZXBsYXlTdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMucmVwbGF5U3RhcnRVcmwgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hTdGFydFVybCA9IG51bGw7XG5cbiAgICB0aGlzLmlkbGVUaW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMubWF4VGltZW91dElkID0gbnVsbDtcblxuICAgIHRoaXMucmVjb3JkTWF4TXMgPSBNQVhfUkVDT1JESU5HX01TO1xuICAgIHRoaXMucmVjb3JkTWluTXMgPSAwO1xuXG4gICAgLy8gZWFjaCByZXBsYXkgaGFzIGl0cyBvd24gYmF0Y2hlciBrZXkgdG8gYXZvaWQgY29uZmxpY3RzIGJldHdlZW4gcnJ3ZWIgZXZlbnRzIG9mIGRpZmZlcmVudCByZWNvcmRpbmdzXG4gICAgLy8gdGhpcyB3aWxsIGJlIGltcG9ydGFudCB3aGVuIHBlcnNpc3RlbmNlIGlzIGludHJvZHVjZWRcbiAgICB2YXIgYmF0Y2hlcktleSA9ICdfX21wcmVjXycgKyB0aGlzLmdldENvbmZpZygndG9rZW4nKSArICdfJyArIHRoaXMucmVwbGF5SWQ7XG4gICAgdGhpcy5iYXRjaGVyID0gbmV3IFJlcXVlc3RCYXRjaGVyKGJhdGNoZXJLZXksIHtcbiAgICAgICAgZXJyb3JSZXBvcnRlcjogXy5iaW5kKHRoaXMucmVwb3J0RXJyb3IsIHRoaXMpLFxuICAgICAgICBmbHVzaE9ubHlPbkludGVydmFsOiB0cnVlLFxuICAgICAgICBsaWJDb25maWc6IFJFQ09SREVSX0JBVENIRVJfTElCX0NPTkZJRyxcbiAgICAgICAgc2VuZFJlcXVlc3RGdW5jOiBfLmJpbmQodGhpcy5mbHVzaEV2ZW50c1dpdGhPcHRPdXQsIHRoaXMpLFxuICAgICAgICB1c2VQZXJzaXN0ZW5jZTogZmFsc2VcbiAgICB9KTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZ1Zhcikge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5nZXRfY29uZmlnKGNvbmZpZ1Zhcik7XG59O1xuXG4vLyBBbGlhcyBmb3IgZ2V0Q29uZmlnLCB1c2VkIGJ5IHRoZSBjb21tb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYiBmdW5jdGlvbiB3aGljaFxuLy8gcmVhY2hlcyBpbnRvIHRoaXMgY2xhc3MgaW5zdGFuY2UgYW5kIGV4cGVjdHMgdGhlIHNuYWtlIGNhc2UgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24uXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5nZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZmlnVmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnKGNvbmZpZ1Zhcik7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5zdGFydFJlY29yZGluZyA9IGZ1bmN0aW9uIChzaG91bGRTdG9wQmF0Y2hlcikge1xuICAgIGlmICh0aGlzLl9zdG9wUmVjb3JkaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGxvZ2dlciQxLmxvZygnUmVjb3JkaW5nIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHNraXBwaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvcmRNYXhNcyA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWF4X21zJyk7XG4gICAgaWYgKHRoaXMucmVjb3JkTWF4TXMgPiBNQVhfUkVDT1JESU5HX01TKSB7XG4gICAgICAgIHRoaXMucmVjb3JkTWF4TXMgPSBNQVhfUkVDT1JESU5HX01TO1xuICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgncmVjb3JkX21heF9tcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICcgKyBNQVhfUkVDT1JESU5HX01TICsgJ21zLiBDYXBwaW5nIHZhbHVlLicpO1xuICAgIH1cblxuICAgIHRoaXMucmVjb3JkTWluTXMgPSB0aGlzLmdldENvbmZpZygncmVjb3JkX21pbl9tcycpO1xuICAgIGlmICh0aGlzLnJlY29yZE1pbk1zID4gTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TKSB7XG4gICAgICAgIHRoaXMucmVjb3JkTWluTXMgPSBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVM7XG4gICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdyZWNvcmRfbWluX21zIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJyArIE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUyArICdtcy4gQ2FwcGluZyB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMuYmF0Y2hTdGFydFVybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG4gICAgdGhpcy5yZXBsYXlTdGFydFVybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG5cbiAgICBpZiAoc2hvdWxkU3RvcEJhdGNoZXIgfHwgdGhpcy5yZWNvcmRNaW5NcyA+IDApIHtcbiAgICAgICAgLy8gdGhlIHByaW1hcnkgY2FzZSBmb3Igc2hvdWxkU3RvcEJhdGNoZXIgaXMgd2hlbiB3ZSdyZSBzdGFydGluZyByZWNvcmRpbmcgYWZ0ZXIgYSByZXNldFxuICAgICAgICAvLyBhbmQgZG9uJ3Qgd2FudCB0byBzZW5kIGFueXRoaW5nIG92ZXIgdGhlIG5ldHdvcmsgdW50aWwgdGhlcmUnc1xuICAgICAgICAvLyBhY3R1YWwgdXNlciBhY3Rpdml0eVxuICAgICAgICAvLyB0aGlzIGFsc28gYXBwbGllcyBpZiB0aGUgbWluaW11bSByZWNvcmRpbmcgbGVuZ3RoIGhhcyBub3QgYmVlbiBoaXQgeWV0XG4gICAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCBkYXRhIHVudGlsIHdlIGtub3cgdGhlIHJlY29yZGluZyB3aWxsIGJlIGxvbmcgZW5vdWdoXG4gICAgICAgIHRoaXMuYmF0Y2hlci5zdG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXRjaGVyLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc2V0SWRsZVRpbWVvdXQgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZW91dElkKTtcbiAgICAgICAgdGhpcy5pZGxlVGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9vbklkbGVUaW1lb3V0LCB0aGlzLmdldENvbmZpZygncmVjb3JkX2lkbGVfdGltZW91dF9tcycpKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHZhciBibG9ja1NlbGVjdG9yID0gdGhpcy5nZXRDb25maWcoJ3JlY29yZF9ibG9ja19zZWxlY3RvcicpO1xuICAgIGlmIChibG9ja1NlbGVjdG9yID09PSAnJyB8fCBibG9ja1NlbGVjdG9yID09PSBudWxsKSB7XG4gICAgICAgIGJsb2NrU2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IHRoaXMuX3Jyd2ViUmVjb3JkKHtcbiAgICAgICAgJ2VtaXQnOiBfLmJpbmQoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoZXIuZW5xdWV1ZShldik7XG4gICAgICAgICAgICBpZiAoaXNVc2VyRXZlbnQoZXYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2hlci5zdG9wcGVkICYmIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5yZXBsYXlTdGFydFRpbWUgPj0gdGhpcy5yZWNvcmRNaW5Ncykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBmbHVzaGluZyBhZ2FpbiBhZnRlciB1c2VyIGFjdGl2aXR5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hlci5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNldElkbGVUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAnYmxvY2tDbGFzcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfYmxvY2tfY2xhc3MnKSxcbiAgICAgICAgJ2Jsb2NrU2VsZWN0b3InOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAnY29sbGVjdEZvbnRzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9jb2xsZWN0X2ZvbnRzJyksXG4gICAgICAgICdkYXRhVVJMT3B0aW9ucyc6IHsgLy8gY2FudmFzIGltYWdlIG9wdGlvbnMgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC90b0RhdGFVUkwpXG4gICAgICAgICAgICAndHlwZSc6ICdpbWFnZS93ZWJwJyxcbiAgICAgICAgICAgICdxdWFsaXR5JzogMC42XG4gICAgICAgIH0sXG4gICAgICAgICdtYXNrQWxsSW5wdXRzJzogdHJ1ZSxcbiAgICAgICAgJ21hc2tUZXh0Q2xhc3MnOiB0aGlzLmdldENvbmZpZygncmVjb3JkX21hc2tfdGV4dF9jbGFzcycpLFxuICAgICAgICAnbWFza1RleHRTZWxlY3Rvcic6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWFza190ZXh0X3NlbGVjdG9yJyksXG4gICAgICAgICdyZWNvcmRDYW52YXMnOiB0aGlzLmdldENvbmZpZygncmVjb3JkX2NhbnZhcycpLFxuICAgICAgICAnc2FtcGxpbmcnOiB7XG4gICAgICAgICAgICAnY2FudmFzJzogMTVcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9zdG9wUmVjb3JkaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ3Jyd2ViIGZhaWxlZCB0byBzdGFydCwgc2tpcHBpbmcgdGhpcyByZWNvcmRpbmcuJyk7XG4gICAgICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTsgLy8gc3RvcCBiYXRjaGVyIGxvb3BpbmcgYW5kIGFueSB0aW1lb3V0c1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzZXRJZGxlVGltZW91dCgpO1xuXG4gICAgdGhpcy5tYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KF8uYmluZCh0aGlzLl9vbk1heExlbmd0aFJlYWNoZWQsIHRoaXMpLCB0aGlzLnJlY29yZE1heE1zKTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnN0b3BSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUnJ3ZWJTdG9wcGVkKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciB3aXRoIHJyd2ViIHN0b3BSZWNvcmRpbmcnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJhdGNoZXIuc3RvcHBlZCkge1xuICAgICAgICAvLyBuZXZlciBnb3QgdXNlciBhY3Rpdml0eSB0byBmbHVzaCBhZnRlciByZXNldCwgc28ganVzdCBjbGVhciB0aGUgYmF0Y2hlclxuICAgICAgICB0aGlzLmJhdGNoZXIuY2xlYXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmbHVzaCBhbnkgcmVtYWluaW5nIGV2ZW50cyBmcm9tIHJ1bm5pbmcgYmF0Y2hlclxuICAgICAgICB0aGlzLmJhdGNoZXIuZmx1c2goKTtcbiAgICAgICAgdGhpcy5iYXRjaGVyLnN0b3AoKTtcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZW91dElkKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tYXhUaW1lb3V0SWQpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuaXNScndlYlN0b3BwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BSZWNvcmRpbmcgPT09IG51bGw7XG59O1xuXG4vKipcbiAqIEZsdXNoZXMgdGhlIGN1cnJlbnQgYmF0Y2ggb2YgZXZlbnRzIHRvIHRoZSBzZXJ2ZXIsIGJ1dCBwYXNzZXMgYW4gb3B0LW91dCBjYWxsYmFjayB0byBtYWtlIHN1cmVcbiAqIHdlIHN0b3AgcmVjb3JkaW5nIGFuZCBkdW1wIGFueSBxdWV1ZWQgZXZlbnRzIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQuXG4gKi9cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLmZsdXNoRXZlbnRzV2l0aE9wdE91dCA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIHRoaXMuX2ZsdXNoRXZlbnRzKGRhdGEsIG9wdGlvbnMsIGNiLCBfLmJpbmQodGhpcy5fb25PcHRPdXQsIHRoaXMpKTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLl9vbk9wdE91dCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgLy8gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYiBpbnZva2VzIHRoaXMgZnVuY3Rpb24gd2l0aCBjb2RlPTAgd2hlbiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nKCk7XG4gICAgfVxufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuX3NlbmRSZXF1ZXN0ID0gZnVuY3Rpb24oY3VycmVudFJlcGxheUlkLCByZXFQYXJhbXMsIHJlcUJvZHksIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9uU3VjY2VzcyA9IF8uYmluZChmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3BvbnNlQm9keSkge1xuICAgICAgICAvLyBVcGRhdGUgYmF0Y2ggc3BlY2lmaWMgcHJvcHMgb25seSBpZiB0aGUgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bCB0byBndWFyYW50ZWUgb3JkZXJpbmcuXG4gICAgICAgIC8vIFJlcXVlc3RCYXRjaGVyIHdpbGwgYWx3YXlzIGZsdXNoIHRoZSBuZXh0IGJhdGNoIGFmdGVyIHRoZSBwcmV2aW91cyBvbmUgc3VjY2VlZHMuXG4gICAgICAgIC8vIGV4dHJhIGNoZWNrIHRvIHNlZSBpZiB0aGUgcmVwbGF5IElEIGhhcyBjaGFuZ2VkIHNvIHRoYXQgd2UgZG9uJ3QgaW5jcmVtZW50IHRoZSBzZXFObyBvbiB0aGUgd3JvbmcgcmVwbGF5XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiB0aGlzLnJlcGxheUlkID09PSBjdXJyZW50UmVwbGF5SWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VxTm8rKztcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hTdGFydFVybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgICAgaHR0cFN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3BvbnNlQm9keTogcmVzcG9uc2VCb2R5LFxuICAgICAgICAgICAgcmV0cnlBZnRlcjogcmVzcG9uc2UuaGVhZGVycy5nZXQoJ1JldHJ5LUFmdGVyJylcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB3aW5bJ2ZldGNoJ10odGhpcy5nZXRDb25maWcoJ2FwaV9ob3N0JykgKyAnLycgKyB0aGlzLmdldENvbmZpZygnYXBpX3JvdXRlcycpWydyZWNvcmQnXSArICc/JyArIG5ldyBVUkxTZWFyY2hQYXJhbXMocmVxUGFyYW1zKSwge1xuICAgICAgICAnbWV0aG9kJzogJ1BPU1QnLFxuICAgICAgICAnaGVhZGVycyc6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0Jhc2ljICcgKyBidG9hKHRoaXMuZ2V0Q29uZmlnKCd0b2tlbicpICsgJzonKSxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgICAgICB9LFxuICAgICAgICAnYm9keSc6IHJlcUJvZHksXG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmVzcG9uc2UuanNvbigpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgb25TdWNjZXNzKHJlc3BvbnNlLCByZXNwb25zZUJvZHkpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHtlcnJvcjogZXJyb3J9KTtcbiAgICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKHtlcnJvcjogZXJyb3IsIGh0dHBTdGF0dXNDb2RlOiAwfSk7XG4gICAgfSk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5fZmx1c2hFdmVudHMgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG51bUV2ZW50cyA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKG51bUV2ZW50cyA+IDApIHtcbiAgICAgICAgdmFyIHJlcGxheUlkID0gdGhpcy5yZXBsYXlJZDtcbiAgICAgICAgLy8gZWFjaCBycndlYiBldmVudCBoYXMgYSB0aW1lc3RhbXAgLSBsZXZlcmFnZSB0aG9zZSB0byBnZXQgdGltZSBwcm9wZXJ0aWVzXG4gICAgICAgIHZhciBiYXRjaFN0YXJ0VGltZSA9IGRhdGFbMF0udGltZXN0YW1wO1xuICAgICAgICBpZiAodGhpcy5zZXFObyA9PT0gMCB8fCAhdGhpcy5yZXBsYXlTdGFydFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGV4dHJhIHNhZmV0eSBuZXQgc28gdGhhdCB3ZSBkb24ndCBzZW5kIGEgbnVsbCByZXBsYXkgc3RhcnQgdGltZVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VxTm8gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdSZXBsYXkgc3RhcnQgdGltZSBub3Qgc2V0IGJ1dCBzZXFObyBpcyBub3QgMC4gVXNpbmcgY3VycmVudCBiYXRjaCBzdGFydCB0aW1lIGFzIGEgZmFsbGJhY2suJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVwbGF5U3RhcnRUaW1lID0gYmF0Y2hTdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcGxheUxlbmd0aE1zID0gZGF0YVtudW1FdmVudHMgLSAxXS50aW1lc3RhbXAgLSB0aGlzLnJlcGxheVN0YXJ0VGltZTtcblxuICAgICAgICB2YXIgcmVxUGFyYW1zID0ge1xuICAgICAgICAgICAgJyRjdXJyZW50X3VybCc6IHRoaXMuYmF0Y2hTdGFydFVybCxcbiAgICAgICAgICAgICckbGliX3ZlcnNpb24nOiBDb25maWcuTElCX1ZFUlNJT04sXG4gICAgICAgICAgICAnYmF0Y2hfc3RhcnRfdGltZSc6IGJhdGNoU3RhcnRUaW1lIC8gMTAwMCxcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IFN0cmluZyh0aGlzLl9taXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKSksXG4gICAgICAgICAgICAnbXBfbGliJzogJ3dlYicsXG4gICAgICAgICAgICAncmVwbGF5X2lkJzogcmVwbGF5SWQsXG4gICAgICAgICAgICAncmVwbGF5X2xlbmd0aF9tcyc6IHJlcGxheUxlbmd0aE1zLFxuICAgICAgICAgICAgJ3JlcGxheV9zdGFydF90aW1lJzogdGhpcy5yZXBsYXlTdGFydFRpbWUgLyAxMDAwLFxuICAgICAgICAgICAgJ3JlcGxheV9zdGFydF91cmwnOiB0aGlzLnJlcGxheVN0YXJ0VXJsLFxuICAgICAgICAgICAgJ3NlcSc6IHRoaXMuc2VxTm9cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGV2ZW50c0pzb24gPSBfLkpTT05FbmNvZGUoZGF0YSk7XG5cbiAgICAgICAgLy8gc2VuZCBJRCBtYW5hZ2VtZW50IHByb3BzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgdmFyIGRldmljZUlkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckZGV2aWNlX2lkJyk7XG4gICAgICAgIGlmIChkZXZpY2VJZCkge1xuICAgICAgICAgICAgcmVxUGFyYW1zWyckZGV2aWNlX2lkJ10gPSBkZXZpY2VJZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXNlcklkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckdXNlcl9pZCcpO1xuICAgICAgICBpZiAodXNlcklkKSB7XG4gICAgICAgICAgICByZXFQYXJhbXNbJyR1c2VyX2lkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQ29tcHJlc3Npb25TdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBqc29uU3RyZWFtID0gbmV3IEJsb2IoW2V2ZW50c0pzb25dLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nfSkuc3RyZWFtKCk7XG4gICAgICAgICAgICB2YXIgZ3ppcFN0cmVhbSA9IGpzb25TdHJlYW0ucGlwZVRocm91Z2gobmV3IENvbXByZXNzaW9uU3RyZWFtKCdnemlwJykpO1xuICAgICAgICAgICAgbmV3IFJlc3BvbnNlKGd6aXBTdHJlYW0pXG4gICAgICAgICAgICAgICAgLmJsb2IoKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbihjb21wcmVzc2VkQmxvYikge1xuICAgICAgICAgICAgICAgICAgICByZXFQYXJhbXNbJ2Zvcm1hdCddID0gJ2d6aXAnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kUmVxdWVzdChyZXBsYXlJZCwgcmVxUGFyYW1zLCBjb21wcmVzc2VkQmxvYiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcVBhcmFtc1snZm9ybWF0J10gPSAnYm9keSc7XG4gICAgICAgICAgICB0aGlzLl9zZW5kUmVxdWVzdChyZXBsYXlJZCwgcmVxUGFyYW1zLCBldmVudHNKc29uLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgbG9nZ2VyJDEuZXJyb3IuYXBwbHkobG9nZ2VyJDEuZXJyb3IsIGFyZ3VtZW50cyk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFlcnIgJiYgIShtc2cgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgIG1zZyA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0Q29uZmlnKCdlcnJvcl9yZXBvcnRlcicpKG1zZywgZXJyKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBsb2dnZXIkMS5lcnJvcihlcnIpO1xuICAgIH1cbn07XG5cbnZhciBsb2dnZXIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdyZWNvcmRlcicpO1xuXG4vKipcbiAqIFJlY29yZGVyIEFQSTogbWFuYWdlcyByZWNvcmRpbmdzIGFuZCBleHBvc2VzIG1ldGhvZHMgcHVibGljIHRvIHRoZSBjb3JlIE1peHBhbmVsIGxpYnJhcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWl4cGFuZWxJbnN0YW5jZV0gLSByZWZlcmVuY2UgdG8gdGhlIGNvcmUgTWl4cGFuZWxMaWJcbiAqL1xudmFyIE1peHBhbmVsUmVjb3JkZXIgPSBmdW5jdGlvbihtaXhwYW5lbEluc3RhbmNlKSB7XG4gICAgdGhpcy5fbWl4cGFuZWwgPSBtaXhwYW5lbEluc3RhbmNlO1xuICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nID0gbnVsbDtcbn07XG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLnN0YXJ0UmVjb3JkaW5nID0gZnVuY3Rpb24oc2hvdWxkU3RvcEJhdGNoZXIpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZWNvcmRpbmcgJiYgIXRoaXMuYWN0aXZlUmVjb3JkaW5nLmlzUnJ3ZWJTdG9wcGVkKCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnUmVjb3JkaW5nIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHNraXBwaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9uSWRsZVRpbWVvdXQgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIubG9nKCdJZGxlIHRpbWVvdXQgcmVhY2hlZCwgcmVzdGFydGluZyByZWNvcmRpbmcuJyk7XG4gICAgICAgIHRoaXMucmVzZXRSZWNvcmRpbmcoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHZhciBvbk1heExlbmd0aFJlYWNoZWQgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIubG9nKCdNYXggcmVjb3JkaW5nIGxlbmd0aCByZWFjaGVkLCBzdG9wcGluZyByZWNvcmRpbmcuJyk7XG4gICAgICAgIHRoaXMucmVzZXRSZWNvcmRpbmcoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nID0gbmV3IFNlc3Npb25SZWNvcmRpbmcoe1xuICAgICAgICBtaXhwYW5lbEluc3RhbmNlOiB0aGlzLl9taXhwYW5lbCxcbiAgICAgICAgb25JZGxlVGltZW91dDogb25JZGxlVGltZW91dCxcbiAgICAgICAgb25NYXhMZW5ndGhSZWFjaGVkOiBvbk1heExlbmd0aFJlYWNoZWQsXG4gICAgICAgIHJlcGxheUlkOiBfLlVVSUQoKSxcbiAgICAgICAgcnJ3ZWJSZWNvcmQ6IHJlY29yZFxuICAgIH0pO1xuXG4gICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcuc3RhcnRSZWNvcmRpbmcoc2hvdWxkU3RvcEJhdGNoZXIpO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUuc3RvcFJlY29yZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlY29yZGluZykge1xuICAgICAgICB0aGlzLmFjdGl2ZVJlY29yZGluZy5zdG9wUmVjb3JkaW5nKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nID0gbnVsbDtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5yZXNldFJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcbiAgICB0aGlzLnN0YXJ0UmVjb3JkaW5nKHRydWUpO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUuZ2V0QWN0aXZlUmVwbGF5SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nICYmICF0aGlzLmFjdGl2ZVJlY29yZGluZy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVJlY29yZGluZy5yZXBsYXlJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vLyBnZXR0ZXIgc28gdGhhdCBvbGRlciBtaXhwYW5lbC1jb3JlIHZlcnNpb25zIGNhbiBzdGlsbCByZXRyaWV2ZSB0aGUgcmVwbGF5IElEXG4vLyB3aGVuIHB1bGxpbmcgdGhlIGxhdGVzdCByZWNvcmRlciBidW5kbGUgZnJvbSB0aGUgQ0ROXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUsICdyZXBsYXlJZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlUmVwbGF5SWQoKTtcbiAgICB9XG59KTtcblxud2luWydfX21wX3JlY29yZGVyJ10gPSBNaXhwYW5lbFJlY29yZGVyO1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qKlxuICogRG9tVHJhY2tlciBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRG9tVHJhY2tlciA9IGZ1bmN0aW9uKCkge307XG5cblxuLy8gaW50ZXJmYWNlXG5Eb21UcmFja2VyLnByb3RvdHlwZS5jcmVhdGVfcHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge307XG5Eb21UcmFja2VyLnByb3RvdHlwZS5ldmVudF9oYW5kbGVyID0gZnVuY3Rpb24oKSB7fTtcbkRvbVRyYWNrZXIucHJvdG90eXBlLmFmdGVyX3RyYWNrX2hhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuXG5Eb21UcmFja2VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obWl4cGFuZWxfaW5zdGFuY2UpIHtcbiAgICB0aGlzLm1wID0gbWl4cGFuZWxfaW5zdGFuY2U7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gcXVlcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb249fSB1c2VyX2NhbGxiYWNrXG4gKi9cbkRvbVRyYWNrZXIucHJvdG90eXBlLnRyYWNrID0gZnVuY3Rpb24ocXVlcnksIGV2ZW50X25hbWUsIHByb3BlcnRpZXMsIHVzZXJfY2FsbGJhY2spIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGVsZW1lbnRzID0gXy5kb21fcXVlcnkocXVlcnkpO1xuXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ1RoZSBET00gcXVlcnkgKCcgKyBxdWVyeSArICcpIHJldHVybmVkIDAgZWxlbWVudHMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF8uZWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBfLnJlZ2lzdGVyX2V2ZW50KGVsZW1lbnQsIHRoaXMub3ZlcnJpZGVfZXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGF0LmNyZWF0ZV9wcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHRoaXMpO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGF0Lm1wLmdldF9jb25maWcoJ3RyYWNrX2xpbmtzX3RpbWVvdXQnKTtcblxuICAgICAgICAgICAgdGhhdC5ldmVudF9oYW5kbGVyKGUsIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBtaXhwYW5lbCBzZXJ2ZXJzIGRvbid0IGdldCBiYWNrIHRvIHVzIGluIHRpbWVcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHRoYXQudHJhY2tfY2FsbGJhY2sodXNlcl9jYWxsYmFjaywgcHJvcHMsIG9wdGlvbnMsIHRydWUpLCB0aW1lb3V0KTtcblxuICAgICAgICAgICAgLy8gZmlyZSB0aGUgdHJhY2tpbmcgZXZlbnRcbiAgICAgICAgICAgIHRoYXQubXAudHJhY2soZXZlbnRfbmFtZSwgcHJvcHMsIHRoYXQudHJhY2tfY2FsbGJhY2sodXNlcl9jYWxsYmFjaywgcHJvcHMsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdXNlcl9jYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB0aW1lb3V0X29jY3VyZWRcbiAqL1xuRG9tVHJhY2tlci5wcm90b3R5cGUudHJhY2tfY2FsbGJhY2sgPSBmdW5jdGlvbih1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucywgdGltZW91dF9vY2N1cmVkKSB7XG4gICAgdGltZW91dF9vY2N1cmVkID0gdGltZW91dF9vY2N1cmVkIHx8IGZhbHNlO1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gb3B0aW9ucyBpcyByZWZlcmVuY2VkIGZyb20gYm90aCBjYWxsYmFja3MsIHNvIHdlIGNhbiBoYXZlXG4gICAgICAgIC8vIGEgJ2xvY2snIG9mIHNvcnRzIHRvIGVuc3VyZSBvbmx5IG9uZSBmaXJlc1xuICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFja19maXJlZCkgeyByZXR1cm47IH1cbiAgICAgICAgb3B0aW9ucy5jYWxsYmFja19maXJlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHVzZXJfY2FsbGJhY2sgJiYgdXNlcl9jYWxsYmFjayh0aW1lb3V0X29jY3VyZWQsIHByb3BzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIHVzZXIgY2FuIHByZXZlbnQgdGhlIGRlZmF1bHQgZnVuY3Rpb25hbGl0eSBieVxuICAgICAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlIGZyb20gdGhlaXIgY2FsbGJhY2tcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQuYWZ0ZXJfdHJhY2tfaGFuZGxlcihwcm9wcywgb3B0aW9ucywgdGltZW91dF9vY2N1cmVkKTtcbiAgICB9O1xufTtcblxuRG9tVHJhY2tlci5wcm90b3R5cGUuY3JlYXRlX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzLCBlbGVtZW50KSB7XG4gICAgdmFyIHByb3BzO1xuXG4gICAgaWYgKHR5cGVvZihwcm9wZXJ0aWVzKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wcyA9IHByb3BlcnRpZXMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMgPSBfLmV4dGVuZCh7fSwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuLyoqXG4gKiBMaW5rVHJhY2tlciBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRG9tVHJhY2tlclxuICovXG52YXIgTGlua1RyYWNrZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm92ZXJyaWRlX2V2ZW50ID0gJ2NsaWNrJztcbn07XG5fLmluaGVyaXQoTGlua1RyYWNrZXIsIERvbVRyYWNrZXIpO1xuXG5MaW5rVHJhY2tlci5wcm90b3R5cGUuY3JlYXRlX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzLCBlbGVtZW50KSB7XG4gICAgdmFyIHByb3BzID0gTGlua1RyYWNrZXIuc3VwZXJjbGFzcy5jcmVhdGVfcHJvcGVydGllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKGVsZW1lbnQuaHJlZikgeyBwcm9wc1sndXJsJ10gPSBlbGVtZW50LmhyZWY7IH1cblxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5ldmVudF9oYW5kbGVyID0gZnVuY3Rpb24oZXZ0LCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5uZXdfdGFiID0gKFxuICAgICAgICBldnQud2hpY2ggPT09IDIgfHxcbiAgICAgICAgZXZ0Lm1ldGFLZXkgfHxcbiAgICAgICAgZXZ0LmN0cmxLZXkgfHxcbiAgICAgICAgZWxlbWVudC50YXJnZXQgPT09ICdfYmxhbmsnXG4gICAgKTtcbiAgICBvcHRpb25zLmhyZWYgPSBlbGVtZW50LmhyZWY7XG5cbiAgICBpZiAoIW9wdGlvbnMubmV3X3RhYikge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG5MaW5rVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKHByb3BzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMubmV3X3RhYikgeyByZXR1cm47IH1cblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IG9wdGlvbnMuaHJlZjtcbiAgICB9LCAwKTtcbn07XG5cbi8qKlxuICogRm9ybVRyYWNrZXIgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERvbVRyYWNrZXJcbiAqL1xudmFyIEZvcm1UcmFja2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vdmVycmlkZV9ldmVudCA9ICdzdWJtaXQnO1xufTtcbl8uaW5oZXJpdChGb3JtVHJhY2tlciwgRG9tVHJhY2tlcik7XG5cbkZvcm1UcmFja2VyLnByb3RvdHlwZS5ldmVudF9oYW5kbGVyID0gZnVuY3Rpb24oZXZ0LCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbn07XG5cbkZvcm1UcmFja2VyLnByb3RvdHlwZS5hZnRlcl90cmFja19oYW5kbGVyID0gZnVuY3Rpb24ocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvcHRpb25zLmVsZW1lbnQuc3VibWl0KCk7XG4gICAgfSwgMCk7XG59O1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9BQ1RJT04gICAgICA9ICckc2V0Jztcbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9PTkNFX0FDVElPTiA9ICckc2V0X29uY2UnO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5TRVRfQUNUSU9OICAgID0gJyR1bnNldCc7XG4vKiogQGNvbnN0ICovIHZhciBBRERfQUNUSU9OICAgICAgPSAnJGFkZCc7XG4vKiogQGNvbnN0ICovIHZhciBBUFBFTkRfQUNUSU9OICAgPSAnJGFwcGVuZCc7XG4vKiogQGNvbnN0ICovIHZhciBVTklPTl9BQ1RJT04gICAgPSAnJHVuaW9uJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFTU9WRV9BQ1RJT04gICA9ICckcmVtb3ZlJztcbi8qKiBAY29uc3QgKi8gdmFyIERFTEVURV9BQ1RJT04gICA9ICckZGVsZXRlJztcblxuLy8gQ29tbW9uIGludGVybmFsIG1ldGhvZHMgZm9yIG1peHBhbmVsLnBlb3BsZSBhbmQgbWl4cGFuZWwuZ3JvdXAgQVBJcy5cbi8vIFRoZXNlIG1ldGhvZHMgc2hvdWxkbid0IGludm9sdmUgbmV0d29yayBJL08uXG52YXIgYXBpQWN0aW9ucyA9IHtcbiAgICBzZXRfYWN0aW9uOiBmdW5jdGlvbihwcm9wLCB0bykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHNldCA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZXRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNldFtwcm9wXSA9IHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtTRVRfQUNUSU9OXSA9ICRzZXQ7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICB1bnNldF9hY3Rpb246IGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICR1bnNldCA9IFtdO1xuICAgICAgICBpZiAoIV8uaXNBcnJheShwcm9wKSkge1xuICAgICAgICAgICAgcHJvcCA9IFtwcm9wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgJHVuc2V0LnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGRhdGFbVU5TRVRfQUNUSU9OXSA9ICR1bnNldDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHNldF9vbmNlX2FjdGlvbjogZnVuY3Rpb24ocHJvcCwgdG8pIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRzZXRfb25jZSA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZXRfb25jZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2V0X29uY2VbcHJvcF0gPSB0bztcbiAgICAgICAgfVxuICAgICAgICBkYXRhW1NFVF9PTkNFX0FDVElPTl0gPSAkc2V0X29uY2U7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICB1bmlvbl9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkdW5pb24gPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHVuaW9uW2tdID0gXy5pc0FycmF5KHYpID8gdiA6IFt2XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR1bmlvbltsaXN0X25hbWVdID0gXy5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbdmFsdWVzXTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW1VOSU9OX0FDVElPTl0gPSAkdW5pb247XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBhcHBlbmRfYWN0aW9uOiBmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkYXBwZW5kID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgICAgIF8uZWFjaChsaXN0X25hbWUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRhcHBlbmRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFwcGVuZFtsaXN0X25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtBUFBFTkRfQUNUSU9OXSA9ICRhcHBlbmQ7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICByZW1vdmVfYWN0aW9uOiBmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkcmVtb3ZlID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgICAgIF8uZWFjaChsaXN0X25hbWUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRyZW1vdmVba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHJlbW92ZVtsaXN0X25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtSRU1PVkVfQUNUSU9OXSA9ICRyZW1vdmU7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBkZWxldGVfYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgZGF0YVtERUxFVEVfQUNUSU9OXSA9ICcnO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59O1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qKlxuICogTWl4cGFuZWwgR3JvdXAgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsR3JvdXAgPSBmdW5jdGlvbigpIHt9O1xuXG5fLmV4dGVuZChNaXhwYW5lbEdyb3VwLnByb3RvdHlwZSwgYXBpQWN0aW9ucyk7XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24obWl4cGFuZWxfaW5zdGFuY2UsIGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICB0aGlzLl9taXhwYW5lbCA9IG1peHBhbmVsX2luc3RhbmNlO1xuICAgIHRoaXMuX2dyb3VwX2tleSA9IGdyb3VwX2tleTtcbiAgICB0aGlzLl9ncm91cF9pZCA9IGdyb3VwX2lkO1xufTtcblxuLyoqXG4gKiBTZXQgcHJvcGVydGllcyBvbiBhIGdyb3VwLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0KCdMb2NhdGlvbicsICc0MDUgSG93YXJkJyk7XG4gKlxuICogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXQoe1xuICogICAgICAgICAgJ0xvY2F0aW9uJzogJzQwNSBIb3dhcmQnLFxuICogICAgICAgICAgJ0ZvdW5kZWQnIDogMjAwOSxcbiAqICAgICB9KTtcbiAqICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgZGF0ZXMsIG9yIGxpc3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAsIG9ubHkgaWYgdGhleSBkbyBub3QgeWV0IGV4aXN0LlxuICogVGhpcyB3aWxsIG5vdCBvdmVyd3JpdGUgcHJldmlvdXMgZ3JvdXAgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2VcbiAqIGdyb3VwLnNldCgpLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0X29uY2UoJ0xvY2F0aW9uJywgJzQwNSBIb3dhcmQnKTtcbiAqXG4gKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldF9vbmNlKHtcbiAqICAgICAgICAgICdMb2NhdGlvbic6ICc0MDUgSG93YXJkJyxcbiAqICAgICAgICAgICdGb3VuZGVkJyA6IDIwMDksXG4gKiAgICAgfSk7XG4gKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMsIGxpc3RzIG9yIGRhdGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0X29uY2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9vbmNlX2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBVbnNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAgcGVybWFuZW50bHkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS51bnNldCgnRm91bmRlZCcpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMudW5zZXRfYWN0aW9uKHByb3ApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogTWVyZ2UgYSBnaXZlbiBsaXN0IHdpdGggYSBsaXN0LXZhbHVlZCBncm91cCBwcm9wZXJ0eSwgZXhjbHVkaW5nIGR1cGxpY2F0ZSB2YWx1ZXMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBtZXJnZSBhIHZhbHVlIHRvIGEgbGlzdCwgY3JlYXRpbmcgaXQgaWYgbmVlZGVkXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykudW5pb24oJ0xvY2F0aW9uJywgWydTYW4gRnJhbmNpc2NvJywgJ0xvbmRvbiddKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGlzdF9uYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFZhbHVlcyB0byBtZXJnZSB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0eVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bmlvbiA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlcywgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWVzO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMudW5pb25fYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFBlcm1hbmVudGx5IGRlbGV0ZSBhIGdyb3VwLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuZGVsZXRlKCk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAvLyBicmFja2V0IG5vdGF0aW9uIGFib3ZlIHByZXZlbnRzIGEgbWluaWZpY2F0aW9uIGVycm9yIHJlbGF0ZWQgdG8gcmVzZXJ2ZWQgd29yZHNcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGVsZXRlX2FjdGlvbigpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUmVtb3ZlIGEgcHJvcGVydHkgZnJvbSBhIGdyb3VwLiBUaGUgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGlmIGRvZXNuJ3QgZXhpc3QuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5yZW1vdmUoJ0xvY2F0aW9uJywgJ0xvbmRvbicpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0X25hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVmFsdWUgdG8gcmVtb3ZlIGZyb20gdGhlIGdpdmVuIGdyb3VwIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yZW1vdmVfYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICAgIGRhdGFbJyRncm91cF9rZXknXSA9IHRoaXMuX2dyb3VwX2tleTtcbiAgICBkYXRhWyckZ3JvdXBfaWQnXSA9IHRoaXMuX2dyb3VwX2lkO1xuICAgIGRhdGFbJyR0b2tlbiddID0gdGhpcy5fZ2V0X2NvbmZpZygndG9rZW4nKTtcblxuICAgIHZhciBkYXRlX2VuY29kZWRfZGF0YSA9IF8uZW5jb2RlRGF0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdncm91cHMnLFxuICAgICAgICBkYXRhOiBkYXRlX2VuY29kZWRfZGF0YSxcbiAgICAgICAgZW5kcG9pbnQ6IHRoaXMuX2dldF9jb25maWcoJ2FwaV9ob3N0JykgKyAnLycgKyAgdGhpcy5fZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpWydncm91cHMnXSxcbiAgICAgICAgYmF0Y2hlcjogdGhpcy5fbWl4cGFuZWwucmVxdWVzdF9iYXRjaGVycy5ncm91cHNcbiAgICB9LCBjYWxsYmFjayk7XG59O1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5faXNfcmVzZXJ2ZWRfcHJvcGVydHkgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgPT09ICckZ3JvdXBfa2V5JyB8fCBwcm9wID09PSAnJGdyb3VwX2lkJztcbn07XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9nZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZikge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5nZXRfY29uZmlnKGNvbmYpO1xufTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwudG9TdHJpbmcoKSArICcuZ3JvdXAuJyArIHRoaXMuX2dyb3VwX2tleSArICcuJyArIHRoaXMuX2dyb3VwX2lkO1xufTtcblxuLy8gTWl4cGFuZWxHcm91cCBFeHBvcnRzXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsncmVtb3ZlJ10gICA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnJlbW92ZTtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydzZXQnXSAgICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0O1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3NldF9vbmNlJ10gPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXRfb25jZTtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWyd1bmlvbiddICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5pb247XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsndW5zZXQnXSAgICA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuc2V0O1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3RvU3RyaW5nJ10gPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS50b1N0cmluZztcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKipcbiAqIE1peHBhbmVsIFBlb3BsZSBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxQZW9wbGUgPSBmdW5jdGlvbigpIHt9O1xuXG5fLmV4dGVuZChNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUsIGFwaUFjdGlvbnMpO1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxfaW5zdGFuY2U7XG59O1xuXG4vKlxuKiBTZXQgcHJvcGVydGllcyBvbiBhIHVzZXIgcmVjb3JkLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0KCdnZW5kZXInLCAnbScpO1xuKlxuKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldCh7XG4qICAgICAgICAgJ0NvbXBhbnknOiAnQWNtZScsXG4qICAgICAgICAgJ1BsYW4nOiAnUHJlbWl1bScsXG4qICAgICAgICAgJ1VwZ3JhZGUgZGF0ZSc6IG5ldyBEYXRlKClcbiogICAgIH0pO1xuKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMsIGRhdGVzLCBvciBsaXN0c1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSByZWZlcnJlciBpbmZvIGhhcyBiZWVuIHVwZGF0ZWQgYW5kIHNhdmVkXG4gICAgaWYgKHRoaXMuX2dldF9jb25maWcoJ3NhdmVfcmVmZXJyZXInKSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS51cGRhdGVfcmVmZXJyZXJfaW5mbyhkb2N1bWVudC5yZWZlcnJlcik7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlICRzZXQgb2JqZWN0IHdpdGggZGVmYXVsdCBwZW9wbGUgcHJvcGVydGllc1xuICAgIGRhdGFbU0VUX0FDVElPTl0gPSBfLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIF8uaW5mby5wZW9wbGVfcHJvcGVydGllcygpLFxuICAgICAgICBkYXRhW1NFVF9BQ1RJT05dXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBTZXQgcHJvcGVydGllcyBvbiBhIHVzZXIgcmVjb3JkLCBvbmx5IGlmIHRoZXkgZG8gbm90IHlldCBleGlzdC5cbiogVGhpcyB3aWxsIG5vdCBvdmVyd3JpdGUgcHJldmlvdXMgcGVvcGxlIHByb3BlcnR5IHZhbHVlcywgdW5saWtlXG4qIHBlb3BsZS5zZXQoKS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldF9vbmNlKCdGaXJzdCBMb2dpbiBEYXRlJywgbmV3IERhdGUoKSk7XG4qXG4qICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0X29uY2Uoe1xuKiAgICAgICAgICdGaXJzdCBMb2dpbiBEYXRlJzogbmV3IERhdGUoKSxcbiogICAgICAgICAnU3RhcnRpbmcgUGxhbic6ICdQcmVtaXVtJ1xuKiAgICAgfSk7XG4qXG4qICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycyBvciBkYXRlc1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldF9vbmNlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X29uY2VfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBVbnNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQgKHBlcm1hbmVudGx5IHJlbW92ZXMgdGhlIHByb3BlcnRpZXMgYW5kIHRoZWlyIHZhbHVlcyBmcm9tIGEgcHJvZmlsZSkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bnNldCgnZ2VuZGVyJyk7XG4qXG4qICAgICAvLyBvciB1bnNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bnNldChbJ2dlbmRlcicsICdDb21wYW55J10pO1xuKlxuKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIGFycmF5LCB0aGlzIGlzIGEgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcy5cbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuc2V0X2FjdGlvbihwcm9wKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBJbmNyZW1lbnQvZGVjcmVtZW50IG51bWVyaWMgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0aWVzLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwYWdlX3ZpZXdzJywgMSk7XG4qXG4qICAgICAvLyBvciwgZm9yIGNvbnZlbmllbmNlLCBpZiB5b3UncmUganVzdCBpbmNyZW1lbnRpbmcgYSBjb3VudGVyIGJ5XG4qICAgICAvLyAxLCB5b3UgY2FuIHNpbXBseSBkb1xuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgncGFnZV92aWV3cycpO1xuKlxuKiAgICAgLy8gdG8gZGVjcmVtZW50IGEgY291bnRlciwgcGFzcyBhIG5lZ2F0aXZlIG51bWJlclxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgnY3JlZGl0c19sZWZ0JywgLTEpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gaW5jcmVtZW50IG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KHtcbiogICAgICAgICBjb3VudGVyMTogMSxcbiogICAgICAgICBjb3VudGVyMjogNlxuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgbnVtZXJpYyB2YWx1ZXMuXG4qIEBwYXJhbSB7TnVtYmVyfSBbYnldIEFuIGFtb3VudCB0byBpbmNyZW1lbnQgdGhlIGdpdmVuIHByb3BlcnR5XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmluY3JlbWVudCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgYnksIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB7fTtcbiAgICB2YXIgJGFkZCA9IHt9O1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQodikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCBpbmNyZW1lbnQgdmFsdWUgcGFzc2VkIHRvIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQgLSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkYWRkW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBjYWxsYmFjayA9IGJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnZlbmllbmNlOiBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwcm9wZXJ0eScpOyB3aWxsXG4gICAgICAgIC8vIGluY3JlbWVudCAncHJvcGVydHknIGJ5IDFcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoYnkpKSB7XG4gICAgICAgICAgICBieSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgJGFkZFtwcm9wXSA9IGJ5O1xuICAgIH1cbiAgICBkYXRhW0FERF9BQ1RJT05dID0gJGFkZDtcblxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIEFwcGVuZCBhIHZhbHVlIHRvIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgLy8gYXBwZW5kIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiogICAgIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoJ3BhZ2VzX3Zpc2l0ZWQnLCAnaG9tZXBhZ2UnKTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLnNldCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZVxuKiAgICAgLy8gcHJvcGVydGllcyBhdCBvbmNlOlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCh7XG4qICAgICAgICAgbGlzdDE6ICdib2InLFxuKiAgICAgICAgIGxpc3QyOiAxMjNcbiogICAgIH0pO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxpc3RfbmFtZSBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt2YWx1ZV0gdmFsdWUgQW4gaXRlbSB0byBhcHBlbmQgdG8gdGhlIGxpc3RcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuYXBwZW5kID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLmFwcGVuZF9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogUmVtb3ZlIGEgdmFsdWUgZnJvbSBhIGxpc3QtdmFsdWVkIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydHkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5yZW1vdmUoJ1NjaG9vbCcsICdVQ0InKTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsaXN0X25hbWUgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdmFsdWVdIHZhbHVlIEl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3RcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUucmVtb3ZlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlbW92ZV9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogTWVyZ2UgYSBnaXZlbiBsaXN0IHdpdGggYSBsaXN0LXZhbHVlZCBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnR5LFxuKiBleGNsdWRpbmcgZHVwbGljYXRlIHZhbHVlcy5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgLy8gbWVyZ2UgYSB2YWx1ZSB0byBhIGxpc3QsIGNyZWF0aW5nIGl0IGlmIG5lZWRlZFxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKCdwYWdlc192aXNpdGVkJywgJ2hvbWVwYWdlJyk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5zZXQoKSwgeW91IGNhbiBhcHBlbmQgbXVsdGlwbGVcbiogICAgIC8vIHByb3BlcnRpZXMgYXQgb25jZTpcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bmlvbih7XG4qICAgICAgICAgbGlzdDE6ICdib2InLFxuKiAgICAgICAgIGxpc3QyOiAxMjNcbiogICAgIH0pO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuYXBwZW5kKCksIHlvdSBjYW4gYXBwZW5kIG11bHRpcGxlXG4qICAgICAvLyB2YWx1ZXMgdG8gdGhlIHNhbWUgbGlzdDpcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bmlvbih7XG4qICAgICAgICAgbGlzdDE6IFsnYm9iJywgJ2JpbGx5J11cbiogICAgIH0pO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxpc3RfbmFtZSBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt2YWx1ZV0gVmFsdWUgLyB2YWx1ZXMgdG8gbWVyZ2Ugd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydHlcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5pb24gPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy51bmlvbl9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4gKiBSZWNvcmQgdGhhdCB5b3UgaGF2ZSBjaGFyZ2VkIHRoZSBjdXJyZW50IHVzZXIgYSBjZXJ0YWluIGFtb3VudFxuICogb2YgbW9uZXkuIENoYXJnZXMgcmVjb3JkZWQgd2l0aCB0cmFja19jaGFyZ2UoKSB3aWxsIGFwcGVhciBpbiB0aGVcbiAqIE1peHBhbmVsIHJldmVudWUgcmVwb3J0LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gY2hhcmdlIGEgdXNlciAkNTBcbiAqICAgICBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlKDUwKTtcbiAqXG4gKiAgICAgLy8gY2hhcmdlIGEgdXNlciAkMzAuNTAgb24gdGhlIDJuZCBvZiBqYW51YXJ5XG4gKiAgICAgbWl4cGFuZWwucGVvcGxlLnRyYWNrX2NoYXJnZSgzMC41MCwge1xuICogICAgICAgICAnJHRpbWUnOiBuZXcgRGF0ZSgnamFuIDEgMjAxMicpXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgYW1vdW50IG9mIG1vbmV5IGNoYXJnZWQgdG8gdGhlIGN1cnJlbnQgdXNlclxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hhcmdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc2VydmVyIHJlc3BvbmRzXG4gKiBAZGVwcmVjYXRlZFxuICovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudHJhY2tfY2hhcmdlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihhbW91bnQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFfLmlzTnVtYmVyKGFtb3VudCkpIHtcbiAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdChhbW91bnQpO1xuICAgICAgICBpZiAoaXNOYU4oYW1vdW50KSkge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIHZhbHVlIHBhc3NlZCB0byBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlIC0gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kKCckdHJhbnNhY3Rpb25zJywgXy5leHRlbmQoe1xuICAgICAgICAnJGFtb3VudCc6IGFtb3VudFxuICAgIH0sIHByb3BlcnRpZXMpLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiAqIFBlcm1hbmVudGx5IGNsZWFyIGFsbCByZXZlbnVlIHJlcG9ydCB0cmFuc2FjdGlvbnMgZnJvbSB0aGVcbiAqIGN1cnJlbnQgdXNlcidzIHBlb3BsZSBhbmFseXRpY3MgcHJvZmlsZS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLnBlb3BsZS5jbGVhcl9jaGFyZ2VzKCk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5jbGVhcl9jaGFyZ2VzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoJyR0cmFuc2FjdGlvbnMnLCBbXSwgY2FsbGJhY2spO1xufTtcblxuLypcbiogUGVybWFuZW50bHkgZGVsZXRlcyB0aGUgY3VycmVudCBwZW9wbGUgYW5hbHl0aWNzIHByb2ZpbGUgZnJvbVxuKiBNaXhwYW5lbCAodXNpbmcgdGhlIGN1cnJlbnQgZGlzdGluY3RfaWQpLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyByZW1vdmUgdGhlIGFsbCBkYXRhIHlvdSBoYXZlIHN0b3JlZCBhYm91dCB0aGUgY3VycmVudCB1c2VyXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuZGVsZXRlX3VzZXIoKTtcbipcbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuZGVsZXRlX3VzZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignbWl4cGFuZWwucGVvcGxlLmRlbGV0ZV91c2VyKCkgcmVxdWlyZXMgeW91IHRvIGNhbGwgaWRlbnRpZnkoKSBmaXJzdCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkYXRhID0geyckZGVsZXRlJzogdGhpcy5fbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCl9O1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSk7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwudG9TdHJpbmcoKSArICcucGVvcGxlJztcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fc2VuZF9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgICBkYXRhWyckdG9rZW4nXSA9IHRoaXMuX2dldF9jb25maWcoJ3Rva2VuJyk7XG4gICAgZGF0YVsnJGRpc3RpbmN0X2lkJ10gPSB0aGlzLl9taXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKTtcbiAgICB2YXIgZGV2aWNlX2lkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckZGV2aWNlX2lkJyk7XG4gICAgdmFyIHVzZXJfaWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyR1c2VyX2lkJyk7XG4gICAgdmFyIGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJyk7XG4gICAgaWYgKGRldmljZV9pZCkge1xuICAgICAgICBkYXRhWyckZGV2aWNlX2lkJ10gPSBkZXZpY2VfaWQ7XG4gICAgfVxuICAgIGlmICh1c2VyX2lkKSB7XG4gICAgICAgIGRhdGFbJyR1c2VyX2lkJ10gPSB1c2VyX2lkO1xuICAgIH1cbiAgICBpZiAoaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCkge1xuICAgICAgICBkYXRhWyckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCddID0gaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZDtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZV9lbmNvZGVkX2RhdGEgPSBfLmVuY29kZURhdGVzKGRhdGEpO1xuXG4gICAgaWYgKCF0aGlzLl9pZGVudGlmeV9jYWxsZWQoKSkge1xuICAgICAgICB0aGlzLl9lbnF1ZXVlKGRhdGEpO1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0X2NvbmZpZygndmVyYm9zZScpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soe3N0YXR1czogLTEsIGVycm9yOiBudWxsfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXy50cnVuY2F0ZShkYXRlX2VuY29kZWRfZGF0YSwgMjU1KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ3Blb3BsZScsXG4gICAgICAgIGRhdGE6IGRhdGVfZW5jb2RlZF9kYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5fZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArICcvJyArICB0aGlzLl9nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ2VuZ2FnZSddLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLl9taXhwYW5lbC5yZXF1ZXN0X2JhdGNoZXJzLnBlb3BsZVxuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZfdmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZl92YXIpO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9pZGVudGlmeV9jYWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX2ZsYWdzLmlkZW50aWZ5X2NhbGxlZCA9PT0gdHJ1ZTtcbn07XG5cbi8vIFF1ZXVlIHVwIGVuZ2FnZSBvcGVyYXRpb25zIGlmIGlkZW50aWZ5IGhhc24ndCBiZWVuIGNhbGxlZCB5ZXQuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2VucXVldWUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKFNFVF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShTRVRfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFNFVF9PTkNFX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChVTlNFVF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoQUREX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFERF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoQVBQRU5EX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoUkVNT1ZFX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoVU5JT05fQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoVU5JT05fQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ0ludmFsaWQgY2FsbCB0byBfZW5xdWV1ZSgpOicsIGRhdGEpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZmx1c2hfb25lX3F1ZXVlID0gZnVuY3Rpb24oYWN0aW9uLCBhY3Rpb25fbWV0aG9kLCBjYWxsYmFjaywgcXVldWVfdG9fcGFyYW1zX2ZuKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgcXVldWVkX2RhdGEgPSBfLmV4dGVuZCh7fSwgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShhY3Rpb24pKTtcbiAgICB2YXIgYWN0aW9uX3BhcmFtcyA9IHF1ZXVlZF9kYXRhO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHF1ZXVlZF9kYXRhKSAmJiBfLmlzT2JqZWN0KHF1ZXVlZF9kYXRhKSAmJiAhXy5pc0VtcHR5T2JqZWN0KHF1ZXVlZF9kYXRhKSkge1xuICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShhY3Rpb24sIHF1ZXVlZF9kYXRhKTtcbiAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnNhdmUoKTtcbiAgICAgICAgaWYgKHF1ZXVlX3RvX3BhcmFtc19mbikge1xuICAgICAgICAgICAgYWN0aW9uX3BhcmFtcyA9IHF1ZXVlX3RvX3BhcmFtc19mbihxdWV1ZWRfZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9uX21ldGhvZC5jYWxsKF90aGlzLCBhY3Rpb25fcGFyYW1zLCBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICAgICAgLy8gb24gYmFkIHJlc3BvbnNlLCB3ZSB3YW50IHRvIGFkZCBpdCBiYWNrIHRvIHRoZSBxdWV1ZVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKGFjdGlvbiwgcXVldWVkX2RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLy8gRmx1c2ggcXVldWVkIGVuZ2FnZSBvcGVyYXRpb25zIC0gb3JkZXIgZG9lcyBub3QgbWF0dGVyLFxuLy8gYW5kIHRoZXJlIGFyZSBuZXR3b3JrIGxldmVsIHJhY2UgY29uZGl0aW9ucyBhbnl3YXlcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihcbiAgICBfc2V0X2NhbGxiYWNrLCBfYWRkX2NhbGxiYWNrLCBfYXBwZW5kX2NhbGxiYWNrLCBfc2V0X29uY2VfY2FsbGJhY2ssIF91bmlvbl9jYWxsYmFjaywgX3Vuc2V0X2NhbGxiYWNrLCBfcmVtb3ZlX2NhbGxiYWNrXG4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFNFVF9BQ1RJT04sIHRoaXMuc2V0LCBfc2V0X2NhbGxiYWNrKTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoU0VUX09OQ0VfQUNUSU9OLCB0aGlzLnNldF9vbmNlLCBfc2V0X29uY2VfY2FsbGJhY2spO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHRoaXMudW5zZXQsIF91bnNldF9jYWxsYmFjaywgZnVuY3Rpb24ocXVldWUpIHsgcmV0dXJuIF8ua2V5cyhxdWV1ZSk7IH0pO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShBRERfQUNUSU9OLCB0aGlzLmluY3JlbWVudCwgX2FkZF9jYWxsYmFjayk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFVOSU9OX0FDVElPTiwgdGhpcy51bmlvbiwgX3VuaW9uX2NhbGxiYWNrKTtcblxuICAgIC8vIHdlIGhhdmUgdG8gZmlyZSBvZmYgZWFjaCAkYXBwZW5kIGluZGl2aWR1YWxseSBzaW5jZSB0aGVyZSBpc1xuICAgIC8vIG5vIGNvbmNhdCBtZXRob2Qgc2VydmVyIHNpZGVcbiAgICB2YXIgJGFwcGVuZF9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoQVBQRU5EX0FDVElPTik7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKCRhcHBlbmRfcXVldWUpICYmIF8uaXNBcnJheSgkYXBwZW5kX3F1ZXVlKSAmJiAkYXBwZW5kX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgJGFwcGVuZF9pdGVtO1xuICAgICAgICB2YXIgYXBwZW5kX2NhbGxiYWNrID0gZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCAkYXBwZW5kX2l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF9hcHBlbmRfY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgX2FwcGVuZF9jYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAkYXBwZW5kX3F1ZXVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAkYXBwZW5kX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShBUFBFTkRfQUNUSU9OKTtcbiAgICAgICAgICAgICRhcHBlbmRfaXRlbSA9ICRhcHBlbmRfcXVldWUucG9wKCk7XG4gICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHlPYmplY3QoJGFwcGVuZF9pdGVtKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFwcGVuZCgkYXBwZW5kX2l0ZW0sIGFwcGVuZF9jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW1lIGZvciAkcmVtb3ZlXG4gICAgdmFyICRyZW1vdmVfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKFJFTU9WRV9BQ1RJT04pO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCgkcmVtb3ZlX3F1ZXVlKSAmJiBfLmlzQXJyYXkoJHJlbW92ZV9xdWV1ZSkgJiYgJHJlbW92ZV9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyICRyZW1vdmVfaXRlbTtcbiAgICAgICAgdmFyIHJlbW92ZV9jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoUkVNT1ZFX0FDVElPTiwgJHJlbW92ZV9pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChfcmVtb3ZlX2NhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIF9yZW1vdmVfY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBqID0gJHJlbW92ZV9xdWV1ZS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgJHJlbW92ZV9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoUkVNT1ZFX0FDVElPTik7XG4gICAgICAgICAgICAkcmVtb3ZlX2l0ZW0gPSAkcmVtb3ZlX3F1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnNhdmUoKTtcbiAgICAgICAgICAgIGlmICghXy5pc0VtcHR5T2JqZWN0KCRyZW1vdmVfaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmUoJHJlbW92ZV9pdGVtLCByZW1vdmVfY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9pc19yZXNlcnZlZF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJyRkaXN0aW5jdF9pZCcgfHwgcHJvcCA9PT0gJyR0b2tlbicgfHwgcHJvcCA9PT0gJyRkZXZpY2VfaWQnIHx8IHByb3AgPT09ICckdXNlcl9pZCcgfHwgcHJvcCA9PT0gJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJztcbn07XG5cbi8vIE1peHBhbmVsUGVvcGxlIEV4cG9ydHNcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnc2V0J10gICAgICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnc2V0X29uY2UnXSAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldF9vbmNlO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd1bnNldCddICAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5zZXQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2luY3JlbWVudCddICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5pbmNyZW1lbnQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2FwcGVuZCddICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5hcHBlbmQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3JlbW92ZSddICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5yZW1vdmU7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3VuaW9uJ10gICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bmlvbjtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndHJhY2tfY2hhcmdlJ10gID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRyYWNrX2NoYXJnZTtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnY2xlYXJfY2hhcmdlcyddID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmNsZWFyX2NoYXJnZXM7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2RlbGV0ZV91c2VyJ10gICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5kZWxldGVfdXNlcjtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndG9TdHJpbmcnXSAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qXG4gKiBDb25zdGFudHNcbiAqL1xuLyoqIEBjb25zdCAqLyB2YXIgU0VUX1FVRVVFX0tFWSAgICAgICAgICA9ICdfX21wcyc7XG4vKiogQGNvbnN0ICovIHZhciBTRVRfT05DRV9RVUVVRV9LRVkgICAgID0gJ19fbXBzbyc7XG4vKiogQGNvbnN0ICovIHZhciBVTlNFVF9RVUVVRV9LRVkgICAgICAgID0gJ19fbXB1cyc7XG4vKiogQGNvbnN0ICovIHZhciBBRERfUVVFVUVfS0VZICAgICAgICAgID0gJ19fbXBhJztcbi8qKiBAY29uc3QgKi8gdmFyIEFQUEVORF9RVUVVRV9LRVkgICAgICAgPSAnX19tcGFwJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFTU9WRV9RVUVVRV9LRVkgICAgICAgPSAnX19tcHInO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5JT05fUVVFVUVfS0VZICAgICAgICA9ICdfX21wdSc7XG4vLyBUaGlzIGtleSBpcyBkZXByZWNhdGVkLCBidXQgd2Ugd2FudCB0byBjaGVjayBmb3IgaXQgdG8gc2VlIHdoZXRoZXIgYWxpYXNpbmcgaXMgYWxsb3dlZC5cbi8qKiBAY29uc3QgKi8gdmFyIFBFT1BMRV9ESVNUSU5DVF9JRF9LRVkgPSAnJHBlb3BsZV9kaXN0aW5jdF9pZCc7XG4vKiogQGNvbnN0ICovIHZhciBBTElBU19JRF9LRVkgICAgICAgICAgID0gJ19fYWxpYXMnO1xuLyoqIEBjb25zdCAqLyB2YXIgRVZFTlRfVElNRVJTX0tFWSAgICAgICA9ICdfX3RpbWVycyc7XG4vKiogQGNvbnN0ICovIHZhciBSRVNFUlZFRF9QUk9QRVJUSUVTID0gW1xuICAgIFNFVF9RVUVVRV9LRVksXG4gICAgU0VUX09OQ0VfUVVFVUVfS0VZLFxuICAgIFVOU0VUX1FVRVVFX0tFWSxcbiAgICBBRERfUVVFVUVfS0VZLFxuICAgIEFQUEVORF9RVUVVRV9LRVksXG4gICAgUkVNT1ZFX1FVRVVFX0tFWSxcbiAgICBVTklPTl9RVUVVRV9LRVksXG4gICAgUEVPUExFX0RJU1RJTkNUX0lEX0tFWSxcbiAgICBBTElBU19JRF9LRVksXG4gICAgRVZFTlRfVElNRVJTX0tFWVxuXTtcblxuLyoqXG4gKiBNaXhwYW5lbCBQZXJzaXN0ZW5jZSBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxQZXJzaXN0ZW5jZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXNbJ3Byb3BzJ10gPSB7fTtcbiAgICB0aGlzLmNhbXBhaWduX3BhcmFtc19zYXZlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGNvbmZpZ1sncGVyc2lzdGVuY2VfbmFtZSddKSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICdtcF8nICsgY29uZmlnWydwZXJzaXN0ZW5jZV9uYW1lJ107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ21wXycgKyBjb25maWdbJ3Rva2VuJ10gKyAnX21peHBhbmVsJztcbiAgICB9XG5cbiAgICB2YXIgc3RvcmFnZV90eXBlID0gY29uZmlnWydwZXJzaXN0ZW5jZSddO1xuICAgIGlmIChzdG9yYWdlX3R5cGUgIT09ICdjb29raWUnICYmIHN0b3JhZ2VfdHlwZSAhPT0gJ2xvY2FsU3RvcmFnZScpIHtcbiAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKCdVbmtub3duIHBlcnNpc3RlbmNlIHR5cGUgJyArIHN0b3JhZ2VfdHlwZSArICc7IGZhbGxpbmcgYmFjayB0byBjb29raWUnKTtcbiAgICAgICAgc3RvcmFnZV90eXBlID0gY29uZmlnWydwZXJzaXN0ZW5jZSddID0gJ2Nvb2tpZSc7XG4gICAgfVxuXG4gICAgaWYgKHN0b3JhZ2VfdHlwZSA9PT0gJ2xvY2FsU3RvcmFnZScgJiYgXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gXy5sb2NhbFN0b3JhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gXy5jb29raWU7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkKCk7XG4gICAgdGhpcy51cGRhdGVfY29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy51cGdyYWRlKCk7XG4gICAgdGhpcy5zYXZlKCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5wcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHAgPSB7fTtcblxuICAgIHRoaXMubG9hZCgpO1xuXG4gICAgLy8gRmlsdGVyIG91dCByZXNlcnZlZCBwcm9wZXJ0aWVzXG4gICAgXy5lYWNoKHRoaXNbJ3Byb3BzJ10sIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgaWYgKCFfLmluY2x1ZGUoUkVTRVJWRURfUFJPUEVSVElFUywgaykpIHtcbiAgICAgICAgICAgIHBba10gPSB2O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHA7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgZW50cnkgPSB0aGlzLnN0b3JhZ2UucGFyc2UodGhpcy5uYW1lKTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgICB0aGlzWydwcm9wcyddID0gXy5leHRlbmQoe30sIGVudHJ5KTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGdyYWRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9sZF9jb29raWUsXG4gICAgICAgIG9sZF9sb2NhbHN0b3JhZ2U7XG5cbiAgICAvLyBpZiB0cmFuc2ZlcnJpbmcgZnJvbSBjb29raWUgdG8gbG9jYWxTdG9yYWdlIG9yIHZpY2UtdmVyc2EsIGNvcHkgZXhpc3RpbmdcbiAgICAvLyBzdXBlciBwcm9wZXJ0aWVzIG92ZXIgdG8gbmV3IHN0b3JhZ2UgbW9kZVxuICAgIGlmICh0aGlzLnN0b3JhZ2UgPT09IF8ubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIG9sZF9jb29raWUgPSBfLmNvb2tpZS5wYXJzZSh0aGlzLm5hbWUpO1xuXG4gICAgICAgIF8uY29va2llLnJlbW92ZSh0aGlzLm5hbWUpO1xuICAgICAgICBfLmNvb2tpZS5yZW1vdmUodGhpcy5uYW1lLCB0cnVlKTtcblxuICAgICAgICBpZiAob2xkX2Nvb2tpZSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKG9sZF9jb29raWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0b3JhZ2UgPT09IF8uY29va2llKSB7XG4gICAgICAgIG9sZF9sb2NhbHN0b3JhZ2UgPSBfLmxvY2FsU3RvcmFnZS5wYXJzZSh0aGlzLm5hbWUpO1xuXG4gICAgICAgIF8ubG9jYWxTdG9yYWdlLnJlbW92ZSh0aGlzLm5hbWUpO1xuXG4gICAgICAgIGlmIChvbGRfbG9jYWxzdG9yYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uob2xkX2xvY2Fsc3RvcmFnZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLnN0b3JhZ2Uuc2V0KFxuICAgICAgICB0aGlzLm5hbWUsXG4gICAgICAgIF8uSlNPTkVuY29kZSh0aGlzWydwcm9wcyddKSxcbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyxcbiAgICAgICAgdGhpcy5jcm9zc19zdWJkb21haW4sXG4gICAgICAgIHRoaXMuc2VjdXJlLFxuICAgICAgICB0aGlzLmNyb3NzX3NpdGUsXG4gICAgICAgIHRoaXMuY29va2llX2RvbWFpblxuICAgICk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5sb2FkX3Byb3AgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB0aGlzLmxvYWQoKTtcbiAgICByZXR1cm4gdGhpc1sncHJvcHMnXVtrZXldO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gcmVtb3ZlIGJvdGggZG9tYWluIGFuZCBzdWJkb21haW4gY29va2llc1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5uYW1lLCBmYWxzZSwgdGhpcy5jb29raWVfZG9tYWluKTtcbiAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSwgdHJ1ZSwgdGhpcy5jb29raWVfZG9tYWluKTtcbn07XG5cbi8vIHJlbW92ZXMgdGhlIHN0b3JhZ2UgZW50cnkgYW5kIGRlbGV0ZXMgYWxsIGxvYWRlZCBkYXRhXG4vLyBmb3JjZWQgbmFtZSBmb3IgdGVzdHNcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICB0aGlzWydwcm9wcyddID0ge307XG59O1xuXG4vKipcbiogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4qIEBwYXJhbSB7Kj19IGRlZmF1bHRfdmFsdWVcbiogQHBhcmFtIHtudW1iZXI9fSBkYXlzXG4qL1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVnaXN0ZXJfb25jZSA9IGZ1bmN0aW9uKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBkYXlzKSB7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YoZGVmYXVsdF92YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7IGRlZmF1bHRfdmFsdWUgPSAnTm9uZSc7IH1cbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyA9ICh0eXBlb2YoZGF5cykgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMuZGVmYXVsdF9leHBpcnkgOiBkYXlzO1xuXG4gICAgICAgIHRoaXMubG9hZCgpO1xuXG4gICAgICAgIF8uZWFjaChwcm9wcywgZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXNbJ3Byb3BzJ10uaGFzT3duUHJvcGVydHkocHJvcCkgfHwgdGhpc1sncHJvcHMnXVtwcm9wXSA9PT0gZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXNbJ3Byb3BzJ11bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4qIEBwYXJhbSB7bnVtYmVyPX0gZGF5c1xuKi9cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcHMsIGRheXMpIHtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyA9ICh0eXBlb2YoZGF5cykgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMuZGVmYXVsdF9leHBpcnkgOiBkYXlzO1xuXG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICBfLmV4dGVuZCh0aGlzWydwcm9wcyddLCBwcm9wcyk7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHRoaXMubG9hZCgpO1xuICAgIGlmIChwcm9wIGluIHRoaXNbJ3Byb3BzJ10pIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ3Byb3BzJ11bcHJvcF07XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9zZWFyY2hfa2V5d29yZCA9IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgdGhpcy5yZWdpc3RlcihfLmluZm8uc2VhcmNoSW5mbyhyZWZlcnJlcikpO1xufTtcblxuLy8gRVhQT1JURUQgTUVUSE9ELCB3ZSB0ZXN0IHRoaXMgZGlyZWN0bHkuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfcmVmZXJyZXJfaW5mbyA9IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgLy8gSWYgcmVmZXJyZXIgZG9lc24ndCBleGlzdCwgd2Ugd2FudCB0byBub3RlIHRoZSBmYWN0IHRoYXQgaXQgd2FzIHR5cGUtaW4gdHJhZmZpYy5cbiAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAnJGluaXRpYWxfcmVmZXJyZXInOiByZWZlcnJlciB8fCAnJGRpcmVjdCcsXG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluJzogXy5pbmZvLnJlZmVycmluZ0RvbWFpbihyZWZlcnJlcikgfHwgJyRkaXJlY3QnXG4gICAgfSwgJycpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X3JlZmVycmVyX2luZm8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmVyJzogdGhpc1sncHJvcHMnXVsnJGluaXRpYWxfcmVmZXJyZXInXSxcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nOiB0aGlzWydwcm9wcyddWyckaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluJ11cbiAgICB9KTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9jb25maWcgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRfZXhwaXJ5ID0gdGhpcy5leHBpcmVfZGF5cyA9IGNvbmZpZ1snY29va2llX2V4cGlyYXRpb24nXTtcbiAgICB0aGlzLnNldF9kaXNhYmxlZChjb25maWdbJ2Rpc2FibGVfcGVyc2lzdGVuY2UnXSk7XG4gICAgdGhpcy5zZXRfY29va2llX2RvbWFpbihjb25maWdbJ2Nvb2tpZV9kb21haW4nXSk7XG4gICAgdGhpcy5zZXRfY3Jvc3Nfc2l0ZShjb25maWdbJ2Nyb3NzX3NpdGVfY29va2llJ10pO1xuICAgIHRoaXMuc2V0X2Nyb3NzX3N1YmRvbWFpbihjb25maWdbJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnXSk7XG4gICAgdGhpcy5zZXRfc2VjdXJlKGNvbmZpZ1snc2VjdXJlX2Nvb2tpZSddKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9kaXNhYmxlZCA9IGZ1bmN0aW9uKGRpc2FibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Nvb2tpZV9kb21haW4gPSBmdW5jdGlvbihjb29raWVfZG9tYWluKSB7XG4gICAgaWYgKGNvb2tpZV9kb21haW4gIT09IHRoaXMuY29va2llX2RvbWFpbikge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmNvb2tpZV9kb21haW4gPSBjb29raWVfZG9tYWluO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfY3Jvc3Nfc2l0ZSA9IGZ1bmN0aW9uKGNyb3NzX3NpdGUpIHtcbiAgICBpZiAoY3Jvc3Nfc2l0ZSAhPT0gdGhpcy5jcm9zc19zaXRlKSB7XG4gICAgICAgIHRoaXMuY3Jvc3Nfc2l0ZSA9IGNyb3NzX3NpdGU7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9jcm9zc19zdWJkb21haW4gPSBmdW5jdGlvbihjcm9zc19zdWJkb21haW4pIHtcbiAgICBpZiAoY3Jvc3Nfc3ViZG9tYWluICE9PSB0aGlzLmNyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICB0aGlzLmNyb3NzX3N1YmRvbWFpbiA9IGNyb3NzX3N1YmRvbWFpbjtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X2Nyb3NzX3N1YmRvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNyb3NzX3N1YmRvbWFpbjtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9zZWN1cmUgPSBmdW5jdGlvbihzZWN1cmUpIHtcbiAgICBpZiAoc2VjdXJlICE9PSB0aGlzLnNlY3VyZSkge1xuICAgICAgICB0aGlzLnNlY3VyZSA9IHNlY3VyZSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX2FkZF90b19wZW9wbGVfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgZGF0YSkge1xuICAgIHZhciBxX2tleSA9IHRoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpLFxuICAgICAgICBxX2RhdGEgPSBkYXRhW3F1ZXVlXSxcbiAgICAgICAgc2V0X3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFNFVF9BQ1RJT04pLFxuICAgICAgICBzZXRfb25jZV9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShTRVRfT05DRV9BQ1RJT04pLFxuICAgICAgICB1bnNldF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShVTlNFVF9BQ1RJT04pLFxuICAgICAgICBhZGRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoQUREX0FDVElPTiksXG4gICAgICAgIHVuaW9uX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFVOSU9OX0FDVElPTiksXG4gICAgICAgIHJlbW92ZV9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShSRU1PVkVfQUNUSU9OLCBbXSksXG4gICAgICAgIGFwcGVuZF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCBbXSk7XG5cbiAgICBpZiAocV9rZXkgPT09IFNFVF9RVUVVRV9LRVkpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZXQgcXVldWUgLSB3ZSBjYW4gb3ZlcnJpZGUgYW55IGV4aXN0aW5nIHZhbHVlc1xuICAgICAgICBfLmV4dGVuZChzZXRfcSwgcV9kYXRhKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgcGVuZGluZyBpbmNyZW1lbnQsIG92ZXJyaWRlIGl0XG4gICAgICAgIC8vIHdpdGggdGhlIHNldC5cbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKEFERF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIHBlbmRpbmcgdW5pb24sIG92ZXJyaWRlIGl0XG4gICAgICAgIC8vIHdpdGggdGhlIHNldC5cbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOSU9OX0FDVElPTiwgcV9kYXRhKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBTRVRfT05DRV9RVUVVRV9LRVkpIHtcbiAgICAgICAgLy8gb25seSBxdWV1ZSB0aGUgZGF0YSBpZiB0aGVyZSBpcyBub3QgYWxyZWFkeSBhIHNldF9vbmNlIGNhbGwgZm9yIGl0LlxuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAoIShrIGluIHNldF9vbmNlX3EpKSB7XG4gICAgICAgICAgICAgICAgc2V0X29uY2VfcVtrXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFVOU0VUX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbihwcm9wKSB7XG5cbiAgICAgICAgICAgIC8vIHVuZG8gcHJldmlvdXNseS1xdWV1ZWQgYWN0aW9ucyBvbiB0aGlzIGtleVxuICAgICAgICAgICAgXy5lYWNoKFtzZXRfcSwgc2V0X29uY2VfcSwgYWRkX3EsIHVuaW9uX3FdLCBmdW5jdGlvbihlbnF1ZXVlZF9vYmopIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBlbnF1ZXVlZF9vYmopIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVucXVldWVkX29ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF8uZWFjaChhcHBlbmRfcSwgZnVuY3Rpb24oYXBwZW5kX29iaikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIGFwcGVuZF9vYmopIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFwcGVuZF9vYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHVuc2V0X3FbcHJvcF0gPSB0cnVlO1xuXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IEFERF9RVUVVRV9LRVkpIHtcbiAgICAgICAgXy5lYWNoKHFfZGF0YSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgLy8gSWYgaXQgZXhpc3RzIGluIHRoZSBzZXQgcXVldWUsIGluY3JlbWVudFxuICAgICAgICAgICAgLy8gdGhlIHZhbHVlXG4gICAgICAgICAgICBpZiAoayBpbiBzZXRfcSkge1xuICAgICAgICAgICAgICAgIHNldF9xW2tdICs9IHY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHVwZGF0ZSB0aGUgYWRkXG4gICAgICAgICAgICAgICAgLy8gcXVldWVcbiAgICAgICAgICAgICAgICBpZiAoIShrIGluIGFkZF9xKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRfcVtrXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZF9xW2tdICs9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFVOSU9OX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoayBpbiB1bmlvbl9xKSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlvbl9xW2tdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIG1heSBzZW5kIGR1cGxpY2F0ZXMsIHRoZSBzZXJ2ZXIgd2lsbCBkZWR1cCB0aGVtLlxuICAgICAgICAgICAgICAgIHVuaW9uX3Fba10gPSB1bmlvbl9xW2tdLmNvbmNhdCh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gUkVNT1ZFX1FVRVVFX0tFWSkge1xuICAgICAgICByZW1vdmVfcS5wdXNoKHFfZGF0YSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IEFQUEVORF9RVUVVRV9LRVkpIHtcbiAgICAgICAgYXBwZW5kX3EucHVzaChxX2RhdGEpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH1cblxuICAgIGNvbnNvbGUkMS5sb2coJ01JWFBBTkVMIFBFT1BMRSBSRVFVRVNUIChRVUVVRUQsIFBFTkRJTkcgSURFTlRJRlkpOicpO1xuICAgIGNvbnNvbGUkMS5sb2coZGF0YSk7XG5cbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgZGF0YSkge1xuICAgIHZhciBxID0gdGhpc1sncHJvcHMnXVt0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKV07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHEpKSB7XG4gICAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAocXVldWUgPT09IEFQUEVORF9BQ1RJT04gfHwgcXVldWUgPT09IFJFTU9WRV9BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAvLyBsaXN0IGFjdGlvbnM6IG9ubHkgcmVtb3ZlIGlmIGJvdGggayt2IG1hdGNoXG4gICAgICAgICAgICAgICAgLy8gZS5nLiByZW1vdmUgc2hvdWxkIG5vdCBvdmVycmlkZSBhcHBlbmQgaW4gYSBjYXNlIGxpa2VcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQoe2ZvbzogJ2Jhcid9KTsgcmVtb3ZlKHtmb286ICdxdXgnfSlcbiAgICAgICAgICAgICAgICBfLmVhY2gocSwgZnVuY3Rpb24ocXVldWVkX2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVkX2FjdGlvbltrXSA9PT0gdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlZF9hY3Rpb25ba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHFba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWRfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSkge1xuICAgIHJldHVybiB0aGlzLmxvYWRfcHJvcCh0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKSk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fZ2V0X3F1ZXVlX2tleSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgaWYgKHF1ZXVlID09PSBTRVRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBTRVRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFNFVF9PTkNFX0FDVElPTikge1xuICAgICAgICByZXR1cm4gU0VUX09OQ0VfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFVOU0VUX0FDVElPTikge1xuICAgICAgICByZXR1cm4gVU5TRVRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IEFERF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIEFERF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gQVBQRU5EX0FDVElPTikge1xuICAgICAgICByZXR1cm4gQVBQRU5EX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBSRU1PVkVfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBSRU1PVkVfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFVOSU9OX0FDVElPTikge1xuICAgICAgICByZXR1cm4gVU5JT05fUVVFVUVfS0VZO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCBxdWV1ZTonLCBxdWV1ZSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX2dldF9vcl9jcmVhdGVfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgZGVmYXVsdF92YWwpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSk7XG4gICAgZGVmYXVsdF92YWwgPSBfLmlzVW5kZWZpbmVkKGRlZmF1bHRfdmFsKSA/IHt9IDogZGVmYXVsdF92YWw7XG4gICAgcmV0dXJuIHRoaXNbJ3Byb3BzJ11ba2V5XSB8fCAodGhpc1sncHJvcHMnXVtrZXldID0gZGVmYXVsdF92YWwpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2V2ZW50X3RpbWVyID0gZnVuY3Rpb24oZXZlbnRfbmFtZSwgdGltZXN0YW1wKSB7XG4gICAgdmFyIHRpbWVycyA9IHRoaXMubG9hZF9wcm9wKEVWRU5UX1RJTUVSU19LRVkpIHx8IHt9O1xuICAgIHRpbWVyc1tldmVudF9uYW1lXSA9IHRpbWVzdGFtcDtcbiAgICB0aGlzWydwcm9wcyddW0VWRU5UX1RJTUVSU19LRVldID0gdGltZXJzO1xuICAgIHRoaXMuc2F2ZSgpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVtb3ZlX2V2ZW50X3RpbWVyID0gZnVuY3Rpb24oZXZlbnRfbmFtZSkge1xuICAgIHZhciB0aW1lcnMgPSB0aGlzLmxvYWRfcHJvcChFVkVOVF9USU1FUlNfS0VZKSB8fCB7fTtcbiAgICB2YXIgdGltZXN0YW1wID0gdGltZXJzW2V2ZW50X25hbWVdO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCh0aW1lc3RhbXApKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydwcm9wcyddW0VWRU5UX1RJTUVSU19LRVldW2V2ZW50X25hbWVdO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcDtcbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLypcbiAqIE1peHBhbmVsIEpTIExpYnJhcnlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiwgTWl4cGFuZWwsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZFxuICogaHR0cDovL21peHBhbmVsLmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBwb3J0aW9ucyBvZiBVbmRlcnNjb3JlLmpzXG4gKiBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmUvXG4gKiAoYykgMjAxMSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbi8vID09Q2xvc3VyZUNvbXBpbGVyPT1cbi8vIEBjb21waWxhdGlvbl9sZXZlbCBBRFZBTkNFRF9PUFRJTUlaQVRJT05TXG4vLyBAb3V0cHV0X2ZpbGVfbmFtZSBtaXhwYW5lbC0yLjgubWluLmpzXG4vLyA9PS9DbG9zdXJlQ29tcGlsZXI9PVxuXG4vKlxuU0lNUExFIFNUWUxFIEdVSURFOlxuXG50aGlzLnggPT09IHB1YmxpYyBmdW5jdGlvblxudGhpcy5feCA9PT0gaW50ZXJuYWwgLSBvbmx5IHVzZSB3aXRoaW4gdGhpcyBmaWxlXG50aGlzLl9feCA9PT0gcHJpdmF0ZSAtIG9ubHkgdXNlIHdpdGhpbiB0aGUgY2xhc3NcblxuR2xvYmFscyBzaG91bGQgYmUgYWxsIGNhcHNcbiovXG5cbnZhciBpbml0X3R5cGU7ICAgICAgIC8vIE1PRFVMRSBvciBTTklQUEVUIGxvYWRlclxuLy8gYWxsb3cgYnVuZGxlcnMgdG8gc3BlY2lmeSBob3cgZXh0cmEgY29kZSAocmVjb3JkZXIgYnVuZGxlKSBzaG91bGQgYmUgbG9hZGVkXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBsb2FkX2V4dHJhX2J1bmRsZSA9IGZ1bmN0aW9uKHNyYywgX29ubG9hZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihzcmMgKyAnIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBidWlsZC4nKTtcbn07XG5cbnZhciBtaXhwYW5lbF9tYXN0ZXI7IC8vIG1haW4gbWl4cGFuZWwgaW5zdGFuY2UgLyBvYmplY3RcbnZhciBJTklUX01PRFVMRSAgPSAwO1xudmFyIElOSVRfU05JUFBFVCA9IDE7XG5cbnZhciBJREVOVElUWV9GVU5DID0gZnVuY3Rpb24oeCkge3JldHVybiB4O307XG52YXIgTk9PUF9GVU5DID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqIEBjb25zdCAqLyB2YXIgUFJJTUFSWV9JTlNUQU5DRV9OQU1FID0gJ21peHBhbmVsJztcbi8qKiBAY29uc3QgKi8gdmFyIFBBWUxPQURfVFlQRV9CQVNFNjQgICA9ICdiYXNlNjQnO1xuLyoqIEBjb25zdCAqLyB2YXIgUEFZTE9BRF9UWVBFX0pTT04gICAgID0gJ2pzb24nO1xuLyoqIEBjb25zdCAqLyB2YXIgREVWSUNFX0lEX1BSRUZJWCAgICAgID0gJyRkZXZpY2U6JztcblxuXG4vKlxuICogRHluYW1pYy4uLiBjb25zdGFudHM/IElzIHRoYXQgYW4gb3h5bW9yb24/XG4gKi9cbi8vIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vWE1MSHR0cFJlcXVlc3Qjd2l0aENyZWRlbnRpYWxzXG52YXIgVVNFX1hIUiA9ICh3aW4uWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpO1xuXG4vLyBJRTwxMCBkb2VzIG5vdCBzdXBwb3J0IGNyb3NzLW9yaWdpbiBYSFIncyBidXQgc2NyaXB0IHRhZ3Ncbi8vIHdpdGggZGVmZXIgd29uJ3QgYmxvY2sgd2luZG93Lm9ubG9hZDsgRU5RVUVVRV9SRVFVRVNUU1xuLy8gc2hvdWxkIG9ubHkgYmUgdHJ1ZSBmb3IgT3BlcmE8MTJcbnZhciBFTlFVRVVFX1JFUVVFU1RTID0gIVVTRV9YSFIgJiYgKHVzZXJBZ2VudC5pbmRleE9mKCdNU0lFJykgPT09IC0xKSAmJiAodXNlckFnZW50LmluZGV4T2YoJ01vemlsbGEnKSA9PT0gLTEpO1xuXG4vLyBzYXZlIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiBzbyBpdCBjYW4gYmUgbWluaWZpZWRcbnZhciBzZW5kQmVhY29uID0gbnVsbDtcbmlmIChuYXZpZ2F0b3JbJ3NlbmRCZWFjb24nXSkge1xuICAgIHNlbmRCZWFjb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbGF0ZSByZWZlcmVuY2UgdG8gbmF2aWdhdG9yLnNlbmRCZWFjb24gdG8gYWxsb3cgcGF0Y2hpbmcvc3B5aW5nXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3JbJ3NlbmRCZWFjb24nXS5hcHBseShuYXZpZ2F0b3IsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxudmFyIERFRkFVTFRfQVBJX1JPVVRFUyA9IHtcbiAgICAndHJhY2snOiAndHJhY2svJyxcbiAgICAnZW5nYWdlJzogJ2VuZ2FnZS8nLFxuICAgICdncm91cHMnOiAnZ3JvdXBzLycsXG4gICAgJ3JlY29yZCc6ICdyZWNvcmQvJ1xufTtcblxuLypcbiAqIE1vZHVsZS1sZXZlbCBnbG9iYWxzXG4gKi9cbnZhciBERUZBVUxUX0NPTkZJRyA9IHtcbiAgICAnYXBpX2hvc3QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLWpzLm1peHBhbmVsLmNvbScsXG4gICAgJ2FwaV9yb3V0ZXMnOiAgICAgICAgICAgICAgICAgICAgICAgIERFRkFVTFRfQVBJX1JPVVRFUyxcbiAgICAnYXBpX21ldGhvZCc6ICAgICAgICAgICAgICAgICAgICAgICAgJ1BPU1QnLFxuICAgICdhcGlfdHJhbnNwb3J0JzogICAgICAgICAgICAgICAgICAgICAnWEhSJyxcbiAgICAnYXBpX3BheWxvYWRfZm9ybWF0JzogICAgICAgICAgICAgICAgUEFZTE9BRF9UWVBFX0JBU0U2NCxcbiAgICAnYXBwX2hvc3QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vbWl4cGFuZWwuY29tJyxcbiAgICAnY2RuJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY2RuLm14cG5sLmNvbScsXG4gICAgJ2Nyb3NzX3NpdGVfY29va2llJzogICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdjcm9zc19zdWJkb21haW5fY29va2llJzogICAgICAgICAgICB0cnVlLFxuICAgICdlcnJvcl9yZXBvcnRlcic6ICAgICAgICAgICAgICAgICAgICBOT09QX0ZVTkMsXG4gICAgJ3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgICAgICAgICAgICdjb29raWUnLFxuICAgICdwZXJzaXN0ZW5jZV9uYW1lJzogICAgICAgICAgICAgICAgICAnJyxcbiAgICAnY29va2llX2RvbWFpbic6ICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgJ2Nvb2tpZV9uYW1lJzogICAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICdsb2FkZWQnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOT09QX0ZVTkMsXG4gICAgJ21wX2xvYWRlcic6ICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgJ3RyYWNrX21hcmtldGluZyc6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3RyYWNrX3BhZ2V2aWV3JzogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdza2lwX2ZpcnN0X3RvdWNoX21hcmtldGluZyc6ICAgICAgICBmYWxzZSxcbiAgICAnc3RvcmVfZ29vZ2xlJzogICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnc3RvcF91dG1fcGVyc2lzdGVuY2UnOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3NhdmVfcmVmZXJyZXInOiAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3Rlc3QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICd2ZXJib3NlJzogICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnaW1nJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2RlYnVnJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICd0cmFja19saW5rc190aW1lb3V0JzogICAgICAgICAgICAgICAzMDAsXG4gICAgJ2Nvb2tpZV9leHBpcmF0aW9uJzogICAgICAgICAgICAgICAgIDM2NSxcbiAgICAndXBncmFkZSc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2Rpc2FibGVfcGVyc2lzdGVuY2UnOiAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkaXNhYmxlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnc2VjdXJlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2lwJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdCc6ICAgICAgIGZhbHNlLFxuICAgICdvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQnOiAgICBmYWxzZSxcbiAgICAnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJzogJ2xvY2FsU3RvcmFnZScsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCc6ICAgIG51bGwsXG4gICAgJ3Byb3BlcnR5X2JsYWNrbGlzdCc6ICAgICAgICAgICAgICAgIFtdLFxuICAgICd4aHJfaGVhZGVycyc6ICAgICAgICAgICAgICAgICAgICAgICB7fSwgLy8geyBoZWFkZXI6IHZhbHVlLCBoZWFkZXIyOiB2YWx1ZSB9XG4gICAgJ2lnbm9yZV9kbnQnOiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdiYXRjaF9yZXF1ZXN0cyc6ICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdiYXRjaF9zaXplJzogICAgICAgICAgICAgICAgICAgICAgICA1MCxcbiAgICAnYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnOiAgICAgICAgICAgNTAwMCxcbiAgICAnYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJzogICAgICAgICAgOTAwMDAsXG4gICAgJ2JhdGNoX2F1dG9zdGFydCc6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ2hvb2tzJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICdyZWNvcmRfYmxvY2tfY2xhc3MnOiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCdeKG1wLWJsb2NrfGZzLWV4Y2x1ZGV8YW1wLWJsb2NrfHJyLWJsb2NrfHBoLW5vLWNhcHR1cmUpJCcpLFxuICAgICdyZWNvcmRfYmxvY2tfc2VsZWN0b3InOiAgICAgICAgICAgICAnaW1nLCB2aWRlbycsXG4gICAgJ3JlY29yZF9jYW52YXMnOiAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdyZWNvcmRfY29sbGVjdF9mb250cyc6ICAgICAgICAgICAgICBmYWxzZSxcbiAgICAncmVjb3JkX2lkbGVfdGltZW91dF9tcyc6ICAgICAgICAgICAgMzAgKiA2MCAqIDEwMDAsIC8vIDMwIG1pbnV0ZXNcbiAgICAncmVjb3JkX21hc2tfdGV4dF9jbGFzcyc6ICAgICAgICAgICAgbmV3IFJlZ0V4cCgnXihtcC1tYXNrfGZzLW1hc2t8YW1wLW1hc2t8cnItbWFza3xwaC1tYXNrKSQnKSxcbiAgICAncmVjb3JkX21hc2tfdGV4dF9zZWxlY3Rvcic6ICAgICAgICAgJyonLFxuICAgICdyZWNvcmRfbWF4X21zJzogICAgICAgICAgICAgICAgICAgICBNQVhfUkVDT1JESU5HX01TLFxuICAgICdyZWNvcmRfbWluX21zJzogICAgICAgICAgICAgICAgICAgICAwLFxuICAgICdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCc6ICAgICAgICAgICAwLFxuICAgICdyZWNvcmRlcl9zcmMnOiAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9jZG4ubXhwbmwuY29tL2xpYnMvbWl4cGFuZWwtcmVjb3JkZXIubWluLmpzJ1xufTtcblxudmFyIERPTV9MT0FERUQgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXhwYW5lbCBMaWJyYXJ5IE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbExpYiA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBjcmVhdGVfbXBsaWIodG9rZW46c3RyaW5nLCBjb25maWc6b2JqZWN0LCBuYW1lOnN0cmluZylcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgdGhlIGluaXQgbWV0aG9kIG9mIE1peHBhbmVsTGliIG9iamVjdHNcbiAqIGFzIHdlbGwgYXMgdGhlIG1haW4gaW5pdGlhbGl6ZXIgYXQgdGhlIGVuZCBvZiB0aGUgSlNMaWIgKHRoYXRcbiAqIGluaXRpYWxpemVzIGRvY3VtZW50Lm1peHBhbmVsIGFzIHdlbGwgYXMgYW55IGFkZGl0aW9uYWwgaW5zdGFuY2VzXG4gKiBkZWNsYXJlZCBiZWZvcmUgdGhpcyBmaWxlIGhhcyBsb2FkZWQpLlxuICovXG52YXIgY3JlYXRlX21wbGliID0gZnVuY3Rpb24odG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgIHZhciBpbnN0YW5jZSxcbiAgICAgICAgdGFyZ2V0ID0gKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgPyBtaXhwYW5lbF9tYXN0ZXIgOiBtaXhwYW5lbF9tYXN0ZXJbbmFtZV07XG5cbiAgICBpZiAodGFyZ2V0ICYmIGluaXRfdHlwZSA9PT0gSU5JVF9NT0RVTEUpIHtcbiAgICAgICAgaW5zdGFuY2UgPSB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldCAmJiAhXy5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignWW91IGhhdmUgYWxyZWFkeSBpbml0aWFsaXplZCAnICsgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgTWl4cGFuZWxMaWIoKTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5fY2FjaGVkX2dyb3VwcyA9IHt9OyAvLyBjYWNoZSBncm91cHMgaW4gYSBwb29sXG5cbiAgICBpbnN0YW5jZS5faW5pdCh0b2tlbiwgY29uZmlnLCBuYW1lKTtcblxuICAgIGluc3RhbmNlWydwZW9wbGUnXSA9IG5ldyBNaXhwYW5lbFBlb3BsZSgpO1xuICAgIGluc3RhbmNlWydwZW9wbGUnXS5faW5pdChpbnN0YW5jZSk7XG5cbiAgICBpZiAoIWluc3RhbmNlLmdldF9jb25maWcoJ3NraXBfZmlyc3RfdG91Y2hfbWFya2V0aW5nJykpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBudWxsIFVUTSBwYXJhbXMgaW4gdGhlIG9iamVjdCBiZWNhdXNlXG4gICAgICAgIC8vIFVUTSBwYXJhbWV0ZXJzIGFjdCBhcyBhIHR1cGxlLiBJZiBhbnkgVVRNIHBhcmFtXG4gICAgICAgIC8vIGlzIHByZXNlbnQsIHRoZW4gd2Ugc2V0IGFsbCBVVE0gcGFyYW1zIGluY2x1ZGluZ1xuICAgICAgICAvLyBlbXB0eSBvbmVzIHRvZ2V0aGVyXG4gICAgICAgIHZhciB1dG1fcGFyYW1zID0gXy5pbmZvLmNhbXBhaWduUGFyYW1zKG51bGwpO1xuICAgICAgICB2YXIgaW5pdGlhbF91dG1fcGFyYW1zID0ge307XG4gICAgICAgIHZhciBoYXNfdXRtID0gZmFsc2U7XG4gICAgICAgIF8uZWFjaCh1dG1fcGFyYW1zLCBmdW5jdGlvbih1dG1fdmFsdWUsIHV0bV9rZXkpIHtcbiAgICAgICAgICAgIGluaXRpYWxfdXRtX3BhcmFtc1snaW5pdGlhbF8nICsgdXRtX2tleV0gPSB1dG1fdmFsdWU7XG4gICAgICAgICAgICBpZiAodXRtX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaGFzX3V0bSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzX3V0bSkge1xuICAgICAgICAgICAgaW5zdGFuY2VbJ3Blb3BsZSddLnNldF9vbmNlKGluaXRpYWxfdXRtX3BhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBhbnkgaW5zdGFuY2Ugb24gdGhlIHBhZ2UgaGFzIGRlYnVnID0gdHJ1ZSwgd2Ugc2V0IHRoZVxuICAgIC8vIGdsb2JhbCBkZWJ1ZyB0byBiZSB0cnVlXG4gICAgQ29uZmlnLkRFQlVHID0gQ29uZmlnLkRFQlVHIHx8IGluc3RhbmNlLmdldF9jb25maWcoJ2RlYnVnJyk7XG5cbiAgICAvLyBpZiB0YXJnZXQgaXMgbm90IGRlZmluZWQsIHdlIGNhbGxlZCBpbml0IGFmdGVyIHRoZSBsaWIgYWxyZWFkeVxuICAgIC8vIGxvYWRlZCwgc28gdGhlcmUgd29uJ3QgYmUgYW4gYXJyYXkgb2YgdGhpbmdzIHRvIGV4ZWN1dGVcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodGFyZ2V0KSAmJiBfLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAvLyBDcnVuY2ggdGhyb3VnaCB0aGUgcGVvcGxlIHF1ZXVlIGZpcnN0IC0gd2UgcXVldWUgdGhpcyBkYXRhIHVwICZcbiAgICAgICAgLy8gZmx1c2ggb24gaWRlbnRpZnksIHNvIGl0J3MgYmV0dGVyIHRvIGRvIGFsbCB0aGVzZSBvcGVyYXRpb25zIGZpcnN0XG4gICAgICAgIGluc3RhbmNlLl9leGVjdXRlX2FycmF5LmNhbGwoaW5zdGFuY2VbJ3Blb3BsZSddLCB0YXJnZXRbJ3Blb3BsZSddKTtcbiAgICAgICAgaW5zdGFuY2UuX2V4ZWN1dGVfYXJyYXkodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG4vLyBJbml0aWFsaXphdGlvbiBtZXRob2RzXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTWl4cGFuZWwgdHJhY2tpbmcgb2JqZWN0LlxuICogQWxsIG5ldyBpbnN0YW5jZXMgYXJlIGFkZGVkIHRvIHRoZSBtYWluIG1peHBhbmVsIG9iamVjdCBhcyBzdWIgcHJvcGVydGllcyAoc3VjaCBhc1xuICogbWl4cGFuZWwubGlicmFyeV9uYW1lKSBhbmQgYWxzbyByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLiBUbyBkZWZpbmUgYVxuICogc2Vjb25kIGluc3RhbmNlIG9uIHRoZSBwYWdlLCB5b3Ugd291bGQgY2FsbDpcbiAqXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnbmV3IHRva2VuJywgeyB5b3VyOiAnY29uZmlnJyB9LCAnbGlicmFyeV9uYW1lJyk7XG4gKlxuICogYW5kIHVzZSBpdCBsaWtlIHNvOlxuICpcbiAqICAgICBtaXhwYW5lbC5saWJyYXJ5X25hbWUudHJhY2soLi4uKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gICBZb3VyIE1peHBhbmVsIEFQSSB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddICBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGUuIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vbWl4cGFuZWwvbWl4cGFuZWwtanMvYmxvYi92Mi40Ni4wL3NyYy9taXhwYW5lbC1jb3JlLmpzI0w4OC1MMTI3XCI+U2VlIGEgbGlzdCBvZiBkZWZhdWx0IGNvbmZpZyBvcHRpb25zPC9hPi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gICAgVGhlIG5hbWUgZm9yIHRoZSBuZXcgbWl4cGFuZWwgaW5zdGFuY2UgdGhhdCB5b3Ugd2FudCBjcmVhdGVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChuYW1lKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignWW91IG11c3QgbmFtZSB5b3VyIG5ldyBsaWJyYXJ5OiBpbml0KHRva2VuLCBjb25maWcsIG5hbWUpJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignWW91IG11c3QgaW5pdGlhbGl6ZSB0aGUgbWFpbiBtaXhwYW5lbCBvYmplY3QgcmlnaHQgYWZ0ZXIgeW91IGluY2x1ZGUgdGhlIE1peHBhbmVsIGpzIHNuaXBwZXQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZV9tcGxpYih0b2tlbiwgY29uZmlnLCBuYW1lKTtcbiAgICBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZTtcbiAgICBpbnN0YW5jZS5fbG9hZGVkKCk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG4vLyBtaXhwYW5lbC5faW5pdCh0b2tlbjpzdHJpbmcsIGNvbmZpZzpvYmplY3QsIG5hbWU6c3RyaW5nKVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gc2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGUgbWl4cGFuZWxcbi8vIGxpYnJhcnkuICBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgbWV0aG9kIGFuZCB0aGUgaW5pdCguLi4pXG4vLyBtZXRob2QgaXMgdGhpcyBvbmUgaW5pdGlhbGl6ZXMgdGhlIGFjdHVhbCBpbnN0YW5jZSwgd2hlcmVhcyB0aGVcbi8vIGluaXQoLi4uKSBtZXRob2Qgc2V0cyB1cCBhIG5ldyBsaWJyYXJ5IGFuZCBjYWxscyBfaW5pdCBvbiBpdC5cbi8vXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgdGhpc1snX19sb2FkZWQnXSA9IHRydWU7XG4gICAgdGhpc1snY29uZmlnJ10gPSB7fTtcblxuICAgIHZhciB2YXJpYWJsZV9mZWF0dXJlcyA9IHt9O1xuXG4gICAgLy8gZGVmYXVsdCB0byBKU09OIHBheWxvYWQgZm9yIHN0YW5kYXJkIG1peHBhbmVsLmNvbSBBUEkgaG9zdHNcbiAgICBpZiAoISgnYXBpX3BheWxvYWRfZm9ybWF0JyBpbiBjb25maWcpKSB7XG4gICAgICAgIHZhciBhcGlfaG9zdCA9IGNvbmZpZ1snYXBpX2hvc3QnXSB8fCBERUZBVUxUX0NPTkZJR1snYXBpX2hvc3QnXTtcbiAgICAgICAgaWYgKGFwaV9ob3N0Lm1hdGNoKC9cXC5taXhwYW5lbFxcLmNvbS8pKSB7XG4gICAgICAgICAgICB2YXJpYWJsZV9mZWF0dXJlc1snYXBpX3BheWxvYWRfZm9ybWF0J10gPSBQQVlMT0FEX1RZUEVfSlNPTjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0X2NvbmZpZyhfLmV4dGVuZCh7fSwgREVGQVVMVF9DT05GSUcsIHZhcmlhYmxlX2ZlYXR1cmVzLCBjb25maWcsIHtcbiAgICAgICAgJ25hbWUnOiBuYW1lLFxuICAgICAgICAndG9rZW4nOiB0b2tlbixcbiAgICAgICAgJ2NhbGxiYWNrX2ZuJzogKChuYW1lID09PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpID8gbmFtZSA6IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSArICcuJyArIG5hbWUpICsgJy5fanNjJ1xuICAgIH0pKTtcblxuICAgIHRoaXNbJ19qc2MnXSA9IE5PT1BfRlVOQztcblxuICAgIHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlID0gW107XG4gICAgdGhpcy5fX3JlcXVlc3RfcXVldWUgPSBbXTtcbiAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gW107XG4gICAgdGhpcy5fZmxhZ3MgPSB7XG4gICAgICAgICdkaXNhYmxlX2FsbF9ldmVudHMnOiBmYWxzZSxcbiAgICAgICAgJ2lkZW50aWZ5X2NhbGxlZCc6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHNldCB1cCByZXF1ZXN0IHF1ZXVlaW5nL2JhdGNoaW5nXG4gICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzID0ge307XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSB0aGlzLmdldF9jb25maWcoJ2JhdGNoX3JlcXVlc3RzJyk7XG4gICAgaWYgKHRoaXMuX2JhdGNoX3JlcXVlc3RzKSB7XG4gICAgICAgIGlmICghXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKHRydWUpIHx8ICFVU0VfWEhSKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc29sZSQxLmxvZygnVHVybmluZyBvZmYgTWl4cGFuZWwgcmVxdWVzdC1xdWV1ZWluZzsgbmVlZHMgWEhSIGFuZCBsb2NhbFN0b3JhZ2Ugc3VwcG9ydCcpO1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMuZ2V0X2JhdGNoZXJfY29uZmlncygpLCBmdW5jdGlvbihiYXRjaGVyX2NvbmZpZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUkMS5sb2coJ0NsZWFyaW5nIGJhdGNoIHF1ZXVlICcgKyBiYXRjaGVyX2NvbmZpZy5xdWV1ZV9rZXkpO1xuICAgICAgICAgICAgICAgIF8ubG9jYWxTdG9yYWdlLnJlbW92ZShiYXRjaGVyX2NvbmZpZy5xdWV1ZV9rZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRfYmF0Y2hlcnMoKTtcbiAgICAgICAgICAgIGlmIChzZW5kQmVhY29uICYmIHdpbi5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQmVmb3JlIHBhZ2UgY2xvc2VzIG9yIGhpZGVzICh1c2VyIHRhYnMgYXdheSBldGMpLCBhdHRlbXB0IHRvIGZsdXNoIGFueSBldmVudHNcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZWQgdXAgdmlhIG5hdmlnYXRvci5zZW5kQmVhY29uLiBTaW5jZSBzZW5kQmVhY29uIGRvZXNuJ3QgcmVwb3J0IHN1Y2Nlc3MvZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgd2lsbCBub3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSBwZXJzaXN0ZW50IHN0b3JlOyBpZiB0aGUgc2l0ZSBpcyBsb2FkZWQgYWdhaW4sXG4gICAgICAgICAgICAgICAgLy8gdGhlIGV2ZW50cyB3aWxsIGJlIGZsdXNoZWQgYWdhaW4gb24gc3RhcnR1cCBhbmQgZGVkdXBsaWNhdGVkIG9uIHRoZSBNaXhwYW5lbCBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyBzaWRlLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHJlbGlhYmxlIHdheSB0byBjYXB0dXJlIG9ubHkgcGFnZSBjbG9zZSBldmVudHMsIHNvIHdlIGxlYW4gb24gdGhlXG4gICAgICAgICAgICAgICAgLy8gdmlzaWJpbGl0eWNoYW5nZSBhbmQgcGFnZWhpZGUgZXZlbnRzIGFzIHJlY29tbWVuZGVkIGF0XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy91bmxvYWRfZXZlbnQjdXNhZ2Vfbm90ZXMuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGZpcmUgd2hlbiB0aGUgdXNlciBjbGlja3MgYXdheSBmcm9tIHRoZSBjdXJyZW50IHBhZ2UvdGFiLCBzbyB3aWxsIG9jY3VyXG4gICAgICAgICAgICAgICAgLy8gbW9yZSBmcmVxdWVudGx5IHRoYW4gcGFnZSB1bmxvYWQsIGJ1dCBhcmUgdGhlIG9ubHkgbWVjaGFuaXNtIGN1cnJlbnRseSBmb3IgY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzY2VuYXJpbyBzb21ld2hhdCByZWxpYWJseS5cbiAgICAgICAgICAgICAgICB2YXIgZmx1c2hfb25fdW5sb2FkID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHMuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cy5mbHVzaCh7dW5sb2FkaW5nOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZbJ3BlcnNpc3RlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaF9vbl91bmxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudCQxWyd2aXNpYmlsaXR5U3RhdGUnXSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoX29uX3VubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddID0gdGhpc1snY29va2llJ10gPSBuZXcgTWl4cGFuZWxQZXJzaXN0ZW5jZSh0aGlzWydjb25maWcnXSk7XG4gICAgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzID0ge307XG4gICAgdGhpcy5fZ2Rwcl9pbml0KCk7XG5cbiAgICB2YXIgdXVpZCA9IF8uVVVJRCgpO1xuICAgIGlmICghdGhpcy5nZXRfZGlzdGluY3RfaWQoKSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHNldCB0aGUgZGlzdGluY3QgaWRcbiAgICAgICAgLy8gb3IgdGhlIGRldmljZSBpZCBpZiBzb21ldGhpbmcgd2FzIGFscmVhZHkgc3RvcmVkXG4gICAgICAgIC8vIGluIHRoZSBwZXJzaXRlbmNlXG4gICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBERVZJQ0VfSURfUFJFRklYICsgdXVpZCxcbiAgICAgICAgICAgICckZGV2aWNlX2lkJzogdXVpZFxuICAgICAgICB9LCAnJyk7XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrX3BhZ2V2aWV3X29wdGlvbiA9IHRoaXMuZ2V0X2NvbmZpZygndHJhY2tfcGFnZXZpZXcnKTtcbiAgICBpZiAodHJhY2tfcGFnZXZpZXdfb3B0aW9uKSB7XG4gICAgICAgIHRoaXMuX2luaXRfdXJsX2NoYW5nZV90cmFja2luZyh0cmFja19wYWdldmlld19vcHRpb24pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3JlY29yZF9zZXNzaW9uc19wZXJjZW50JykgPiAwICYmIE1hdGgucmFuZG9tKCkgKiAxMDAgPD0gdGhpcy5nZXRfY29uZmlnKCdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCcpKSB7XG4gICAgICAgIHRoaXMuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXdpblsnTXV0YXRpb25PYnNlcnZlciddKSB7XG4gICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbCgnQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE11dGF0aW9uT2JzZXJ2ZXI7IHNraXBwaW5nIHNlc3Npb24gcmVjb3JkaW5nJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlTG9hZGVkUmVjb3JkZXIgPSBfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlY29yZGVyID0gdGhpcy5fcmVjb3JkZXIgfHwgbmV3IHdpblsnX19tcF9yZWNvcmRlciddKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWNvcmRlclsnc3RhcnRSZWNvcmRpbmcnXSgpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQod2luWydfX21wX3JlY29yZGVyJ10pKSB7XG4gICAgICAgIGxvYWRfZXh0cmFfYnVuZGxlKHRoaXMuZ2V0X2NvbmZpZygncmVjb3JkZXJfc3JjJyksIGhhbmRsZUxvYWRlZFJlY29yZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVMb2FkZWRSZWNvcmRlcigpO1xuICAgIH1cbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9zZXNzaW9uX3JlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgdGhpcy5fcmVjb3JkZXJbJ3N0b3BSZWNvcmRpbmcnXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbCgnU2Vzc2lvbiByZWNvcmRlciBtb2R1bGUgbm90IGxvYWRlZCcpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIgcmVwbGF5X2lkID0gdGhpcy5fZ2V0X3Nlc3Npb25fcmVwbGF5X2lkKCk7XG4gICAgaWYgKHJlcGxheV9pZCkge1xuICAgICAgICBwcm9wc1snJG1wX3JlcGxheV9pZCddID0gcmVwbGF5X2lkO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVwbGF5X3VybCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVwbGF5X3VybCA9IG51bGw7XG4gICAgdmFyIHJlcGxheV9pZCA9IHRoaXMuX2dldF9zZXNzaW9uX3JlcGxheV9pZCgpO1xuICAgIGlmIChyZXBsYXlfaWQpIHtcbiAgICAgICAgdmFyIHF1ZXJ5X3BhcmFtcyA9IF8uSFRUUEJ1aWxkUXVlcnkoe1xuICAgICAgICAgICAgJ3JlcGxheV9pZCc6IHJlcGxheV9pZCxcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IHRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCksXG4gICAgICAgICAgICAndG9rZW4nOiB0aGlzLmdldF9jb25maWcoJ3Rva2VuJylcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcGxheV91cmwgPSAnaHR0cHM6Ly9taXhwYW5lbC5jb20vcHJvamVjdHMvcmVwbGF5LXJlZGlyZWN0PycgKyBxdWVyeV9wYXJhbXM7XG4gICAgfVxuICAgIHJldHVybiByZXBsYXlfdXJsO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZXRfc2Vzc2lvbl9yZXBsYXlfaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcGxheV9pZCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3JlY29yZGVyKSB7XG4gICAgICAgIHJlcGxheV9pZCA9IHRoaXMuX3JlY29yZGVyWydyZXBsYXlJZCddO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGF5X2lkIHx8IG51bGw7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZHNcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9sb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmdldF9jb25maWcoJ2xvYWRlZCcpKHRoaXMpO1xuICAgIHRoaXMuX3NldF9kZWZhdWx0X3N1cGVycHJvcHMoKTtcbiAgICB0aGlzWydwZW9wbGUnXS5zZXRfb25jZSh0aGlzWydwZXJzaXN0ZW5jZSddLmdldF9yZWZlcnJlcl9pbmZvKCkpO1xuXG4gICAgLy8gYHN0b3JlX2dvb2dsZWAgaXMgbm93IGRlcHJlY2F0ZWQgYW5kIHByZXZpb3VzbHkgc3RvcmVkIFVUTSBwYXJhbWV0ZXJzIGFyZSBjbGVhcmVkXG4gICAgLy8gZnJvbSBwZXJzaXN0ZW5jZSBieSBkZWZhdWx0LlxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3N0b3JlX2dvb2dsZScpICYmIHRoaXMuZ2V0X2NvbmZpZygnc3RvcF91dG1fcGVyc2lzdGVuY2UnKSkge1xuICAgICAgICB2YXIgdXRtX3BhcmFtcyA9IF8uaW5mby5jYW1wYWlnblBhcmFtcyhudWxsKTtcbiAgICAgICAgXy5lYWNoKHV0bV9wYXJhbXMsIGZ1bmN0aW9uKF91dG1fdmFsdWUsIHV0bV9rZXkpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdW5yZWdpc3RlciBwZXJzaXN0ZWQgVVRNIHBhcmFtZXRlcnMgc28gb2xkIHZhbHVlc1xuICAgICAgICAgICAgLy8gYXJlIG5vdCBtaXhlZCB3aXRoIHRoZSBuZXcgVVRNIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3Rlcih1dG1fa2V5KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59O1xuXG4vLyB1cGRhdGUgcGVyc2lzdGVuY2Ugd2l0aCBpbmZvIG9uIHJlZmVycmVyLCBVVE0gcGFyYW1zLCBldGNcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fc2V0X2RlZmF1bHRfc3VwZXJwcm9wcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX3NlYXJjaF9rZXl3b3JkKGRvY3VtZW50JDEucmVmZXJyZXIpO1xuICAgIC8vIFJlZ2lzdGVyaW5nIHN1cGVyIHByb3BlcnRpZXMgZm9yIFVUTSBwZXJzaXN0ZW5jZSBieSAnc3RvcmVfZ29vZ2xlJyBpcyBkZXByZWNhdGVkLlxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3N0b3JlX2dvb2dsZScpICYmICF0aGlzLmdldF9jb25maWcoJ3N0b3BfdXRtX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihfLmluZm8uY2FtcGFpZ25QYXJhbXMoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3NhdmVfcmVmZXJyZXInKSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9yZWZlcnJlcl9pbmZvKGRvY3VtZW50JDEucmVmZXJyZXIpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZG9tX2xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIF8uZWFjaCh0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB0aGlzLl90cmFja19kb20uYXBwbHkodGhpcywgaXRlbSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoIXRoaXMuaGFzX29wdGVkX291dF90cmFja2luZygpKSB7XG4gICAgICAgIF8uZWFjaCh0aGlzLl9fcmVxdWVzdF9xdWV1ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5fc2VuZF9yZXF1ZXN0LmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5fX2RvbV9sb2FkZWRfcXVldWU7XG4gICAgZGVsZXRlIHRoaXMuX19yZXF1ZXN0X3F1ZXVlO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl90cmFja19kb20gPSBmdW5jdGlvbihEb21DbGFzcywgYXJncykge1xuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2ltZycpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdZb3UgY2FuXFwndCB1c2UgRE9NIHRyYWNraW5nIGZ1bmN0aW9ucyB3aXRoIGltZyA9IHRydWUuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIURPTV9MT0FERUQpIHtcbiAgICAgICAgdGhpcy5fX2RvbV9sb2FkZWRfcXVldWUucHVzaChbRG9tQ2xhc3MsIGFyZ3NdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBkdCA9IG5ldyBEb21DbGFzcygpLmluaXQodGhpcyk7XG4gICAgcmV0dXJuIGR0LnRyYWNrLmFwcGx5KGR0LCBhcmdzKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5faW5pdF91cmxfY2hhbmdlX3RyYWNraW5nID0gZnVuY3Rpb24odHJhY2tfcGFnZXZpZXdfb3B0aW9uKSB7XG4gICAgdmFyIHByZXZpb3VzX3RyYWNrZWRfdXJsID0gJyc7XG4gICAgdmFyIHRyYWNrZWQgPSB0aGlzLnRyYWNrX3BhZ2V2aWV3KCk7XG4gICAgaWYgKHRyYWNrZWQpIHtcbiAgICAgICAgcHJldmlvdXNfdHJhY2tlZF91cmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgIH1cblxuICAgIGlmIChfLmluY2x1ZGUoWydmdWxsLXVybCcsICd1cmwtd2l0aC1wYXRoLWFuZC1xdWVyeS1zdHJpbmcnLCAndXJsLXdpdGgtcGF0aCddLCB0cmFja19wYWdldmlld19vcHRpb24pKSB7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdtcF9sb2NhdGlvbmNoYW5nZScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ21wX2xvY2F0aW9uY2hhbmdlJykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5hdGl2ZVB1c2hTdGF0ZSA9IHdpbi5oaXN0b3J5LnB1c2hTdGF0ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYXRpdmVQdXNoU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHdpbi5oaXN0b3J5LnB1c2hTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCB1bnVzZWQsIHVybCkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZVB1c2hTdGF0ZS5jYWxsKHdpbi5oaXN0b3J5LCBzdGF0ZSwgdW51c2VkLCB1cmwpO1xuICAgICAgICAgICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbXBfbG9jYXRpb25jaGFuZ2UnKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYXRpdmVSZXBsYWNlU3RhdGUgPSB3aW4uaGlzdG9yeS5yZXBsYWNlU3RhdGU7XG4gICAgICAgIGlmICh0eXBlb2YgbmF0aXZlUmVwbGFjZVN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3aW4uaGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgdW51c2VkLCB1cmwpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVSZXBsYWNlU3RhdGUuY2FsbCh3aW4uaGlzdG9yeSwgc3RhdGUsIHVudXNlZCwgdXJsKTtcbiAgICAgICAgICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ21wX2xvY2F0aW9uY2hhbmdlJykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignbXBfbG9jYXRpb25jaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50X3VybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkX3RyYWNrID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodHJhY2tfcGFnZXZpZXdfb3B0aW9uID09PSAnZnVsbC11cmwnKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkX3RyYWNrID0gY3VycmVudF91cmwgIT09IHByZXZpb3VzX3RyYWNrZWRfdXJsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0cmFja19wYWdldmlld19vcHRpb24gPT09ICd1cmwtd2l0aC1wYXRoLWFuZC1xdWVyeS1zdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkX3RyYWNrID0gY3VycmVudF91cmwuc3BsaXQoJyMnKVswXSAhPT0gcHJldmlvdXNfdHJhY2tlZF91cmwuc3BsaXQoJyMnKVswXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhY2tfcGFnZXZpZXdfb3B0aW9uID09PSAndXJsLXdpdGgtcGF0aCcpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRfdHJhY2sgPSBjdXJyZW50X3VybC5zcGxpdCgnIycpWzBdLnNwbGl0KCc/JylbMF0gIT09IHByZXZpb3VzX3RyYWNrZWRfdXJsLnNwbGl0KCcjJylbMF0uc3BsaXQoJz8nKVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3VsZF90cmFjaykge1xuICAgICAgICAgICAgICAgIHZhciB0cmFja2VkID0gdGhpcy50cmFja19wYWdldmlldygpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX3RyYWNrZWRfdXJsID0gY3VycmVudF91cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbn07XG5cbi8qKlxuICogX3ByZXBhcmVfY2FsbGJhY2soKSBzaG91bGQgYmUgY2FsbGVkIGJ5IGNhbGxlcnMgb2YgX3NlbmRfcmVxdWVzdCBmb3IgdXNlXG4gKiBhcyB0aGUgY2FsbGJhY2sgYXJndW1lbnQuXG4gKlxuICogSWYgdGhlcmUgaXMgbm8gY2FsbGJhY2ssIHRoaXMgcmV0dXJucyBudWxsLlxuICogSWYgd2UgYXJlIGdvaW5nIHRvIG1ha2UgWEhSL1hEUiByZXF1ZXN0cywgdGhpcyByZXR1cm5zIGEgZnVuY3Rpb24uXG4gKiBJZiB3ZSBhcmUgZ29pbmcgdG8gdXNlIHNjcmlwdCB0YWdzLCB0aGlzIHJldHVybnMgYSBzdHJpbmcgdG8gdXNlIGFzIHRoZVxuICogY2FsbGJhY2sgR0VUIHBhcmFtLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3ByZXBhcmVfY2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgZGF0YSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKGNhbGxiYWNrKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoVVNFX1hIUikge1xuICAgICAgICB2YXIgY2FsbGJhY2tfZnVuY3Rpb24gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tfZnVuY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgZ2l2ZXMgdXMgYSBjYWxsYmFjaywgd2Ugc3RvcmUgYXMgYSByYW5kb21cbiAgICAgICAgLy8gcHJvcGVydHkgb24gdGhpcyBpbnN0YW5jZXMganNjIGZ1bmN0aW9uIGFuZCB1cGRhdGUgb3VyXG4gICAgICAgIC8vIGNhbGxiYWNrIHN0cmluZyB0byByZWZsZWN0IHRoYXQuXG4gICAgICAgIHZhciBqc2MgPSB0aGlzWydfanNjJ107XG4gICAgICAgIHZhciByYW5kb21pemVkX2NiID0gJycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xuICAgICAgICB2YXIgY2FsbGJhY2tfc3RyaW5nID0gdGhpcy5nZXRfY29uZmlnKCdjYWxsYmFja19mbicpICsgJ1snICsgcmFuZG9taXplZF9jYiArICddJztcbiAgICAgICAganNjW3JhbmRvbWl6ZWRfY2JdID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBqc2NbcmFuZG9taXplZF9jYl07XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWxsYmFja19zdHJpbmc7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN1Y2NlZWRlZCA9IHRydWU7XG5cbiAgICBpZiAoRU5RVUVVRV9SRVFVRVNUUykge1xuICAgICAgICB0aGlzLl9fcmVxdWVzdF9xdWV1ZS5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBzdWNjZWVkZWQ7XG4gICAgfVxuXG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLmdldF9jb25maWcoJ2FwaV9tZXRob2QnKSxcbiAgICAgICAgdHJhbnNwb3J0OiB0aGlzLmdldF9jb25maWcoJ2FwaV90cmFuc3BvcnQnKSxcbiAgICAgICAgdmVyYm9zZTogdGhpcy5nZXRfY29uZmlnKCd2ZXJib3NlJylcbiAgICB9O1xuICAgIHZhciBib2R5X2RhdGEgPSBudWxsO1xuXG4gICAgaWYgKCFjYWxsYmFjayAmJiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnMpIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyB8fCB7fSk7XG4gICAgaWYgKCFVU0VfWEhSKSB7XG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgfVxuICAgIHZhciB1c2VfcG9zdCA9IG9wdGlvbnMubWV0aG9kID09PSAnUE9TVCc7XG4gICAgdmFyIHVzZV9zZW5kQmVhY29uID0gc2VuZEJlYWNvbiAmJiB1c2VfcG9zdCAmJiBvcHRpb25zLnRyYW5zcG9ydC50b0xvd2VyQ2FzZSgpID09PSAnc2VuZGJlYWNvbic7XG5cbiAgICAvLyBuZWVkZWQgdG8gY29ycmVjdGx5IGZvcm1hdCByZXNwb25zZXNcbiAgICB2YXIgdmVyYm9zZV9tb2RlID0gb3B0aW9ucy52ZXJib3NlO1xuICAgIGlmIChkYXRhWyd2ZXJib3NlJ10pIHsgdmVyYm9zZV9tb2RlID0gdHJ1ZTsgfVxuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygndGVzdCcpKSB7IGRhdGFbJ3Rlc3QnXSA9IDE7IH1cbiAgICBpZiAodmVyYm9zZV9tb2RlKSB7IGRhdGFbJ3ZlcmJvc2UnXSA9IDE7IH1cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdpbWcnKSkgeyBkYXRhWydpbWcnXSA9IDE7IH1cbiAgICBpZiAoIVVTRV9YSFIpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBkYXRhWydjYWxsYmFjayddID0gY2FsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodmVyYm9zZV9tb2RlIHx8IHRoaXMuZ2V0X2NvbmZpZygndGVzdCcpKSB7XG4gICAgICAgICAgICAvLyBWZXJib3NlIG91dHB1dCAoZnJvbSB2ZXJib3NlIG1vZGUsIG9yIGFuIGVycm9yIGluIHRlc3QgbW9kZSkgaXMgYSBqc29uIGJsb2IsXG4gICAgICAgICAgICAvLyB3aGljaCBieSBpdHNlbGYgaXMgbm90IHZhbGlkIGphdmFzY3JpcHQuIFdpdGhvdXQgYSBjYWxsYmFjaywgdGhpcyB2ZXJib3NlIG91dHB1dCB3aWxsXG4gICAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvciB3aGVuIHJldHVybmVkIHZpYSBqc29ucCwgc28gd2UgZm9yY2UgYSBuby1vcCBjYWxsYmFjayBwYXJhbS5cbiAgICAgICAgICAgIC8vIFNlZSB0aGUgRUNNQSBzY3JpcHQgc3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTEyLjRcbiAgICAgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSAnKGZ1bmN0aW9uKCl7fSknO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF0YVsnaXAnXSA9IHRoaXMuZ2V0X2NvbmZpZygnaXAnKT8xOjA7XG4gICAgZGF0YVsnXyddID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoKTtcblxuICAgIGlmICh1c2VfcG9zdCkge1xuICAgICAgICBib2R5X2RhdGEgPSAnZGF0YT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFbJ2RhdGEnXSk7XG4gICAgICAgIGRlbGV0ZSBkYXRhWydkYXRhJ107XG4gICAgfVxuXG4gICAgdXJsICs9ICc/JyArIF8uSFRUUEJ1aWxkUXVlcnkoZGF0YSk7XG5cbiAgICB2YXIgbGliID0gdGhpcztcbiAgICBpZiAoJ2ltZycgaW4gZGF0YSkge1xuICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgZG9jdW1lbnQkMS5ib2R5LmFwcGVuZENoaWxkKGltZyk7XG4gICAgfSBlbHNlIGlmICh1c2Vfc2VuZEJlYWNvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gc2VuZEJlYWNvbih1cmwsIGJvZHlfZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc3VjY2VlZGVkID8gMSA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChVU0VfWEhSKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXEub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmdldF9jb25maWcoJ3hocl9oZWFkZXJzJyk7XG4gICAgICAgICAgICBpZiAodXNlX3Bvc3QpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5lYWNoKGhlYWRlcnMsIGZ1bmN0aW9uKGhlYWRlclZhbHVlLCBoZWFkZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXRfbXMgJiYgdHlwZW9mIHJlcS50aW1lb3V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlcS50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0X21zO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlbmQgdGhlIG1wX29wdG91dCBjb29raWVcbiAgICAgICAgICAgIC8vIHdpdGhDcmVkZW50aWFscyBjYW5ub3QgYmUgbW9kaWZpZWQgdW50aWwgYWZ0ZXIgY2FsbGluZyAub3BlbiBvbiBBbmRyb2lkIGFuZCBNb2JpbGUgU2FmYXJpXG4gICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7IC8vIFhNTEh0dHBSZXF1ZXN0LkRPTkUgPT0gNCwgZXhjZXB0IGluIHNhZmFyaSA0XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlX21vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfLkpTT05EZWNvZGUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVfanNvbl9lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlcS5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soTnVtYmVyKHJlcS5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRpbWVvdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcmVxLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRfdGltZSA+PSByZXEudGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAndGltZW91dCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ0JhZCBIVFRQIHN0YXR1czogJyArIHJlcS5zdGF0dXMgKyAnICcgKyByZXEuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2VfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VfaGVhZGVycyA9IHJlcVsncmVzcG9uc2VIZWFkZXJzJ10gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtzdGF0dXM6IDAsIGh0dHBTdGF0dXNDb2RlOiByZXFbJ3N0YXR1cyddLCBlcnJvcjogZXJyb3IsIHJldHJ5QWZ0ZXI6IHJlc3BvbnNlX2hlYWRlcnNbJ1JldHJ5LUFmdGVyJ119KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxLnNlbmQoYm9keV9kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIHZhciBzID0gZG9jdW1lbnQkMS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gICAgICAgIHMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VjY2VlZGVkO1xufTtcblxuLyoqXG4gKiBfZXhlY3V0ZV9hcnJheSgpIGRlYWxzIHdpdGggcHJvY2Vzc2luZyBhbnkgbWl4cGFuZWwgZnVuY3Rpb25cbiAqIGNhbGxzIHRoYXQgd2VyZSBjYWxsZWQgYmVmb3JlIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IHdlcmUgbG9hZGVkXG4gKiAoYW5kIGFyZSB0aHVzIHN0b3JlZCBpbiBhbiBhcnJheSBzbyB0aGV5IGNhbiBiZSBjYWxsZWQgbGF0ZXIpXG4gKlxuICogTm90ZTogd2UgZmlyZSBvZmYgYWxsIHRoZSBtaXhwYW5lbCBmdW5jdGlvbiBjYWxscyAmJiB1c2VyIGRlZmluZWRcbiAqIGZ1bmN0aW9ucyBCRUZPUkUgd2UgZmlyZSBvZmYgbWl4cGFuZWwgdHJhY2tpbmcgY2FsbHMuIFRoaXMgaXMgc29cbiAqIGlkZW50aWZ5L3JlZ2lzdGVyL3NldF9jb25maWcgY2FsbHMgY2FuIHByb3Blcmx5IG1vZGlmeSBlYXJseVxuICogdHJhY2tpbmcgY2FsbHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9leGVjdXRlX2FycmF5ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgZm5fbmFtZSwgYWxpYXNfY2FsbHMgPSBbXSwgb3RoZXJfY2FsbHMgPSBbXSwgdHJhY2tpbmdfY2FsbHMgPSBbXTtcbiAgICBfLmVhY2goYXJyYXksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGZuX25hbWUgPSBpdGVtWzBdO1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShmbl9uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRyYWNraW5nX2NhbGxzLnB1c2goaXRlbSk7IC8vIGNoYWluZWQgY2FsbCBlLmcuIG1peHBhbmVsLmdldF9ncm91cCgpLnNldCgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpdGVtKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KGl0ZW0pICYmIGZuX25hbWUgPT09ICdhbGlhcycpIHtcbiAgICAgICAgICAgICAgICBhbGlhc19jYWxscy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoaXRlbSkgJiYgZm5fbmFtZS5pbmRleE9mKCd0cmFjaycpICE9PSAtMSAmJiB0eXBlb2YodGhpc1tmbl9uYW1lXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cmFja2luZ19jYWxscy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdGhlcl9jYWxscy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB2YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uKGNhbGxzLCBjb250ZXh0KSB7XG4gICAgICAgIF8uZWFjaChjYWxscywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShpdGVtWzBdKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoYWluZWQgY2FsbFxuICAgICAgICAgICAgICAgIHZhciBjYWxsZXIgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIF8uZWFjaChpdGVtLCBmdW5jdGlvbihjYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlciA9IGNhbGxlcltjYWxsWzBdXS5hcHBseShjYWxsZXIsIGNhbGwuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2l0ZW1bMF1dLmFwcGx5KHRoaXMsIGl0ZW0uc2xpY2UoMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgZXhlY3V0ZShhbGlhc19jYWxscywgdGhpcyk7XG4gICAgZXhlY3V0ZShvdGhlcl9jYWxscywgdGhpcyk7XG4gICAgZXhlY3V0ZSh0cmFja2luZ19jYWxscywgdGhpcyk7XG59O1xuXG4vLyByZXF1ZXN0IHF1ZXVlaW5nIHV0aWxzXG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5hcmVfYmF0Y2hlcnNfaW5pdGlhbGl6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISF0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9iYXRjaGVyX2NvbmZpZ3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcXVldWVfcHJlZml4ID0gJ19fbXBxXycgKyB0aGlzLmdldF9jb25maWcoJ3Rva2VuJyk7XG4gICAgdmFyIGFwaV9yb3V0ZXMgPSB0aGlzLmdldF9jb25maWcoJ2FwaV9yb3V0ZXMnKTtcbiAgICB0aGlzLl9iYXRjaGVyX2NvbmZpZ3MgPSB0aGlzLl9iYXRjaGVyX2NvbmZpZ3MgfHwge1xuICAgICAgICBldmVudHM6IHt0eXBlOiAnZXZlbnRzJywgZW5kcG9pbnQ6ICcvJyArIGFwaV9yb3V0ZXNbJ3RyYWNrJ10sIHF1ZXVlX2tleTogcXVldWVfcHJlZml4ICsgJ19ldid9LFxuICAgICAgICBwZW9wbGU6IHt0eXBlOiAncGVvcGxlJywgZW5kcG9pbnQ6ICcvJyArIGFwaV9yb3V0ZXNbJ2VuZ2FnZSddLCBxdWV1ZV9rZXk6IHF1ZXVlX3ByZWZpeCArICdfcHAnfSxcbiAgICAgICAgZ3JvdXBzOiB7dHlwZTogJ2dyb3VwcycsIGVuZHBvaW50OiAnLycgKyBhcGlfcm91dGVzWydncm91cHMnXSwgcXVldWVfa2V5OiBxdWV1ZV9wcmVmaXggKyAnX2dyJ31cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9iYXRjaGVyX2NvbmZpZ3M7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdF9iYXRjaGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5hcmVfYmF0Y2hlcnNfaW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICB2YXIgYmF0Y2hlcl9mb3IgPSBfLmJpbmQoZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVxdWVzdEJhdGNoZXIoXG4gICAgICAgICAgICAgICAgYXR0cnMucXVldWVfa2V5LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGliQ29uZmlnOiB0aGlzWydjb25maWcnXSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXBvcnRlcjogdGhpcy5nZXRfY29uZmlnKCdlcnJvcl9yZXBvcnRlcicpLFxuICAgICAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdEZ1bmM6IF8uYmluZChmdW5jdGlvbihkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZF9yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArIGF0dHJzLmVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0KGRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZV9jYWxsYmFjayhjYiwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVTZW5kSG9vazogXy5iaW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5faG9vaygnYmVmb3JlX3NlbmRfJyArIGF0dHJzLnR5cGUsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcEFsbEJhdGNoaW5nRnVuYzogXy5iaW5kKHRoaXMuc3RvcF9iYXRjaF9zZW5kZXJzLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlUGVyc2lzdGVuY2U6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdmFyIGJhdGNoZXJfY29uZmlncyA9IHRoaXMuZ2V0X2JhdGNoZXJfY29uZmlncygpO1xuICAgICAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMgPSB7XG4gICAgICAgICAgICBldmVudHM6IGJhdGNoZXJfZm9yKGJhdGNoZXJfY29uZmlncy5ldmVudHMpLFxuICAgICAgICAgICAgcGVvcGxlOiBiYXRjaGVyX2ZvcihiYXRjaGVyX2NvbmZpZ3MucGVvcGxlKSxcbiAgICAgICAgICAgIGdyb3VwczogYmF0Y2hlcl9mb3IoYmF0Y2hlcl9jb25maWdzLmdyb3VwcylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnYmF0Y2hfYXV0b3N0YXJ0JykpIHtcbiAgICAgICAgdGhpcy5zdGFydF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X2JhdGNoX3NlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iYXRjaGVyc193ZXJlX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gdHJ1ZTtcbiAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgYmF0Y2hlci5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9iYXRjaF9zZW5kZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSBmYWxzZTtcbiAgICBfLmVhY2godGhpcy5yZXF1ZXN0X2JhdGNoZXJzLCBmdW5jdGlvbihiYXRjaGVyKSB7XG4gICAgICAgIGJhdGNoZXIuc3RvcCgpO1xuICAgICAgICBiYXRjaGVyLmNsZWFyKCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIHB1c2goKSBrZWVwcyB0aGUgc3RhbmRhcmQgYXN5bmMtYXJyYXktcHVzaFxuICogYmVoYXZpb3IgYXJvdW5kIGFmdGVyIHRoZSBsaWIgaXMgbG9hZGVkLlxuICogVGhpcyBpcyBvbmx5IHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaW50ZWdyYXRpb25zIHRoYXRcbiAqIGRvIG5vdCB3aXNoIHRvIHJlbHkgb24gb3VyIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqIChjcmVhdGVkIGluIHRoZSBzbmlwcGV0KS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKiAgICAgbWl4cGFuZWwucHVzaChbJ3JlZ2lzdGVyJywgeyBhOiAnYicgfV0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW0gQSBbZnVuY3Rpb25fbmFtZSwgYXJncy4uLl0gYXJyYXkgdG8gYmUgZXhlY3V0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgdGhpcy5fZXhlY3V0ZV9hcnJheShbaXRlbV0pO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIGV2ZW50cyBvbiB0aGUgTWl4cGFuZWwgb2JqZWN0LiBJZiBwYXNzZWQgbm8gYXJndW1lbnRzLFxuICogdGhpcyBmdW5jdGlvbiBkaXNhYmxlcyB0cmFja2luZyBvZiBhbnkgZXZlbnQuIElmIHBhc3NlZCBhblxuICogYXJyYXkgb2YgZXZlbnQgbmFtZXMsIHRob3NlIGV2ZW50cyB3aWxsIGJlIGRpc2FibGVkLCBidXQgb3RoZXJcbiAqIGV2ZW50cyB3aWxsIGNvbnRpbnVlIHRvIGJlIHRyYWNrZWQuXG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdG9wIG90aGVyIG1peHBhbmVsIGZ1bmN0aW9ucyBmcm9tXG4gKiBmaXJpbmcsIHN1Y2ggYXMgcmVnaXN0ZXIoKSBvciBwZW9wbGUuc2V0KCkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW2V2ZW50c10gQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGlzYWJsZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgIGlmICh0eXBlb2YoZXZlbnRzKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fZmxhZ3MuZGlzYWJsZV9hbGxfZXZlbnRzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gdGhpcy5fX2Rpc2FibGVkX2V2ZW50cy5jb25jYXQoZXZlbnRzKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBlbmNvZGVkX2RhdGEgPSBfLkpTT05FbmNvZGUoZGF0YSk7XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnYXBpX3BheWxvYWRfZm9ybWF0JykgPT09IFBBWUxPQURfVFlQRV9CQVNFNjQpIHtcbiAgICAgICAgZW5jb2RlZF9kYXRhID0gXy5iYXNlNjRFbmNvZGUoZW5jb2RlZF9kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHsnZGF0YSc6IGVuY29kZWRfZGF0YX07XG59O1xuXG4vLyBpbnRlcm5hbCBtZXRob2QgZm9yIGhhbmRsaW5nIHRyYWNrIHZzIGJhdGNoLWVucXVldWUgbG9naWNcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fdHJhY2tfb3JfYmF0Y2ggPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciB0cnVuY2F0ZWRfZGF0YSA9IF8udHJ1bmNhdGUob3B0aW9ucy5kYXRhLCAyNTUpO1xuICAgIHZhciBlbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnQ7XG4gICAgdmFyIGJhdGNoZXIgPSBvcHRpb25zLmJhdGNoZXI7XG4gICAgdmFyIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5ID0gb3B0aW9ucy5zaG91bGRfc2VuZF9pbW1lZGlhdGVseTtcbiAgICB2YXIgc2VuZF9yZXF1ZXN0X29wdGlvbnMgPSBvcHRpb25zLnNlbmRfcmVxdWVzdF9vcHRpb25zIHx8IHt9O1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgTk9PUF9GVU5DO1xuXG4gICAgdmFyIHJlcXVlc3RfZW5xdWV1ZWRfb3JfaW5pdGlhdGVkID0gdHJ1ZTtcbiAgICB2YXIgc2VuZF9yZXF1ZXN0X2ltbWVkaWF0ZWx5ID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbmRfcmVxdWVzdF9vcHRpb25zLnNraXBfaG9va3MpIHtcbiAgICAgICAgICAgIHRydW5jYXRlZF9kYXRhID0gdGhpcy5fcnVuX2hvb2soJ2JlZm9yZV9zZW5kXycgKyBvcHRpb25zLnR5cGUsIHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJ1bmNhdGVkX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5sb2coJ01JWFBBTkVMIFJFUVVFU1Q6Jyk7XG4gICAgICAgICAgICBjb25zb2xlJDEubG9nKHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlX2RhdGFfZm9yX3JlcXVlc3QodHJ1bmNhdGVkX2RhdGEpLFxuICAgICAgICAgICAgICAgIHNlbmRfcmVxdWVzdF9vcHRpb25zLFxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVfY2FsbGJhY2soY2FsbGJhY2ssIHRydW5jYXRlZF9kYXRhKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5fYmF0Y2hfcmVxdWVzdHMgJiYgIXNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5KSB7XG4gICAgICAgIGJhdGNoZXIuZW5xdWV1ZSh0cnVuY2F0ZWRfZGF0YSkudGhlbihmdW5jdGlvbihzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygxLCB0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCA9IHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCAmJiB0cnVuY2F0ZWRfZGF0YTtcbn07XG5cbi8qKlxuICogVHJhY2sgYW4gZXZlbnQuIFRoaXMgaXMgdGhlIG1vc3QgaW1wb3J0YW50IGFuZFxuICogZnJlcXVlbnRseSB1c2VkIE1peHBhbmVsIGZ1bmN0aW9uLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgYW4gZXZlbnQgbmFtZWQgJ1JlZ2lzdGVyZWQnXG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ1JlZ2lzdGVyZWQnLCB7J0dlbmRlcic6ICdNYWxlJywgJ0FnZSc6IDIxfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIGFuIGV2ZW50IHVzaW5nIG5hdmlnYXRvci5zZW5kQmVhY29uXG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ0xlZnQgcGFnZScsIHsnZHVyYXRpb25fc2Vjb25kcyc6IDM1fSwge3RyYW5zcG9ydDogJ3NlbmRCZWFjb24nfSk7XG4gKlxuICogVG8gdHJhY2sgbGluayBjbGlja3Mgb3IgZm9ybSBzdWJtaXNzaW9ucywgc2VlIHRyYWNrX2xpbmtzKCkgb3IgdHJhY2tfZm9ybXMoKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuIFRoaXMgY2FuIGJlIGFueXRoaW5nIHRoZSB1c2VyIGRvZXMgLSAnQnV0dG9uIENsaWNrJywgJ1NpZ24gVXAnLCAnSXRlbSBQdXJjaGFzZWQnLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZy4gVGhlc2UgZGVzY3JpYmUgdGhlIHVzZXIgd2hvIGRpZCB0aGUgZXZlbnQgb3IgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQgaXRzZWxmLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHRyYWNrIHJlcXVlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJhbnNwb3J0XSBUcmFuc3BvcnQgbWV0aG9kIGZvciBuZXR3b3JrIHJlcXVlc3QgKCd4aHInIG9yICdzZW5kQmVhY29uJykuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlbmRfaW1tZWRpYXRlbHldIFdoZXRoZXIgdG8gYnlwYXNzIGJhdGNoaW5nL3F1ZXVlaW5nIGFuZCBzZW5kIHRyYWNrIHJlcXVlc3QgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0Jvb2xlYW58T2JqZWN0fSBJZiB0aGUgdHJhY2tpbmcgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYXRlZC9xdWV1ZWQsIGFuIG9iamVjdFxuICogd2l0aCB0aGUgdHJhY2tpbmcgcGF5bG9hZCBzZW50IHRvIHRoZSBBUEkgc2VydmVyIGlzIHJldHVybmVkOyBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFjayA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0cmFuc3BvcnQgPSBvcHRpb25zWyd0cmFuc3BvcnQnXTsgLy8gZXh0ZXJuYWwgQVBJLCBkb24ndCBtaW5pZnkgJ3RyYW5zcG9ydCcgcHJvcFxuICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7IC8vICd0cmFuc3BvcnQnIHByb3AgbmFtZSBjYW4gYmUgbWluaWZpZWQgaW50ZXJuYWxseVxuICAgIH1cbiAgICB2YXIgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHkgPSBvcHRpb25zWydzZW5kX2ltbWVkaWF0ZWx5J107XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IE5PT1BfRlVOQztcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChldmVudF9uYW1lKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignTm8gZXZlbnQgbmFtZSBwcm92aWRlZCB0byBtaXhwYW5lbC50cmFjaycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50X2lzX2Rpc2FibGVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHRzXG4gICAgcHJvcGVydGllcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKTtcbiAgICBwcm9wZXJ0aWVzWyd0b2tlbiddID0gdGhpcy5nZXRfY29uZmlnKCd0b2tlbicpO1xuXG4gICAgLy8gc2V0ICRkdXJhdGlvbiBpZiB0aW1lX2V2ZW50IHdhcyBwcmV2aW91c2x5IGNhbGxlZCBmb3IgdGhpcyBldmVudFxuICAgIHZhciBzdGFydF90aW1lc3RhbXAgPSB0aGlzWydwZXJzaXN0ZW5jZSddLnJlbW92ZV9ldmVudF90aW1lcihldmVudF9uYW1lKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3RhcnRfdGltZXN0YW1wKSkge1xuICAgICAgICB2YXIgZHVyYXRpb25faW5fbXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0X3RpbWVzdGFtcDtcbiAgICAgICAgcHJvcGVydGllc1snJGR1cmF0aW9uJ10gPSBwYXJzZUZsb2F0KChkdXJhdGlvbl9pbl9tcyAvIDEwMDApLnRvRml4ZWQoMykpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldF9kZWZhdWx0X3N1cGVycHJvcHMoKTtcblxuICAgIHZhciBtYXJrZXRpbmdfcHJvcGVydGllcyA9IHRoaXMuZ2V0X2NvbmZpZygndHJhY2tfbWFya2V0aW5nJylcbiAgICAgICAgPyBfLmluZm8ubWFya2V0aW5nUGFyYW1zKClcbiAgICAgICAgOiB7fTtcblxuICAgIC8vIG5vdGU6IGV4dGVuZCB3cml0ZXMgdG8gdGhlIGZpcnN0IG9iamVjdCwgc28gbGV0cyBtYWtlIHN1cmUgd2VcbiAgICAvLyBkb24ndCB3cml0ZSB0byB0aGUgcGVyc2lzdGVuY2UgcHJvcGVydGllcyBvYmplY3QgYW5kIGluZm9cbiAgICAvLyBwcm9wZXJ0aWVzIG9iamVjdCBieSBwYXNzaW5nIGluIGEgbmV3IG9iamVjdFxuXG4gICAgLy8gdXBkYXRlIHByb3BlcnRpZXMgd2l0aCBwYWdldmlldyBpbmZvIGFuZCBzdXBlci1wcm9wZXJ0aWVzXG4gICAgcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgXy5pbmZvLnByb3BlcnRpZXMoeydtcF9sb2FkZXInOiB0aGlzLmdldF9jb25maWcoJ21wX2xvYWRlcicpfSksXG4gICAgICAgIG1hcmtldGluZ19wcm9wZXJ0aWVzLFxuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnByb3BlcnRpZXMoKSxcbiAgICAgICAgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzLFxuICAgICAgICB0aGlzLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzKCksXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICApO1xuXG4gICAgdmFyIHByb3BlcnR5X2JsYWNrbGlzdCA9IHRoaXMuZ2V0X2NvbmZpZygncHJvcGVydHlfYmxhY2tsaXN0Jyk7XG4gICAgaWYgKF8uaXNBcnJheShwcm9wZXJ0eV9ibGFja2xpc3QpKSB7XG4gICAgICAgIF8uZWFjaChwcm9wZXJ0eV9ibGFja2xpc3QsIGZ1bmN0aW9uKGJsYWNrbGlzdGVkX3Byb3ApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzW2JsYWNrbGlzdGVkX3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcHJvcGVydHlfYmxhY2tsaXN0IGNvbmZpZzogJyArIHByb3BlcnR5X2JsYWNrbGlzdCk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICdldmVudCc6IGV2ZW50X25hbWUsXG4gICAgICAgICdwcm9wZXJ0aWVzJzogcHJvcGVydGllc1xuICAgIH07XG4gICAgdmFyIHJldCA9IHRoaXMuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ2V2ZW50cycsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGVuZHBvaW50OiB0aGlzLmdldF9jb25maWcoJ2FwaV9ob3N0JykgKyAnLycgKyB0aGlzLmdldF9jb25maWcoJ2FwaV9yb3V0ZXMnKVsndHJhY2snXSxcbiAgICAgICAgYmF0Y2hlcjogdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cyxcbiAgICAgICAgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHk6IHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5LFxuICAgICAgICBzZW5kX3JlcXVlc3Rfb3B0aW9uczogb3B0aW9uc1xuICAgIH0sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiByZXQ7XG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGUgY3VycmVudCB1c2VyIGludG8gb25lL21hbnkgZ3JvdXBzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLnNldF9ncm91cCgnY29tcGFueScsIFsnbWl4cGFuZWwnLCAnZ29vZ2xlJ10pIC8vIGFuIGFycmF5IG9mIElEc1xuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCAxMjg3NDYzMTIpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfE51bWJlcn0gZ3JvdXBfaWRzIEFuIGFycmF5IG9mIGdyb3VwIElEcywgb3IgYSBzaW5ndWxhciBncm91cCBJRFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWRzLCBjYWxsYmFjaykge1xuICAgIGlmICghXy5pc0FycmF5KGdyb3VwX2lkcykpIHtcbiAgICAgICAgZ3JvdXBfaWRzID0gW2dyb3VwX2lkc107XG4gICAgfVxuICAgIHZhciBwcm9wID0ge307XG4gICAgcHJvcFtncm91cF9rZXldID0gZ3JvdXBfaWRzO1xuICAgIHRoaXMucmVnaXN0ZXIocHJvcCk7XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnNldChncm91cF9rZXksIGdyb3VwX2lkcywgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogQWRkIGEgbmV3IGdyb3VwIGZvciB0aGlzIHVzZXIuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwuYWRkX2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHsqfSBncm91cF9pZCBBIHZhbGlkIE1peHBhbmVsIHByb3BlcnR5IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5hZGRfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9sZF92YWx1ZXMgPSB0aGlzLmdldF9wcm9wZXJ0eShncm91cF9rZXkpO1xuICAgIHZhciBwcm9wID0ge307XG4gICAgaWYgKG9sZF92YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wW2dyb3VwX2tleV0gPSBbZ3JvdXBfaWRdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvbGRfdmFsdWVzLmluZGV4T2YoZ3JvdXBfaWQpID09PSAtMSkge1xuICAgICAgICAgICAgb2xkX3ZhbHVlcy5wdXNoKGdyb3VwX2lkKTtcbiAgICAgICAgICAgIHByb3BbZ3JvdXBfa2V5XSA9IG9sZF92YWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS51bmlvbihncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBSZW1vdmUgYSBncm91cCBmcm9tIHRoaXMgdXNlci5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC5yZW1vdmVfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0geyp9IGdyb3VwX2lkIEEgdmFsaWQgTWl4cGFuZWwgcHJvcGVydHkgdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlbW92ZV9ncm91cCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2xkX3ZhbHVlID0gdGhpcy5nZXRfcHJvcGVydHkoZ3JvdXBfa2V5KTtcbiAgICAvLyBpZiB0aGUgdmFsdWUgZG9lc24ndCBleGlzdCwgdGhlIHBlcnNpc3RlbnQgc3RvcmUgaXMgdW5jaGFuZ2VkXG4gICAgaWYgKG9sZF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBpZHggPSBvbGRfdmFsdWUuaW5kZXhPZihncm91cF9pZCk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgb2xkX3ZhbHVlLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih7Z3JvdXBfa2V5OiBvbGRfdmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkX3ZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGdyb3VwX2tleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnJlbW92ZShncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBUcmFjayBhbiBldmVudCB3aXRoIHNwZWNpZmljIGdyb3Vwcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC50cmFja193aXRoX2dyb3VwcygncHVyY2hhc2UnLCB7J3Byb2R1Y3QnOiAnaXBob25lJ30sIHsnVW5pdmVyc2l0eSc6IFsnVUNCJywgJ1VDTEEnXX0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChzZWUgYG1peHBhbmVsLnRyYWNrKClgKVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZyAoc2VlIGBtaXhwYW5lbC50cmFjaygpYClcbiAqIEBwYXJhbSB7T2JqZWN0PX0gZ3JvdXBzIEFuIG9iamVjdCBtYXBwaW5nIGdyb3VwIG5hbWUga2V5cyB0byBvbmUgb3IgbW9yZSB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja193aXRoX2dyb3VwcyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgZ3JvdXBzLCBjYWxsYmFjaykge1xuICAgIHZhciB0cmFja2luZ19wcm9wcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICBfLmVhY2goZ3JvdXBzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmICh2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhY2tpbmdfcHJvcHNba10gPSB2O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2soZXZlbnRfbmFtZSwgdHJhY2tpbmdfcHJvcHMsIGNhbGxiYWNrKTtcbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2NyZWF0ZV9tYXBfa2V5ID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICByZXR1cm4gZ3JvdXBfa2V5ICsgJ18nICsgSlNPTi5zdHJpbmdpZnkoZ3JvdXBfaWQpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9yZW1vdmVfZ3JvdXBfZnJvbV9jYWNoZSA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZF9ncm91cHNbdGhpcy5fY3JlYXRlX21hcF9rZXkoZ3JvdXBfa2V5LCBncm91cF9pZCldO1xufTtcblxuLyoqXG4gKiBMb29rIHVwIHJlZmVyZW5jZSB0byBhIE1peHBhbmVsIGdyb3VwXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgIG1peHBhbmVsLmdldF9ncm91cChncm91cF9rZXksIGdyb3VwX2lkKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gZ3JvdXBfaWQgQSB2YWxpZCBNaXhwYW5lbCBwcm9wZXJ0eSB0eXBlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIE1peHBhbmVsR3JvdXAgaWRlbnRpZmllclxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2dyb3VwID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICB2YXIgbWFwX2tleSA9IHRoaXMuX2NyZWF0ZV9tYXBfa2V5KGdyb3VwX2tleSwgZ3JvdXBfaWQpO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2NhY2hlZF9ncm91cHNbbWFwX2tleV07XG4gICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQgfHwgZ3JvdXAuX2dyb3VwX2tleSAhPT0gZ3JvdXBfa2V5IHx8IGdyb3VwLl9ncm91cF9pZCAhPT0gZ3JvdXBfaWQpIHtcbiAgICAgICAgZ3JvdXAgPSBuZXcgTWl4cGFuZWxHcm91cCgpO1xuICAgICAgICBncm91cC5faW5pdCh0aGlzLCBncm91cF9rZXksIGdyb3VwX2lkKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkX2dyb3Vwc1ttYXBfa2V5XSA9IGdyb3VwO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG59O1xuXG4vKipcbiAqIFRyYWNrIGEgZGVmYXVsdCBNaXhwYW5lbCBwYWdlIHZpZXcgZXZlbnQsIHdoaWNoIGluY2x1ZGVzIGV4dHJhIGRlZmF1bHQgZXZlbnQgcHJvcGVydGllcyB0b1xuICogaW1wcm92ZSBwYWdlIHZpZXcgZGF0YS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIGEgZGVmYXVsdCAkbXBfd2ViX3BhZ2VfdmlldyBldmVudFxuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KCk7XG4gKlxuICogICAgIC8vIHRyYWNrIGEgcGFnZSB2aWV3IGV2ZW50IHdpdGggYWRkaXRpb25hbCBldmVudCBwcm9wZXJ0aWVzXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydhYl90ZXN0X3ZhcmlhbnQnOiAnY2FyZC1sYXlvdXQtYid9KTtcbiAqXG4gKiAgICAgLy8gZXhhbXBsZSBhcHByb2FjaCB0byB0cmFjayBwYWdlIHZpZXdzIG9uIGRpZmZlcmVudCBwYWdlIHR5cGVzIGFzIGV2ZW50IHByb3BlcnRpZXNcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J3BhZ2UnOiAncHJpY2luZyd9KTtcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J3BhZ2UnOiAnaG9tZXBhZ2UnfSk7XG4gKlxuICogICAgIC8vIFVOQ09NTU9OOiBUcmFja2luZyBhIHBhZ2UgdmlldyBldmVudCB3aXRoIGEgY3VzdG9tIGV2ZW50X25hbWUgb3B0aW9uLiBOT1QgZXhwZWN0ZWQgdG8gYmUgdXNlZCBmb3JcbiAqICAgICAvLyBpbmRpdmlkdWFsIHBhZ2VzIG9uIHRoZSBzYW1lIHNpdGUgb3IgcHJvZHVjdC4gVXNlIGNhc2VzIGZvciBjdXN0b20gZXZlbnRfbmFtZSBtYXkgYmUgcGFnZVxuICogICAgIC8vIHZpZXdzIG9uIGRpZmZlcmVudCBwcm9kdWN0cyBvciBpbnRlcm5hbCBhcHBsaWNhdGlvbnMgdGhhdCBhcmUgY29uc2lkZXJlZCBjb21wbGV0ZWx5IHNlcGFyYXRlXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydwYWdlJzogJ2N1c3RvbWVyLXNlYXJjaCd9LCB7J2V2ZW50X25hbWUnOiAnW2ludGVybmFsXSBBZG1pbiBQYWdlIFZpZXcnfSk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIFRoZSBgY29uZmlnLnRyYWNrX3BhZ2V2aWV3YCBvcHRpb24gZm9yIDxhIGhyZWY9XCIjbWl4cGFuZWxpbml0XCI+bWl4cGFuZWwuaW5pdCgpPC9hPlxuICogbWF5IGJlIHR1cm5lZCBvbiBmb3IgdHJhY2tpbmcgcGFnZSBsb2FkcyBhdXRvbWF0aWNhbGx5LlxuICpcbiAqICAgICAvLyB0cmFjayBvbmx5IHBhZ2UgbG9hZHNcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogdHJ1ZX0pO1xuICpcbiAqICAgICAvLyB0cmFjayB3aGVuIHRoZSBVUkwgY2hhbmdlcyBpbiBhbnkgbWFubmVyXG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6ICdmdWxsLXVybCd9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgVVJMIGNoYW5nZXMsIGlnbm9yaW5nIGFueSBjaGFuZ2VzIGluIHRoZSBoYXNoIHBhcnRcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogJ3VybC13aXRoLXBhdGgtYW5kLXF1ZXJ5LXN0cmluZyd9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgcGF0aCBjaGFuZ2VzLCBpZ25vcmluZyBhbnkgcXVlcnkgcGFyYW1ldGVyIG9yIGhhc2ggY2hhbmdlc1xuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiAndXJsLXdpdGgtcGF0aCd9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEFuIG9wdGlvbmFsIHNldCBvZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gc2VuZCB3aXRoIHRoZSBwYWdlIHZpZXcgZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gUGFnZSB2aWV3IHRyYWNraW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ldmVudF9uYW1lXSAtIEFsdGVybmF0ZSBuYW1lIGZvciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufE9iamVjdH0gSWYgdGhlIHRyYWNraW5nIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWF0ZWQvcXVldWVkLCBhbiBvYmplY3RcbiAqIHdpdGggdGhlIHRyYWNraW5nIHBheWxvYWQgc2VudCB0byB0aGUgQVBJIHNlcnZlciBpcyByZXR1cm5lZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfcGFnZXZpZXcgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGV2ZW50X25hbWUgPSBvcHRpb25zWydldmVudF9uYW1lJ10gfHwgJyRtcF93ZWJfcGFnZV92aWV3JztcblxuICAgIHZhciBkZWZhdWx0X3BhZ2VfcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICBfLmluZm8ubXBQYWdlVmlld1Byb3BlcnRpZXMoKSxcbiAgICAgICAgXy5pbmZvLmNhbXBhaWduUGFyYW1zKCksXG4gICAgICAgIF8uaW5mby5jbGlja1BhcmFtcygpXG4gICAgKTtcblxuICAgIHZhciBldmVudF9wcm9wZXJ0aWVzID0gXy5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBkZWZhdWx0X3BhZ2VfcHJvcGVydGllcyxcbiAgICAgICAgcHJvcGVydGllc1xuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy50cmFjayhldmVudF9uYW1lLCBldmVudF9wcm9wZXJ0aWVzKTtcbn0pO1xuXG4vKipcbiAqIFRyYWNrIGNsaWNrcyBvbiBhIHNldCBvZiBkb2N1bWVudCBlbGVtZW50cy4gU2VsZWN0b3IgbXVzdCBiZSBhXG4gKiB2YWxpZCBxdWVyeS4gRWxlbWVudHMgbXVzdCBleGlzdCBvbiB0aGUgcGFnZSBhdCB0aGUgdGltZSB0cmFja19saW5rcyBpcyBjYWxsZWQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBjbGljayBmb3IgbGluayBpZCAjbmF2XG4gKiAgICAgbWl4cGFuZWwudHJhY2tfbGlua3MoJyNuYXYnLCAnQ2xpY2tlZCBOYXYgTGluaycpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgd2FpdCB1cCB0byAzMDAgbXMgZm9yIHRoZSBNaXhwYW5lbFxuICogc2VydmVycyB0byByZXNwb25kLiBJZiB0aGV5IGhhdmUgbm90IHJlc3BvbmRlZCBieSB0aGF0IHRpbWVcbiAqIGl0IHdpbGwgaGVhZCB0byB0aGUgbGluayB3aXRob3V0IGVuc3VyaW5nIHRoYXQgeW91ciBldmVudFxuICogaGFzIGJlZW4gdHJhY2tlZC4gIFRvIGNvbmZpZ3VyZSB0aGlzIHRpbWVvdXQgcGxlYXNlIHNlZSB0aGVcbiAqIHNldF9jb25maWcoKSBkb2N1bWVudGF0aW9uIGJlbG93LlxuICpcbiAqIElmIHlvdSBwYXNzIGEgZnVuY3Rpb24gaW4gYXMgdGhlIHByb3BlcnRpZXMgYXJndW1lbnQsIHRoZVxuICogZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBET01FbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICogZXZlbnQgYXMgYW4gYXJndW1lbnQuICBZb3UgYXJlIGV4cGVjdGVkIHRvIHJldHVybiBhbiBvYmplY3RcbiAqIGZyb20gdGhlIGZ1bmN0aW9uOyBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIHRoaXMgb2JqZWN0XG4gKiB3aWxsIGJlIHNlbnQgdG8gbWl4cGFuZWwgYXMgZXZlbnQgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHF1ZXJ5IEEgdmFsaWQgRE9NIHF1ZXJ5LCBlbGVtZW50IG9yIGpRdWVyeS1lc3F1ZSBsaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbcHJvcGVydGllc10gQSBwcm9wZXJ0aWVzIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBkaWN0aW9uYXJ5IG9mIHByb3BlcnRpZXMgd2hlbiBwYXNzZWQgYSBET01FbGVtZW50XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19saW5rcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFja19kb20uY2FsbCh0aGlzLCBMaW5rVHJhY2tlciwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogVHJhY2sgZm9ybSBzdWJtaXNzaW9ucy4gU2VsZWN0b3IgbXVzdCBiZSBhIHZhbGlkIHF1ZXJ5LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgc3VibWlzc2lvbiBmb3IgZm9ybSBpZCAncmVnaXN0ZXInXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfZm9ybXMoJyNyZWdpc3RlcicsICdDcmVhdGVkIEFjY291bnQnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHdhaXQgdXAgdG8gMzAwIG1zIGZvciB0aGUgbWl4cGFuZWxcbiAqIHNlcnZlcnMgdG8gcmVzcG9uZCwgaWYgdGhleSBoYXZlIG5vdCByZXNwb25kZWQgYnkgdGhhdCB0aW1lXG4gKiBpdCB3aWxsIGhlYWQgdG8gdGhlIGxpbmsgd2l0aG91dCBlbnN1cmluZyB0aGF0IHlvdXIgZXZlbnRcbiAqIGhhcyBiZWVuIHRyYWNrZWQuICBUbyBjb25maWd1cmUgdGhpcyB0aW1lb3V0IHBsZWFzZSBzZWUgdGhlXG4gKiBzZXRfY29uZmlnKCkgZG9jdW1lbnRhdGlvbiBiZWxvdy5cbiAqXG4gKiBJZiB5b3UgcGFzcyBhIGZ1bmN0aW9uIGluIGFzIHRoZSBwcm9wZXJ0aWVzIGFyZ3VtZW50LCB0aGVcbiAqIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgRE9NRWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGVcbiAqIGV2ZW50IGFzIGFuIGFyZ3VtZW50LiAgWW91IGFyZSBleHBlY3RlZCB0byByZXR1cm4gYW4gb2JqZWN0XG4gKiBmcm9tIHRoZSBmdW5jdGlvbjsgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGlzIG9iamVjdFxuICogd2lsbCBiZSBzZW50IHRvIG1peHBhbmVsIGFzIGV2ZW50IHByb3BlcnRpZXMuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBxdWVyeSBBIHZhbGlkIERPTSBxdWVyeSwgZWxlbWVudCBvciBqUXVlcnktZXNxdWUgbGlzdFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyYWNrXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW3Byb3BlcnRpZXNdIFRoaXMgY2FuIGJlIGEgc2V0IG9mIHByb3BlcnRpZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIHByb3BlcnRpZXMgYWZ0ZXIgYmVpbmcgcGFzc2VkIGEgRE9NRWxlbWVudFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfZm9ybXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tfZG9tLmNhbGwodGhpcywgRm9ybVRyYWNrZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFRpbWUgYW4gZXZlbnQgYnkgaW5jbHVkaW5nIHRoZSB0aW1lIGJldHdlZW4gdGhpcyBjYWxsIGFuZCBhXG4gKiBsYXRlciAndHJhY2snIGNhbGwgZm9yIHRoZSBzYW1lIGV2ZW50IGluIHRoZSBwcm9wZXJ0aWVzIHNlbnRcbiAqIHdpdGggdGhlIGV2ZW50LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdGltZSBhbiBldmVudCBuYW1lZCAnUmVnaXN0ZXJlZCdcbiAqICAgICBtaXhwYW5lbC50aW1lX2V2ZW50KCdSZWdpc3RlcmVkJyk7XG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ1JlZ2lzdGVyZWQnLCB7J0dlbmRlcic6ICdNYWxlJywgJ0FnZSc6IDIxfSk7XG4gKlxuICogV2hlbiBjYWxsZWQgZm9yIGEgcGFydGljdWxhciBldmVudCBuYW1lLCB0aGUgbmV4dCB0cmFjayBjYWxsIGZvciB0aGF0IGV2ZW50XG4gKiBuYW1lIHdpbGwgaW5jbHVkZSB0aGUgZWxhcHNlZCB0aW1lIGJldHdlZW4gdGhlICd0aW1lX2V2ZW50JyBhbmQgJ3RyYWNrJ1xuICogY2FsbHMuIFRoaXMgdmFsdWUgaXMgc3RvcmVkIGFzIHNlY29uZHMgaW4gdGhlICckZHVyYXRpb24nIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRpbWVfZXZlbnQgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ05vIGV2ZW50IG5hbWUgcHJvdmlkZWQgdG8gbWl4cGFuZWwudGltZV9ldmVudCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50X2lzX2Rpc2FibGVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnNldF9ldmVudF90aW1lcihldmVudF9uYW1lLCAgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xufTtcblxudmFyIFJFR0lTVEVSX0RFRkFVTFRTID0ge1xuICAgICdwZXJzaXN0ZW50JzogdHJ1ZVxufTtcbi8qKlxuICogSGVscGVyIHRvIHBhcnNlIG9wdGlvbnMgcGFyYW0gZm9yIHJlZ2lzdGVyIG1ldGhvZHMsIG1haW50YWluaW5nXG4gKiBsZWdhY3kgc3VwcG9ydCBmb3IgcGxhaW4gXCJkYXlzXCIgcGFyYW0gaW5zdGVhZCBvZiBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF5c19vcl9vcHRpb25zXSAnZGF5cycgb3B0aW9uIChOdW1iZXIpLCBvciBPcHRpb25zIG9iamVjdCBmb3IgcmVnaXN0ZXIgbWV0aG9kc1xuICogQHJldHVybnMge09iamVjdH0gb3B0aW9ucyBvYmplY3RcbiAqL1xudmFyIG9wdGlvbnNfZm9yX3JlZ2lzdGVyID0gZnVuY3Rpb24oZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgaWYgKF8uaXNPYmplY3QoZGF5c19vcl9vcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gZGF5c19vcl9vcHRpb25zO1xuICAgIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQoZGF5c19vcl9vcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geydkYXlzJzogZGF5c19vcl9vcHRpb25zfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHJldHVybiBfLmV4dGVuZCh7fSwgUkVHSVNURVJfREVGQVVMVFMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHNldCBvZiBzdXBlciBwcm9wZXJ0aWVzLCB3aGljaCBhcmUgaW5jbHVkZWQgd2l0aCBhbGxcbiAqIGV2ZW50cy4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBwcmV2aW91cyBzdXBlciBwcm9wZXJ0eSB2YWx1ZXMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyByZWdpc3RlciAnR2VuZGVyJyBhcyBhIHN1cGVyIHByb3BlcnR5XG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXIoeydHZW5kZXInOiAnRmVtYWxlJ30pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBzZXZlcmFsIHN1cGVyIHByb3BlcnRpZXMgd2hlbiBhIHVzZXIgc2lnbnMgdXBcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcih7XG4gKiAgICAgICAgICdFbWFpbCc6ICdqZG9lQGV4YW1wbGUuY29tJyxcbiAqICAgICAgICAgJ0FjY291bnQgVHlwZSc6ICdGcmVlJ1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBvbmx5IGZvciB0aGUgY3VycmVudCBwYWdlbG9hZFxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyKHsnTmFtZSc6ICdQYXQnfSwge3BlcnNpc3RlbnQ6IGZhbHNlfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgQW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgcHJvcGVydGllcyB0byBzdG9yZSBhYm91dCB0aGUgdXNlclxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF5c19vcl9vcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5kYXlzXSAtIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLnBlcnNpc3RlbnQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHB1dCBpbiBwZXJzaXN0ZW50IHN0b3JhZ2UgKGNvb2tpZS9sb2NhbFN0b3JhZ2UpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3BzLCBkYXlzX29yX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKGRheXNfb3Jfb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnNbJ3BlcnNpc3RlbnQnXSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnJlZ2lzdGVyKHByb3BzLCBvcHRpb25zWydkYXlzJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcywgcHJvcHMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBzZXQgb2Ygc3VwZXIgcHJvcGVydGllcyBvbmx5IG9uY2UuIFRoaXMgd2lsbCBub3RcbiAqIG92ZXJ3cml0ZSBwcmV2aW91cyBzdXBlciBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZSByZWdpc3RlcigpLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgYSBzdXBlciBwcm9wZXJ0eSBmb3IgdGhlIGZpcnN0IHRpbWUgb25seVxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyX29uY2Uoe1xuICogICAgICAgICAnRmlyc3QgTG9naW4gRGF0ZSc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBvbmNlLCBvbmx5IGZvciB0aGUgY3VycmVudCBwYWdlbG9hZFxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyX29uY2Uoe1xuICogICAgICAgICAnRmlyc3QgaW50ZXJhY3Rpb24gdGltZSc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICogICAgIH0sICdOb25lJywge3BlcnNpc3RlbnQ6IGZhbHNlfSk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIElmIGRlZmF1bHRfdmFsdWUgaXMgc3BlY2lmaWVkLCBjdXJyZW50IHN1cGVyIHByb3BlcnRpZXNcbiAqIHdpdGggdGhhdCB2YWx1ZSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gc3RvcmUgYWJvdXQgdGhlIHVzZXJcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRfdmFsdWVdIFZhbHVlIHRvIG92ZXJyaWRlIGlmIGFscmVhZHkgc2V0IGluIHN1cGVyIHByb3BlcnRpZXMgKGV4OiAnRmFsc2UnKSBEZWZhdWx0OiAnTm9uZSdcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgb3IgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMuZGF5c10gLSBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBwdXQgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXJfb25jZSA9IGZ1bmN0aW9uKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBkYXlzX29yX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKGRheXNfb3Jfb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnNbJ3BlcnNpc3RlbnQnXSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnJlZ2lzdGVyX29uY2UocHJvcHMsIGRlZmF1bHRfdmFsdWUsIG9wdGlvbnNbJ2RheXMnXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZihkZWZhdWx0X3ZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRlZmF1bHRfdmFsdWUgPSAnTm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgXy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWwsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzLmhhc093blByb3BlcnR5KHByb3ApIHx8IHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wXSA9PT0gZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZWxldGUgYSBzdXBlciBwcm9wZXJ0eSBzdG9yZWQgd2l0aCB0aGUgY3VycmVudCB1c2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBlcnNpc3RlbnQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIGxvb2sgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3BlcnR5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS51bnJlZ2lzdGVyKHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzW3Byb3BlcnR5XTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3JlZ2lzdGVyX3NpbmdsZSA9IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgcHJvcHNbcHJvcF0gPSB2YWx1ZTtcbiAgICB0aGlzLnJlZ2lzdGVyKHByb3BzKTtcbn07XG5cbi8qKlxuICogSWRlbnRpZnkgYSB1c2VyIHdpdGggYSB1bmlxdWUgSUQgdG8gdHJhY2sgdXNlciBhY3Rpdml0eSBhY3Jvc3NcbiAqIGRldmljZXMsIHRpZSBhIHVzZXIgdG8gdGhlaXIgZXZlbnRzLCBhbmQgY3JlYXRlIGEgdXNlciBwcm9maWxlLlxuICogSWYgeW91IG5ldmVyIGNhbGwgdGhpcyBtZXRob2QsIHVuaXF1ZSB2aXNpdG9ycyBhcmUgdHJhY2tlZCB1c2luZ1xuICogYSBVVUlEIGdlbmVyYXRlZCB0aGUgZmlyc3QgdGltZSB0aGV5IHZpc2l0IHRoZSBzaXRlLlxuICpcbiAqIENhbGwgaWRlbnRpZnkgd2hlbiB5b3Uga25vdyB0aGUgaWRlbnRpdHkgb2YgdGhlIGN1cnJlbnQgdXNlcixcbiAqIHR5cGljYWxseSBhZnRlciBsb2dpbiBvciBzaWdudXAuIFdlIHJlY29tbWVuZCBhZ2FpbnN0IHVzaW5nXG4gKiBpZGVudGlmeSBmb3IgYW5vbnltb3VzIHZpc2l0b3JzIHRvIHlvdXIgc2l0ZS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKiBJZiB5b3VyIHByb2plY3QgaGFzXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9oZWxwLm1peHBhbmVsLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMzkxMzM4NTFcIj5JRCBNZXJnZTwvYT5cbiAqIGVuYWJsZWQsIHRoZSBpZGVudGlmeSBtZXRob2Qgd2lsbCBjb25uZWN0IHByZS0gYW5kXG4gKiBwb3N0LWF1dGhlbnRpY2F0aW9uIGV2ZW50cyB3aGVuIGFwcHJvcHJpYXRlLlxuICpcbiAqIElmIHlvdXIgcHJvamVjdCBkb2VzIG5vdCBoYXZlIElEIE1lcmdlIGVuYWJsZWQsIGlkZW50aWZ5IHdpbGxcbiAqIGNoYW5nZSB0aGUgdXNlcidzIGxvY2FsIGRpc3RpbmN0X2lkIHRvIHRoZSB1bmlxdWUgSUQgeW91IHBhc3MuXG4gKiBFdmVudHMgdHJhY2tlZCBwcmlvciB0byBhdXRoZW50aWNhdGlvbiB3aWxsIG5vdCBiZSBjb25uZWN0ZWRcbiAqIHRvIHRoZSBzYW1lIHVzZXIgaWRlbnRpdHkuIElmIElEIE1lcmdlIGlzIGRpc2FibGVkLCBhbGlhcyBjYW5cbiAqIGJlIHVzZWQgdG8gY29ubmVjdCBwcmUtIGFuZCBwb3N0LXJlZ2lzdHJhdGlvbiBldmVudHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt1bmlxdWVfaWRdIEEgc3RyaW5nIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyBhIHVzZXIuIElmIG5vdCBwcm92aWRlZCwgdGhlIGRpc3RpbmN0X2lkIGN1cnJlbnRseSBpbiB0aGUgcGVyc2lzdGVudCBzdG9yZSAoY29va2llIG9yIGxvY2FsU3RvcmFnZSkgd2lsbCBiZSB1c2VkLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaWRlbnRpZnkgPSBmdW5jdGlvbihcbiAgICBuZXdfZGlzdGluY3RfaWQsIF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2tcbikge1xuICAgIC8vIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAgICAvLyAgX3NldF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBzZXQgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfYWRkX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIGFkZCBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF9hcHBlbmRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgYXBwZW5kIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3NldF9vbmNlX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHNldF9vbmNlIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3VuaW9uX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHVuaW9uIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3Vuc2V0X2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHVuc2V0IHF1ZXVlIGlzIGZsdXNoZWRcblxuICAgIHZhciBwcmV2aW91c19kaXN0aW5jdF9pZCA9IHRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAmJiBwcmV2aW91c19kaXN0aW5jdF9pZCAhPT0gbmV3X2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIC8vIHdlIGFsbG93IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlmIHByZXZpb3VzIGRpc3RpbmN0X2lkIGlzIHNhbWUgYXMgbmV3X2Rpc3RpbmN0X2lkXG4gICAgICAgIC8vIHNvIHRoYXQgeW91IGNhbiBmb3JjZSBmbHVzaCBwZW9wbGUgdXBkYXRlcyBmb3IgYW5vbnltb3VzIHByb2ZpbGVzLlxuICAgICAgICBpZiAodHlwZW9mIG5ld19kaXN0aW5jdF9pZCA9PT0gJ3N0cmluZycgJiYgbmV3X2Rpc3RpbmN0X2lkLmluZGV4T2YoREVWSUNFX0lEX1BSRUZJWCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdkaXN0aW5jdF9pZCBjYW5ub3QgaGF2ZSAkZGV2aWNlOiBwcmVmaXgnKTtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHsnJHVzZXJfaWQnOiBuZXdfZGlzdGluY3RfaWR9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0X3Byb3BlcnR5KCckZGV2aWNlX2lkJykpIHtcbiAgICAgICAgLy8gVGhlIHBlcnNpc3RlZCBkaXN0aW5jdCBpZCBtaWdodCBub3QgYWN0dWFsbHkgYmUgYSBkZXZpY2UgaWQgYXQgYWxsXG4gICAgICAgIC8vIGl0IG1pZ2h0IGJlIGEgZGlzdGluY3QgaWQgb2YgdGhlIHVzZXIgZnJvbSBiZWZvcmVcbiAgICAgICAgdmFyIGRldmljZV9pZCA9IHByZXZpb3VzX2Rpc3RpbmN0X2lkO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAgICAgJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJzogdHJ1ZSxcbiAgICAgICAgICAgICckZGV2aWNlX2lkJzogZGV2aWNlX2lkXG4gICAgICAgIH0sICcnKTtcbiAgICB9XG5cbiAgICAvLyBpZGVudGlmeSBvbmx5IGNoYW5nZXMgdGhlIGRpc3RpbmN0IGlkIGlmIGl0IGRvZXNuJ3QgbWF0Y2ggZWl0aGVyIHRoZSBleGlzdGluZyBvciB0aGUgYWxpYXM7XG4gICAgLy8gaWYgaXQncyBuZXcsIGJsb3cgYXdheSB0aGUgYWxpYXMgYXMgd2VsbC5cbiAgICBpZiAobmV3X2Rpc3RpbmN0X2lkICE9PSBwcmV2aW91c19kaXN0aW5jdF9pZCAmJiBuZXdfZGlzdGluY3RfaWQgIT09IHRoaXMuZ2V0X3Byb3BlcnR5KEFMSUFTX0lEX0tFWSkpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyKEFMSUFTX0lEX0tFWSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoeydkaXN0aW5jdF9pZCc6IG5ld19kaXN0aW5jdF9pZH0pO1xuICAgIH1cbiAgICB0aGlzLl9mbGFncy5pZGVudGlmeV9jYWxsZWQgPSB0cnVlO1xuICAgIC8vIEZsdXNoIGFueSBxdWV1ZWQgdXAgcGVvcGxlIHJlcXVlc3RzXG4gICAgdGhpc1sncGVvcGxlJ10uX2ZsdXNoKF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2spO1xuXG4gICAgLy8gc2VuZCBhbiAkaWRlbnRpZnkgZXZlbnQgYW55IHRpbWUgdGhlIGRpc3RpbmN0X2lkIGlzIGNoYW5naW5nIC0gbG9naWMgb24gdGhlIHNlcnZlclxuICAgIC8vIHdpbGwgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGRvIGFueXRoaW5nIHdpdGggaXQuXG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAhPT0gcHJldmlvdXNfZGlzdGluY3RfaWQpIHtcbiAgICAgICAgdGhpcy50cmFjaygnJGlkZW50aWZ5Jywge1xuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogbmV3X2Rpc3RpbmN0X2lkLFxuICAgICAgICAgICAgJyRhbm9uX2Rpc3RpbmN0X2lkJzogcHJldmlvdXNfZGlzdGluY3RfaWRcbiAgICAgICAgfSwge3NraXBfaG9va3M6IHRydWV9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFycyBzdXBlciBwcm9wZXJ0aWVzIGFuZCBnZW5lcmF0ZXMgYSBuZXcgcmFuZG9tIGRpc3RpbmN0X2lkIGZvciB0aGlzIGluc3RhbmNlLlxuICogVXNlZnVsIGZvciBjbGVhcmluZyBkYXRhIHdoZW4gYSB1c2VyIGxvZ3Mgb3V0LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddLmNsZWFyKCk7XG4gICAgdGhpcy5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHV1aWQgPSBfLlVVSUQoKTtcbiAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAnZGlzdGluY3RfaWQnOiBERVZJQ0VfSURfUFJFRklYICsgdXVpZCxcbiAgICAgICAgJyRkZXZpY2VfaWQnOiB1dWlkXG4gICAgfSwgJycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRpc3RpbmN0IGlkIG9mIHRoZSB1c2VyLiBUaGlzIGlzIGVpdGhlciB0aGUgaWQgYXV0b21hdGljYWxseVxuICogZ2VuZXJhdGVkIGJ5IHRoZSBsaWJyYXJ5IG9yIHRoZSBpZCB0aGF0IGhhcyBiZWVuIHBhc3NlZCBieSBhIGNhbGwgdG8gaWRlbnRpZnkoKS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogZ2V0X2Rpc3RpbmN0X2lkKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICogaW5pdCgpIGhhcyBhIGxvYWRlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gaGFuZGxlIHRoaXMgYXV0b21hdGljYWxseS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIC8vIHNldCBkaXN0aW5jdF9pZCBhZnRlciB0aGUgbWl4cGFuZWwgbGlicmFyeSBoYXMgbG9hZGVkXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnWU9VUiBQUk9KRUNUIFRPS0VOJywge1xuICogICAgICAgICBsb2FkZWQ6IGZ1bmN0aW9uKG1peHBhbmVsKSB7XG4gKiAgICAgICAgICAgICBkaXN0aW5jdF9pZCA9IG1peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZGlzdGluY3RfaWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRfcHJvcGVydHkoJ2Rpc3RpbmN0X2lkJyk7XG59O1xuXG4vKipcbiAqIFRoZSBhbGlhcyBtZXRob2QgY3JlYXRlcyBhbiBhbGlhcyB3aGljaCBNaXhwYW5lbCB3aWxsIHVzZSB0b1xuICogcmVtYXAgb25lIGlkIHRvIGFub3RoZXIuIE11bHRpcGxlIGFsaWFzZXMgY2FuIHBvaW50IHRvIHRoZVxuICogc2FtZSBpZGVudGlmaWVyLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgaXMgYSB2YWxpZCB1c2Ugb2YgYWxpYXM6XG4gKlxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqICAgICAvLyBZb3UgY2FuIGFkZCBtdWx0aXBsZSBpZCBhbGlhc2VzIHRvIHRoZSBleGlzdGluZyBJRFxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdlcl9pZCcsICdleGlzdGluZ19pZCcpO1xuICpcbiAqIEFsaWFzZXMgY2FuIGFsc28gYmUgY2hhaW5lZCAtIHRoZSBmb2xsb3dpbmcgaXMgYSB2YWxpZCBleGFtcGxlOlxuICpcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKiAgICAgLy8gY2hhaW4gbmV3ZXJfaWQgLSBuZXdfaWQgLSBleGlzdGluZ19pZFxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdlcl9pZCcsICduZXdfaWQnKTtcbiAqXG4gKiBBbGlhc2VzIGNhbm5vdCBwb2ludCB0byBtdWx0aXBsZSBpZGVudGlmaWVycyAtIHRoZSBmb2xsb3dpbmdcbiAqIGV4YW1wbGUgd2lsbCBub3Qgd29yazpcbiAqXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICdleGlzdGluZ19pZCcpO1xuICogICAgIC8vIHRoaXMgaXMgaW52YWxpZCBhcyAnbmV3X2lkJyBhbHJlYWR5IHBvaW50cyB0byAnZXhpc3RpbmdfaWQnXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICduZXdlcl9pZCcpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBJZiB5b3VyIHByb2plY3QgZG9lcyBub3QgaGF2ZVxuICogPGEgaHJlZj1cImh0dHBzOi8vaGVscC5taXhwYW5lbC5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDM5MTMzODUxXCI+SUQgTWVyZ2U8L2E+XG4gKiBlbmFibGVkLCB0aGUgYmVzdCBwcmFjdGljZSBpcyB0byBjYWxsIGFsaWFzIG9uY2Ugd2hlbiBhIHVuaXF1ZVxuICogSUQgaXMgZmlyc3QgY3JlYXRlZCBmb3IgYSB1c2VyIChlLmcuLCB3aGVuIGEgdXNlciBmaXJzdCByZWdpc3RlcnNcbiAqIGZvciBhbiBhY2NvdW50KS4gRG8gbm90IHVzZSBhbGlhcyBtdWx0aXBsZSB0aW1lcyBmb3IgYSBzaW5nbGVcbiAqIHVzZXIgd2l0aG91dCBJRCBNZXJnZSBlbmFibGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhcyBBIHVuaXF1ZSBpZGVudGlmaWVyIHRoYXQgeW91IHdhbnQgdG8gdXNlIGZvciB0aGlzIHVzZXIgaW4gdGhlIGZ1dHVyZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3JpZ2luYWxdIFRoZSBjdXJyZW50IGlkZW50aWZpZXIgYmVpbmcgdXNlZCBmb3IgdGhpcyB1c2VyLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuYWxpYXMgPSBmdW5jdGlvbihhbGlhcywgb3JpZ2luYWwpIHtcbiAgICAvLyBJZiB0aGUgJHBlb3BsZV9kaXN0aW5jdF9pZCBrZXkgZXhpc3RzIGluIHBlcnNpc3RlbmNlLCB0aGVyZSBoYXMgYmVlbiBhIHByZXZpb3VzXG4gICAgLy8gbWl4cGFuZWwucGVvcGxlLmlkZW50aWZ5KCkgY2FsbCBtYWRlIGZvciB0aGlzIHVzZXIuIEl0IGlzIFZFUlkgQkFEIHRvIG1ha2UgYW4gYWxpYXMgd2l0aFxuICAgIC8vIHRoaXMgSUQsIGFzIGl0IHdpbGwgZHVwbGljYXRlIHVzZXJzLlxuICAgIGlmIChhbGlhcyA9PT0gdGhpcy5nZXRfcHJvcGVydHkoUEVPUExFX0RJU1RJTkNUX0lEX0tFWSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0F0dGVtcHRpbmcgdG8gY3JlYXRlIGFsaWFzIGZvciBleGlzdGluZyBQZW9wbGUgdXNlciAtIGFib3J0aW5nLicpO1xuICAgICAgICByZXR1cm4gLTI7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChvcmlnaW5hbCkpIHtcbiAgICAgICAgb3JpZ2luYWwgPSB0aGlzLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIH1cbiAgICBpZiAoYWxpYXMgIT09IG9yaWdpbmFsKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyX3NpbmdsZShBTElBU19JRF9LRVksIGFsaWFzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2soJyRjcmVhdGVfYWxpYXMnLCB7XG4gICAgICAgICAgICAnYWxpYXMnOiBhbGlhcyxcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IG9yaWdpbmFsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNraXBfaG9va3M6IHRydWVcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBGbHVzaCB0aGUgcGVvcGxlIHF1ZXVlXG4gICAgICAgICAgICBfdGhpcy5pZGVudGlmeShhbGlhcyk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdhbGlhcyBtYXRjaGVzIGN1cnJlbnQgZGlzdGluY3RfaWQgLSBza2lwcGluZyBhcGkgY2FsbC4nKTtcbiAgICAgICAgdGhpcy5pZGVudGlmeShhbGlhcyk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGUgYSBzdHJpbmcgdG8gcmVjb2duaXplIHRoZSB1c2VyIGJ5LiBUaGUgc3RyaW5nIHBhc3NlZCB0b1xuICogdGhpcyBtZXRob2Qgd2lsbCBhcHBlYXIgaW4gdGhlIE1peHBhbmVsIFN0cmVhbXMgcHJvZHVjdCByYXRoZXJcbiAqIHRoYW4gYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgbmFtZS4gTmFtZSB0YWdzIGRvIG5vdCBoYXZlIHRvXG4gKiBiZSB1bmlxdWUuXG4gKlxuICogVGhpcyB2YWx1ZSB3aWxsIG9ubHkgYmUgaW5jbHVkZWQgaW4gU3RyZWFtcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lX3RhZyBBIGh1bWFuIHJlYWRhYmxlIG5hbWUgZm9yIHRoZSB1c2VyXG4gKiBAZGVwcmVjYXRlZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUubmFtZV90YWcgPSBmdW5jdGlvbihuYW1lX3RhZykge1xuICAgIHRoaXMuX3JlZ2lzdGVyX3NpbmdsZSgnbXBfbmFtZV90YWcnLCBuYW1lX3RhZyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29uZmlndXJhdGlvbiBvZiBhIG1peHBhbmVsIGxpYnJhcnkgaW5zdGFuY2UuXG4gKlxuICogVGhlIGRlZmF1bHQgY29uZmlnIGlzOlxuICpcbiAqICAgICB7XG4gKiAgICAgICAvLyBob3N0IGZvciByZXF1ZXN0cyAoY3VzdG9taXphYmxlIGZvciBlLmcuIGEgbG9jYWwgcHJveHkpXG4gKiAgICAgICBhcGlfaG9zdDogJ2h0dHBzOi8vYXBpLWpzLm1peHBhbmVsLmNvbScsXG4gKlxuICogICAgICAgLy8gZW5kcG9pbnRzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgcmVxdWVzdHNcbiAqICAgICAgIGFwaV9yb3V0ZXM6IHtcbiAqICAgICAgICAgdHJhY2s6ICd0cmFjay8nLFxuICogICAgICAgICBlbmdhZ2U6ICdlbmdhZ2UvJyxcbiAqICAgICAgICAgZ3JvdXBzOiAnZ3JvdXBzLycsXG4gKiAgICAgICB9XG4gKlxuICogICAgICAgLy8gSFRUUCBtZXRob2QgZm9yIHRyYWNraW5nIHJlcXVlc3RzXG4gKiAgICAgICBhcGlfbWV0aG9kOiAnUE9TVCdcbiAqXG4gKiAgICAgICAvLyB0cmFuc3BvcnQgZm9yIHNlbmRpbmcgcmVxdWVzdHMgKCdYSFInIG9yICdzZW5kQmVhY29uJylcbiAqICAgICAgIC8vIE5COiBzZW5kQmVhY29uIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHNjZW5hcmlvcyBzdWNoIGFzXG4gKiAgICAgICAvLyBwYWdlIHVubG9hZCB3aGVyZSBhIFwiYmVzdC1lZmZvcnRcIiBhdHRlbXB0IHRvIHNlbmQgaXNcbiAqICAgICAgIC8vIGFjY2VwdGFibGU7IHRoZSBzZW5kQmVhY29uIEFQSSBkb2VzIG5vdCBzdXBwb3J0IGNhbGxiYWNrc1xuICogICAgICAgLy8gb3IgYW55IHdheSB0byBrbm93IHRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3QuIE1peHBhbmVsXG4gKiAgICAgICAvLyB0cmFja2luZyB2aWEgc2VuZEJlYWNvbiB3aWxsIG5vdCBzdXBwb3J0IGFueSBldmVudC1cbiAqICAgICAgIC8vIGJhdGNoaW5nIG9yIHJldHJ5IG1lY2hhbmlzbXMuXG4gKiAgICAgICBhcGlfdHJhbnNwb3J0OiAnWEhSJ1xuICpcbiAqICAgICAgIC8vIHJlcXVlc3QtYmF0Y2hpbmcvcXVldWVpbmcvcmV0cnlcbiAqICAgICAgIGJhdGNoX3JlcXVlc3RzOiB0cnVlLFxuICpcbiAqICAgICAgIC8vIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cy91cGRhdGVzIHRvIHNlbmQgaW4gYSBzaW5nbGVcbiAqICAgICAgIC8vIG5ldHdvcmsgcmVxdWVzdFxuICogICAgICAgYmF0Y2hfc2l6ZTogNTAsXG4gKlxuICogICAgICAgLy8gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmV0d2VlbiBzZW5kaW5nIGJhdGNoIHJlcXVlc3RzXG4gKiAgICAgICBiYXRjaF9mbHVzaF9pbnRlcnZhbF9tczogNTAwMCxcbiAqXG4gKiAgICAgICAvLyBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgbmV0d29yayByZXNwb25zZXMgdG8gYmF0Y2ggcmVxdWVzdHNcbiAqICAgICAgIC8vIGJlZm9yZSB0aGV5IGFyZSBjb25zaWRlcmVkIHRpbWVkLW91dCBhbmQgcmV0cmllZFxuICogICAgICAgYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zOiA5MDAwMCxcbiAqXG4gKiAgICAgICAvLyBvdmVycmlkZSB2YWx1ZSBmb3IgY29va2llIGRvbWFpbiwgb25seSB1c2VmdWwgZm9yIGVuc3VyaW5nXG4gKiAgICAgICAvLyBjb3JyZWN0IGNyb3NzLXN1YmRvbWFpbiBjb29raWVzIG9uIHVudXN1YWwgZG9tYWlucyBsaWtlXG4gKiAgICAgICAvLyBzdWJkb21haW4ubWFpbnNpdGUuYXZvY2F0LmZyOyBOQiB0aGlzIGNhbm5vdCBiZSB1c2VkIHRvXG4gKiAgICAgICAvLyBzZXQgY29va2llcyBvbiBhIGRpZmZlcmVudCBkb21haW4gdGhhbiB0aGUgY3VycmVudCBvcmlnaW5cbiAqICAgICAgIGNvb2tpZV9kb21haW46ICcnXG4gKlxuICogICAgICAgLy8gc3VwZXIgcHJvcGVydGllcyBjb29raWUgZXhwaXJhdGlvbiAoaW4gZGF5cylcbiAqICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzNjVcbiAqXG4gKiAgICAgICAvLyBpZiB0cnVlLCBjb29raWUgd2lsbCBiZSBzZXQgd2l0aCBTYW1lU2l0ZT1Ob25lOyBTZWN1cmVcbiAqICAgICAgIC8vIHRoaXMgaXMgb25seSB1c2VmdWwgaW4gc3BlY2lhbCBzaXR1YXRpb25zLCBsaWtlIGVtYmVkZGVkXG4gKiAgICAgICAvLyAzcmQtcGFydHkgaWZyYW1lcyB0aGF0IHNldCB1cCBhIE1peHBhbmVsIGluc3RhbmNlXG4gKiAgICAgICBjcm9zc19zaXRlX2Nvb2tpZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBzdXBlciBwcm9wZXJ0aWVzIHNwYW4gc3ViZG9tYWluc1xuICogICAgICAgY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZTogdHJ1ZVxuICpcbiAqICAgICAgIC8vIGRlYnVnIG1vZGVcbiAqICAgICAgIGRlYnVnOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgdGhlIG1peHBhbmVsIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgZW50cnlcbiAqICAgICAgIC8vIHdpbGwgYmUgZGVsZXRlZCwgYW5kIG5vIHVzZXIgcGVyc2lzdGVuY2Ugd2lsbCB0YWtlIHBsYWNlXG4gKiAgICAgICBkaXNhYmxlX3BlcnNpc3RlbmNlOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgTWl4cGFuZWwgd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVybWluZVxuICogICAgICAgLy8gQ2l0eSwgUmVnaW9uIGFuZCBDb3VudHJ5IGRhdGEgdXNpbmcgdGhlIElQIGFkZHJlc3Mgb2ZcbiAqICAgICAgIC8vdGhlIGNsaWVudFxuICogICAgICAgaXA6IHRydWVcbiAqXG4gKiAgICAgICAvLyBvcHQgdXNlcnMgb3V0IG9mIHRyYWNraW5nIGJ5IHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UgYnkgZGVmYXVsdFxuICogICAgICAgb3B0X291dF90cmFja2luZ19ieV9kZWZhdWx0OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIG9wdCB1c2VycyBvdXQgb2YgYnJvd3NlciBkYXRhIHN0b3JhZ2UgYnkgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSBieSBkZWZhdWx0XG4gKiAgICAgICBvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQ6IGZhbHNlXG4gKlxuICogICAgICAgLy8gcGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgYnkgb3B0LWluL29wdC1vdXQgbWV0aG9kcyAtIGNvb2tpZVxuICogICAgICAgLy8gb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiAgICAgICBvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGU6ICdsb2NhbFN0b3JhZ2UnXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplIHRoZSBuYW1lIG9mIGNvb2tpZS9sb2NhbFN0b3JhZ2Ugc2V0IGJ5IG9wdC1pbi9vcHQtb3V0IG1ldGhvZHNcbiAqICAgICAgIG9wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeDogbnVsbFxuICpcbiAqICAgICAgIC8vIHR5cGUgb2YgcGVyc2lzdGVudCBzdG9yZSBmb3Igc3VwZXIgcHJvcGVydGllcyAoY29va2llL1xuICogICAgICAgLy8gbG9jYWxTdG9yYWdlKSBpZiBzZXQgdG8gJ2xvY2FsU3RvcmFnZScsIGFueSBleGlzdGluZ1xuICogICAgICAgLy8gbWl4cGFuZWwgY29va2llIHZhbHVlIHdpdGggdGhlIHNhbWUgcGVyc2lzdGVuY2VfbmFtZVxuICogICAgICAgLy8gd2lsbCBiZSB0cmFuc2ZlcnJlZCB0byBsb2NhbFN0b3JhZ2UgYW5kIGRlbGV0ZWRcbiAqICAgICAgIHBlcnNpc3RlbmNlOiAnY29va2llJ1xuICpcbiAqICAgICAgIC8vIG5hbWUgZm9yIHN1cGVyIHByb3BlcnRpZXMgcGVyc2lzdGVudCBzdG9yZVxuICogICAgICAgcGVyc2lzdGVuY2VfbmFtZTogJydcbiAqXG4gKiAgICAgICAvLyBuYW1lcyBvZiBwcm9wZXJ0aWVzL3N1cGVycHJvcGVydGllcyB3aGljaCBzaG91bGQgbmV2ZXJcbiAqICAgICAgIC8vIGJlIHNlbnQgd2l0aCB0cmFjaygpIGNhbGxzXG4gKiAgICAgICBwcm9wZXJ0eV9ibGFja2xpc3Q6IFtdXG4gKlxuICogICAgICAgLy8gaWYgdGhpcyBpcyB0cnVlLCBtaXhwYW5lbCBjb29raWVzIHdpbGwgYmUgbWFya2VkIGFzXG4gKiAgICAgICAvLyBzZWN1cmUsIG1lYW5pbmcgdGhleSB3aWxsIG9ubHkgYmUgdHJhbnNtaXR0ZWQgb3ZlciBodHRwc1xuICogICAgICAgc2VjdXJlX2Nvb2tpZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBkaXNhYmxlcyBlbnJpY2hpbmcgdXNlciBwcm9maWxlcyB3aXRoIGZpcnN0IHRvdWNoIG1hcmtldGluZyBkYXRhXG4gKiAgICAgICBza2lwX2ZpcnN0X3RvdWNoX21hcmtldGluZzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgdHJhY2tfbGlua3Mgd2lsbFxuICogICAgICAgLy8gd2FpdCBmb3IgTWl4cGFuZWwncyBzZXJ2ZXJzIHRvIHJlc3BvbmRcbiAqICAgICAgIHRyYWNrX2xpbmtzX3RpbWVvdXQ6IDMwMFxuICpcbiAqICAgICAgIC8vIGFkZHMgYW55IFVUTSBwYXJhbWV0ZXJzIGFuZCBjbGljayBJRHMgcHJlc2VudCBvbiB0aGUgcGFnZSB0byBhbnkgZXZlbnRzIGZpcmVkXG4gKiAgICAgICB0cmFja19tYXJrZXRpbmc6IHRydWVcbiAqXG4gKiAgICAgICAvLyBlbmFibGVzIGF1dG9tYXRpYyBwYWdlIHZpZXcgdHJhY2tpbmcgdXNpbmcgZGVmYXVsdCBwYWdlIHZpZXcgZXZlbnRzIHRocm91Z2hcbiAqICAgICAgIC8vIHRoZSB0cmFja19wYWdldmlldygpIG1ldGhvZFxuICogICAgICAgdHJhY2tfcGFnZXZpZXc6IGZhbHNlXG4gKlxuICogICAgICAgLy8gaWYgeW91IHNldCB1cGdyYWRlIHRvIGJlIHRydWUsIHRoZSBsaWJyYXJ5IHdpbGwgY2hlY2sgZm9yXG4gKiAgICAgICAvLyBhIGNvb2tpZSBmcm9tIG91ciBvbGQganMgbGlicmFyeSBhbmQgaW1wb3J0IHN1cGVyXG4gKiAgICAgICAvLyBwcm9wZXJ0aWVzIGZyb20gaXQsIHRoZW4gdGhlIG9sZCBjb29raWUgaXMgZGVsZXRlZFxuICogICAgICAgLy8gVGhlIHVwZ3JhZGUgY29uZmlnIG9wdGlvbiBvbmx5IHdvcmtzIGluIHRoZSBpbml0aWFsaXphdGlvbixcbiAqICAgICAgIC8vIHNvIG1ha2Ugc3VyZSB5b3Ugc2V0IGl0IHdoZW4geW91IGNyZWF0ZSB0aGUgbGlicmFyeS5cbiAqICAgICAgIHVwZ3JhZGU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gZXh0cmEgSFRUUCByZXF1ZXN0IGhlYWRlcnMgdG8gc2V0IGZvciBlYWNoIEFQSSByZXF1ZXN0LCBpblxuICogICAgICAgLy8gdGhlIGZvcm1hdCB7J0hlYWRlci1OYW1lJzogdmFsdWV9XG4gKiAgICAgICB4aHJfaGVhZGVyczoge31cbiAqXG4gKiAgICAgICAvLyB3aGV0aGVyIHRvIGlnbm9yZSBvciByZXNwZWN0IHRoZSB3ZWIgYnJvd3NlcidzIERvIE5vdCBUcmFjayBzZXR0aW5nXG4gKiAgICAgICBpZ25vcmVfZG50OiBmYWxzZVxuICogICAgIH1cbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBBIGRpY3Rpb25hcnkgb2YgbmV3IGNvbmZpZ3VyYXRpb24gdmFsdWVzIHRvIHVwZGF0ZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIGlmIChfLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgXy5leHRlbmQodGhpc1snY29uZmlnJ10sIGNvbmZpZyk7XG5cbiAgICAgICAgdmFyIG5ld19iYXRjaF9zaXplID0gY29uZmlnWydiYXRjaF9zaXplJ107XG4gICAgICAgIGlmIChuZXdfYmF0Y2hfc2l6ZSkge1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgICAgIGJhdGNoZXIucmVzZXRCYXRjaFNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ3BlcnNpc3RlbmNlX25hbWUnKSkge1xuICAgICAgICAgICAgdGhpc1snY29uZmlnJ11bJ3BlcnNpc3RlbmNlX25hbWUnXSA9IHRoaXNbJ2NvbmZpZyddWydjb29raWVfbmFtZSddO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdkaXNhYmxlX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgICAgIHRoaXNbJ2NvbmZpZyddWydkaXNhYmxlX3BlcnNpc3RlbmNlJ10gPSB0aGlzWydjb25maWcnXVsnZGlzYWJsZV9jb29raWUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzWydwZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9jb25maWcodGhpc1snY29uZmlnJ10pO1xuICAgICAgICB9XG4gICAgICAgIENvbmZpZy5ERUJVRyA9IENvbmZpZy5ERUJVRyB8fCB0aGlzLmdldF9jb25maWcoJ2RlYnVnJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBjdXJyZW50IGNvbmZpZyBvYmplY3QgZm9yIHRoZSBsaWJyYXJ5LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKHByb3BfbmFtZSkge1xuICAgIHJldHVybiB0aGlzWydjb25maWcnXVtwcm9wX25hbWVdO1xufTtcblxuLyoqXG4gKiBGZXRjaCBhIGhvb2sgZnVuY3Rpb24gZnJvbSBjb25maWcsIHdpdGggc2FmZSBkZWZhdWx0LCBhbmQgcnVuIGl0XG4gKiBhZ2FpbnN0IHRoZSBnaXZlbiBhcmd1bWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBob29rX25hbWUgd2hpY2ggaG9vayB0byByZXRyaWV2ZVxuICogQHJldHVybnMge2FueXxudWxsfSByZXR1cm4gdmFsdWUgb2YgdXNlci1wcm92aWRlZCBob29rLCBvciBudWxsIGlmIG5vdGhpbmcgd2FzIHJldHVybmVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcnVuX2hvb2sgPSBmdW5jdGlvbihob29rX25hbWUpIHtcbiAgICB2YXIgcmV0ID0gKHRoaXNbJ2NvbmZpZyddWydob29rcyddW2hvb2tfbmFtZV0gfHwgSURFTlRJVFlfRlVOQykuYXBwbHkodGhpcywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoaG9va19uYW1lICsgJyBob29rIGRpZCBub3QgcmV0dXJuIGEgdmFsdWUnKTtcbiAgICAgICAgcmV0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IG5hbWVkIHByb3BlcnR5X25hbWUuIElmIG5vIHN1Y2hcbiAqIHByb3BlcnR5IGlzIHNldCwgZ2V0X3Byb3BlcnR5KCkgd2lsbCByZXR1cm4gdGhlIHVuZGVmaW5lZCB2YWx1ZS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogZ2V0X3Byb3BlcnR5KCkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICogaW5pdCgpIGhhcyBhIGxvYWRlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gaGFuZGxlIHRoaXMgYXV0b21hdGljYWxseS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIC8vIGdyYWIgdmFsdWUgZm9yICd1c2VyX2lkJyBhZnRlciB0aGUgbWl4cGFuZWwgbGlicmFyeSBoYXMgbG9hZGVkXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnWU9VUiBQUk9KRUNUIFRPS0VOJywge1xuICogICAgICAgICBsb2FkZWQ6IGZ1bmN0aW9uKG1peHBhbmVsKSB7XG4gKiAgICAgICAgICAgICB1c2VyX2lkID0gbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCd1c2VyX2lkJyk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlfbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgeW91IHdhbnQgdG8gcmV0cmlldmVcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5X25hbWUpIHtcbiAgICByZXR1cm4gdGhpc1sncGVyc2lzdGVuY2UnXS5sb2FkX3Byb3AoW3Byb3BlcnR5X25hbWVdKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gdGhpcy5nZXRfY29uZmlnKCduYW1lJyk7XG4gICAgaWYgKG5hbWUgIT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkge1xuICAgICAgICBuYW1lID0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FICsgJy4nICsgbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2V2ZW50X2lzX2Rpc2FibGVkID0gZnVuY3Rpb24oZXZlbnRfbmFtZSkge1xuICAgIHJldHVybiBfLmlzQmxvY2tlZFVBKHVzZXJBZ2VudCkgfHxcbiAgICAgICAgdGhpcy5fZmxhZ3MuZGlzYWJsZV9hbGxfZXZlbnRzIHx8XG4gICAgICAgIF8uaW5jbHVkZSh0aGlzLl9fZGlzYWJsZWRfZXZlbnRzLCBldmVudF9uYW1lKTtcbn07XG5cbi8vIHBlcmZvcm0gc29tZSBob3VzZWtlZXBpbmcgYXJvdW5kIEdEUFIgb3B0LWluL291dCBzdGF0ZVxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNfbG9jYWxTdG9yYWdlX3JlcXVlc3RlZCA9IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJykgPT09ICdsb2NhbFN0b3JhZ2UnO1xuXG4gICAgLy8gdHJ5IHRvIGNvbnZlcnQgb3B0LWluL291dCBjb29raWVzIHRvIGxvY2FsU3RvcmFnZSBpZiBwb3NzaWJsZVxuICAgIGlmIChpc19sb2NhbFN0b3JhZ2VfcmVxdWVzdGVkICYmIF8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoKSAmJiB0aGlzLmhhc19vcHRlZF9pbl90cmFja2luZyh7J3BlcnNpc3RlbmNlX3R5cGUnOiAnY29va2llJ30pKSB7XG4gICAgICAgICAgICB0aGlzLm9wdF9pbl90cmFja2luZyh7J2VuYWJsZV9wZXJzaXN0ZW5jZSc6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSAmJiB0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoeydwZXJzaXN0ZW5jZV90eXBlJzogJ2Nvb2tpZSd9KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRfb3V0X3RyYWNraW5nKHsnY2xlYXJfcGVyc2lzdGVuY2UnOiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJfb3B0X2luX291dF90cmFja2luZyh7XG4gICAgICAgICAgICAncGVyc2lzdGVuY2VfdHlwZSc6ICdjb29raWUnLFxuICAgICAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGFscmVhZHkgb3B0ZWQgb3V0IC0gaWYgc28sIGNsZWFyICYgZGlzYWJsZSBwZXJzaXN0ZW5jZVxuICAgIGlmICh0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSkge1xuICAgICAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZSh7J2NsZWFyX3BlcnNpc3RlbmNlJzogdHJ1ZX0pO1xuXG4gICAgLy8gY2hlY2sgd2hldGhlciB3ZSBzaG91bGQgb3B0IG91dCBieSBkZWZhdWx0XG4gICAgLy8gbm90ZTogd2UgZG9uJ3QgY2xlYXIgcGVyc2lzdGVuY2UgaGVyZSBieSBkZWZhdWx0IHNpbmNlIG9wdC1vdXQgZGVmYXVsdCBzdGF0ZSBpcyBvZnRlblxuICAgIC8vICAgICAgIHVzZWQgYXMgYW4gaW5pdGlhbCBzdGF0ZSB3aGlsZSBHRFBSIGluZm9ybWF0aW9uIGlzIGJlaW5nIGNvbGxlY3RlZFxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzX29wdGVkX2luX3RyYWNraW5nKCkgJiYgKFxuICAgICAgICB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdCcpIHx8IF8uY29va2llLmdldCgnbXBfb3B0b3V0JylcbiAgICApKSB7XG4gICAgICAgIF8uY29va2llLnJlbW92ZSgnbXBfb3B0b3V0Jyk7XG4gICAgICAgIHRoaXMub3B0X291dF90cmFja2luZyh7XG4gICAgICAgICAgICAnY2xlYXJfcGVyc2lzdGVuY2UnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfcGVyc2lzdGVuY2VfYnlfZGVmYXVsdCcpXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIG9yIGRpc2FibGUgcGVyc2lzdGVuY2UgYmFzZWQgb24gb3B0aW9uc1xuICogb25seSBlbmFibGUvZGlzYWJsZSBpZiBwZXJzaXN0ZW5jZSBpcyBub3QgYWxyZWFkeSBpbiB0aGlzIHN0YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyX3BlcnNpc3RlbmNlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSBhbGwgZGF0YSBzdG9yZWQgYnkgdGhlIHNkayBpbiBwZXJzaXN0ZW5jZSBhbmQgZGlzYWJsZSBpdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2VdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBkaXNhYmxlZDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zWydjbGVhcl9wZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1snZW5hYmxlX3BlcnNpc3RlbmNlJ10pIHtcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ2Rpc2FibGVfcGVyc2lzdGVuY2UnKSAmJiB0aGlzWydwZXJzaXN0ZW5jZSddLmRpc2FibGVkICE9PSBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnNldF9kaXNhYmxlZChkaXNhYmxlZCk7XG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc3RvcF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb25seSBzdGFydCBiYXRjaGVycyBhZnRlciBvcHQtaW4gaWYgdGhleSBoYXZlIHByZXZpb3VzbHkgYmVlbiBzdGFydGVkXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIHVuaW50ZW50aW9uYWxseSBzdGFydGluZyB1cCBiYXRjaGluZyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgaWYgKHRoaXMuX2JhdGNoZXJzX3dlcmVfc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBjYWxsIGEgYmFzZSBnZHByIGZ1bmN0aW9uIGFmdGVyIGNvbnN0cnVjdGluZyB0aGUgYXBwcm9wcmlhdGUgdG9rZW4gYW5kIG9wdGlvbnMgYXJnc1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX2NhbGxfZnVuYyA9IGZ1bmN0aW9uKGZ1bmMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAndHJhY2snOiBfLmJpbmQodGhpcy50cmFjaywgdGhpcyksXG4gICAgICAgICdwZXJzaXN0ZW5jZV90eXBlJzogdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnKSxcbiAgICAgICAgJ2Nvb2tpZV9wcmVmaXgnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCcpLFxuICAgICAgICAnY29va2llX2V4cGlyYXRpb24nOiB0aGlzLmdldF9jb25maWcoJ2Nvb2tpZV9leHBpcmF0aW9uJyksXG4gICAgICAgICdjcm9zc19zaXRlX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnY3Jvc3Nfc2l0ZV9jb29raWUnKSxcbiAgICAgICAgJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnKSxcbiAgICAgICAgJ2Nvb2tpZV9kb21haW4nOiB0aGlzLmdldF9jb25maWcoJ2Nvb2tpZV9kb21haW4nKSxcbiAgICAgICAgJ3NlY3VyZV9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ3NlY3VyZV9jb29raWUnKSxcbiAgICAgICAgJ2lnbm9yZV9kbnQnOiB0aGlzLmdldF9jb25maWcoJ2lnbm9yZV9kbnQnKVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgaWYgbG9jYWxTdG9yYWdlIGNhbiBiZSB1c2VkIGZvciByZWNvcmRpbmcgb3B0IG91dCBzdGF0dXMsIGZhbGwgYmFjayB0byBjb29raWUgaWYgbm90XG4gICAgaWYgKCFfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICBvcHRpb25zWydwZXJzaXN0ZW5jZV90eXBlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuYyh0aGlzLmdldF9jb25maWcoJ3Rva2VuJyksIHtcbiAgICAgICAgdHJhY2s6IG9wdGlvbnNbJ3RyYWNrJ10sXG4gICAgICAgIHRyYWNrRXZlbnROYW1lOiBvcHRpb25zWyd0cmFja19ldmVudF9uYW1lJ10sXG4gICAgICAgIHRyYWNrUHJvcGVydGllczogb3B0aW9uc1sndHJhY2tfcHJvcGVydGllcyddLFxuICAgICAgICBwZXJzaXN0ZW5jZVR5cGU6IG9wdGlvbnNbJ3BlcnNpc3RlbmNlX3R5cGUnXSxcbiAgICAgICAgcGVyc2lzdGVuY2VQcmVmaXg6IG9wdGlvbnNbJ2Nvb2tpZV9wcmVmaXgnXSxcbiAgICAgICAgY29va2llRG9tYWluOiBvcHRpb25zWydjb29raWVfZG9tYWluJ10sXG4gICAgICAgIGNvb2tpZUV4cGlyYXRpb246IG9wdGlvbnNbJ2Nvb2tpZV9leHBpcmF0aW9uJ10sXG4gICAgICAgIGNyb3NzU2l0ZUNvb2tpZTogb3B0aW9uc1snY3Jvc3Nfc2l0ZV9jb29raWUnXSxcbiAgICAgICAgY3Jvc3NTdWJkb21haW5Db29raWU6IG9wdGlvbnNbJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnXSxcbiAgICAgICAgc2VjdXJlQ29va2llOiBvcHRpb25zWydzZWN1cmVfY29va2llJ10sXG4gICAgICAgIGlnbm9yZURudDogb3B0aW9uc1snaWdub3JlX2RudCddXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgaW5cbiAqICAgICBtaXhwYW5lbC5vcHRfaW5fdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgaW4gd2l0aCBzcGVjaWZpYyBldmVudCBuYW1lLCBwcm9wZXJ0aWVzLCBjb29raWUgY29uZmlndXJhdGlvblxuICogICAgIG1peHBhbmVsLm9wdF9pbl90cmFja2luZyh7XG4gKiAgICAgICAgIHRyYWNrX2V2ZW50X25hbWU6ICdVc2VyIG9wdGVkIGluJyxcbiAqICAgICAgICAgdHJhY2tfZXZlbnRfcHJvcGVydGllczoge1xuICogICAgICAgICAgICAgJ0VtYWlsJzogJ2pkb2VAZXhhbXBsZS5jb20nXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzMCxcbiAqICAgICAgICAgc2VjdXJlX2Nvb2tpZTogdHJ1ZVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gRnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb24gKGRlZmF1bHQgaXMgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIHRyYWNrIG1ldGhvZClcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja19ldmVudF9uYW1lPSRvcHRfaW5dIEV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja19wcm9wZXJ0aWVzXSBTZXQgb2YgcHJvcGVydGllcyB0byBiZSB0cmFja2VkIGFsb25nIHdpdGggdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlX3BlcnNpc3RlbmNlPXRydWVdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVfZXhwaXJhdGlvbl0gTnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlcyAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9kb21haW5dIEN1c3RvbSBjb29raWUgZG9tYWluIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3NpdGVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWQgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfaW5fdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKG9wdEluLCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgb3V0XG4gKiAgICAgbWl4cGFuZWwub3B0X291dF90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBvcHQgdXNlciBvdXQgd2l0aCBkaWZmZXJlbnQgY29va2llIGNvbmZpZ3VyYXRpb24gZnJvbSBNaXhwYW5lbCBpbnN0YW5jZVxuICogICAgIG1peHBhbmVsLm9wdF9vdXRfdHJhY2tpbmcoe1xuICogICAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzAsXG4gKiAgICAgICAgIHNlY3VyZV9jb29raWU6IHRydWVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWxldGVfdXNlcj10cnVlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSB0aGUgY3VycmVudGx5IGlkZW50aWZpZWQgdXNlcidzIHByb2ZpbGUgYW5kIGNsZWFyIGFsbCBjaGFyZ2VzIGFmdGVyIG9wdGluZyB0aGUgdXNlciBvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xlYXJfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCBkZWxldGUgYWxsIGRhdGEgc3RvcmVkIGJ5IHRoZSBzZGsgaW4gcGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llX2V4cGlyYXRpb25dIE51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXMgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfZG9tYWluXSBDdXN0b20gY29va2llIGRvbWFpbiAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zaXRlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3N1YmRvbWFpbl9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X291dF90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnY2xlYXJfcGVyc2lzdGVuY2UnOiB0cnVlLFxuICAgICAgICAnZGVsZXRlX3VzZXInOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBkZWxldGUgdXNlciBhbmQgY2xlYXIgY2hhcmdlcyBzaW5jZSB0aGVzZSBtZXRob2RzIG1heSBiZSBkaXNhYmxlZCBieSBvcHQtb3V0XG4gICAgaWYgKG9wdGlvbnNbJ2RlbGV0ZV91c2VyJ10gJiYgdGhpc1sncGVvcGxlJ10gJiYgdGhpc1sncGVvcGxlJ10uX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIHRoaXNbJ3Blb3BsZSddLmRlbGV0ZV91c2VyKCk7XG4gICAgICAgIHRoaXNbJ3Blb3BsZSddLmNsZWFyX2NoYXJnZXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZHByX2NhbGxfZnVuYyhvcHRPdXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgdmFyIGhhc19vcHRlZF9pbiA9IG1peHBhbmVsLmhhc19vcHRlZF9pbl90cmFja2luZygpO1xuICogICAgIC8vIHVzZSBoYXNfb3B0ZWRfaW4gdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IG9wdC1pbiBzdGF0dXNcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9pbl90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMoaGFzT3B0ZWRJbiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgdmFyIGhhc19vcHRlZF9vdXQgPSBtaXhwYW5lbC5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCk7XG4gKiAgICAgLy8gdXNlIGhhc19vcHRlZF9vdXQgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IG9wdC1vdXQgc3RhdHVzXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZHByX2NhbGxfZnVuYyhoYXNPcHRlZE91dCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSB1c2VyJ3Mgb3B0IGluL291dCBzdGF0dXMgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIGNsZWFyIHVzZXIncyBvcHQtaW4vb3V0IHN0YXR1c1xuICogICAgIG1peHBhbmVsLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gY2xlYXIgdXNlcidzIG9wdC1pbi9vdXQgc3RhdHVzIHdpdGggc3BlY2lmaWMgY29va2llIGNvbmZpZ3VyYXRpb24gLSBzaG91bGQgbWF0Y2hcbiAqICAgICAvLyBjb25maWd1cmF0aW9uIHVzZWQgd2hlbiBvcHRfaW5fdHJhY2tpbmcvb3B0X291dF90cmFja2luZyBtZXRob2RzIHdlcmUgY2FsbGVkLlxuICogICAgIG1peHBhbmVsLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoe1xuICogICAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzAsXG4gKiAgICAgICAgIHNlY3VyZV9jb29raWU6IHRydWVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKGNsZWFyT3B0SW5PdXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlcG9ydF9lcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgY29uc29sZSQxLmVycm9yLmFwcGx5KGNvbnNvbGUkMS5lcnJvciwgYXJndW1lbnRzKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWVyciAmJiAhKG1zZyBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgbXNnID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdlcnJvcl9yZXBvcnRlcicpKG1zZywgZXJyKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoZXJyKTtcbiAgICB9XG59O1xuXG4vLyBFWFBPUlRTIChmb3IgY2xvc3VyZSBjb21waWxlcilcblxuLy8gTWl4cGFuZWxMaWIgRXhwb3J0c1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydpbml0J10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVzZXQnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc2V0O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydkaXNhYmxlJ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZGlzYWJsZTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndGltZV9ldmVudCddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRpbWVfZXZlbnQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrJ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFjaztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfbGlua3MnXSAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2xpbmtzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja19mb3JtcyddICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfZm9ybXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX3BhZ2V2aWV3J10gICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19wYWdldmlldztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVnaXN0ZXInXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZWdpc3Rlcl9vbmNlJ10gICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXJfb25jZTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndW5yZWdpc3RlciddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnVucmVnaXN0ZXI7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2lkZW50aWZ5J10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5pZGVudGlmeTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnYWxpYXMnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmFsaWFzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyduYW1lX3RhZyddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUubmFtZV90YWc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3NldF9jb25maWcnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfY29uZmlnO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfY29uZmlnJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2NvbmZpZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3Byb3BlcnR5J10gICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9wcm9wZXJ0eTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X2Rpc3RpbmN0X2lkJ10gICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9kaXN0aW5jdF9pZDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndG9TdHJpbmcnXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRvU3RyaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydvcHRfb3V0X3RyYWNraW5nJ10gICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X291dF90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnb3B0X2luX3RyYWNraW5nJ10gICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9pbl90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaGFzX29wdGVkX291dF90cmFja2luZyddICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9vdXRfdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2hhc19vcHRlZF9pbl90cmFja2luZyddICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfaW5fdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2NsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcnXSAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzZXRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydhZGRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuYWRkX2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZW1vdmVfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVtb3ZlX2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja193aXRoX2dyb3VwcyddICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfd2l0aF9ncm91cHM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0YXJ0X2JhdGNoX3NlbmRlcnMnXSAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9iYXRjaF9zZW5kZXJzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdG9wX2JhdGNoX3NlbmRlcnMnXSAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9iYXRjaF9zZW5kZXJzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdGFydF9zZXNzaW9uX3JlY29yZGluZyddICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdG9wX3Nlc3Npb25fcmVjb3JkaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcyddICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9zZXNzaW9uX3JlcGxheV91cmwnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZXBsYXlfdXJsO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydERUZBVUxUX0FQSV9ST1VURVMnXSAgICAgICAgICAgICAgICAgPSBERUZBVUxUX0FQSV9ST1VURVM7XG5cbi8vIE1peHBhbmVsUGVyc2lzdGVuY2UgRXhwb3J0c1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3Byb3BlcnRpZXMnXSAgICAgICAgICAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucHJvcGVydGllcztcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWyd1cGRhdGVfc2VhcmNoX2tleXdvcmQnXSA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9zZWFyY2hfa2V5d29yZDtcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWyd1cGRhdGVfcmVmZXJyZXJfaW5mbyddICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9yZWZlcnJlcl9pbmZvO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ2dldF9jcm9zc19zdWJkb21haW4nXSAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X2Nyb3NzX3N1YmRvbWFpbjtcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWydjbGVhciddICAgICAgICAgICAgICAgICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmNsZWFyO1xuXG5cbnZhciBpbnN0YW5jZXMgPSB7fTtcbnZhciBleHRlbmRfbXAgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBhZGQgYWxsIHRoZSBzdWIgbWl4cGFuZWwgaW5zdGFuY2VzXG4gICAgXy5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24oaW5zdGFuY2UsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgIT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgeyBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZTsgfVxuICAgIH0pO1xuXG4gICAgLy8gYWRkIHByaXZhdGUgZnVuY3Rpb25zIGFzIF9cbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ18nXSA9IF87XG59O1xuXG52YXIgb3ZlcnJpZGVfbXBfaW5pdF9mdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gd2Ugb3ZlcnJpZGUgdGhlIHNuaXBwZXRzIGluaXQgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFcbiAgICAvLyB1c2VyIGluaXRpYWxpemVzIHRoZSBtaXhwYW5lbCBsaWJyYXJ5IGFmdGVyIHRoZSBzY3JpcHQgbG9hZHMgJiBydW5zXG4gICAgbWl4cGFuZWxfbWFzdGVyWydpbml0J10gPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIGEgc3ViIGxpYnJhcnlcbiAgICAgICAgICAgIGlmICghbWl4cGFuZWxfbWFzdGVyW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyW25hbWVdID0gaW5zdGFuY2VzW25hbWVdID0gY3JlYXRlX21wbGliKHRva2VuLCBjb25maWcsIG5hbWUpO1xuICAgICAgICAgICAgICAgIG1peHBhbmVsX21hc3RlcltuYW1lXS5fbG9hZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWl4cGFuZWxfbWFzdGVyW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbWl4cGFuZWxfbWFzdGVyO1xuXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VzW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0pIHtcbiAgICAgICAgICAgICAgICAvLyBtYWluIG1peHBhbmVsIGxpYiBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbnRpYWxpemUgdGhlIG1haW4gbWl4cGFuZWwgbGliXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBjcmVhdGVfbXBsaWIodG9rZW4sIGNvbmZpZywgUFJJTUFSWV9JTlNUQU5DRV9OQU1FKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5fbG9hZGVkKCk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoaW5pdF90eXBlID09PSBJTklUX1NOSVBQRVQpIHtcbiAgICAgICAgICAgICAgICB3aW5bUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSA9IG1peHBhbmVsX21hc3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuZF9tcCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBhZGRfZG9tX2xvYWRlZF9oYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ3Jvc3MgYnJvd3NlciBET00gTG9hZGVkIHN1cHBvcnRcbiAgICBmdW5jdGlvbiBkb21fbG9hZGVkX2hhbmRsZXIoKSB7XG4gICAgICAgIC8vIGZ1bmN0aW9uIGZsYWcgc2luY2Ugd2Ugb25seSB3YW50IHRvIGV4ZWN1dGUgdGhpcyBvbmNlXG4gICAgICAgIGlmIChkb21fbG9hZGVkX2hhbmRsZXIuZG9uZSkgeyByZXR1cm47IH1cbiAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyLmRvbmUgPSB0cnVlO1xuXG4gICAgICAgIERPTV9MT0FERUQgPSB0cnVlO1xuICAgICAgICBFTlFVRVVFX1JFUVVFU1RTID0gZmFsc2U7XG5cbiAgICAgICAgXy5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24oaW5zdCkge1xuICAgICAgICAgICAgaW5zdC5fZG9tX2xvYWRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb19zY3JvbGxfY2hlY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCgnbGVmdCcpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9fc2Nyb2xsX2NoZWNrLCAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbV9sb2FkZWRfaGFuZGxlcigpO1xuICAgIH1cblxuICAgIGlmIChkb2N1bWVudCQxLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50JDEucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgLy8gc2FmYXJpIDQgY2FuIGZpcmUgdGhlIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgYmVmb3JlIGxvYWRpbmcgYWxsXG4gICAgICAgICAgICAvLyBleHRlcm5hbCBKUyAoaW5jbHVkaW5nIHRoaXMgZmlsZSkuIHlvdSB3aWxsIHNlZSBzb21lIGNvcHlwYXN0YVxuICAgICAgICAgICAgLy8gb24gdGhlIGludGVybmV0IHRoYXQgY2hlY2tzIGZvciAnY29tcGxldGUnIGFuZCAnbG9hZGVkJywgYnV0XG4gICAgICAgICAgICAvLyAnbG9hZGVkJyBpcyBhbiBJRSB0aGluZ1xuICAgICAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudCQxLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBkb21fbG9hZGVkX2hhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQkMS5hdHRhY2hFdmVudCkge1xuICAgICAgICAvLyBJRVxuICAgICAgICBkb2N1bWVudCQxLmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBkb21fbG9hZGVkX2hhbmRsZXIpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIG1ha2Ugc3VyZSB3ZSBhcm4ndCBpbiBhIGZyYW1lXG4gICAgICAgIHZhciB0b3BsZXZlbCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdG9wbGV2ZWwgPSB3aW4uZnJhbWVFbGVtZW50ID09PSBudWxsO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCAmJiB0b3BsZXZlbCkge1xuICAgICAgICAgICAgZG9fc2Nyb2xsX2NoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayBoYW5kbGVyLCBhbHdheXMgd2lsbCB3b3JrXG4gICAgXy5yZWdpc3Rlcl9ldmVudCh3aW4sICdsb2FkJywgZG9tX2xvYWRlZF9oYW5kbGVyLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIGluaXRfYXNfbW9kdWxlKGJ1bmRsZV9sb2FkZXIpIHtcbiAgICBsb2FkX2V4dHJhX2J1bmRsZSA9IGJ1bmRsZV9sb2FkZXI7XG4gICAgaW5pdF90eXBlID0gSU5JVF9NT0RVTEU7XG4gICAgbWl4cGFuZWxfbWFzdGVyID0gbmV3IE1peHBhbmVsTGliKCk7XG5cbiAgICBvdmVycmlkZV9tcF9pbml0X2Z1bmMoKTtcbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ2luaXQnXSgpO1xuICAgIGFkZF9kb21fbG9hZGVkX2hhbmRsZXIoKTtcblxuICAgIHJldHVybiBtaXhwYW5lbF9tYXN0ZXI7XG59XG5cbi8vIEZvciBsb2FkaW5nIHNlcGFyYXRlIGJ1bmRsZXMgYXN5bmNocm9ub3VzbHkgdmlhIHNjcmlwdCB0YWdcblxuLy8gRm9yIGJ1aWxkcyB0aGF0IGhhdmUgZXZlcnl0aGluZyBpbiBvbmUgYnVuZGxlLCBubyBleHRyYSB3b3JrLlxuZnVuY3Rpb24gbG9hZE5vb3AgKF9zcmMsIG9ubG9hZCkge1xuICAgIG9ubG9hZCgpO1xufVxuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbnZhciBtaXhwYW5lbCA9IGluaXRfYXNfbW9kdWxlKGxvYWROb29wKTtcblxuZXhwb3J0IHsgbWl4cGFuZWwgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mixpanel-browser/dist/mixpanel.module.js\n");

/***/ })

};
;